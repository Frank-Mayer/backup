{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/30011/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/30011/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/30011"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/30011"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/30011/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/30011"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/f512769700ba99b98b88e6d8df4f538d9ee59030"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 5523,
            "forks_count": 5523,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1775,
            "open_issues_count": 1775,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2024-08-13T01:54:54Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 282602,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 80732,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2024-08-13T01:58:29Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 80732,
            "watchers_count": 80732,
            "web_commit_signoff_required": false
        },
        "sha": "0d3f2c4904d552635da07a6e2b4e75520b514940",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim"
        }
    },
    "body": "Problem: Adding support for modern Nvim features (reflow, OSC 8, full utf8/emoji support) requires coupling libvterm to Nvim internals (e.g., utf8proc).\r\n\r\nSolution: Vendor libvterm at v0.3.3. As a first step, make necessary fixes to enable terminal reflow again.\r\n\r\nQuestion: How much should we invest in improving code quality? (Besides a lot of stylistic warnings, clangd raises a few valid complaints.)\r\n\r\nFollow-ups:\r\n* check recent commits on https://github.com/neovim/libvterm/commits/mirror/ for possible cherry-picking\r\n* refactor duplicated code from `libtermkey` (but note different pointer arguments)\r\n* replace `unicode.c` and `fullwidth.inc` (and `utf8.h`) with `mbyte.c`/`utf8proc` functions\r\n* convert upstream tests to `unittest`s ",
    "closed_at": "2024-08-10T08:26:08Z",
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30011#discussion_r1709252565"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30011"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709252565"
                }
            },
            "author_association": "NONE",
            "body": "## Multiplication result converted to larger type\n\nMultiplication result may overflow 'int' before it is converted to 'unsigned long'.\n\n[Show more details](https://github.com/neovim/neovim/security/code-scanning/58)",
            "commit_id": "f512769700ba99b98b88e6d8df4f538d9ee59030",
            "created_at": "2024-08-08T11:15:46Z",
            "diff_hunk": "@@ -0,0 +1,1191 @@\n+#include \"vterm_internal.h\"\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"rect.h\"\n+#include \"utf8.h\"\n+\n+#define UNICODE_SPACE 0x20\n+#define UNICODE_LINEFEED 0x0a\n+\n+#undef DEBUG_REFLOW\n+\n+/* State of the pen at some moment in time, also used in a cell */\n+typedef struct\n+{\n+  /* After the bitfield */\n+  VTermColor   fg, bg;\n+\n+  unsigned int bold      : 1;\n+  unsigned int underline : 2;\n+  unsigned int italic    : 1;\n+  unsigned int blink     : 1;\n+  unsigned int reverse   : 1;\n+  unsigned int conceal   : 1;\n+  unsigned int strike    : 1;\n+  unsigned int font      : 4; /* 0 to 9 */\n+  unsigned int small     : 1;\n+  unsigned int baseline  : 2;\n+\n+  /* Extra state storage that isn't strictly pen-related */\n+  unsigned int protected_cell : 1;\n+  unsigned int dwl            : 1; /* on a DECDWL or DECDHL line */\n+  unsigned int dhl            : 2; /* on a DECDHL line (1=top 2=bottom) */\n+} ScreenPen;\n+\n+/* Internal representation of a screen cell */\n+typedef struct\n+{\n+  uint32_t chars[VTERM_MAX_CHARS_PER_CELL];\n+  ScreenPen pen;\n+} ScreenCell;\n+\n+struct VTermScreen\n+{\n+  VTerm *vt;\n+  VTermState *state;\n+\n+  const VTermScreenCallbacks *callbacks;\n+  void *cbdata;\n+\n+  VTermDamageSize damage_merge;\n+  /* start_row == -1 => no damage */\n+  VTermRect damaged;\n+  VTermRect pending_scrollrect;\n+  int pending_scroll_downward, pending_scroll_rightward;\n+\n+  int rows;\n+  int cols;\n+\n+  unsigned int global_reverse : 1;\n+  unsigned int reflow : 1;\n+\n+  /* Primary and Altscreen. buffers[1] is lazily allocated as needed */\n+  ScreenCell *buffers[2];\n+\n+  /* buffer will == buffers[0] or buffers[1], depending on altscreen */\n+  ScreenCell *buffer;\n+\n+  /* buffer for a single screen row used in scrollback storage callbacks */\n+  VTermScreenCell *sb_buffer;\n+\n+  ScreenPen pen;\n+};\n+\n+static inline void clearcell(const VTermScreen *screen, ScreenCell *cell)\n+{\n+  cell->chars[0] = 0;\n+  cell->pen = screen->pen;\n+}\n+\n+static inline ScreenCell *getcell(const VTermScreen *screen, int row, int col)\n+{\n+  if(row < 0 || row >= screen->rows)\n+    return NULL;\n+  if(col < 0 || col >= screen->cols)\n+    return NULL;\n+  return screen->buffer + (screen->cols * row) + col;\n+}\n+\n+static ScreenCell *alloc_buffer(VTermScreen *screen, int rows, int cols)\n+{\n+  ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * rows * cols);\n+\n+  for(int row = 0; row < rows; row++) {\n+    for(int col = 0; col < cols; col++) {\n+      clearcell(screen, &new_buffer[row * cols + col]);\n+    }\n+  }\n+\n+  return new_buffer;\n+}\n+\n+static void damagerect(VTermScreen *screen, VTermRect rect)\n+{\n+  VTermRect emit;\n+\n+  switch(screen->damage_merge) {\n+  case VTERM_DAMAGE_CELL:\n+    /* Always emit damage event */\n+    emit = rect;\n+    break;\n+\n+  case VTERM_DAMAGE_ROW:\n+    /* Emit damage longer than one row. Try to merge with existing damage in\n+     * the same row */\n+    if(rect.end_row > rect.start_row + 1) {\n+      // Bigger than 1 line - flush existing, emit this\n+      vterm_screen_flush_damage(screen);\n+      emit = rect;\n+    }\n+    else if(screen->damaged.start_row == -1) {\n+      // None stored yet\n+      screen->damaged = rect;\n+      return;\n+    }\n+    else if(rect.start_row == screen->damaged.start_row) {\n+      // Merge with the stored line\n+      if(screen->damaged.start_col > rect.start_col)\n+        screen->damaged.start_col = rect.start_col;\n+      if(screen->damaged.end_col < rect.end_col)\n+        screen->damaged.end_col = rect.end_col;\n+      return;\n+    }\n+    else {\n+      // Emit the currently stored line, store a new one\n+      emit = screen->damaged;\n+      screen->damaged = rect;\n+    }\n+    break;\n+\n+  case VTERM_DAMAGE_SCREEN:\n+  case VTERM_DAMAGE_SCROLL:\n+    /* Never emit damage event */\n+    if(screen->damaged.start_row == -1)\n+      screen->damaged = rect;\n+    else {\n+      rect_expand(&screen->damaged, &rect);\n+    }\n+    return;\n+\n+  default:\n+    DEBUG_LOG(\"TODO: Maybe merge damage for level %d\\n\", screen->damage_merge);\n+    return;\n+  }\n+\n+  if(screen->callbacks && screen->callbacks->damage)\n+    (*screen->callbacks->damage)(emit, screen->cbdata);\n+}\n+\n+static void damagescreen(VTermScreen *screen)\n+{\n+  VTermRect rect = {\n+    .start_row = 0,\n+    .end_row   = screen->rows,\n+    .start_col = 0,\n+    .end_col   = screen->cols,\n+  };\n+\n+  damagerect(screen, rect);\n+}\n+\n+static int putglyph(VTermGlyphInfo *info, VTermPos pos, void *user)\n+{\n+  VTermScreen *screen = user;\n+  ScreenCell *cell = getcell(screen, pos.row, pos.col);\n+\n+  if(!cell)\n+    return 0;\n+\n+  int i;\n+  for(i = 0; i < VTERM_MAX_CHARS_PER_CELL && info->chars[i]; i++) {\n+    cell->chars[i] = info->chars[i];\n+    cell->pen = screen->pen;\n+  }\n+  if(i < VTERM_MAX_CHARS_PER_CELL)\n+    cell->chars[i] = 0;\n+\n+  for(int col = 1; col < info->width; col++)\n+    getcell(screen, pos.row, pos.col + col)->chars[0] = (uint32_t)-1;\n+\n+  VTermRect rect = {\n+    .start_row = pos.row,\n+    .end_row   = pos.row+1,\n+    .start_col = pos.col,\n+    .end_col   = pos.col+info->width,\n+  };\n+\n+  cell->pen.protected_cell = info->protected_cell;\n+  cell->pen.dwl            = info->dwl;\n+  cell->pen.dhl            = info->dhl;\n+\n+  damagerect(screen, rect);\n+\n+  return 1;\n+}\n+\n+static void sb_pushline_from_row(VTermScreen *screen, int row)\n+{\n+  VTermPos pos = { .row = row };\n+  for(pos.col = 0; pos.col < screen->cols; pos.col++)\n+    vterm_screen_get_cell(screen, pos, screen->sb_buffer + pos.col);\n+\n+  (screen->callbacks->sb_pushline)(screen->cols, screen->sb_buffer, screen->cbdata);\n+}\n+\n+static int moverect_internal(VTermRect dest, VTermRect src, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  if(screen->callbacks && screen->callbacks->sb_pushline &&\n+     dest.start_row == 0 && dest.start_col == 0 &&        // starts top-left corner\n+     dest.end_col == screen->cols &&                      // full width\n+     screen->buffer == screen->buffers[BUFIDX_PRIMARY]) { // not altscreen\n+    for(int row = 0; row < src.start_row; row++)\n+      sb_pushline_from_row(screen, row);\n+  }\n+\n+  int cols = src.end_col - src.start_col;\n+  int downward = src.start_row - dest.start_row;\n+\n+  int init_row, test_row, inc_row;\n+  if(downward < 0) {\n+    init_row = dest.end_row - 1;\n+    test_row = dest.start_row - 1;\n+    inc_row  = -1;\n+  }\n+  else {\n+    init_row = dest.start_row;\n+    test_row = dest.end_row;\n+    inc_row  = +1;\n+  }\n+\n+  for(int row = init_row; row != test_row; row += inc_row)\n+    memmove(getcell(screen, row, dest.start_col),\n+            getcell(screen, row + downward, src.start_col),\n+            cols * sizeof(ScreenCell));\n+\n+  return 1;\n+}\n+\n+static int moverect_user(VTermRect dest, VTermRect src, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  if(screen->callbacks && screen->callbacks->moverect) {\n+    if(screen->damage_merge != VTERM_DAMAGE_SCROLL)\n+      // Avoid an infinite loop\n+      vterm_screen_flush_damage(screen);\n+\n+    if((*screen->callbacks->moverect)(dest, src, screen->cbdata))\n+      return 1;\n+  }\n+\n+  damagerect(screen, dest);\n+\n+  return 1;\n+}\n+\n+static int erase_internal(VTermRect rect, int selective, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  for(int row = rect.start_row; row < screen->state->rows && row < rect.end_row; row++) {\n+    const VTermLineInfo *info = vterm_state_get_lineinfo(screen->state, row);\n+\n+    for(int col = rect.start_col; col < rect.end_col; col++) {\n+      ScreenCell *cell = getcell(screen, row, col);\n+\n+      if(selective && cell->pen.protected_cell)\n+        continue;\n+\n+      cell->chars[0] = 0;\n+      cell->pen = (ScreenPen){\n+        /* Only copy .fg and .bg; leave things like rv in reset state */\n+        .fg = screen->pen.fg,\n+        .bg = screen->pen.bg,\n+      };\n+      cell->pen.dwl = info->doublewidth;\n+      cell->pen.dhl = info->doubleheight;\n+    }\n+  }\n+\n+  return 1;\n+}\n+\n+static int erase_user(VTermRect rect, int selective, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  damagerect(screen, rect);\n+\n+  return 1;\n+}\n+\n+static int erase(VTermRect rect, int selective, void *user)\n+{\n+  erase_internal(rect, selective, user);\n+  return erase_user(rect, 0, user);\n+}\n+\n+static int scrollrect(VTermRect rect, int downward, int rightward, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  if(screen->damage_merge != VTERM_DAMAGE_SCROLL) {\n+    vterm_scroll_rect(rect, downward, rightward,\n+        moverect_internal, erase_internal, screen);\n+\n+    vterm_screen_flush_damage(screen);\n+\n+    vterm_scroll_rect(rect, downward, rightward,\n+        moverect_user, erase_user, screen);\n+\n+    return 1;\n+  }\n+\n+  if(screen->damaged.start_row != -1 &&\n+     !rect_intersects(&rect, &screen->damaged)) {\n+    vterm_screen_flush_damage(screen);\n+  }\n+\n+  if(screen->pending_scrollrect.start_row == -1) {\n+    screen->pending_scrollrect = rect;\n+    screen->pending_scroll_downward  = downward;\n+    screen->pending_scroll_rightward = rightward;\n+  }\n+  else if(rect_equal(&screen->pending_scrollrect, &rect) &&\n+     ((screen->pending_scroll_downward  == 0 && downward  == 0) ||\n+      (screen->pending_scroll_rightward == 0 && rightward == 0))) {\n+    screen->pending_scroll_downward  += downward;\n+    screen->pending_scroll_rightward += rightward;\n+  }\n+  else {\n+    vterm_screen_flush_damage(screen);\n+\n+    screen->pending_scrollrect = rect;\n+    screen->pending_scroll_downward  = downward;\n+    screen->pending_scroll_rightward = rightward;\n+  }\n+\n+  vterm_scroll_rect(rect, downward, rightward,\n+      moverect_internal, erase_internal, screen);\n+\n+  if(screen->damaged.start_row == -1)\n+    return 1;\n+\n+  if(rect_contains(&rect, &screen->damaged)) {\n+    /* Scroll region entirely contains the damage; just move it */\n+    vterm_rect_move(&screen->damaged, -downward, -rightward);\n+    rect_clip(&screen->damaged, &rect);\n+  }\n+  /* There are a number of possible cases here, but lets restrict this to only\n+   * the common case where we might actually gain some performance by\n+   * optimising it. Namely, a vertical scroll that neatly cuts the damage\n+   * region in half.\n+   */\n+  else if(rect.start_col <= screen->damaged.start_col &&\n+          rect.end_col   >= screen->damaged.end_col &&\n+          rightward == 0) {\n+    if(screen->damaged.start_row >= rect.start_row &&\n+       screen->damaged.start_row  < rect.end_row) {\n+      screen->damaged.start_row -= downward;\n+      if(screen->damaged.start_row < rect.start_row)\n+        screen->damaged.start_row = rect.start_row;\n+      if(screen->damaged.start_row > rect.end_row)\n+        screen->damaged.start_row = rect.end_row;\n+    }\n+    if(screen->damaged.end_row >= rect.start_row &&\n+       screen->damaged.end_row  < rect.end_row) {\n+      screen->damaged.end_row -= downward;\n+      if(screen->damaged.end_row < rect.start_row)\n+        screen->damaged.end_row = rect.start_row;\n+      if(screen->damaged.end_row > rect.end_row)\n+        screen->damaged.end_row = rect.end_row;\n+    }\n+  }\n+  else {\n+    DEBUG_LOG(\"TODO: Just flush and redo damaged=\" STRFrect \" rect=\" STRFrect \"\\n\",\n+        ARGSrect(screen->damaged), ARGSrect(rect));\n+  }\n+\n+  return 1;\n+}\n+\n+static int movecursor(VTermPos pos, VTermPos oldpos, int visible, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  if(screen->callbacks && screen->callbacks->movecursor)\n+    return (*screen->callbacks->movecursor)(pos, oldpos, visible, screen->cbdata);\n+\n+  return 0;\n+}\n+\n+static int setpenattr(VTermAttr attr, VTermValue *val, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  switch(attr) {\n+  case VTERM_ATTR_BOLD:\n+    screen->pen.bold = val->boolean;\n+    return 1;\n+  case VTERM_ATTR_UNDERLINE:\n+    screen->pen.underline = val->number;\n+    return 1;\n+  case VTERM_ATTR_ITALIC:\n+    screen->pen.italic = val->boolean;\n+    return 1;\n+  case VTERM_ATTR_BLINK:\n+    screen->pen.blink = val->boolean;\n+    return 1;\n+  case VTERM_ATTR_REVERSE:\n+    screen->pen.reverse = val->boolean;\n+    return 1;\n+  case VTERM_ATTR_CONCEAL:\n+    screen->pen.conceal = val->boolean;\n+    return 1;\n+  case VTERM_ATTR_STRIKE:\n+    screen->pen.strike = val->boolean;\n+    return 1;\n+  case VTERM_ATTR_FONT:\n+    screen->pen.font = val->number;\n+    return 1;\n+  case VTERM_ATTR_FOREGROUND:\n+    screen->pen.fg = val->color;\n+    return 1;\n+  case VTERM_ATTR_BACKGROUND:\n+    screen->pen.bg = val->color;\n+    return 1;\n+  case VTERM_ATTR_SMALL:\n+    screen->pen.small = val->boolean;\n+    return 1;\n+  case VTERM_ATTR_BASELINE:\n+    screen->pen.baseline = val->number;\n+    return 1;\n+\n+  case VTERM_N_ATTRS:\n+    return 0;\n+  }\n+\n+  return 0;\n+}\n+\n+static int settermprop(VTermProp prop, VTermValue *val, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  switch(prop) {\n+  case VTERM_PROP_ALTSCREEN:\n+    if(val->boolean && !screen->buffers[BUFIDX_ALTSCREEN])\n+      return 0;\n+\n+    screen->buffer = val->boolean ? screen->buffers[BUFIDX_ALTSCREEN] : screen->buffers[BUFIDX_PRIMARY];\n+    /* only send a damage event on disable; because during enable there's an\n+     * erase that sends a damage anyway\n+     */\n+    if(!val->boolean)\n+      damagescreen(screen);\n+    break;\n+  case VTERM_PROP_REVERSE:\n+    screen->global_reverse = val->boolean;\n+    damagescreen(screen);\n+    break;\n+  default:\n+    ; /* ignore */\n+  }\n+\n+  if(screen->callbacks && screen->callbacks->settermprop)\n+    return (*screen->callbacks->settermprop)(prop, val, screen->cbdata);\n+\n+  return 1;\n+}\n+\n+static int bell(void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  if(screen->callbacks && screen->callbacks->bell)\n+    return (*screen->callbacks->bell)(screen->cbdata);\n+\n+  return 0;\n+}\n+\n+/* How many cells are non-blank\n+ * Returns the position of the first blank cell in the trailing blank end */\n+static int line_popcount(ScreenCell *buffer, int row, int rows, int cols)\n+{\n+  int col = cols - 1;\n+  while(col >= 0 && buffer[row * cols + col].chars[0] == 0)\n+    col--;\n+  return col + 1;\n+}\n+\n+#define REFLOW (screen->reflow)\n+\n+static void resize_buffer(VTermScreen *screen, int bufidx, int new_rows, int new_cols, bool active, VTermStateFields *statefields)\n+{\n+  int old_rows = screen->rows;\n+  int old_cols = screen->cols;\n+\n+  ScreenCell *old_buffer = screen->buffers[bufidx];\n+  VTermLineInfo *old_lineinfo = statefields->lineinfos[bufidx];\n+\n+  ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * new_rows * new_cols);\n+  VTermLineInfo *new_lineinfo = vterm_allocator_malloc(screen->vt, sizeof(new_lineinfo[0]) * new_rows);\n+\n+  int old_row = old_rows - 1;\n+  int new_row = new_rows - 1;\n+\n+  VTermPos old_cursor = statefields->pos;\n+  VTermPos new_cursor = { -1, -1 };\n+\n+#ifdef DEBUG_REFLOW\n+  fprintf(stderr, \"Resizing from %dx%d to %dx%d; cursor was at (%d,%d)\\n\",\n+      old_cols, old_rows, new_cols, new_rows, old_cursor.col, old_cursor.row);\n+#endif\n+\n+  /* Keep track of the final row that is knonw to be blank, so we know what\n+   * spare space we have for scrolling into\n+   */\n+  int final_blank_row = new_rows;\n+\n+  while(old_row >= 0) {\n+    int old_row_end = old_row;\n+    /* TODO: Stop if dwl or dhl */\n+    while(REFLOW && old_lineinfo && old_row > 0 && old_lineinfo[old_row].continuation)\n+      old_row--;\n+    int old_row_start = old_row;\n+\n+    int width = 0;\n+    for(int row = old_row_start; row <= old_row_end; row++) {\n+      if(REFLOW && row < (old_rows - 1) && old_lineinfo[row + 1].continuation)\n+        width += old_cols;\n+      else\n+        width += line_popcount(old_buffer, row, old_rows, old_cols);\n+    }\n+\n+    if(final_blank_row == (new_row + 1) && width == 0)\n+      final_blank_row = new_row;\n+\n+    int new_height = REFLOW\n+      ? width ? (width + new_cols - 1) / new_cols : 1\n+      : 1;\n+\n+    int new_row_end = new_row;\n+    int new_row_start = new_row - new_height + 1;\n+\n+    old_row = old_row_start;\n+    int old_col = 0;\n+\n+    int spare_rows = new_rows - final_blank_row;\n+\n+    if(new_row_start < 0 && /* we'd fall off the top */\n+        spare_rows >= 0 && /* we actually have spare rows */\n+        (!active || new_cursor.row == -1 || (new_cursor.row - new_row_start) < new_rows))\n+    {\n+      /* Attempt to scroll content down into the blank rows at the bottom to\n+       * make it fit\n+       */\n+      int downwards = -new_row_start;\n+      if(downwards > spare_rows)\n+        downwards = spare_rows;\n+      int rowcount = new_rows - downwards;\n+\n+#ifdef DEBUG_REFLOW\n+      fprintf(stderr, \"  scroll %d rows +%d downwards\\n\", rowcount, downwards);\n+#endif\n+\n+      memmove(&new_buffer[downwards * new_cols], &new_buffer[0],   rowcount * new_cols * sizeof(ScreenCell));",
            "html_url": "https://github.com/neovim/neovim/pull/30011#discussion_r1709252565",
            "id": 1709252565,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5l4R_V",
            "original_commit_id": "c7c7d8fcbfe51e4eea0ea95e3a495b1c626648e3",
            "original_line": 580,
            "original_position": 580,
            "original_start_line": null,
            "path": "src/vterm/screen.c",
            "position": null,
            "pull_request_review_id": 2227568718,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30011",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709252565/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-08-08T11:15:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709252565",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/in/57789?v=4",
                "events_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/events{/privacy}",
                "followers_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/followers",
                "following_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/following{/other_user}",
                "gists_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/apps/github-advanced-security",
                "id": 62310815,
                "login": "github-advanced-security[bot]",
                "node_id": "MDM6Qm90NjIzMTA4MTU=",
                "organizations_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/orgs",
                "received_events_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/received_events",
                "repos_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/subscriptions",
                "type": "Bot",
                "url": "https://api.github.com/users/github-advanced-security%5Bbot%5D"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30011#discussion_r1709252573"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30011"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709252573"
                }
            },
            "author_association": "NONE",
            "body": "## Multiplication result converted to larger type\n\nMultiplication result may overflow 'int' before it is converted to 'unsigned long'.\n\n[Show more details](https://github.com/neovim/neovim/security/code-scanning/59)",
            "commit_id": "f512769700ba99b98b88e6d8df4f538d9ee59030",
            "created_at": "2024-08-08T11:15:46Z",
            "diff_hunk": "@@ -0,0 +1,1191 @@\n+#include \"vterm_internal.h\"\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"rect.h\"\n+#include \"utf8.h\"\n+\n+#define UNICODE_SPACE 0x20\n+#define UNICODE_LINEFEED 0x0a\n+\n+#undef DEBUG_REFLOW\n+\n+/* State of the pen at some moment in time, also used in a cell */\n+typedef struct\n+{\n+  /* After the bitfield */\n+  VTermColor   fg, bg;\n+\n+  unsigned int bold      : 1;\n+  unsigned int underline : 2;\n+  unsigned int italic    : 1;\n+  unsigned int blink     : 1;\n+  unsigned int reverse   : 1;\n+  unsigned int conceal   : 1;\n+  unsigned int strike    : 1;\n+  unsigned int font      : 4; /* 0 to 9 */\n+  unsigned int small     : 1;\n+  unsigned int baseline  : 2;\n+\n+  /* Extra state storage that isn't strictly pen-related */\n+  unsigned int protected_cell : 1;\n+  unsigned int dwl            : 1; /* on a DECDWL or DECDHL line */\n+  unsigned int dhl            : 2; /* on a DECDHL line (1=top 2=bottom) */\n+} ScreenPen;\n+\n+/* Internal representation of a screen cell */\n+typedef struct\n+{\n+  uint32_t chars[VTERM_MAX_CHARS_PER_CELL];\n+  ScreenPen pen;\n+} ScreenCell;\n+\n+struct VTermScreen\n+{\n+  VTerm *vt;\n+  VTermState *state;\n+\n+  const VTermScreenCallbacks *callbacks;\n+  void *cbdata;\n+\n+  VTermDamageSize damage_merge;\n+  /* start_row == -1 => no damage */\n+  VTermRect damaged;\n+  VTermRect pending_scrollrect;\n+  int pending_scroll_downward, pending_scroll_rightward;\n+\n+  int rows;\n+  int cols;\n+\n+  unsigned int global_reverse : 1;\n+  unsigned int reflow : 1;\n+\n+  /* Primary and Altscreen. buffers[1] is lazily allocated as needed */\n+  ScreenCell *buffers[2];\n+\n+  /* buffer will == buffers[0] or buffers[1], depending on altscreen */\n+  ScreenCell *buffer;\n+\n+  /* buffer for a single screen row used in scrollback storage callbacks */\n+  VTermScreenCell *sb_buffer;\n+\n+  ScreenPen pen;\n+};\n+\n+static inline void clearcell(const VTermScreen *screen, ScreenCell *cell)\n+{\n+  cell->chars[0] = 0;\n+  cell->pen = screen->pen;\n+}\n+\n+static inline ScreenCell *getcell(const VTermScreen *screen, int row, int col)\n+{\n+  if(row < 0 || row >= screen->rows)\n+    return NULL;\n+  if(col < 0 || col >= screen->cols)\n+    return NULL;\n+  return screen->buffer + (screen->cols * row) + col;\n+}\n+\n+static ScreenCell *alloc_buffer(VTermScreen *screen, int rows, int cols)\n+{\n+  ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * rows * cols);\n+\n+  for(int row = 0; row < rows; row++) {\n+    for(int col = 0; col < cols; col++) {\n+      clearcell(screen, &new_buffer[row * cols + col]);\n+    }\n+  }\n+\n+  return new_buffer;\n+}\n+\n+static void damagerect(VTermScreen *screen, VTermRect rect)\n+{\n+  VTermRect emit;\n+\n+  switch(screen->damage_merge) {\n+  case VTERM_DAMAGE_CELL:\n+    /* Always emit damage event */\n+    emit = rect;\n+    break;\n+\n+  case VTERM_DAMAGE_ROW:\n+    /* Emit damage longer than one row. Try to merge with existing damage in\n+     * the same row */\n+    if(rect.end_row > rect.start_row + 1) {\n+      // Bigger than 1 line - flush existing, emit this\n+      vterm_screen_flush_damage(screen);\n+      emit = rect;\n+    }\n+    else if(screen->damaged.start_row == -1) {\n+      // None stored yet\n+      screen->damaged = rect;\n+      return;\n+    }\n+    else if(rect.start_row == screen->damaged.start_row) {\n+      // Merge with the stored line\n+      if(screen->damaged.start_col > rect.start_col)\n+        screen->damaged.start_col = rect.start_col;\n+      if(screen->damaged.end_col < rect.end_col)\n+        screen->damaged.end_col = rect.end_col;\n+      return;\n+    }\n+    else {\n+      // Emit the currently stored line, store a new one\n+      emit = screen->damaged;\n+      screen->damaged = rect;\n+    }\n+    break;\n+\n+  case VTERM_DAMAGE_SCREEN:\n+  case VTERM_DAMAGE_SCROLL:\n+    /* Never emit damage event */\n+    if(screen->damaged.start_row == -1)\n+      screen->damaged = rect;\n+    else {\n+      rect_expand(&screen->damaged, &rect);\n+    }\n+    return;\n+\n+  default:\n+    DEBUG_LOG(\"TODO: Maybe merge damage for level %d\\n\", screen->damage_merge);\n+    return;\n+  }\n+\n+  if(screen->callbacks && screen->callbacks->damage)\n+    (*screen->callbacks->damage)(emit, screen->cbdata);\n+}\n+\n+static void damagescreen(VTermScreen *screen)\n+{\n+  VTermRect rect = {\n+    .start_row = 0,\n+    .end_row   = screen->rows,\n+    .start_col = 0,\n+    .end_col   = screen->cols,\n+  };\n+\n+  damagerect(screen, rect);\n+}\n+\n+static int putglyph(VTermGlyphInfo *info, VTermPos pos, void *user)\n+{\n+  VTermScreen *screen = user;\n+  ScreenCell *cell = getcell(screen, pos.row, pos.col);\n+\n+  if(!cell)\n+    return 0;\n+\n+  int i;\n+  for(i = 0; i < VTERM_MAX_CHARS_PER_CELL && info->chars[i]; i++) {\n+    cell->chars[i] = info->chars[i];\n+    cell->pen = screen->pen;\n+  }\n+  if(i < VTERM_MAX_CHARS_PER_CELL)\n+    cell->chars[i] = 0;\n+\n+  for(int col = 1; col < info->width; col++)\n+    getcell(screen, pos.row, pos.col + col)->chars[0] = (uint32_t)-1;\n+\n+  VTermRect rect = {\n+    .start_row = pos.row,\n+    .end_row   = pos.row+1,\n+    .start_col = pos.col,\n+    .end_col   = pos.col+info->width,\n+  };\n+\n+  cell->pen.protected_cell = info->protected_cell;\n+  cell->pen.dwl            = info->dwl;\n+  cell->pen.dhl            = info->dhl;\n+\n+  damagerect(screen, rect);\n+\n+  return 1;\n+}\n+\n+static void sb_pushline_from_row(VTermScreen *screen, int row)\n+{\n+  VTermPos pos = { .row = row };\n+  for(pos.col = 0; pos.col < screen->cols; pos.col++)\n+    vterm_screen_get_cell(screen, pos, screen->sb_buffer + pos.col);\n+\n+  (screen->callbacks->sb_pushline)(screen->cols, screen->sb_buffer, screen->cbdata);\n+}\n+\n+static int moverect_internal(VTermRect dest, VTermRect src, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  if(screen->callbacks && screen->callbacks->sb_pushline &&\n+     dest.start_row == 0 && dest.start_col == 0 &&        // starts top-left corner\n+     dest.end_col == screen->cols &&                      // full width\n+     screen->buffer == screen->buffers[BUFIDX_PRIMARY]) { // not altscreen\n+    for(int row = 0; row < src.start_row; row++)\n+      sb_pushline_from_row(screen, row);\n+  }\n+\n+  int cols = src.end_col - src.start_col;\n+  int downward = src.start_row - dest.start_row;\n+\n+  int init_row, test_row, inc_row;\n+  if(downward < 0) {\n+    init_row = dest.end_row - 1;\n+    test_row = dest.start_row - 1;\n+    inc_row  = -1;\n+  }\n+  else {\n+    init_row = dest.start_row;\n+    test_row = dest.end_row;\n+    inc_row  = +1;\n+  }\n+\n+  for(int row = init_row; row != test_row; row += inc_row)\n+    memmove(getcell(screen, row, dest.start_col),\n+            getcell(screen, row + downward, src.start_col),\n+            cols * sizeof(ScreenCell));\n+\n+  return 1;\n+}\n+\n+static int moverect_user(VTermRect dest, VTermRect src, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  if(screen->callbacks && screen->callbacks->moverect) {\n+    if(screen->damage_merge != VTERM_DAMAGE_SCROLL)\n+      // Avoid an infinite loop\n+      vterm_screen_flush_damage(screen);\n+\n+    if((*screen->callbacks->moverect)(dest, src, screen->cbdata))\n+      return 1;\n+  }\n+\n+  damagerect(screen, dest);\n+\n+  return 1;\n+}\n+\n+static int erase_internal(VTermRect rect, int selective, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  for(int row = rect.start_row; row < screen->state->rows && row < rect.end_row; row++) {\n+    const VTermLineInfo *info = vterm_state_get_lineinfo(screen->state, row);\n+\n+    for(int col = rect.start_col; col < rect.end_col; col++) {\n+      ScreenCell *cell = getcell(screen, row, col);\n+\n+      if(selective && cell->pen.protected_cell)\n+        continue;\n+\n+      cell->chars[0] = 0;\n+      cell->pen = (ScreenPen){\n+        /* Only copy .fg and .bg; leave things like rv in reset state */\n+        .fg = screen->pen.fg,\n+        .bg = screen->pen.bg,\n+      };\n+      cell->pen.dwl = info->doublewidth;\n+      cell->pen.dhl = info->doubleheight;\n+    }\n+  }\n+\n+  return 1;\n+}\n+\n+static int erase_user(VTermRect rect, int selective, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  damagerect(screen, rect);\n+\n+  return 1;\n+}\n+\n+static int erase(VTermRect rect, int selective, void *user)\n+{\n+  erase_internal(rect, selective, user);\n+  return erase_user(rect, 0, user);\n+}\n+\n+static int scrollrect(VTermRect rect, int downward, int rightward, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  if(screen->damage_merge != VTERM_DAMAGE_SCROLL) {\n+    vterm_scroll_rect(rect, downward, rightward,\n+        moverect_internal, erase_internal, screen);\n+\n+    vterm_screen_flush_damage(screen);\n+\n+    vterm_scroll_rect(rect, downward, rightward,\n+        moverect_user, erase_user, screen);\n+\n+    return 1;\n+  }\n+\n+  if(screen->damaged.start_row != -1 &&\n+     !rect_intersects(&rect, &screen->damaged)) {\n+    vterm_screen_flush_damage(screen);\n+  }\n+\n+  if(screen->pending_scrollrect.start_row == -1) {\n+    screen->pending_scrollrect = rect;\n+    screen->pending_scroll_downward  = downward;\n+    screen->pending_scroll_rightward = rightward;\n+  }\n+  else if(rect_equal(&screen->pending_scrollrect, &rect) &&\n+     ((screen->pending_scroll_downward  == 0 && downward  == 0) ||\n+      (screen->pending_scroll_rightward == 0 && rightward == 0))) {\n+    screen->pending_scroll_downward  += downward;\n+    screen->pending_scroll_rightward += rightward;\n+  }\n+  else {\n+    vterm_screen_flush_damage(screen);\n+\n+    screen->pending_scrollrect = rect;\n+    screen->pending_scroll_downward  = downward;\n+    screen->pending_scroll_rightward = rightward;\n+  }\n+\n+  vterm_scroll_rect(rect, downward, rightward,\n+      moverect_internal, erase_internal, screen);\n+\n+  if(screen->damaged.start_row == -1)\n+    return 1;\n+\n+  if(rect_contains(&rect, &screen->damaged)) {\n+    /* Scroll region entirely contains the damage; just move it */\n+    vterm_rect_move(&screen->damaged, -downward, -rightward);\n+    rect_clip(&screen->damaged, &rect);\n+  }\n+  /* There are a number of possible cases here, but lets restrict this to only\n+   * the common case where we might actually gain some performance by\n+   * optimising it. Namely, a vertical scroll that neatly cuts the damage\n+   * region in half.\n+   */\n+  else if(rect.start_col <= screen->damaged.start_col &&\n+          rect.end_col   >= screen->damaged.end_col &&\n+          rightward == 0) {\n+    if(screen->damaged.start_row >= rect.start_row &&\n+       screen->damaged.start_row  < rect.end_row) {\n+      screen->damaged.start_row -= downward;\n+      if(screen->damaged.start_row < rect.start_row)\n+        screen->damaged.start_row = rect.start_row;\n+      if(screen->damaged.start_row > rect.end_row)\n+        screen->damaged.start_row = rect.end_row;\n+    }\n+    if(screen->damaged.end_row >= rect.start_row &&\n+       screen->damaged.end_row  < rect.end_row) {\n+      screen->damaged.end_row -= downward;\n+      if(screen->damaged.end_row < rect.start_row)\n+        screen->damaged.end_row = rect.start_row;\n+      if(screen->damaged.end_row > rect.end_row)\n+        screen->damaged.end_row = rect.end_row;\n+    }\n+  }\n+  else {\n+    DEBUG_LOG(\"TODO: Just flush and redo damaged=\" STRFrect \" rect=\" STRFrect \"\\n\",\n+        ARGSrect(screen->damaged), ARGSrect(rect));\n+  }\n+\n+  return 1;\n+}\n+\n+static int movecursor(VTermPos pos, VTermPos oldpos, int visible, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  if(screen->callbacks && screen->callbacks->movecursor)\n+    return (*screen->callbacks->movecursor)(pos, oldpos, visible, screen->cbdata);\n+\n+  return 0;\n+}\n+\n+static int setpenattr(VTermAttr attr, VTermValue *val, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  switch(attr) {\n+  case VTERM_ATTR_BOLD:\n+    screen->pen.bold = val->boolean;\n+    return 1;\n+  case VTERM_ATTR_UNDERLINE:\n+    screen->pen.underline = val->number;\n+    return 1;\n+  case VTERM_ATTR_ITALIC:\n+    screen->pen.italic = val->boolean;\n+    return 1;\n+  case VTERM_ATTR_BLINK:\n+    screen->pen.blink = val->boolean;\n+    return 1;\n+  case VTERM_ATTR_REVERSE:\n+    screen->pen.reverse = val->boolean;\n+    return 1;\n+  case VTERM_ATTR_CONCEAL:\n+    screen->pen.conceal = val->boolean;\n+    return 1;\n+  case VTERM_ATTR_STRIKE:\n+    screen->pen.strike = val->boolean;\n+    return 1;\n+  case VTERM_ATTR_FONT:\n+    screen->pen.font = val->number;\n+    return 1;\n+  case VTERM_ATTR_FOREGROUND:\n+    screen->pen.fg = val->color;\n+    return 1;\n+  case VTERM_ATTR_BACKGROUND:\n+    screen->pen.bg = val->color;\n+    return 1;\n+  case VTERM_ATTR_SMALL:\n+    screen->pen.small = val->boolean;\n+    return 1;\n+  case VTERM_ATTR_BASELINE:\n+    screen->pen.baseline = val->number;\n+    return 1;\n+\n+  case VTERM_N_ATTRS:\n+    return 0;\n+  }\n+\n+  return 0;\n+}\n+\n+static int settermprop(VTermProp prop, VTermValue *val, void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  switch(prop) {\n+  case VTERM_PROP_ALTSCREEN:\n+    if(val->boolean && !screen->buffers[BUFIDX_ALTSCREEN])\n+      return 0;\n+\n+    screen->buffer = val->boolean ? screen->buffers[BUFIDX_ALTSCREEN] : screen->buffers[BUFIDX_PRIMARY];\n+    /* only send a damage event on disable; because during enable there's an\n+     * erase that sends a damage anyway\n+     */\n+    if(!val->boolean)\n+      damagescreen(screen);\n+    break;\n+  case VTERM_PROP_REVERSE:\n+    screen->global_reverse = val->boolean;\n+    damagescreen(screen);\n+    break;\n+  default:\n+    ; /* ignore */\n+  }\n+\n+  if(screen->callbacks && screen->callbacks->settermprop)\n+    return (*screen->callbacks->settermprop)(prop, val, screen->cbdata);\n+\n+  return 1;\n+}\n+\n+static int bell(void *user)\n+{\n+  VTermScreen *screen = user;\n+\n+  if(screen->callbacks && screen->callbacks->bell)\n+    return (*screen->callbacks->bell)(screen->cbdata);\n+\n+  return 0;\n+}\n+\n+/* How many cells are non-blank\n+ * Returns the position of the first blank cell in the trailing blank end */\n+static int line_popcount(ScreenCell *buffer, int row, int rows, int cols)\n+{\n+  int col = cols - 1;\n+  while(col >= 0 && buffer[row * cols + col].chars[0] == 0)\n+    col--;\n+  return col + 1;\n+}\n+\n+#define REFLOW (screen->reflow)\n+\n+static void resize_buffer(VTermScreen *screen, int bufidx, int new_rows, int new_cols, bool active, VTermStateFields *statefields)\n+{\n+  int old_rows = screen->rows;\n+  int old_cols = screen->cols;\n+\n+  ScreenCell *old_buffer = screen->buffers[bufidx];\n+  VTermLineInfo *old_lineinfo = statefields->lineinfos[bufidx];\n+\n+  ScreenCell *new_buffer = vterm_allocator_malloc(screen->vt, sizeof(ScreenCell) * new_rows * new_cols);\n+  VTermLineInfo *new_lineinfo = vterm_allocator_malloc(screen->vt, sizeof(new_lineinfo[0]) * new_rows);\n+\n+  int old_row = old_rows - 1;\n+  int new_row = new_rows - 1;\n+\n+  VTermPos old_cursor = statefields->pos;\n+  VTermPos new_cursor = { -1, -1 };\n+\n+#ifdef DEBUG_REFLOW\n+  fprintf(stderr, \"Resizing from %dx%d to %dx%d; cursor was at (%d,%d)\\n\",\n+      old_cols, old_rows, new_cols, new_rows, old_cursor.col, old_cursor.row);\n+#endif\n+\n+  /* Keep track of the final row that is knonw to be blank, so we know what\n+   * spare space we have for scrolling into\n+   */\n+  int final_blank_row = new_rows;\n+\n+  while(old_row >= 0) {\n+    int old_row_end = old_row;\n+    /* TODO: Stop if dwl or dhl */\n+    while(REFLOW && old_lineinfo && old_row > 0 && old_lineinfo[old_row].continuation)\n+      old_row--;\n+    int old_row_start = old_row;\n+\n+    int width = 0;\n+    for(int row = old_row_start; row <= old_row_end; row++) {\n+      if(REFLOW && row < (old_rows - 1) && old_lineinfo[row + 1].continuation)\n+        width += old_cols;\n+      else\n+        width += line_popcount(old_buffer, row, old_rows, old_cols);\n+    }\n+\n+    if(final_blank_row == (new_row + 1) && width == 0)\n+      final_blank_row = new_row;\n+\n+    int new_height = REFLOW\n+      ? width ? (width + new_cols - 1) / new_cols : 1\n+      : 1;\n+\n+    int new_row_end = new_row;\n+    int new_row_start = new_row - new_height + 1;\n+\n+    old_row = old_row_start;\n+    int old_col = 0;\n+\n+    int spare_rows = new_rows - final_blank_row;\n+\n+    if(new_row_start < 0 && /* we'd fall off the top */\n+        spare_rows >= 0 && /* we actually have spare rows */\n+        (!active || new_cursor.row == -1 || (new_cursor.row - new_row_start) < new_rows))\n+    {\n+      /* Attempt to scroll content down into the blank rows at the bottom to\n+       * make it fit\n+       */\n+      int downwards = -new_row_start;\n+      if(downwards > spare_rows)\n+        downwards = spare_rows;\n+      int rowcount = new_rows - downwards;\n+\n+#ifdef DEBUG_REFLOW\n+      fprintf(stderr, \"  scroll %d rows +%d downwards\\n\", rowcount, downwards);\n+#endif\n+\n+      memmove(&new_buffer[downwards * new_cols], &new_buffer[0],   rowcount * new_cols * sizeof(ScreenCell));\n+      memmove(&new_lineinfo[downwards],          &new_lineinfo[0], rowcount            * sizeof(new_lineinfo[0]));\n+\n+      new_row += downwards;\n+      new_row_start += downwards;\n+      new_row_end += downwards;\n+\n+      if(new_cursor.row >= 0)\n+        new_cursor.row += downwards;\n+\n+      final_blank_row += downwards;\n+    }\n+\n+#ifdef DEBUG_REFLOW\n+    fprintf(stderr, \"  rows [%d..%d] <- [%d..%d] width=%d\\n\",\n+        new_row_start, new_row_end, old_row_start, old_row_end, width);\n+#endif\n+\n+    if(new_row_start < 0) {\n+      if(old_row_start <= old_cursor.row && old_cursor.row <= old_row_end) {\n+        new_cursor.row = 0;\n+        new_cursor.col = old_cursor.col;\n+        if(new_cursor.col >= new_cols)\n+          new_cursor.col = new_cols-1;\n+      }\n+      break;\n+    }\n+\n+    for(new_row = new_row_start, old_row = old_row_start; new_row <= new_row_end; new_row++) {\n+      int count = width >= new_cols ? new_cols : width;\n+      width -= count;\n+\n+      int new_col = 0;\n+\n+      while(count) {\n+        /* TODO: This could surely be done a lot faster by memcpy()'ing the entire range */\n+        new_buffer[new_row * new_cols + new_col] = old_buffer[old_row * old_cols + old_col];\n+\n+        if(old_cursor.row == old_row && old_cursor.col == old_col)\n+          new_cursor.row = new_row, new_cursor.col = new_col;\n+\n+        old_col++;\n+        if(old_col == old_cols) {\n+          old_row++;\n+\n+          if(!REFLOW) {\n+            new_col++;\n+            break;\n+          }\n+          old_col = 0;\n+        }\n+\n+        new_col++;\n+        count--;\n+      }\n+\n+      if(old_cursor.row == old_row && old_cursor.col >= old_col) {\n+        new_cursor.row = new_row, new_cursor.col = (old_cursor.col - old_col + new_col);\n+        if(new_cursor.col >= new_cols)\n+          new_cursor.col = new_cols-1;\n+      }\n+\n+      while(new_col < new_cols) {\n+        clearcell(screen, &new_buffer[new_row * new_cols + new_col]);\n+        new_col++;\n+      }\n+\n+      new_lineinfo[new_row].continuation = (new_row > new_row_start);\n+    }\n+\n+    old_row = old_row_start - 1;\n+    new_row = new_row_start - 1;\n+  }\n+\n+  if(old_cursor.row <= old_row) {\n+    /* cursor would have moved entirely off the top of the screen; lets just\n+     * bring it within range */\n+    new_cursor.row = 0, new_cursor.col = old_cursor.col;\n+    if(new_cursor.col >= new_cols)\n+      new_cursor.col = new_cols-1;\n+  }\n+\n+  /* We really expect the cursor position to be set by now */\n+  if(active && (new_cursor.row == -1 || new_cursor.col == -1)) {\n+    fprintf(stderr, \"screen_resize failed to update cursor position\\n\");\n+    abort();\n+  }\n+\n+  if(old_row >= 0 && bufidx == BUFIDX_PRIMARY) {\n+    /* Push spare lines to scrollback buffer */\n+    if(screen->callbacks && screen->callbacks->sb_pushline)\n+      for(int row = 0; row <= old_row; row++)\n+        sb_pushline_from_row(screen, row);\n+    if(active)\n+      statefields->pos.row -= (old_row + 1);\n+  }\n+  if(new_row >= 0 && bufidx == BUFIDX_PRIMARY &&\n+      screen->callbacks && screen->callbacks->sb_popline) {\n+    /* Try to backfill rows by popping scrollback buffer */\n+    while(new_row >= 0) {\n+      if(!(screen->callbacks->sb_popline(old_cols, screen->sb_buffer, screen->cbdata)))\n+        break;\n+\n+      VTermPos pos = { .row = new_row };\n+      for(pos.col = 0; pos.col < old_cols && pos.col < new_cols; pos.col += screen->sb_buffer[pos.col].width) {\n+        VTermScreenCell *src = &screen->sb_buffer[pos.col];\n+        ScreenCell *dst = &new_buffer[pos.row * new_cols + pos.col];\n+\n+        for(int i = 0; i < VTERM_MAX_CHARS_PER_CELL; i++) {\n+          dst->chars[i] = src->chars[i];\n+          if(!src->chars[i])\n+            break;\n+        }\n+\n+        dst->pen.bold      = src->attrs.bold;\n+        dst->pen.underline = src->attrs.underline;\n+        dst->pen.italic    = src->attrs.italic;\n+        dst->pen.blink     = src->attrs.blink;\n+        dst->pen.reverse   = src->attrs.reverse ^ screen->global_reverse;\n+        dst->pen.conceal   = src->attrs.conceal;\n+        dst->pen.strike    = src->attrs.strike;\n+        dst->pen.font      = src->attrs.font;\n+        dst->pen.small     = src->attrs.small;\n+        dst->pen.baseline  = src->attrs.baseline;\n+\n+        dst->pen.fg = src->fg;\n+        dst->pen.bg = src->bg;\n+\n+        if(src->width == 2 && pos.col < (new_cols-1))\n+          (dst + 1)->chars[0] = (uint32_t) -1;\n+      }\n+      for( ; pos.col < new_cols; pos.col++)\n+        clearcell(screen, &new_buffer[pos.row * new_cols + pos.col]);\n+      new_row--;\n+\n+      if(active)\n+        statefields->pos.row++;\n+    }\n+  }\n+  if(new_row >= 0) {\n+    /* Scroll new rows back up to the top and fill in blanks at the bottom */\n+    int moverows = new_rows - new_row - 1;\n+    memmove(&new_buffer[0], &new_buffer[(new_row + 1) * new_cols], moverows * new_cols * sizeof(ScreenCell));",
            "html_url": "https://github.com/neovim/neovim/pull/30011#discussion_r1709252573",
            "id": 1709252573,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5l4R_d",
            "original_commit_id": "c7c7d8fcbfe51e4eea0ea95e3a495b1c626648e3",
            "original_line": 722,
            "original_position": 722,
            "original_start_line": null,
            "path": "src/vterm/screen.c",
            "position": null,
            "pull_request_review_id": 2227568718,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30011",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709252573/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-08-08T11:15:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709252573",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/in/57789?v=4",
                "events_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/events{/privacy}",
                "followers_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/followers",
                "following_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/following{/other_user}",
                "gists_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/apps/github-advanced-security",
                "id": 62310815,
                "login": "github-advanced-security[bot]",
                "node_id": "MDM6Qm90NjIzMTA4MTU=",
                "organizations_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/orgs",
                "received_events_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/received_events",
                "repos_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/github-advanced-security%5Bbot%5D/subscriptions",
                "type": "Bot",
                "url": "https://api.github.com/users/github-advanced-security%5Bbot%5D"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30011#discussion_r1709267069"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30011"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709267069"
                }
            },
            "author_association": "MEMBER",
            "body": "Any idea why Windows is complaining about that?\r\n\r\n```\r\nD:\\a\\neovim\\neovim\\src\\vterm/vterm.h(510): error C2632: 'int' followed by 'char' is illegal\r\n```",
            "commit_id": "f512769700ba99b98b88e6d8df4f538d9ee59030",
            "created_at": "2024-08-08T11:22:33Z",
            "diff_hunk": "@@ -0,0 +1,637 @@\n+#ifndef __VTERM_H__\n+#define __VTERM_H__\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include \"vterm_keycodes.h\"\n+\n+#define VTERM_VERSION_MAJOR 0\n+#define VTERM_VERSION_MINOR 3\n+#define VTERM_VERSION_PATCH 3\n+\n+#define VTERM_CHECK_VERSION \\\n+        vterm_check_version(VTERM_VERSION_MAJOR, VTERM_VERSION_MINOR)\n+\n+/* Any cell can contain at most one basic printing character and 5 combining\n+ * characters. This number could be changed but will be ABI-incompatible if\n+ * you do */\n+#define VTERM_MAX_CHARS_PER_CELL 6\n+\n+typedef struct VTerm VTerm;\n+typedef struct VTermState VTermState;\n+typedef struct VTermScreen VTermScreen;\n+\n+typedef struct {\n+  int row;\n+  int col;\n+} VTermPos;\n+\n+/* some small utility functions; we can just keep these static here */\n+\n+/* order points by on-screen flow order */\n+static inline int vterm_pos_cmp(VTermPos a, VTermPos b)\n+{\n+  return (a.row == b.row) ? a.col - b.col : a.row - b.row;\n+}\n+\n+typedef struct {\n+  int start_row;\n+  int end_row;\n+  int start_col;\n+  int end_col;\n+} VTermRect;\n+\n+/* true if the rect contains the point */\n+static inline int vterm_rect_contains(VTermRect r, VTermPos p)\n+{\n+  return p.row >= r.start_row && p.row < r.end_row &&\n+         p.col >= r.start_col && p.col < r.end_col;\n+}\n+\n+/* move a rect */\n+static inline void vterm_rect_move(VTermRect *rect, int row_delta, int col_delta)\n+{\n+  rect->start_row += row_delta; rect->end_row += row_delta;\n+  rect->start_col += col_delta; rect->end_col += col_delta;\n+}\n+\n+/**\n+ * Bit-field describing the content of the tagged union `VTermColor`.\n+ */\n+typedef enum {\n+  /**\n+   * If the lower bit of `type` is not set, the colour is 24-bit RGB.\n+   */\n+  VTERM_COLOR_RGB = 0x00,\n+\n+  /**\n+   * The colour is an index into a palette of 256 colours.\n+   */\n+  VTERM_COLOR_INDEXED = 0x01,\n+\n+  /**\n+   * Mask that can be used to extract the RGB/Indexed bit.\n+   */\n+  VTERM_COLOR_TYPE_MASK = 0x01,\n+\n+  /**\n+   * If set, indicates that this colour should be the default foreground\n+   * color, i.e. there was no SGR request for another colour. When\n+   * rendering this colour it is possible to ignore \"idx\" and just use a\n+   * colour that is not in the palette.\n+   */\n+  VTERM_COLOR_DEFAULT_FG = 0x02,\n+\n+  /**\n+   * If set, indicates that this colour should be the default background\n+   * color, i.e. there was no SGR request for another colour. A common\n+   * option when rendering this colour is to not render a background at\n+   * all, for example by rendering the window transparently at this spot.\n+   */\n+  VTERM_COLOR_DEFAULT_BG = 0x04,\n+\n+  /**\n+   * Mask that can be used to extract the default foreground/background bit.\n+   */\n+  VTERM_COLOR_DEFAULT_MASK = 0x06\n+} VTermColorType;\n+\n+/**\n+ * Returns true if the VTERM_COLOR_RGB `type` flag is set, indicating that the\n+ * given VTermColor instance is an indexed colour.\n+ */\n+#define VTERM_COLOR_IS_INDEXED(col) \\\n+  (((col)->type & VTERM_COLOR_TYPE_MASK) == VTERM_COLOR_INDEXED)\n+\n+/**\n+ * Returns true if the VTERM_COLOR_INDEXED `type` flag is set, indicating that\n+ * the given VTermColor instance is an rgb colour.\n+ */\n+#define VTERM_COLOR_IS_RGB(col) \\\n+  (((col)->type & VTERM_COLOR_TYPE_MASK) == VTERM_COLOR_RGB)\n+\n+/**\n+ * Returns true if the VTERM_COLOR_DEFAULT_FG `type` flag is set, indicating\n+ * that the given VTermColor instance corresponds to the default foreground\n+ * color.\n+ */\n+#define VTERM_COLOR_IS_DEFAULT_FG(col) \\\n+  (!!((col)->type & VTERM_COLOR_DEFAULT_FG))\n+\n+/**\n+ * Returns true if the VTERM_COLOR_DEFAULT_BG `type` flag is set, indicating\n+ * that the given VTermColor instance corresponds to the default background\n+ * color.\n+ */\n+#define VTERM_COLOR_IS_DEFAULT_BG(col) \\\n+  (!!((col)->type & VTERM_COLOR_DEFAULT_BG))\n+\n+/**\n+ * Tagged union storing either an RGB color or an index into a colour palette.\n+ * In order to convert indexed colours to RGB, you may use the\n+ * vterm_state_convert_color_to_rgb() or vterm_screen_convert_color_to_rgb()\n+ * functions which lookup the RGB colour from the palette maintained by a\n+ * VTermState or VTermScreen instance.\n+ */\n+typedef union {\n+  /**\n+   * Tag indicating which union member is actually valid. This variable\n+   * coincides with the `type` member of the `rgb` and the `indexed` struct\n+   * in memory. Please use the `VTERM_COLOR_IS_*` test macros to check whether\n+   * a particular type flag is set.\n+   */\n+  uint8_t type;\n+\n+  /**\n+   * Valid if `VTERM_COLOR_IS_RGB(type)` is true. Holds the RGB colour values.\n+   */\n+  struct {\n+    /**\n+     * Same as the top-level `type` member stored in VTermColor.\n+     */\n+    uint8_t type;\n+\n+    /**\n+     * The actual 8-bit red, green, blue colour values.\n+     */\n+    uint8_t red, green, blue;\n+  } rgb;\n+\n+  /**\n+   * If `VTERM_COLOR_IS_INDEXED(type)` is true, this member holds the index into\n+   * the colour palette.\n+   */\n+  struct {\n+    /**\n+     * Same as the top-level `type` member stored in VTermColor.\n+     */\n+    uint8_t type;\n+\n+    /**\n+     * Index into the colour map.\n+     */\n+    uint8_t idx;\n+  } indexed;\n+} VTermColor;\n+\n+/**\n+ * Constructs a new VTermColor instance representing the given RGB values.\n+ */\n+static inline void vterm_color_rgb(VTermColor *col, uint8_t red, uint8_t green,\n+                                   uint8_t blue)\n+{\n+  col->type = VTERM_COLOR_RGB;\n+  col->rgb.red   = red;\n+  col->rgb.green = green;\n+  col->rgb.blue  = blue;\n+}\n+\n+/**\n+ * Construct a new VTermColor instance representing an indexed color with the\n+ * given index.\n+ */\n+static inline void vterm_color_indexed(VTermColor *col, uint8_t idx)\n+{\n+  col->type = VTERM_COLOR_INDEXED;\n+  col->indexed.idx = idx;\n+}\n+\n+/**\n+ * Compares two colours. Returns true if the colors are equal, false otherwise.\n+ */\n+int vterm_color_is_equal(const VTermColor *a, const VTermColor *b);\n+\n+typedef enum {\n+  /* VTERM_VALUETYPE_NONE = 0 */\n+  VTERM_VALUETYPE_BOOL = 1,\n+  VTERM_VALUETYPE_INT,\n+  VTERM_VALUETYPE_STRING,\n+  VTERM_VALUETYPE_COLOR,\n+\n+  VTERM_N_VALUETYPES\n+} VTermValueType;\n+\n+typedef struct {\n+  const char *str;\n+  size_t      len : 30;\n+  bool        initial : 1;\n+  bool        final : 1;\n+} VTermStringFragment;\n+\n+typedef union {\n+  int boolean;\n+  int number;\n+  VTermStringFragment string;\n+  VTermColor color;\n+} VTermValue;\n+\n+typedef enum {\n+  /* VTERM_ATTR_NONE = 0 */\n+  VTERM_ATTR_BOLD = 1,   // bool:   1, 22\n+  VTERM_ATTR_UNDERLINE,  // number: 4, 21, 24\n+  VTERM_ATTR_ITALIC,     // bool:   3, 23\n+  VTERM_ATTR_BLINK,      // bool:   5, 25\n+  VTERM_ATTR_REVERSE,    // bool:   7, 27\n+  VTERM_ATTR_CONCEAL,    // bool:   8, 28\n+  VTERM_ATTR_STRIKE,     // bool:   9, 29\n+  VTERM_ATTR_FONT,       // number: 10-19\n+  VTERM_ATTR_FOREGROUND, // color:  30-39 90-97\n+  VTERM_ATTR_BACKGROUND, // color:  40-49 100-107\n+  VTERM_ATTR_SMALL,      // bool:   73, 74, 75\n+  VTERM_ATTR_BASELINE,   // number: 73, 74, 75\n+\n+  VTERM_N_ATTRS\n+} VTermAttr;\n+\n+typedef enum {\n+  /* VTERM_PROP_NONE = 0 */\n+  VTERM_PROP_CURSORVISIBLE = 1, // bool\n+  VTERM_PROP_CURSORBLINK,       // bool\n+  VTERM_PROP_ALTSCREEN,         // bool\n+  VTERM_PROP_TITLE,             // string\n+  VTERM_PROP_ICONNAME,          // string\n+  VTERM_PROP_REVERSE,           // bool\n+  VTERM_PROP_CURSORSHAPE,       // number\n+  VTERM_PROP_MOUSE,             // number\n+  VTERM_PROP_FOCUSREPORT,       // bool\n+\n+  VTERM_N_PROPS\n+} VTermProp;\n+\n+enum {\n+  VTERM_PROP_CURSORSHAPE_BLOCK = 1,\n+  VTERM_PROP_CURSORSHAPE_UNDERLINE,\n+  VTERM_PROP_CURSORSHAPE_BAR_LEFT,\n+\n+  VTERM_N_PROP_CURSORSHAPES\n+};\n+\n+enum {\n+  VTERM_PROP_MOUSE_NONE = 0,\n+  VTERM_PROP_MOUSE_CLICK,\n+  VTERM_PROP_MOUSE_DRAG,\n+  VTERM_PROP_MOUSE_MOVE,\n+\n+  VTERM_N_PROP_MOUSES\n+};\n+\n+typedef enum {\n+  VTERM_SELECTION_CLIPBOARD = (1<<0),\n+  VTERM_SELECTION_PRIMARY   = (1<<1),\n+  VTERM_SELECTION_SECONDARY = (1<<2),\n+  VTERM_SELECTION_SELECT    = (1<<3),\n+  VTERM_SELECTION_CUT0      = (1<<4), /* also CUT1 .. CUT7 by bitshifting */\n+} VTermSelectionMask;\n+\n+typedef struct {\n+  const uint32_t *chars;\n+  int             width;\n+  unsigned int    protected_cell:1;  /* DECSCA-protected against DECSEL/DECSED */\n+  unsigned int    dwl:1;             /* DECDWL or DECDHL double-width line */\n+  unsigned int    dhl:2;             /* DECDHL double-height line (1=top 2=bottom) */\n+} VTermGlyphInfo;\n+\n+typedef struct {\n+  unsigned int    doublewidth:1;     /* DECDWL or DECDHL line */\n+  unsigned int    doubleheight:2;    /* DECDHL line (1=top 2=bottom) */\n+  unsigned int    continuation:1;    /* Line is a flow continuation of the previous */\n+} VTermLineInfo;\n+\n+/* Copies of VTermState fields that the 'resize' callback might have reason to\n+ * edit. 'resize' callback gets total control of these fields and may\n+ * free-and-reallocate them if required. They will be copied back from the\n+ * struct after the callback has returned.\n+ */\n+typedef struct {\n+  VTermPos pos;                /* current cursor position */\n+  VTermLineInfo *lineinfos[2]; /* [1] may be NULL */\n+} VTermStateFields;\n+\n+typedef struct {\n+  /* libvterm relies on this memory to be zeroed out before it is returned\n+   * by the allocator. */\n+  void *(*malloc)(size_t size, void *allocdata);\n+  void  (*free)(void *ptr, void *allocdata);\n+} VTermAllocatorFunctions;\n+\n+void vterm_check_version(int major, int minor);\n+\n+struct VTermBuilder {\n+  int ver; /* currently unused but reserved for some sort of ABI version flag */\n+\n+  int rows, cols;\n+\n+  const VTermAllocatorFunctions *allocator;\n+  void *allocdata;\n+\n+  /* Override default sizes for various structures */\n+  size_t outbuffer_len;  /* default: 4096 */\n+  size_t tmpbuffer_len;  /* default: 4096 */\n+};\n+\n+VTerm *vterm_build(const struct VTermBuilder *builder);\n+\n+/* A convenient shortcut for default cases */\n+VTerm *vterm_new(int rows, int cols);\n+/* This shortcuts are generally discouraged in favour of just using vterm_build() */\n+VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata);\n+\n+void   vterm_free(VTerm* vt);\n+\n+void vterm_get_size(const VTerm *vt, int *rowsp, int *colsp);\n+void vterm_set_size(VTerm *vt, int rows, int cols);\n+\n+int  vterm_get_utf8(const VTerm *vt);\n+void vterm_set_utf8(VTerm *vt, int is_utf8);\n+\n+size_t vterm_input_write(VTerm *vt, const char *bytes, size_t len);\n+\n+/* Setting output callback will override the buffer logic */\n+typedef void VTermOutputCallback(const char *s, size_t len, void *user);\n+void vterm_output_set_callback(VTerm *vt, VTermOutputCallback *func, void *user);\n+\n+/* These buffer functions only work if output callback is NOT set\n+ * These are deprecated and will be removed in a later version */\n+size_t vterm_output_get_buffer_size(const VTerm *vt);\n+size_t vterm_output_get_buffer_current(const VTerm *vt);\n+size_t vterm_output_get_buffer_remaining(const VTerm *vt);\n+\n+/* This too */\n+size_t vterm_output_read(VTerm *vt, char *buffer, size_t len);\n+\n+void vterm_keyboard_unichar(VTerm *vt, uint32_t c, VTermModifier mod);\n+void vterm_keyboard_key(VTerm *vt, VTermKey key, VTermModifier mod);\n+\n+void vterm_keyboard_start_paste(VTerm *vt);\n+void vterm_keyboard_end_paste(VTerm *vt);\n+\n+void vterm_mouse_move(VTerm *vt, int row, int col, VTermModifier mod);\n+void vterm_mouse_button(VTerm *vt, int button, bool pressed, VTermModifier mod);\n+\n+// ------------\n+// Parser layer\n+// ------------\n+\n+/* Flag to indicate non-final subparameters in a single CSI parameter.\n+ * Consider\n+ *   CSI 1;2:3:4;5a\n+ * 1 4 and 5 are final.\n+ * 2 and 3 are non-final and will have this bit set\n+ *\n+ * Don't confuse this with the final byte of the CSI escape; 'a' in this case.\n+ */\n+#define CSI_ARG_FLAG_MORE (1U<<31)\n+#define CSI_ARG_MASK      (~(1U<<31))\n+\n+#define CSI_ARG_HAS_MORE(a) ((a) & CSI_ARG_FLAG_MORE)\n+#define CSI_ARG(a)          ((a) & CSI_ARG_MASK)\n+\n+/* Can't use -1 to indicate a missing argument; use this instead */\n+#define CSI_ARG_MISSING ((1UL<<31)-1)\n+\n+#define CSI_ARG_IS_MISSING(a) (CSI_ARG(a) == CSI_ARG_MISSING)\n+#define CSI_ARG_OR(a,def)     (CSI_ARG(a) == CSI_ARG_MISSING ? (def) : CSI_ARG(a))\n+#define CSI_ARG_COUNT(a)      (CSI_ARG(a) == CSI_ARG_MISSING || CSI_ARG(a) == 0 ? 1 : CSI_ARG(a))\n+\n+typedef struct {\n+  int (*text)(const char *bytes, size_t len, void *user);\n+  int (*control)(unsigned char control, void *user);\n+  int (*escape)(const char *bytes, size_t len, void *user);\n+  int (*csi)(const char *leader, const long args[], int argcount, const char *intermed, char command, void *user);\n+  int (*osc)(int command, VTermStringFragment frag, void *user);\n+  int (*dcs)(const char *command, size_t commandlen, VTermStringFragment frag, void *user);\n+  int (*apc)(VTermStringFragment frag, void *user);\n+  int (*pm)(VTermStringFragment frag, void *user);\n+  int (*sos)(VTermStringFragment frag, void *user);\n+  int (*resize)(int rows, int cols, void *user);\n+} VTermParserCallbacks;\n+\n+void  vterm_parser_set_callbacks(VTerm *vt, const VTermParserCallbacks *callbacks, void *user);\n+void *vterm_parser_get_cbdata(VTerm *vt);\n+\n+/* Normally NUL, CAN, SUB and DEL are ignored. Setting this true causes them\n+ * to be emitted by the 'control' callback\n+ */\n+void vterm_parser_set_emit_nul(VTerm *vt, bool emit);\n+\n+// -----------\n+// State layer\n+// -----------\n+\n+typedef struct {\n+  int (*putglyph)(VTermGlyphInfo *info, VTermPos pos, void *user);\n+  int (*movecursor)(VTermPos pos, VTermPos oldpos, int visible, void *user);\n+  int (*scrollrect)(VTermRect rect, int downward, int rightward, void *user);\n+  int (*moverect)(VTermRect dest, VTermRect src, void *user);\n+  int (*erase)(VTermRect rect, int selective, void *user);\n+  int (*initpen)(void *user);\n+  int (*setpenattr)(VTermAttr attr, VTermValue *val, void *user);\n+  int (*settermprop)(VTermProp prop, VTermValue *val, void *user);\n+  int (*bell)(void *user);\n+  int (*resize)(int rows, int cols, VTermStateFields *fields, void *user);\n+  int (*setlineinfo)(int row, const VTermLineInfo *newinfo, const VTermLineInfo *oldinfo, void *user);\n+  int (*sb_clear)(void *user);\n+} VTermStateCallbacks;\n+\n+typedef struct {\n+  int (*control)(unsigned char control, void *user);\n+  int (*csi)(const char *leader, const long args[], int argcount, const char *intermed, char command, void *user);\n+  int (*osc)(int command, VTermStringFragment frag, void *user);\n+  int (*dcs)(const char *command, size_t commandlen, VTermStringFragment frag, void *user);\n+  int (*apc)(VTermStringFragment frag, void *user);\n+  int (*pm)(VTermStringFragment frag, void *user);\n+  int (*sos)(VTermStringFragment frag, void *user);\n+} VTermStateFallbacks;\n+\n+typedef struct {\n+  int (*set)(VTermSelectionMask mask, VTermStringFragment frag, void *user);\n+  int (*query)(VTermSelectionMask mask, void *user);\n+} VTermSelectionCallbacks;\n+\n+VTermState *vterm_obtain_state(VTerm *vt);\n+\n+void  vterm_state_set_callbacks(VTermState *state, const VTermStateCallbacks *callbacks, void *user);\n+void *vterm_state_get_cbdata(VTermState *state);\n+\n+void  vterm_state_set_unrecognised_fallbacks(VTermState *state, const VTermStateFallbacks *fallbacks, void *user);\n+void *vterm_state_get_unrecognised_fbdata(VTermState *state);\n+\n+void vterm_state_reset(VTermState *state, int hard);\n+void vterm_state_get_cursorpos(const VTermState *state, VTermPos *cursorpos);\n+void vterm_state_get_default_colors(const VTermState *state, VTermColor *default_fg, VTermColor *default_bg);\n+void vterm_state_get_palette_color(const VTermState *state, int index, VTermColor *col);\n+void vterm_state_set_default_colors(VTermState *state, const VTermColor *default_fg, const VTermColor *default_bg);\n+void vterm_state_set_palette_color(VTermState *state, int index, const VTermColor *col);\n+void vterm_state_set_bold_highbright(VTermState *state, int bold_is_highbright);\n+int  vterm_state_get_penattr(const VTermState *state, VTermAttr attr, VTermValue *val);\n+int  vterm_state_set_termprop(VTermState *state, VTermProp prop, VTermValue *val);\n+void vterm_state_focus_in(VTermState *state);\n+void vterm_state_focus_out(VTermState *state);\n+const VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row);\n+\n+/**\n+ * Makes sure that the given color `col` is indeed an RGB colour. After this\n+ * function returns, VTERM_COLOR_IS_RGB(col) will return true, while all other\n+ * flags stored in `col->type` will have been reset.\n+ *\n+ * @param state is the VTermState instance from which the colour palette should\n+ * be extracted.\n+ * @param col is a pointer at the VTermColor instance that should be converted\n+ * to an RGB colour.\n+ */\n+void vterm_state_convert_color_to_rgb(const VTermState *state, VTermColor *col);\n+\n+void vterm_state_set_selection_callbacks(VTermState *state, const VTermSelectionCallbacks *callbacks, void *user,\n+    char *buffer, size_t buflen);\n+\n+void vterm_state_send_selection(VTermState *state, VTermSelectionMask mask, VTermStringFragment frag);\n+\n+// ------------\n+// Screen layer\n+// ------------\n+\n+typedef struct {\n+    unsigned int bold      : 1;\n+    unsigned int underline : 2;\n+    unsigned int italic    : 1;\n+    unsigned int blink     : 1;\n+    unsigned int reverse   : 1;\n+    unsigned int conceal   : 1;\n+    unsigned int strike    : 1;\n+    unsigned int font      : 4; /* 0 to 9 */\n+    unsigned int dwl       : 1; /* On a DECDWL or DECDHL line */\n+    unsigned int dhl       : 2; /* On a DECDHL line (1=top 2=bottom) */\n+    unsigned int small     : 1;",
            "html_url": "https://github.com/neovim/neovim/pull/30011#discussion_r1709267069",
            "id": 1709267069,
            "line": 510,
            "node_id": "PRRC_kwDOAPphoM5l4Vh9",
            "original_commit_id": "91757fad56437366892a275ccaaad0f124a3e08f",
            "original_line": 510,
            "original_position": 510,
            "original_start_line": null,
            "path": "src/vterm/vterm.h",
            "position": 510,
            "pull_request_review_id": 2227585554,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30011",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709267069/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-08-08T12:13:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709267069",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30011#discussion_r1709305234"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30011"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709305234"
                }
            },
            "author_association": "MEMBER",
            "body": "Code duplication: if we vendor both libs, we might be able to consolidate @gpanders \r\n\r\n(Original code is here: https://github.com/neovim/neovim/blob/a89088b7a02b70d15ccd6f17402c36f2ff7b7a81/src/termkey/termkey.c#L656-L689)",
            "commit_id": "f512769700ba99b98b88e6d8df4f538d9ee59030",
            "created_at": "2024-08-08T11:46:28Z",
            "diff_hunk": "@@ -0,0 +1,39 @@\n+/* The following functions copied and adapted from libtermkey",
            "html_url": "https://github.com/neovim/neovim/pull/30011#discussion_r1709305234",
            "id": 1709305234,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM5l4e2S",
            "original_commit_id": "91757fad56437366892a275ccaaad0f124a3e08f",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "src/vterm/utf8.h",
            "position": 1,
            "pull_request_review_id": 2227629836,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30011",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709305234/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-08-08T16:49:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709305234",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30011#discussion_r1709405481"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30011"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709405481"
                }
            },
            "author_association": "MEMBER",
            "body": "@zeertzjq I've pulled in the fixes suggested in https://github.com/neovim/neovim/issues/23762 and haven't seen any issues so far. I'd appreciate it if you could test your reproducers and see if they still fail.",
            "commit_id": "f512769700ba99b98b88e6d8df4f538d9ee59030",
            "created_at": "2024-08-08T12:39:48Z",
            "diff_hunk": "@@ -320,7 +320,7 @@ void terminal_open(Terminal **termpp, buf_T *buf, TerminalOptions opts)\n   term->vts = vterm_obtain_screen(term->vt);\n   vterm_screen_enable_altscreen(term->vts, true);\n   // TODO(clason): reenable when https://github.com/neovim/neovim/issues/23762 is fixed",
            "html_url": "https://github.com/neovim/neovim/pull/30011#discussion_r1709405481",
            "id": 1709405481,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5l43Up",
            "original_commit_id": "78feeb87c613ca38d8ca0847d8b8dddcc368b52c",
            "original_line": 322,
            "original_position": 21,
            "original_start_line": null,
            "path": "src/nvim/terminal.c",
            "position": null,
            "pull_request_review_id": 2227747902,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30011",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709405481/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-08-08T12:39:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709405481",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30011#discussion_r1709417589"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30011"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709417589"
                }
            },
            "author_association": "MEMBER",
            "body": "Question: should we vendor the tables as well? Or just move the comments to the include files?\r\n\r\n(Longterm we probably want to replace all of this with `utf8proc`?)",
            "commit_id": "f512769700ba99b98b88e6d8df4f538d9ee59030",
            "created_at": "2024-08-08T12:45:55Z",
            "diff_hunk": "@@ -0,0 +1,31 @@\n+6/0 = U+25C6 # BLACK DIAMOND",
            "html_url": "https://github.com/neovim/neovim/pull/30011#discussion_r1709417589",
            "id": 1709417589,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5l46R1",
            "original_commit_id": "78feeb87c613ca38d8ca0847d8b8dddcc368b52c",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "src/vterm/encoding/DECdrawing.tbl",
            "position": null,
            "pull_request_review_id": 2227763227,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30011",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709417589/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-08-08T12:45:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709417589",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30011#discussion_r1709433548"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30011"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709433548"
                }
            },
            "author_association": "MEMBER",
            "body": "These functions can eventually be replaced with our own (utf8proc-based) functions, which means we can remove this file and `fullwidth.inc` entirely.",
            "commit_id": "f512769700ba99b98b88e6d8df4f538d9ee59030",
            "created_at": "2024-08-08T12:54:09Z",
            "diff_hunk": "@@ -0,0 +1,313 @@\n+#include \"vterm_internal.h\"\n+\n+// ### The following from http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c\n+// With modifications:\n+//   made functions static\n+//   moved 'combining' table to file scope, so other functions can see it\n+// ###################################################################\n+\n+/*\n+ * This is an implementation of wcwidth() and wcswidth() (defined in\n+ * IEEE Std 1002.1-2001) for Unicode.\n+ *\n+ * http://www.opengroup.org/onlinepubs/007904975/functions/wcwidth.html\n+ * http://www.opengroup.org/onlinepubs/007904975/functions/wcswidth.html\n+ *\n+ * In fixed-width output devices, Latin characters all occupy a single\n+ * \"cell\" position of equal width, whereas ideographic CJK characters\n+ * occupy two such cells. Interoperability between terminal-line\n+ * applications and (teletype-style) character terminals using the\n+ * UTF-8 encoding requires agreement on which character should advance\n+ * the cursor by how many cell positions. No established formal\n+ * standards exist at present on which Unicode character shall occupy\n+ * how many cell positions on character terminals. These routines are\n+ * a first attempt of defining such behavior based on simple rules\n+ * applied to data provided by the Unicode Consortium.\n+ *\n+ * For some graphical characters, the Unicode standard explicitly\n+ * defines a character-cell width via the definition of the East Asian\n+ * FullWidth (F), Wide (W), Half-width (H), and Narrow (Na) classes.\n+ * In all these cases, there is no ambiguity about which width a\n+ * terminal shall use. For characters in the East Asian Ambiguous (A)\n+ * class, the width choice depends purely on a preference of backward\n+ * compatibility with either historic CJK or Western practice.\n+ * Choosing single-width for these characters is easy to justify as\n+ * the appropriate long-term solution, as the CJK practice of\n+ * displaying these characters as double-width comes from historic\n+ * implementation simplicity (8-bit encoded characters were displayed\n+ * single-width and 16-bit ones double-width, even for Greek,\n+ * Cyrillic, etc.) and not any typographic considerations.\n+ *\n+ * Much less clear is the choice of width for the Not East Asian\n+ * (Neutral) class. Existing practice does not dictate a width for any\n+ * of these characters. It would nevertheless make sense\n+ * typographically to allocate two character cells to characters such\n+ * as for instance EM SPACE or VOLUME INTEGRAL, which cannot be\n+ * represented adequately with a single-width glyph. The following\n+ * routines at present merely assign a single-cell width to all\n+ * neutral characters, in the interest of simplicity. This is not\n+ * entirely satisfactory and should be reconsidered before\n+ * establishing a formal standard in this area. At the moment, the\n+ * decision which Not East Asian (Neutral) characters should be\n+ * represented by double-width glyphs cannot yet be answered by\n+ * applying a simple rule from the Unicode database content. Setting\n+ * up a proper standard for the behavior of UTF-8 character terminals\n+ * will require a careful analysis not only of each Unicode character,\n+ * but also of each presentation form, something the author of these\n+ * routines has avoided to do so far.\n+ *\n+ * http://www.unicode.org/unicode/reports/tr11/\n+ *\n+ * Markus Kuhn -- 2007-05-26 (Unicode 5.0)\n+ *\n+ * Permission to use, copy, modify, and distribute this software\n+ * for any purpose and without fee is hereby granted. The author\n+ * disclaims all warranties with regard to this software.\n+ *\n+ * Latest version: http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c\n+ */\n+\n+struct interval {\n+  int first;\n+  int last;\n+};\n+\n+/* sorted list of non-overlapping intervals of non-spacing characters */\n+/* generated by \"uniset +cat=Me +cat=Mn +cat=Cf -00AD +1160-11FF +200B c\" */\n+static const struct interval combining[] = {\n+  { 0x0300, 0x036F }, { 0x0483, 0x0486 }, { 0x0488, 0x0489 },\n+  { 0x0591, 0x05BD }, { 0x05BF, 0x05BF }, { 0x05C1, 0x05C2 },\n+  { 0x05C4, 0x05C5 }, { 0x05C7, 0x05C7 }, { 0x0600, 0x0603 },\n+  { 0x0610, 0x0615 }, { 0x064B, 0x065E }, { 0x0670, 0x0670 },\n+  { 0x06D6, 0x06E4 }, { 0x06E7, 0x06E8 }, { 0x06EA, 0x06ED },\n+  { 0x070F, 0x070F }, { 0x0711, 0x0711 }, { 0x0730, 0x074A },\n+  { 0x07A6, 0x07B0 }, { 0x07EB, 0x07F3 }, { 0x0901, 0x0902 },\n+  { 0x093C, 0x093C }, { 0x0941, 0x0948 }, { 0x094D, 0x094D },\n+  { 0x0951, 0x0954 }, { 0x0962, 0x0963 }, { 0x0981, 0x0981 },\n+  { 0x09BC, 0x09BC }, { 0x09C1, 0x09C4 }, { 0x09CD, 0x09CD },\n+  { 0x09E2, 0x09E3 }, { 0x0A01, 0x0A02 }, { 0x0A3C, 0x0A3C },\n+  { 0x0A41, 0x0A42 }, { 0x0A47, 0x0A48 }, { 0x0A4B, 0x0A4D },\n+  { 0x0A70, 0x0A71 }, { 0x0A81, 0x0A82 }, { 0x0ABC, 0x0ABC },\n+  { 0x0AC1, 0x0AC5 }, { 0x0AC7, 0x0AC8 }, { 0x0ACD, 0x0ACD },\n+  { 0x0AE2, 0x0AE3 }, { 0x0B01, 0x0B01 }, { 0x0B3C, 0x0B3C },\n+  { 0x0B3F, 0x0B3F }, { 0x0B41, 0x0B43 }, { 0x0B4D, 0x0B4D },\n+  { 0x0B56, 0x0B56 }, { 0x0B82, 0x0B82 }, { 0x0BC0, 0x0BC0 },\n+  { 0x0BCD, 0x0BCD }, { 0x0C3E, 0x0C40 }, { 0x0C46, 0x0C48 },\n+  { 0x0C4A, 0x0C4D }, { 0x0C55, 0x0C56 }, { 0x0CBC, 0x0CBC },\n+  { 0x0CBF, 0x0CBF }, { 0x0CC6, 0x0CC6 }, { 0x0CCC, 0x0CCD },\n+  { 0x0CE2, 0x0CE3 }, { 0x0D41, 0x0D43 }, { 0x0D4D, 0x0D4D },\n+  { 0x0DCA, 0x0DCA }, { 0x0DD2, 0x0DD4 }, { 0x0DD6, 0x0DD6 },\n+  { 0x0E31, 0x0E31 }, { 0x0E34, 0x0E3A }, { 0x0E47, 0x0E4E },\n+  { 0x0EB1, 0x0EB1 }, { 0x0EB4, 0x0EB9 }, { 0x0EBB, 0x0EBC },\n+  { 0x0EC8, 0x0ECD }, { 0x0F18, 0x0F19 }, { 0x0F35, 0x0F35 },\n+  { 0x0F37, 0x0F37 }, { 0x0F39, 0x0F39 }, { 0x0F71, 0x0F7E },\n+  { 0x0F80, 0x0F84 }, { 0x0F86, 0x0F87 }, { 0x0F90, 0x0F97 },\n+  { 0x0F99, 0x0FBC }, { 0x0FC6, 0x0FC6 }, { 0x102D, 0x1030 },\n+  { 0x1032, 0x1032 }, { 0x1036, 0x1037 }, { 0x1039, 0x1039 },\n+  { 0x1058, 0x1059 }, { 0x1160, 0x11FF }, { 0x135F, 0x135F },\n+  { 0x1712, 0x1714 }, { 0x1732, 0x1734 }, { 0x1752, 0x1753 },\n+  { 0x1772, 0x1773 }, { 0x17B4, 0x17B5 }, { 0x17B7, 0x17BD },\n+  { 0x17C6, 0x17C6 }, { 0x17C9, 0x17D3 }, { 0x17DD, 0x17DD },\n+  { 0x180B, 0x180D }, { 0x18A9, 0x18A9 }, { 0x1920, 0x1922 },\n+  { 0x1927, 0x1928 }, { 0x1932, 0x1932 }, { 0x1939, 0x193B },\n+  { 0x1A17, 0x1A18 }, { 0x1B00, 0x1B03 }, { 0x1B34, 0x1B34 },\n+  { 0x1B36, 0x1B3A }, { 0x1B3C, 0x1B3C }, { 0x1B42, 0x1B42 },\n+  { 0x1B6B, 0x1B73 }, { 0x1DC0, 0x1DCA }, { 0x1DFE, 0x1DFF },\n+  { 0x200B, 0x200F }, { 0x202A, 0x202E }, { 0x2060, 0x2063 },\n+  { 0x206A, 0x206F }, { 0x20D0, 0x20EF }, { 0x302A, 0x302F },\n+  { 0x3099, 0x309A }, { 0xA806, 0xA806 }, { 0xA80B, 0xA80B },\n+  { 0xA825, 0xA826 }, { 0xFB1E, 0xFB1E }, { 0xFE00, 0xFE0F },\n+  { 0xFE20, 0xFE23 }, { 0xFEFF, 0xFEFF }, { 0xFFF9, 0xFFFB },\n+  { 0x10A01, 0x10A03 }, { 0x10A05, 0x10A06 }, { 0x10A0C, 0x10A0F },\n+  { 0x10A38, 0x10A3A }, { 0x10A3F, 0x10A3F }, { 0x1D167, 0x1D169 },\n+  { 0x1D173, 0x1D182 }, { 0x1D185, 0x1D18B }, { 0x1D1AA, 0x1D1AD },\n+  { 0x1D242, 0x1D244 }, { 0xE0001, 0xE0001 }, { 0xE0020, 0xE007F },\n+  { 0xE0100, 0xE01EF }\n+};\n+\n+\n+/* auxiliary function for binary search in interval table */\n+static int bisearch(uint32_t ucs, const struct interval *table, int max) {\n+  int min = 0;\n+  int mid;\n+\n+  if (ucs < table[0].first || ucs > table[max].last)\n+    return 0;\n+  while (max >= min) {\n+    mid = (min + max) / 2;\n+    if (ucs > table[mid].last)\n+      min = mid + 1;\n+    else if (ucs < table[mid].first)\n+      max = mid - 1;\n+    else\n+      return 1;\n+  }\n+\n+  return 0;\n+}\n+\n+\n+/* The following two functions define the column width of an ISO 10646\n+ * character as follows:\n+ *\n+ *    - The null character (U+0000) has a column width of 0.\n+ *\n+ *    - Other C0/C1 control characters and DEL will lead to a return\n+ *      value of -1.\n+ *\n+ *    - Non-spacing and enclosing combining characters (general\n+ *      category code Mn or Me in the Unicode database) have a\n+ *      column width of 0.\n+ *\n+ *    - SOFT HYPHEN (U+00AD) has a column width of 1.\n+ *\n+ *    - Other format characters (general category code Cf in the Unicode\n+ *      database) and ZERO WIDTH SPACE (U+200B) have a column width of 0.\n+ *\n+ *    - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)\n+ *      have a column width of 0.\n+ *\n+ *    - Spacing characters in the East Asian Wide (W) or East Asian\n+ *      Full-width (F) category as defined in Unicode Technical\n+ *      Report #11 have a column width of 2.\n+ *\n+ *    - All remaining characters (including all printable\n+ *      ISO 8859-1 and WGL4 characters, Unicode control characters,\n+ *      etc.) have a column width of 1.\n+ *\n+ * This implementation assumes that uint32_t characters are encoded\n+ * in ISO 10646.\n+ */\n+\n+\n+static int mk_wcwidth(uint32_t ucs)\n+{\n+  /* test for 8-bit control characters */\n+  if (ucs == 0)\n+    return 0;\n+  if (ucs < 32 || (ucs >= 0x7f && ucs < 0xa0))\n+    return -1;\n+\n+  /* binary search in table of non-spacing characters */\n+  if (bisearch(ucs, combining,\n+               sizeof(combining) / sizeof(struct interval) - 1))\n+    return 0;\n+\n+  /* if we arrive here, ucs is not a combining or C0/C1 control character */\n+\n+  return 1 + \n+    (ucs >= 0x1100 &&\n+     (ucs <= 0x115f ||                    /* Hangul Jamo init. consonants */\n+      ucs == 0x2329 || ucs == 0x232a ||\n+      (ucs >= 0x2e80 && ucs <= 0xa4cf &&\n+       ucs != 0x303f) ||                  /* CJK ... Yi */\n+      (ucs >= 0xac00 && ucs <= 0xd7a3) || /* Hangul Syllables */\n+      (ucs >= 0xf900 && ucs <= 0xfaff) || /* CJK Compatibility Ideographs */\n+      (ucs >= 0xfe10 && ucs <= 0xfe19) || /* Vertical forms */\n+      (ucs >= 0xfe30 && ucs <= 0xfe6f) || /* CJK Compatibility Forms */\n+      (ucs >= 0xff00 && ucs <= 0xff60) || /* Fullwidth Forms */\n+      (ucs >= 0xffe0 && ucs <= 0xffe6) ||\n+      (ucs >= 0x20000 && ucs <= 0x2fffd) ||\n+      (ucs >= 0x30000 && ucs <= 0x3fffd)));\n+}\n+\n+\n+#ifdef USE_MK_WCWIDTH_CJK\n+\n+/*\n+ * The following functions are the same as mk_wcwidth() and\n+ * mk_wcswidth(), except that spacing characters in the East Asian\n+ * Ambiguous (A) category as defined in Unicode Technical Report #11\n+ * have a column width of 2. This variant might be useful for users of\n+ * CJK legacy encodings who want to migrate to UCS without changing\n+ * the traditional terminal character-width behaviour. It is not\n+ * otherwise recommended for general use.\n+ */\n+static int mk_wcwidth_cjk(uint32_t ucs)\n+{\n+  /* sorted list of non-overlapping intervals of East Asian Ambiguous\n+   * characters, generated by \"uniset +WIDTH-A -cat=Me -cat=Mn -cat=Cf c\" */\n+  static const struct interval ambiguous[] = {\n+    { 0x00A1, 0x00A1 }, { 0x00A4, 0x00A4 }, { 0x00A7, 0x00A8 },\n+    { 0x00AA, 0x00AA }, { 0x00AE, 0x00AE }, { 0x00B0, 0x00B4 },\n+    { 0x00B6, 0x00BA }, { 0x00BC, 0x00BF }, { 0x00C6, 0x00C6 },\n+    { 0x00D0, 0x00D0 }, { 0x00D7, 0x00D8 }, { 0x00DE, 0x00E1 },\n+    { 0x00E6, 0x00E6 }, { 0x00E8, 0x00EA }, { 0x00EC, 0x00ED },\n+    { 0x00F0, 0x00F0 }, { 0x00F2, 0x00F3 }, { 0x00F7, 0x00FA },\n+    { 0x00FC, 0x00FC }, { 0x00FE, 0x00FE }, { 0x0101, 0x0101 },\n+    { 0x0111, 0x0111 }, { 0x0113, 0x0113 }, { 0x011B, 0x011B },\n+    { 0x0126, 0x0127 }, { 0x012B, 0x012B }, { 0x0131, 0x0133 },\n+    { 0x0138, 0x0138 }, { 0x013F, 0x0142 }, { 0x0144, 0x0144 },\n+    { 0x0148, 0x014B }, { 0x014D, 0x014D }, { 0x0152, 0x0153 },\n+    { 0x0166, 0x0167 }, { 0x016B, 0x016B }, { 0x01CE, 0x01CE },\n+    { 0x01D0, 0x01D0 }, { 0x01D2, 0x01D2 }, { 0x01D4, 0x01D4 },\n+    { 0x01D6, 0x01D6 }, { 0x01D8, 0x01D8 }, { 0x01DA, 0x01DA },\n+    { 0x01DC, 0x01DC }, { 0x0251, 0x0251 }, { 0x0261, 0x0261 },\n+    { 0x02C4, 0x02C4 }, { 0x02C7, 0x02C7 }, { 0x02C9, 0x02CB },\n+    { 0x02CD, 0x02CD }, { 0x02D0, 0x02D0 }, { 0x02D8, 0x02DB },\n+    { 0x02DD, 0x02DD }, { 0x02DF, 0x02DF }, { 0x0391, 0x03A1 },\n+    { 0x03A3, 0x03A9 }, { 0x03B1, 0x03C1 }, { 0x03C3, 0x03C9 },\n+    { 0x0401, 0x0401 }, { 0x0410, 0x044F }, { 0x0451, 0x0451 },\n+    { 0x2010, 0x2010 }, { 0x2013, 0x2016 }, { 0x2018, 0x2019 },\n+    { 0x201C, 0x201D }, { 0x2020, 0x2022 }, { 0x2024, 0x2027 },\n+    { 0x2030, 0x2030 }, { 0x2032, 0x2033 }, { 0x2035, 0x2035 },\n+    { 0x203B, 0x203B }, { 0x203E, 0x203E }, { 0x2074, 0x2074 },\n+    { 0x207F, 0x207F }, { 0x2081, 0x2084 }, { 0x20AC, 0x20AC },\n+    { 0x2103, 0x2103 }, { 0x2105, 0x2105 }, { 0x2109, 0x2109 },\n+    { 0x2113, 0x2113 }, { 0x2116, 0x2116 }, { 0x2121, 0x2122 },\n+    { 0x2126, 0x2126 }, { 0x212B, 0x212B }, { 0x2153, 0x2154 },\n+    { 0x215B, 0x215E }, { 0x2160, 0x216B }, { 0x2170, 0x2179 },\n+    { 0x2190, 0x2199 }, { 0x21B8, 0x21B9 }, { 0x21D2, 0x21D2 },\n+    { 0x21D4, 0x21D4 }, { 0x21E7, 0x21E7 }, { 0x2200, 0x2200 },\n+    { 0x2202, 0x2203 }, { 0x2207, 0x2208 }, { 0x220B, 0x220B },\n+    { 0x220F, 0x220F }, { 0x2211, 0x2211 }, { 0x2215, 0x2215 },\n+    { 0x221A, 0x221A }, { 0x221D, 0x2220 }, { 0x2223, 0x2223 },\n+    { 0x2225, 0x2225 }, { 0x2227, 0x222C }, { 0x222E, 0x222E },\n+    { 0x2234, 0x2237 }, { 0x223C, 0x223D }, { 0x2248, 0x2248 },\n+    { 0x224C, 0x224C }, { 0x2252, 0x2252 }, { 0x2260, 0x2261 },\n+    { 0x2264, 0x2267 }, { 0x226A, 0x226B }, { 0x226E, 0x226F },\n+    { 0x2282, 0x2283 }, { 0x2286, 0x2287 }, { 0x2295, 0x2295 },\n+    { 0x2299, 0x2299 }, { 0x22A5, 0x22A5 }, { 0x22BF, 0x22BF },\n+    { 0x2312, 0x2312 }, { 0x2460, 0x24E9 }, { 0x24EB, 0x254B },\n+    { 0x2550, 0x2573 }, { 0x2580, 0x258F }, { 0x2592, 0x2595 },\n+    { 0x25A0, 0x25A1 }, { 0x25A3, 0x25A9 }, { 0x25B2, 0x25B3 },\n+    { 0x25B6, 0x25B7 }, { 0x25BC, 0x25BD }, { 0x25C0, 0x25C1 },\n+    { 0x25C6, 0x25C8 }, { 0x25CB, 0x25CB }, { 0x25CE, 0x25D1 },\n+    { 0x25E2, 0x25E5 }, { 0x25EF, 0x25EF }, { 0x2605, 0x2606 },\n+    { 0x2609, 0x2609 }, { 0x260E, 0x260F }, { 0x2614, 0x2615 },\n+    { 0x261C, 0x261C }, { 0x261E, 0x261E }, { 0x2640, 0x2640 },\n+    { 0x2642, 0x2642 }, { 0x2660, 0x2661 }, { 0x2663, 0x2665 },\n+    { 0x2667, 0x266A }, { 0x266C, 0x266D }, { 0x266F, 0x266F },\n+    { 0x273D, 0x273D }, { 0x2776, 0x277F }, { 0xE000, 0xF8FF },\n+    { 0xFFFD, 0xFFFD }, { 0xF0000, 0xFFFFD }, { 0x100000, 0x10FFFD }\n+  };\n+\n+  /* binary search in table of non-spacing characters */\n+  if (bisearch(ucs, ambiguous,\n+               sizeof(ambiguous) / sizeof(struct interval) - 1))\n+    return 2;\n+\n+  return mk_wcwidth(ucs);\n+}\n+\n+#endif\n+\n+// ################################\n+// ### The rest added by Paul Evans\n+\n+static const struct interval fullwidth[] = {\n+#include \"fullwidth.inc\"\n+};\n+\n+INTERNAL int vterm_unicode_width(uint32_t codepoint)\n+{\n+  if(bisearch(codepoint, fullwidth, sizeof(fullwidth) / sizeof(fullwidth[0]) - 1))\n+    return 2;\n+\n+  return mk_wcwidth(codepoint);\n+}\n+\n+INTERNAL int vterm_unicode_is_combining(uint32_t codepoint)\n+{\n+  return bisearch(codepoint, combining, sizeof(combining) / sizeof(struct interval) - 1);\n+}",
            "html_url": "https://github.com/neovim/neovim/pull/30011#discussion_r1709433548",
            "id": 1709433548,
            "line": 313,
            "node_id": "PRRC_kwDOAPphoM5l4-LM",
            "original_commit_id": "78feeb87c613ca38d8ca0847d8b8dddcc368b52c",
            "original_line": 313,
            "original_position": 313,
            "original_start_line": 302,
            "path": "src/vterm/unicode.c",
            "position": 313,
            "pull_request_review_id": 2227783911,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30011",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709433548/reactions"
            },
            "side": "RIGHT",
            "start_line": 302,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-08-08T16:48:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709433548",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30011#discussion_r1709672759"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30011"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709672759"
                }
            },
            "author_association": "MEMBER",
            "body": "`<windows.h>` includes `<rpcndr.h>`, which contains the following:\r\n\r\n```\r\n#define small char\r\n```\r\n\r\nAdding a `#undef small` after `#include <windows.h>` in `src/nvim/os/win_defs.h` removes the warning.",
            "commit_id": "f512769700ba99b98b88e6d8df4f538d9ee59030",
            "created_at": "2024-08-08T14:45:15Z",
            "diff_hunk": "@@ -0,0 +1,637 @@\n+#ifndef __VTERM_H__\n+#define __VTERM_H__\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include \"vterm_keycodes.h\"\n+\n+#define VTERM_VERSION_MAJOR 0\n+#define VTERM_VERSION_MINOR 3\n+#define VTERM_VERSION_PATCH 3\n+\n+#define VTERM_CHECK_VERSION \\\n+        vterm_check_version(VTERM_VERSION_MAJOR, VTERM_VERSION_MINOR)\n+\n+/* Any cell can contain at most one basic printing character and 5 combining\n+ * characters. This number could be changed but will be ABI-incompatible if\n+ * you do */\n+#define VTERM_MAX_CHARS_PER_CELL 6\n+\n+typedef struct VTerm VTerm;\n+typedef struct VTermState VTermState;\n+typedef struct VTermScreen VTermScreen;\n+\n+typedef struct {\n+  int row;\n+  int col;\n+} VTermPos;\n+\n+/* some small utility functions; we can just keep these static here */\n+\n+/* order points by on-screen flow order */\n+static inline int vterm_pos_cmp(VTermPos a, VTermPos b)\n+{\n+  return (a.row == b.row) ? a.col - b.col : a.row - b.row;\n+}\n+\n+typedef struct {\n+  int start_row;\n+  int end_row;\n+  int start_col;\n+  int end_col;\n+} VTermRect;\n+\n+/* true if the rect contains the point */\n+static inline int vterm_rect_contains(VTermRect r, VTermPos p)\n+{\n+  return p.row >= r.start_row && p.row < r.end_row &&\n+         p.col >= r.start_col && p.col < r.end_col;\n+}\n+\n+/* move a rect */\n+static inline void vterm_rect_move(VTermRect *rect, int row_delta, int col_delta)\n+{\n+  rect->start_row += row_delta; rect->end_row += row_delta;\n+  rect->start_col += col_delta; rect->end_col += col_delta;\n+}\n+\n+/**\n+ * Bit-field describing the content of the tagged union `VTermColor`.\n+ */\n+typedef enum {\n+  /**\n+   * If the lower bit of `type` is not set, the colour is 24-bit RGB.\n+   */\n+  VTERM_COLOR_RGB = 0x00,\n+\n+  /**\n+   * The colour is an index into a palette of 256 colours.\n+   */\n+  VTERM_COLOR_INDEXED = 0x01,\n+\n+  /**\n+   * Mask that can be used to extract the RGB/Indexed bit.\n+   */\n+  VTERM_COLOR_TYPE_MASK = 0x01,\n+\n+  /**\n+   * If set, indicates that this colour should be the default foreground\n+   * color, i.e. there was no SGR request for another colour. When\n+   * rendering this colour it is possible to ignore \"idx\" and just use a\n+   * colour that is not in the palette.\n+   */\n+  VTERM_COLOR_DEFAULT_FG = 0x02,\n+\n+  /**\n+   * If set, indicates that this colour should be the default background\n+   * color, i.e. there was no SGR request for another colour. A common\n+   * option when rendering this colour is to not render a background at\n+   * all, for example by rendering the window transparently at this spot.\n+   */\n+  VTERM_COLOR_DEFAULT_BG = 0x04,\n+\n+  /**\n+   * Mask that can be used to extract the default foreground/background bit.\n+   */\n+  VTERM_COLOR_DEFAULT_MASK = 0x06\n+} VTermColorType;\n+\n+/**\n+ * Returns true if the VTERM_COLOR_RGB `type` flag is set, indicating that the\n+ * given VTermColor instance is an indexed colour.\n+ */\n+#define VTERM_COLOR_IS_INDEXED(col) \\\n+  (((col)->type & VTERM_COLOR_TYPE_MASK) == VTERM_COLOR_INDEXED)\n+\n+/**\n+ * Returns true if the VTERM_COLOR_INDEXED `type` flag is set, indicating that\n+ * the given VTermColor instance is an rgb colour.\n+ */\n+#define VTERM_COLOR_IS_RGB(col) \\\n+  (((col)->type & VTERM_COLOR_TYPE_MASK) == VTERM_COLOR_RGB)\n+\n+/**\n+ * Returns true if the VTERM_COLOR_DEFAULT_FG `type` flag is set, indicating\n+ * that the given VTermColor instance corresponds to the default foreground\n+ * color.\n+ */\n+#define VTERM_COLOR_IS_DEFAULT_FG(col) \\\n+  (!!((col)->type & VTERM_COLOR_DEFAULT_FG))\n+\n+/**\n+ * Returns true if the VTERM_COLOR_DEFAULT_BG `type` flag is set, indicating\n+ * that the given VTermColor instance corresponds to the default background\n+ * color.\n+ */\n+#define VTERM_COLOR_IS_DEFAULT_BG(col) \\\n+  (!!((col)->type & VTERM_COLOR_DEFAULT_BG))\n+\n+/**\n+ * Tagged union storing either an RGB color or an index into a colour palette.\n+ * In order to convert indexed colours to RGB, you may use the\n+ * vterm_state_convert_color_to_rgb() or vterm_screen_convert_color_to_rgb()\n+ * functions which lookup the RGB colour from the palette maintained by a\n+ * VTermState or VTermScreen instance.\n+ */\n+typedef union {\n+  /**\n+   * Tag indicating which union member is actually valid. This variable\n+   * coincides with the `type` member of the `rgb` and the `indexed` struct\n+   * in memory. Please use the `VTERM_COLOR_IS_*` test macros to check whether\n+   * a particular type flag is set.\n+   */\n+  uint8_t type;\n+\n+  /**\n+   * Valid if `VTERM_COLOR_IS_RGB(type)` is true. Holds the RGB colour values.\n+   */\n+  struct {\n+    /**\n+     * Same as the top-level `type` member stored in VTermColor.\n+     */\n+    uint8_t type;\n+\n+    /**\n+     * The actual 8-bit red, green, blue colour values.\n+     */\n+    uint8_t red, green, blue;\n+  } rgb;\n+\n+  /**\n+   * If `VTERM_COLOR_IS_INDEXED(type)` is true, this member holds the index into\n+   * the colour palette.\n+   */\n+  struct {\n+    /**\n+     * Same as the top-level `type` member stored in VTermColor.\n+     */\n+    uint8_t type;\n+\n+    /**\n+     * Index into the colour map.\n+     */\n+    uint8_t idx;\n+  } indexed;\n+} VTermColor;\n+\n+/**\n+ * Constructs a new VTermColor instance representing the given RGB values.\n+ */\n+static inline void vterm_color_rgb(VTermColor *col, uint8_t red, uint8_t green,\n+                                   uint8_t blue)\n+{\n+  col->type = VTERM_COLOR_RGB;\n+  col->rgb.red   = red;\n+  col->rgb.green = green;\n+  col->rgb.blue  = blue;\n+}\n+\n+/**\n+ * Construct a new VTermColor instance representing an indexed color with the\n+ * given index.\n+ */\n+static inline void vterm_color_indexed(VTermColor *col, uint8_t idx)\n+{\n+  col->type = VTERM_COLOR_INDEXED;\n+  col->indexed.idx = idx;\n+}\n+\n+/**\n+ * Compares two colours. Returns true if the colors are equal, false otherwise.\n+ */\n+int vterm_color_is_equal(const VTermColor *a, const VTermColor *b);\n+\n+typedef enum {\n+  /* VTERM_VALUETYPE_NONE = 0 */\n+  VTERM_VALUETYPE_BOOL = 1,\n+  VTERM_VALUETYPE_INT,\n+  VTERM_VALUETYPE_STRING,\n+  VTERM_VALUETYPE_COLOR,\n+\n+  VTERM_N_VALUETYPES\n+} VTermValueType;\n+\n+typedef struct {\n+  const char *str;\n+  size_t      len : 30;\n+  bool        initial : 1;\n+  bool        final : 1;\n+} VTermStringFragment;\n+\n+typedef union {\n+  int boolean;\n+  int number;\n+  VTermStringFragment string;\n+  VTermColor color;\n+} VTermValue;\n+\n+typedef enum {\n+  /* VTERM_ATTR_NONE = 0 */\n+  VTERM_ATTR_BOLD = 1,   // bool:   1, 22\n+  VTERM_ATTR_UNDERLINE,  // number: 4, 21, 24\n+  VTERM_ATTR_ITALIC,     // bool:   3, 23\n+  VTERM_ATTR_BLINK,      // bool:   5, 25\n+  VTERM_ATTR_REVERSE,    // bool:   7, 27\n+  VTERM_ATTR_CONCEAL,    // bool:   8, 28\n+  VTERM_ATTR_STRIKE,     // bool:   9, 29\n+  VTERM_ATTR_FONT,       // number: 10-19\n+  VTERM_ATTR_FOREGROUND, // color:  30-39 90-97\n+  VTERM_ATTR_BACKGROUND, // color:  40-49 100-107\n+  VTERM_ATTR_SMALL,      // bool:   73, 74, 75\n+  VTERM_ATTR_BASELINE,   // number: 73, 74, 75\n+\n+  VTERM_N_ATTRS\n+} VTermAttr;\n+\n+typedef enum {\n+  /* VTERM_PROP_NONE = 0 */\n+  VTERM_PROP_CURSORVISIBLE = 1, // bool\n+  VTERM_PROP_CURSORBLINK,       // bool\n+  VTERM_PROP_ALTSCREEN,         // bool\n+  VTERM_PROP_TITLE,             // string\n+  VTERM_PROP_ICONNAME,          // string\n+  VTERM_PROP_REVERSE,           // bool\n+  VTERM_PROP_CURSORSHAPE,       // number\n+  VTERM_PROP_MOUSE,             // number\n+  VTERM_PROP_FOCUSREPORT,       // bool\n+\n+  VTERM_N_PROPS\n+} VTermProp;\n+\n+enum {\n+  VTERM_PROP_CURSORSHAPE_BLOCK = 1,\n+  VTERM_PROP_CURSORSHAPE_UNDERLINE,\n+  VTERM_PROP_CURSORSHAPE_BAR_LEFT,\n+\n+  VTERM_N_PROP_CURSORSHAPES\n+};\n+\n+enum {\n+  VTERM_PROP_MOUSE_NONE = 0,\n+  VTERM_PROP_MOUSE_CLICK,\n+  VTERM_PROP_MOUSE_DRAG,\n+  VTERM_PROP_MOUSE_MOVE,\n+\n+  VTERM_N_PROP_MOUSES\n+};\n+\n+typedef enum {\n+  VTERM_SELECTION_CLIPBOARD = (1<<0),\n+  VTERM_SELECTION_PRIMARY   = (1<<1),\n+  VTERM_SELECTION_SECONDARY = (1<<2),\n+  VTERM_SELECTION_SELECT    = (1<<3),\n+  VTERM_SELECTION_CUT0      = (1<<4), /* also CUT1 .. CUT7 by bitshifting */\n+} VTermSelectionMask;\n+\n+typedef struct {\n+  const uint32_t *chars;\n+  int             width;\n+  unsigned int    protected_cell:1;  /* DECSCA-protected against DECSEL/DECSED */\n+  unsigned int    dwl:1;             /* DECDWL or DECDHL double-width line */\n+  unsigned int    dhl:2;             /* DECDHL double-height line (1=top 2=bottom) */\n+} VTermGlyphInfo;\n+\n+typedef struct {\n+  unsigned int    doublewidth:1;     /* DECDWL or DECDHL line */\n+  unsigned int    doubleheight:2;    /* DECDHL line (1=top 2=bottom) */\n+  unsigned int    continuation:1;    /* Line is a flow continuation of the previous */\n+} VTermLineInfo;\n+\n+/* Copies of VTermState fields that the 'resize' callback might have reason to\n+ * edit. 'resize' callback gets total control of these fields and may\n+ * free-and-reallocate them if required. They will be copied back from the\n+ * struct after the callback has returned.\n+ */\n+typedef struct {\n+  VTermPos pos;                /* current cursor position */\n+  VTermLineInfo *lineinfos[2]; /* [1] may be NULL */\n+} VTermStateFields;\n+\n+typedef struct {\n+  /* libvterm relies on this memory to be zeroed out before it is returned\n+   * by the allocator. */\n+  void *(*malloc)(size_t size, void *allocdata);\n+  void  (*free)(void *ptr, void *allocdata);\n+} VTermAllocatorFunctions;\n+\n+void vterm_check_version(int major, int minor);\n+\n+struct VTermBuilder {\n+  int ver; /* currently unused but reserved for some sort of ABI version flag */\n+\n+  int rows, cols;\n+\n+  const VTermAllocatorFunctions *allocator;\n+  void *allocdata;\n+\n+  /* Override default sizes for various structures */\n+  size_t outbuffer_len;  /* default: 4096 */\n+  size_t tmpbuffer_len;  /* default: 4096 */\n+};\n+\n+VTerm *vterm_build(const struct VTermBuilder *builder);\n+\n+/* A convenient shortcut for default cases */\n+VTerm *vterm_new(int rows, int cols);\n+/* This shortcuts are generally discouraged in favour of just using vterm_build() */\n+VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata);\n+\n+void   vterm_free(VTerm* vt);\n+\n+void vterm_get_size(const VTerm *vt, int *rowsp, int *colsp);\n+void vterm_set_size(VTerm *vt, int rows, int cols);\n+\n+int  vterm_get_utf8(const VTerm *vt);\n+void vterm_set_utf8(VTerm *vt, int is_utf8);\n+\n+size_t vterm_input_write(VTerm *vt, const char *bytes, size_t len);\n+\n+/* Setting output callback will override the buffer logic */\n+typedef void VTermOutputCallback(const char *s, size_t len, void *user);\n+void vterm_output_set_callback(VTerm *vt, VTermOutputCallback *func, void *user);\n+\n+/* These buffer functions only work if output callback is NOT set\n+ * These are deprecated and will be removed in a later version */\n+size_t vterm_output_get_buffer_size(const VTerm *vt);\n+size_t vterm_output_get_buffer_current(const VTerm *vt);\n+size_t vterm_output_get_buffer_remaining(const VTerm *vt);\n+\n+/* This too */\n+size_t vterm_output_read(VTerm *vt, char *buffer, size_t len);\n+\n+void vterm_keyboard_unichar(VTerm *vt, uint32_t c, VTermModifier mod);\n+void vterm_keyboard_key(VTerm *vt, VTermKey key, VTermModifier mod);\n+\n+void vterm_keyboard_start_paste(VTerm *vt);\n+void vterm_keyboard_end_paste(VTerm *vt);\n+\n+void vterm_mouse_move(VTerm *vt, int row, int col, VTermModifier mod);\n+void vterm_mouse_button(VTerm *vt, int button, bool pressed, VTermModifier mod);\n+\n+// ------------\n+// Parser layer\n+// ------------\n+\n+/* Flag to indicate non-final subparameters in a single CSI parameter.\n+ * Consider\n+ *   CSI 1;2:3:4;5a\n+ * 1 4 and 5 are final.\n+ * 2 and 3 are non-final and will have this bit set\n+ *\n+ * Don't confuse this with the final byte of the CSI escape; 'a' in this case.\n+ */\n+#define CSI_ARG_FLAG_MORE (1U<<31)\n+#define CSI_ARG_MASK      (~(1U<<31))\n+\n+#define CSI_ARG_HAS_MORE(a) ((a) & CSI_ARG_FLAG_MORE)\n+#define CSI_ARG(a)          ((a) & CSI_ARG_MASK)\n+\n+/* Can't use -1 to indicate a missing argument; use this instead */\n+#define CSI_ARG_MISSING ((1UL<<31)-1)\n+\n+#define CSI_ARG_IS_MISSING(a) (CSI_ARG(a) == CSI_ARG_MISSING)\n+#define CSI_ARG_OR(a,def)     (CSI_ARG(a) == CSI_ARG_MISSING ? (def) : CSI_ARG(a))\n+#define CSI_ARG_COUNT(a)      (CSI_ARG(a) == CSI_ARG_MISSING || CSI_ARG(a) == 0 ? 1 : CSI_ARG(a))\n+\n+typedef struct {\n+  int (*text)(const char *bytes, size_t len, void *user);\n+  int (*control)(unsigned char control, void *user);\n+  int (*escape)(const char *bytes, size_t len, void *user);\n+  int (*csi)(const char *leader, const long args[], int argcount, const char *intermed, char command, void *user);\n+  int (*osc)(int command, VTermStringFragment frag, void *user);\n+  int (*dcs)(const char *command, size_t commandlen, VTermStringFragment frag, void *user);\n+  int (*apc)(VTermStringFragment frag, void *user);\n+  int (*pm)(VTermStringFragment frag, void *user);\n+  int (*sos)(VTermStringFragment frag, void *user);\n+  int (*resize)(int rows, int cols, void *user);\n+} VTermParserCallbacks;\n+\n+void  vterm_parser_set_callbacks(VTerm *vt, const VTermParserCallbacks *callbacks, void *user);\n+void *vterm_parser_get_cbdata(VTerm *vt);\n+\n+/* Normally NUL, CAN, SUB and DEL are ignored. Setting this true causes them\n+ * to be emitted by the 'control' callback\n+ */\n+void vterm_parser_set_emit_nul(VTerm *vt, bool emit);\n+\n+// -----------\n+// State layer\n+// -----------\n+\n+typedef struct {\n+  int (*putglyph)(VTermGlyphInfo *info, VTermPos pos, void *user);\n+  int (*movecursor)(VTermPos pos, VTermPos oldpos, int visible, void *user);\n+  int (*scrollrect)(VTermRect rect, int downward, int rightward, void *user);\n+  int (*moverect)(VTermRect dest, VTermRect src, void *user);\n+  int (*erase)(VTermRect rect, int selective, void *user);\n+  int (*initpen)(void *user);\n+  int (*setpenattr)(VTermAttr attr, VTermValue *val, void *user);\n+  int (*settermprop)(VTermProp prop, VTermValue *val, void *user);\n+  int (*bell)(void *user);\n+  int (*resize)(int rows, int cols, VTermStateFields *fields, void *user);\n+  int (*setlineinfo)(int row, const VTermLineInfo *newinfo, const VTermLineInfo *oldinfo, void *user);\n+  int (*sb_clear)(void *user);\n+} VTermStateCallbacks;\n+\n+typedef struct {\n+  int (*control)(unsigned char control, void *user);\n+  int (*csi)(const char *leader, const long args[], int argcount, const char *intermed, char command, void *user);\n+  int (*osc)(int command, VTermStringFragment frag, void *user);\n+  int (*dcs)(const char *command, size_t commandlen, VTermStringFragment frag, void *user);\n+  int (*apc)(VTermStringFragment frag, void *user);\n+  int (*pm)(VTermStringFragment frag, void *user);\n+  int (*sos)(VTermStringFragment frag, void *user);\n+} VTermStateFallbacks;\n+\n+typedef struct {\n+  int (*set)(VTermSelectionMask mask, VTermStringFragment frag, void *user);\n+  int (*query)(VTermSelectionMask mask, void *user);\n+} VTermSelectionCallbacks;\n+\n+VTermState *vterm_obtain_state(VTerm *vt);\n+\n+void  vterm_state_set_callbacks(VTermState *state, const VTermStateCallbacks *callbacks, void *user);\n+void *vterm_state_get_cbdata(VTermState *state);\n+\n+void  vterm_state_set_unrecognised_fallbacks(VTermState *state, const VTermStateFallbacks *fallbacks, void *user);\n+void *vterm_state_get_unrecognised_fbdata(VTermState *state);\n+\n+void vterm_state_reset(VTermState *state, int hard);\n+void vterm_state_get_cursorpos(const VTermState *state, VTermPos *cursorpos);\n+void vterm_state_get_default_colors(const VTermState *state, VTermColor *default_fg, VTermColor *default_bg);\n+void vterm_state_get_palette_color(const VTermState *state, int index, VTermColor *col);\n+void vterm_state_set_default_colors(VTermState *state, const VTermColor *default_fg, const VTermColor *default_bg);\n+void vterm_state_set_palette_color(VTermState *state, int index, const VTermColor *col);\n+void vterm_state_set_bold_highbright(VTermState *state, int bold_is_highbright);\n+int  vterm_state_get_penattr(const VTermState *state, VTermAttr attr, VTermValue *val);\n+int  vterm_state_set_termprop(VTermState *state, VTermProp prop, VTermValue *val);\n+void vterm_state_focus_in(VTermState *state);\n+void vterm_state_focus_out(VTermState *state);\n+const VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row);\n+\n+/**\n+ * Makes sure that the given color `col` is indeed an RGB colour. After this\n+ * function returns, VTERM_COLOR_IS_RGB(col) will return true, while all other\n+ * flags stored in `col->type` will have been reset.\n+ *\n+ * @param state is the VTermState instance from which the colour palette should\n+ * be extracted.\n+ * @param col is a pointer at the VTermColor instance that should be converted\n+ * to an RGB colour.\n+ */\n+void vterm_state_convert_color_to_rgb(const VTermState *state, VTermColor *col);\n+\n+void vterm_state_set_selection_callbacks(VTermState *state, const VTermSelectionCallbacks *callbacks, void *user,\n+    char *buffer, size_t buflen);\n+\n+void vterm_state_send_selection(VTermState *state, VTermSelectionMask mask, VTermStringFragment frag);\n+\n+// ------------\n+// Screen layer\n+// ------------\n+\n+typedef struct {\n+    unsigned int bold      : 1;\n+    unsigned int underline : 2;\n+    unsigned int italic    : 1;\n+    unsigned int blink     : 1;\n+    unsigned int reverse   : 1;\n+    unsigned int conceal   : 1;\n+    unsigned int strike    : 1;\n+    unsigned int font      : 4; /* 0 to 9 */\n+    unsigned int dwl       : 1; /* On a DECDWL or DECDHL line */\n+    unsigned int dhl       : 2; /* On a DECDHL line (1=top 2=bottom) */\n+    unsigned int small     : 1;",
            "html_url": "https://github.com/neovim/neovim/pull/30011#discussion_r1709672759",
            "id": 1709672759,
            "in_reply_to_id": 1709267069,
            "line": 510,
            "node_id": "PRRC_kwDOAPphoM5l54k3",
            "original_commit_id": "91757fad56437366892a275ccaaad0f124a3e08f",
            "original_line": 510,
            "original_position": 510,
            "original_start_line": null,
            "path": "src/vterm/vterm.h",
            "position": 510,
            "pull_request_review_id": 2228110121,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30011",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709672759/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-08-08T14:45:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709672759",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30011#discussion_r1709704962"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30011"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709704962"
                }
            },
            "author_association": "MEMBER",
            "body": "Do we want this, or just rename `small` to `little` or `tiny`? :P",
            "commit_id": "f512769700ba99b98b88e6d8df4f538d9ee59030",
            "created_at": "2024-08-08T15:01:02Z",
            "diff_hunk": "@@ -0,0 +1,637 @@\n+#ifndef __VTERM_H__\n+#define __VTERM_H__\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include \"vterm_keycodes.h\"\n+\n+#define VTERM_VERSION_MAJOR 0\n+#define VTERM_VERSION_MINOR 3\n+#define VTERM_VERSION_PATCH 3\n+\n+#define VTERM_CHECK_VERSION \\\n+        vterm_check_version(VTERM_VERSION_MAJOR, VTERM_VERSION_MINOR)\n+\n+/* Any cell can contain at most one basic printing character and 5 combining\n+ * characters. This number could be changed but will be ABI-incompatible if\n+ * you do */\n+#define VTERM_MAX_CHARS_PER_CELL 6\n+\n+typedef struct VTerm VTerm;\n+typedef struct VTermState VTermState;\n+typedef struct VTermScreen VTermScreen;\n+\n+typedef struct {\n+  int row;\n+  int col;\n+} VTermPos;\n+\n+/* some small utility functions; we can just keep these static here */\n+\n+/* order points by on-screen flow order */\n+static inline int vterm_pos_cmp(VTermPos a, VTermPos b)\n+{\n+  return (a.row == b.row) ? a.col - b.col : a.row - b.row;\n+}\n+\n+typedef struct {\n+  int start_row;\n+  int end_row;\n+  int start_col;\n+  int end_col;\n+} VTermRect;\n+\n+/* true if the rect contains the point */\n+static inline int vterm_rect_contains(VTermRect r, VTermPos p)\n+{\n+  return p.row >= r.start_row && p.row < r.end_row &&\n+         p.col >= r.start_col && p.col < r.end_col;\n+}\n+\n+/* move a rect */\n+static inline void vterm_rect_move(VTermRect *rect, int row_delta, int col_delta)\n+{\n+  rect->start_row += row_delta; rect->end_row += row_delta;\n+  rect->start_col += col_delta; rect->end_col += col_delta;\n+}\n+\n+/**\n+ * Bit-field describing the content of the tagged union `VTermColor`.\n+ */\n+typedef enum {\n+  /**\n+   * If the lower bit of `type` is not set, the colour is 24-bit RGB.\n+   */\n+  VTERM_COLOR_RGB = 0x00,\n+\n+  /**\n+   * The colour is an index into a palette of 256 colours.\n+   */\n+  VTERM_COLOR_INDEXED = 0x01,\n+\n+  /**\n+   * Mask that can be used to extract the RGB/Indexed bit.\n+   */\n+  VTERM_COLOR_TYPE_MASK = 0x01,\n+\n+  /**\n+   * If set, indicates that this colour should be the default foreground\n+   * color, i.e. there was no SGR request for another colour. When\n+   * rendering this colour it is possible to ignore \"idx\" and just use a\n+   * colour that is not in the palette.\n+   */\n+  VTERM_COLOR_DEFAULT_FG = 0x02,\n+\n+  /**\n+   * If set, indicates that this colour should be the default background\n+   * color, i.e. there was no SGR request for another colour. A common\n+   * option when rendering this colour is to not render a background at\n+   * all, for example by rendering the window transparently at this spot.\n+   */\n+  VTERM_COLOR_DEFAULT_BG = 0x04,\n+\n+  /**\n+   * Mask that can be used to extract the default foreground/background bit.\n+   */\n+  VTERM_COLOR_DEFAULT_MASK = 0x06\n+} VTermColorType;\n+\n+/**\n+ * Returns true if the VTERM_COLOR_RGB `type` flag is set, indicating that the\n+ * given VTermColor instance is an indexed colour.\n+ */\n+#define VTERM_COLOR_IS_INDEXED(col) \\\n+  (((col)->type & VTERM_COLOR_TYPE_MASK) == VTERM_COLOR_INDEXED)\n+\n+/**\n+ * Returns true if the VTERM_COLOR_INDEXED `type` flag is set, indicating that\n+ * the given VTermColor instance is an rgb colour.\n+ */\n+#define VTERM_COLOR_IS_RGB(col) \\\n+  (((col)->type & VTERM_COLOR_TYPE_MASK) == VTERM_COLOR_RGB)\n+\n+/**\n+ * Returns true if the VTERM_COLOR_DEFAULT_FG `type` flag is set, indicating\n+ * that the given VTermColor instance corresponds to the default foreground\n+ * color.\n+ */\n+#define VTERM_COLOR_IS_DEFAULT_FG(col) \\\n+  (!!((col)->type & VTERM_COLOR_DEFAULT_FG))\n+\n+/**\n+ * Returns true if the VTERM_COLOR_DEFAULT_BG `type` flag is set, indicating\n+ * that the given VTermColor instance corresponds to the default background\n+ * color.\n+ */\n+#define VTERM_COLOR_IS_DEFAULT_BG(col) \\\n+  (!!((col)->type & VTERM_COLOR_DEFAULT_BG))\n+\n+/**\n+ * Tagged union storing either an RGB color or an index into a colour palette.\n+ * In order to convert indexed colours to RGB, you may use the\n+ * vterm_state_convert_color_to_rgb() or vterm_screen_convert_color_to_rgb()\n+ * functions which lookup the RGB colour from the palette maintained by a\n+ * VTermState or VTermScreen instance.\n+ */\n+typedef union {\n+  /**\n+   * Tag indicating which union member is actually valid. This variable\n+   * coincides with the `type` member of the `rgb` and the `indexed` struct\n+   * in memory. Please use the `VTERM_COLOR_IS_*` test macros to check whether\n+   * a particular type flag is set.\n+   */\n+  uint8_t type;\n+\n+  /**\n+   * Valid if `VTERM_COLOR_IS_RGB(type)` is true. Holds the RGB colour values.\n+   */\n+  struct {\n+    /**\n+     * Same as the top-level `type` member stored in VTermColor.\n+     */\n+    uint8_t type;\n+\n+    /**\n+     * The actual 8-bit red, green, blue colour values.\n+     */\n+    uint8_t red, green, blue;\n+  } rgb;\n+\n+  /**\n+   * If `VTERM_COLOR_IS_INDEXED(type)` is true, this member holds the index into\n+   * the colour palette.\n+   */\n+  struct {\n+    /**\n+     * Same as the top-level `type` member stored in VTermColor.\n+     */\n+    uint8_t type;\n+\n+    /**\n+     * Index into the colour map.\n+     */\n+    uint8_t idx;\n+  } indexed;\n+} VTermColor;\n+\n+/**\n+ * Constructs a new VTermColor instance representing the given RGB values.\n+ */\n+static inline void vterm_color_rgb(VTermColor *col, uint8_t red, uint8_t green,\n+                                   uint8_t blue)\n+{\n+  col->type = VTERM_COLOR_RGB;\n+  col->rgb.red   = red;\n+  col->rgb.green = green;\n+  col->rgb.blue  = blue;\n+}\n+\n+/**\n+ * Construct a new VTermColor instance representing an indexed color with the\n+ * given index.\n+ */\n+static inline void vterm_color_indexed(VTermColor *col, uint8_t idx)\n+{\n+  col->type = VTERM_COLOR_INDEXED;\n+  col->indexed.idx = idx;\n+}\n+\n+/**\n+ * Compares two colours. Returns true if the colors are equal, false otherwise.\n+ */\n+int vterm_color_is_equal(const VTermColor *a, const VTermColor *b);\n+\n+typedef enum {\n+  /* VTERM_VALUETYPE_NONE = 0 */\n+  VTERM_VALUETYPE_BOOL = 1,\n+  VTERM_VALUETYPE_INT,\n+  VTERM_VALUETYPE_STRING,\n+  VTERM_VALUETYPE_COLOR,\n+\n+  VTERM_N_VALUETYPES\n+} VTermValueType;\n+\n+typedef struct {\n+  const char *str;\n+  size_t      len : 30;\n+  bool        initial : 1;\n+  bool        final : 1;\n+} VTermStringFragment;\n+\n+typedef union {\n+  int boolean;\n+  int number;\n+  VTermStringFragment string;\n+  VTermColor color;\n+} VTermValue;\n+\n+typedef enum {\n+  /* VTERM_ATTR_NONE = 0 */\n+  VTERM_ATTR_BOLD = 1,   // bool:   1, 22\n+  VTERM_ATTR_UNDERLINE,  // number: 4, 21, 24\n+  VTERM_ATTR_ITALIC,     // bool:   3, 23\n+  VTERM_ATTR_BLINK,      // bool:   5, 25\n+  VTERM_ATTR_REVERSE,    // bool:   7, 27\n+  VTERM_ATTR_CONCEAL,    // bool:   8, 28\n+  VTERM_ATTR_STRIKE,     // bool:   9, 29\n+  VTERM_ATTR_FONT,       // number: 10-19\n+  VTERM_ATTR_FOREGROUND, // color:  30-39 90-97\n+  VTERM_ATTR_BACKGROUND, // color:  40-49 100-107\n+  VTERM_ATTR_SMALL,      // bool:   73, 74, 75\n+  VTERM_ATTR_BASELINE,   // number: 73, 74, 75\n+\n+  VTERM_N_ATTRS\n+} VTermAttr;\n+\n+typedef enum {\n+  /* VTERM_PROP_NONE = 0 */\n+  VTERM_PROP_CURSORVISIBLE = 1, // bool\n+  VTERM_PROP_CURSORBLINK,       // bool\n+  VTERM_PROP_ALTSCREEN,         // bool\n+  VTERM_PROP_TITLE,             // string\n+  VTERM_PROP_ICONNAME,          // string\n+  VTERM_PROP_REVERSE,           // bool\n+  VTERM_PROP_CURSORSHAPE,       // number\n+  VTERM_PROP_MOUSE,             // number\n+  VTERM_PROP_FOCUSREPORT,       // bool\n+\n+  VTERM_N_PROPS\n+} VTermProp;\n+\n+enum {\n+  VTERM_PROP_CURSORSHAPE_BLOCK = 1,\n+  VTERM_PROP_CURSORSHAPE_UNDERLINE,\n+  VTERM_PROP_CURSORSHAPE_BAR_LEFT,\n+\n+  VTERM_N_PROP_CURSORSHAPES\n+};\n+\n+enum {\n+  VTERM_PROP_MOUSE_NONE = 0,\n+  VTERM_PROP_MOUSE_CLICK,\n+  VTERM_PROP_MOUSE_DRAG,\n+  VTERM_PROP_MOUSE_MOVE,\n+\n+  VTERM_N_PROP_MOUSES\n+};\n+\n+typedef enum {\n+  VTERM_SELECTION_CLIPBOARD = (1<<0),\n+  VTERM_SELECTION_PRIMARY   = (1<<1),\n+  VTERM_SELECTION_SECONDARY = (1<<2),\n+  VTERM_SELECTION_SELECT    = (1<<3),\n+  VTERM_SELECTION_CUT0      = (1<<4), /* also CUT1 .. CUT7 by bitshifting */\n+} VTermSelectionMask;\n+\n+typedef struct {\n+  const uint32_t *chars;\n+  int             width;\n+  unsigned int    protected_cell:1;  /* DECSCA-protected against DECSEL/DECSED */\n+  unsigned int    dwl:1;             /* DECDWL or DECDHL double-width line */\n+  unsigned int    dhl:2;             /* DECDHL double-height line (1=top 2=bottom) */\n+} VTermGlyphInfo;\n+\n+typedef struct {\n+  unsigned int    doublewidth:1;     /* DECDWL or DECDHL line */\n+  unsigned int    doubleheight:2;    /* DECDHL line (1=top 2=bottom) */\n+  unsigned int    continuation:1;    /* Line is a flow continuation of the previous */\n+} VTermLineInfo;\n+\n+/* Copies of VTermState fields that the 'resize' callback might have reason to\n+ * edit. 'resize' callback gets total control of these fields and may\n+ * free-and-reallocate them if required. They will be copied back from the\n+ * struct after the callback has returned.\n+ */\n+typedef struct {\n+  VTermPos pos;                /* current cursor position */\n+  VTermLineInfo *lineinfos[2]; /* [1] may be NULL */\n+} VTermStateFields;\n+\n+typedef struct {\n+  /* libvterm relies on this memory to be zeroed out before it is returned\n+   * by the allocator. */\n+  void *(*malloc)(size_t size, void *allocdata);\n+  void  (*free)(void *ptr, void *allocdata);\n+} VTermAllocatorFunctions;\n+\n+void vterm_check_version(int major, int minor);\n+\n+struct VTermBuilder {\n+  int ver; /* currently unused but reserved for some sort of ABI version flag */\n+\n+  int rows, cols;\n+\n+  const VTermAllocatorFunctions *allocator;\n+  void *allocdata;\n+\n+  /* Override default sizes for various structures */\n+  size_t outbuffer_len;  /* default: 4096 */\n+  size_t tmpbuffer_len;  /* default: 4096 */\n+};\n+\n+VTerm *vterm_build(const struct VTermBuilder *builder);\n+\n+/* A convenient shortcut for default cases */\n+VTerm *vterm_new(int rows, int cols);\n+/* This shortcuts are generally discouraged in favour of just using vterm_build() */\n+VTerm *vterm_new_with_allocator(int rows, int cols, VTermAllocatorFunctions *funcs, void *allocdata);\n+\n+void   vterm_free(VTerm* vt);\n+\n+void vterm_get_size(const VTerm *vt, int *rowsp, int *colsp);\n+void vterm_set_size(VTerm *vt, int rows, int cols);\n+\n+int  vterm_get_utf8(const VTerm *vt);\n+void vterm_set_utf8(VTerm *vt, int is_utf8);\n+\n+size_t vterm_input_write(VTerm *vt, const char *bytes, size_t len);\n+\n+/* Setting output callback will override the buffer logic */\n+typedef void VTermOutputCallback(const char *s, size_t len, void *user);\n+void vterm_output_set_callback(VTerm *vt, VTermOutputCallback *func, void *user);\n+\n+/* These buffer functions only work if output callback is NOT set\n+ * These are deprecated and will be removed in a later version */\n+size_t vterm_output_get_buffer_size(const VTerm *vt);\n+size_t vterm_output_get_buffer_current(const VTerm *vt);\n+size_t vterm_output_get_buffer_remaining(const VTerm *vt);\n+\n+/* This too */\n+size_t vterm_output_read(VTerm *vt, char *buffer, size_t len);\n+\n+void vterm_keyboard_unichar(VTerm *vt, uint32_t c, VTermModifier mod);\n+void vterm_keyboard_key(VTerm *vt, VTermKey key, VTermModifier mod);\n+\n+void vterm_keyboard_start_paste(VTerm *vt);\n+void vterm_keyboard_end_paste(VTerm *vt);\n+\n+void vterm_mouse_move(VTerm *vt, int row, int col, VTermModifier mod);\n+void vterm_mouse_button(VTerm *vt, int button, bool pressed, VTermModifier mod);\n+\n+// ------------\n+// Parser layer\n+// ------------\n+\n+/* Flag to indicate non-final subparameters in a single CSI parameter.\n+ * Consider\n+ *   CSI 1;2:3:4;5a\n+ * 1 4 and 5 are final.\n+ * 2 and 3 are non-final and will have this bit set\n+ *\n+ * Don't confuse this with the final byte of the CSI escape; 'a' in this case.\n+ */\n+#define CSI_ARG_FLAG_MORE (1U<<31)\n+#define CSI_ARG_MASK      (~(1U<<31))\n+\n+#define CSI_ARG_HAS_MORE(a) ((a) & CSI_ARG_FLAG_MORE)\n+#define CSI_ARG(a)          ((a) & CSI_ARG_MASK)\n+\n+/* Can't use -1 to indicate a missing argument; use this instead */\n+#define CSI_ARG_MISSING ((1UL<<31)-1)\n+\n+#define CSI_ARG_IS_MISSING(a) (CSI_ARG(a) == CSI_ARG_MISSING)\n+#define CSI_ARG_OR(a,def)     (CSI_ARG(a) == CSI_ARG_MISSING ? (def) : CSI_ARG(a))\n+#define CSI_ARG_COUNT(a)      (CSI_ARG(a) == CSI_ARG_MISSING || CSI_ARG(a) == 0 ? 1 : CSI_ARG(a))\n+\n+typedef struct {\n+  int (*text)(const char *bytes, size_t len, void *user);\n+  int (*control)(unsigned char control, void *user);\n+  int (*escape)(const char *bytes, size_t len, void *user);\n+  int (*csi)(const char *leader, const long args[], int argcount, const char *intermed, char command, void *user);\n+  int (*osc)(int command, VTermStringFragment frag, void *user);\n+  int (*dcs)(const char *command, size_t commandlen, VTermStringFragment frag, void *user);\n+  int (*apc)(VTermStringFragment frag, void *user);\n+  int (*pm)(VTermStringFragment frag, void *user);\n+  int (*sos)(VTermStringFragment frag, void *user);\n+  int (*resize)(int rows, int cols, void *user);\n+} VTermParserCallbacks;\n+\n+void  vterm_parser_set_callbacks(VTerm *vt, const VTermParserCallbacks *callbacks, void *user);\n+void *vterm_parser_get_cbdata(VTerm *vt);\n+\n+/* Normally NUL, CAN, SUB and DEL are ignored. Setting this true causes them\n+ * to be emitted by the 'control' callback\n+ */\n+void vterm_parser_set_emit_nul(VTerm *vt, bool emit);\n+\n+// -----------\n+// State layer\n+// -----------\n+\n+typedef struct {\n+  int (*putglyph)(VTermGlyphInfo *info, VTermPos pos, void *user);\n+  int (*movecursor)(VTermPos pos, VTermPos oldpos, int visible, void *user);\n+  int (*scrollrect)(VTermRect rect, int downward, int rightward, void *user);\n+  int (*moverect)(VTermRect dest, VTermRect src, void *user);\n+  int (*erase)(VTermRect rect, int selective, void *user);\n+  int (*initpen)(void *user);\n+  int (*setpenattr)(VTermAttr attr, VTermValue *val, void *user);\n+  int (*settermprop)(VTermProp prop, VTermValue *val, void *user);\n+  int (*bell)(void *user);\n+  int (*resize)(int rows, int cols, VTermStateFields *fields, void *user);\n+  int (*setlineinfo)(int row, const VTermLineInfo *newinfo, const VTermLineInfo *oldinfo, void *user);\n+  int (*sb_clear)(void *user);\n+} VTermStateCallbacks;\n+\n+typedef struct {\n+  int (*control)(unsigned char control, void *user);\n+  int (*csi)(const char *leader, const long args[], int argcount, const char *intermed, char command, void *user);\n+  int (*osc)(int command, VTermStringFragment frag, void *user);\n+  int (*dcs)(const char *command, size_t commandlen, VTermStringFragment frag, void *user);\n+  int (*apc)(VTermStringFragment frag, void *user);\n+  int (*pm)(VTermStringFragment frag, void *user);\n+  int (*sos)(VTermStringFragment frag, void *user);\n+} VTermStateFallbacks;\n+\n+typedef struct {\n+  int (*set)(VTermSelectionMask mask, VTermStringFragment frag, void *user);\n+  int (*query)(VTermSelectionMask mask, void *user);\n+} VTermSelectionCallbacks;\n+\n+VTermState *vterm_obtain_state(VTerm *vt);\n+\n+void  vterm_state_set_callbacks(VTermState *state, const VTermStateCallbacks *callbacks, void *user);\n+void *vterm_state_get_cbdata(VTermState *state);\n+\n+void  vterm_state_set_unrecognised_fallbacks(VTermState *state, const VTermStateFallbacks *fallbacks, void *user);\n+void *vterm_state_get_unrecognised_fbdata(VTermState *state);\n+\n+void vterm_state_reset(VTermState *state, int hard);\n+void vterm_state_get_cursorpos(const VTermState *state, VTermPos *cursorpos);\n+void vterm_state_get_default_colors(const VTermState *state, VTermColor *default_fg, VTermColor *default_bg);\n+void vterm_state_get_palette_color(const VTermState *state, int index, VTermColor *col);\n+void vterm_state_set_default_colors(VTermState *state, const VTermColor *default_fg, const VTermColor *default_bg);\n+void vterm_state_set_palette_color(VTermState *state, int index, const VTermColor *col);\n+void vterm_state_set_bold_highbright(VTermState *state, int bold_is_highbright);\n+int  vterm_state_get_penattr(const VTermState *state, VTermAttr attr, VTermValue *val);\n+int  vterm_state_set_termprop(VTermState *state, VTermProp prop, VTermValue *val);\n+void vterm_state_focus_in(VTermState *state);\n+void vterm_state_focus_out(VTermState *state);\n+const VTermLineInfo *vterm_state_get_lineinfo(const VTermState *state, int row);\n+\n+/**\n+ * Makes sure that the given color `col` is indeed an RGB colour. After this\n+ * function returns, VTERM_COLOR_IS_RGB(col) will return true, while all other\n+ * flags stored in `col->type` will have been reset.\n+ *\n+ * @param state is the VTermState instance from which the colour palette should\n+ * be extracted.\n+ * @param col is a pointer at the VTermColor instance that should be converted\n+ * to an RGB colour.\n+ */\n+void vterm_state_convert_color_to_rgb(const VTermState *state, VTermColor *col);\n+\n+void vterm_state_set_selection_callbacks(VTermState *state, const VTermSelectionCallbacks *callbacks, void *user,\n+    char *buffer, size_t buflen);\n+\n+void vterm_state_send_selection(VTermState *state, VTermSelectionMask mask, VTermStringFragment frag);\n+\n+// ------------\n+// Screen layer\n+// ------------\n+\n+typedef struct {\n+    unsigned int bold      : 1;\n+    unsigned int underline : 2;\n+    unsigned int italic    : 1;\n+    unsigned int blink     : 1;\n+    unsigned int reverse   : 1;\n+    unsigned int conceal   : 1;\n+    unsigned int strike    : 1;\n+    unsigned int font      : 4; /* 0 to 9 */\n+    unsigned int dwl       : 1; /* On a DECDWL or DECDHL line */\n+    unsigned int dhl       : 2; /* On a DECDHL line (1=top 2=bottom) */\n+    unsigned int small     : 1;",
            "html_url": "https://github.com/neovim/neovim/pull/30011#discussion_r1709704962",
            "id": 1709704962,
            "in_reply_to_id": 1709267069,
            "line": 510,
            "node_id": "PRRC_kwDOAPphoM5l6AcC",
            "original_commit_id": "91757fad56437366892a275ccaaad0f124a3e08f",
            "original_line": 510,
            "original_position": 510,
            "original_start_line": null,
            "path": "src/vterm/vterm.h",
            "position": 510,
            "pull_request_review_id": 2228151039,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30011",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709704962/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-08-08T15:01:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1709704962",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30011#discussion_r1710629241"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30011"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1710629241"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  'scrollback' are not reflown.\r\n```",
            "commit_id": "f512769700ba99b98b88e6d8df4f538d9ee59030",
            "created_at": "2024-08-09T03:14:56Z",
            "diff_hunk": "@@ -163,6 +163,9 @@ TERMINAL\n   system clipboard (copy). Querying with OSC 52 (paste) is not supported.\n • |hl-StatusLineTerm| and |hl-StatusLineTermNC| define highlights for the\n   status line in |terminal| windows.\n+• The terminal buffer now supports reflow (wrapped lines adapt when the buffer\n+  is resized horizontally). Note: Lines that are not visible and kept in\n+  |'scrollback'| are not reflown.",
            "html_url": "https://github.com/neovim/neovim/pull/30011#discussion_r1710629241",
            "id": 1710629241,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5l9iF5",
            "original_commit_id": "01fc52578edc91a5b0d15a752d6a01772aa28ae2",
            "original_line": 168,
            "original_position": 6,
            "original_start_line": null,
            "path": "runtime/doc/news.txt",
            "position": null,
            "pull_request_review_id": 2229201717,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30011",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1710629241/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-08-09T03:14:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1710629241",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30011#discussion_r1710650345"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30011"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1710650345"
                }
            },
            "author_association": "MEMBER",
            "body": "I can't reproduce the heap-buffer-overflow on this branch.\r\n```suggestion\r\n```",
            "commit_id": "f512769700ba99b98b88e6d8df4f538d9ee59030",
            "created_at": "2024-08-09T03:35:29Z",
            "diff_hunk": "@@ -320,7 +320,7 @@ void terminal_open(Terminal **termpp, buf_T *buf, TerminalOptions opts)\n   term->vts = vterm_obtain_screen(term->vt);\n   vterm_screen_enable_altscreen(term->vts, true);\n   // TODO(clason): reenable when https://github.com/neovim/neovim/issues/23762 is fixed",
            "html_url": "https://github.com/neovim/neovim/pull/30011#discussion_r1710650345",
            "id": 1710650345,
            "in_reply_to_id": 1709405481,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5l9nPp",
            "original_commit_id": "78feeb87c613ca38d8ca0847d8b8dddcc368b52c",
            "original_line": 322,
            "original_position": 21,
            "original_start_line": null,
            "path": "src/nvim/terminal.c",
            "position": null,
            "pull_request_review_id": 2229219013,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30011",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 1,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1710650345/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-08-09T03:35:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1710650345",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30011#discussion_r1710997358"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30011"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1710997358"
                }
            },
            "author_association": "MEMBER",
            "body": "Why? I was explicitly asked to link this, IIRC.",
            "commit_id": "f512769700ba99b98b88e6d8df4f538d9ee59030",
            "created_at": "2024-08-09T08:01:38Z",
            "diff_hunk": "@@ -163,6 +163,9 @@ TERMINAL\n   system clipboard (copy). Querying with OSC 52 (paste) is not supported.\n • |hl-StatusLineTerm| and |hl-StatusLineTermNC| define highlights for the\n   status line in |terminal| windows.\n+• The terminal buffer now supports reflow (wrapped lines adapt when the buffer\n+  is resized horizontally). Note: Lines that are not visible and kept in\n+  |'scrollback'| are not reflown.",
            "html_url": "https://github.com/neovim/neovim/pull/30011#discussion_r1710997358",
            "id": 1710997358,
            "in_reply_to_id": 1710629241,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5l-79u",
            "original_commit_id": "01fc52578edc91a5b0d15a752d6a01772aa28ae2",
            "original_line": 168,
            "original_position": 6,
            "original_start_line": null,
            "path": "runtime/doc/news.txt",
            "position": null,
            "pull_request_review_id": 2229596324,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30011",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1710997358/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-08-09T08:01:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1710997358",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30011#discussion_r1711017416"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30011"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1711017416"
                }
            },
            "author_association": "MEMBER",
            "body": "You shouldn't use `|` to link to an option. The single quotes are enough.",
            "commit_id": "f512769700ba99b98b88e6d8df4f538d9ee59030",
            "created_at": "2024-08-09T08:14:35Z",
            "diff_hunk": "@@ -163,6 +163,9 @@ TERMINAL\n   system clipboard (copy). Querying with OSC 52 (paste) is not supported.\n • |hl-StatusLineTerm| and |hl-StatusLineTermNC| define highlights for the\n   status line in |terminal| windows.\n+• The terminal buffer now supports reflow (wrapped lines adapt when the buffer\n+  is resized horizontally). Note: Lines that are not visible and kept in\n+  |'scrollback'| are not reflown.",
            "html_url": "https://github.com/neovim/neovim/pull/30011#discussion_r1711017416",
            "id": 1711017416,
            "in_reply_to_id": 1710629241,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5l_A3I",
            "original_commit_id": "01fc52578edc91a5b0d15a752d6a01772aa28ae2",
            "original_line": 168,
            "original_position": 6,
            "original_start_line": null,
            "path": "runtime/doc/news.txt",
            "position": null,
            "pull_request_review_id": 2229622008,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30011",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1711017416/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-08-09T08:14:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1711017416",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "- There is a `# libvterm-dev` comment in `.github/workflows/test.yml` you can remove.\r\n\r\n- You can remove libvterm line in `contrib/local.mk.example`\r\n",
            "created_at": "2024-08-08T15:17:28Z",
            "html_url": "https://github.com/neovim/neovim/pull/30011#issuecomment-2276084520",
            "id": 2276084520,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30011",
            "node_id": "IC_kwDOAPphoM6Hqkso",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2276084520/reactions"
            },
            "updated_at": "2024-08-08T15:34:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2276084520",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "It's all yours, @gpanders !",
            "created_at": "2024-08-10T08:26:24Z",
            "html_url": "https://github.com/neovim/neovim/pull/30011#issuecomment-2280289877",
            "id": 2280289877,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30011",
            "node_id": "IC_kwDOAPphoM6H6nZV",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2280289877/reactions"
            },
            "updated_at": "2024-08-10T08:26:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2280289877",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/30011/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/30011/commits",
    "created_at": "2024-08-08T10:52:36Z",
    "diff_url": "https://github.com/neovim/neovim/pull/30011.diff",
    "draft": false,
    "head": {
        "label": "clason:build/vterm",
        "ref": "build/vterm",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/clason/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/clason/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/clason/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/clason/neovim/branches{/branch}",
            "clone_url": "https://github.com/clason/neovim.git",
            "collaborators_url": "https://api.github.com/repos/clason/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/clason/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/clason/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/clason/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/clason/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/clason/neovim/contributors",
            "created_at": "2022-06-19T14:32:07Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/clason/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/clason/neovim/downloads",
            "events_url": "https://api.github.com/repos/clason/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/clason/neovim/forks",
            "full_name": "clason/neovim",
            "git_commits_url": "https://api.github.com/repos/clason/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/clason/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/clason/neovim/git/tags{/sha}",
            "git_url": "git://github.com/clason/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/clason/neovim/hooks",
            "html_url": "https://github.com/clason/neovim",
            "id": 505133677,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/clason/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/clason/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/clason/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/clason/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/clason/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/clason/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/clason/neovim/merges",
            "milestones_url": "https://api.github.com/repos/clason/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOHhu6bQ",
            "notifications_url": "https://api.github.com/repos/clason/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/clason/neovim/pulls{/number}",
            "pushed_at": "2024-08-10T08:26:11Z",
            "releases_url": "https://api.github.com/repos/clason/neovim/releases{/id}",
            "size": 276896,
            "ssh_url": "git@github.com:clason/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/clason/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/clason/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/clason/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/clason/neovim/subscription",
            "svn_url": "https://github.com/clason/neovim",
            "tags_url": "https://api.github.com/repos/clason/neovim/tags",
            "teams_url": "https://api.github.com/repos/clason/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/clason/neovim/git/trees{/sha}",
            "updated_at": "2024-07-31T20:46:41Z",
            "url": "https://api.github.com/repos/clason/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "f512769700ba99b98b88e6d8df4f538d9ee59030",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
            "events_url": "https://api.github.com/users/clason/events{/privacy}",
            "followers_url": "https://api.github.com/users/clason/followers",
            "following_url": "https://api.github.com/users/clason/following{/other_user}",
            "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/clason",
            "id": 2361214,
            "login": "clason",
            "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
            "organizations_url": "https://api.github.com/users/clason/orgs",
            "received_events_url": "https://api.github.com/users/clason/received_events",
            "repos_url": "https://api.github.com/users/clason/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/clason"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/30011",
    "id": 2010258664,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30011",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": "building and installing Neovim using the provided scripts",
            "id": 84723321,
            "name": "build",
            "node_id": "MDU6TGFiZWw4NDcyMzMyMQ==",
            "url": "https://api.github.com/repos/neovim/neovim/labels/build"
        },
        {
            "color": "c5def5",
            "default": false,
            "description": "built-in :terminal or :shell",
            "id": 212696822,
            "name": "terminal",
            "node_id": "MDU6TGFiZWwyMTI2OTY4MjI=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/terminal"
        }
    ],
    "locked": false,
    "merge_commit_sha": "8df6736ca14d09f87cf0a8486758ac5708819434",
    "merged_at": "2024-08-10T08:26:08Z",
    "milestone": null,
    "node_id": "PR_kwDOAPphoM530hzo",
    "number": 30011,
    "patch_url": "https://github.com/neovim/neovim/pull/30011.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/30011/comments",
    "state": "closed",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/f512769700ba99b98b88e6d8df4f538d9ee59030",
    "title": "build(deps): vendor libvterm at v0.3.3 and enable reflow (for realsies this time)",
    "updated_at": "2024-08-10T08:26:26Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/30011",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
        "events_url": "https://api.github.com/users/clason/events{/privacy}",
        "followers_url": "https://api.github.com/users/clason/followers",
        "following_url": "https://api.github.com/users/clason/following{/other_user}",
        "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/clason",
        "id": 2361214,
        "login": "clason",
        "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
        "organizations_url": "https://api.github.com/users/clason/orgs",
        "received_events_url": "https://api.github.com/users/clason/received_events",
        "repos_url": "https://api.github.com/users/clason/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/clason"
    }
}