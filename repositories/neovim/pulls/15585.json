{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/15585/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/15585/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/15585"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/15585"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/15585/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/4fca63dbf722f60f9096ef32c0dbecc2055c4a9a"
        }
    },
    "active_lock_reason": "resolved",
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 5531,
            "forks_count": 5531,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1778,
            "open_issues_count": 1778,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2024-08-20T01:30:37Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 282327,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 80980,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2024-08-20T00:20:26Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 80980,
            "watchers_count": 80980,
            "web_commit_signoff_required": false
        },
        "sha": "685cf398130c61c158401b992a1893c2405cd7d2",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim"
        }
    },
    "body": "- [X] Move vim.lsp.diagnostic to vim.diagnostic\r\n- [X] Refactor client ids to diagnostic namespaces\r\n- [x] Update tests\r\n- [x] Write/update documentation and function signatures\r\n- [x] Discuss modifications/additions to API\r\n\r\n## Overview\r\n\r\nCurrently, non-LSP diagnostics in Neovim must hook into the LSP subsystem. This is what e.g. null-ls and nvim-lint do. This is necessary because none of the diagnostic API is exposed separately from the LSP subsystem.\r\n\r\nThis PR is an attempt to address this by generalizing the diagnostic subsystem beyond the scope of LSP. The `vim.lsp.diagnostic` module is now simply a specific diagnostic producer and primarily maintains the interface between LSP clients and the broader diagnostic API.\r\n\r\nThe current diagnostic API uses \"client ids\" which only makes sense in the context of LSP. We replace \"client ids\" with standard API namespaces generated from `nvim_create_namespace`.\r\n\r\nThis PR is *mostly* backward compatible (so long as plugins are only using the publicly documented API): LSP diagnostics will continue to work as usual, as will pseudo-LSP clients like null-ls and nvim-lint. However, the latter can now use the new interface, which looks something like this:\r\n\r\n```lua\r\n-- The namespace *must* be given a name. Anonymous namespaces will not work with diagnostics\r\nlocal ns = vim.api.nvim_create_namespace(\"foo\")\r\n\r\n-- Generate diagnostics\r\nlocal diagnostics = generate_diagnostics()\r\n\r\n-- Set diagnostics for the current buffer\r\nvim.diagnostic.set(ns, diagnostics, bufnr)\r\n```\r\n\r\nSome public facing API utility methods were removed and internalized directly in `vim.diagnostic`:\r\n\r\n* `vim.lsp.util.diagnostics_to_items`\r\n\r\n## API Design\r\n\r\n`vim.diagnostic` contains most of the same API as `vim.lsp.diagnostic` with `client_id` simply replaced with `namespace`, with some differences:\r\n\r\n* Generally speaking, functions that modify or add diagnostics require a namespace as their first argument, e.g.\r\n\r\n  ```lua\r\n  vim.diagnostic.set({namespace}, {bufnr}, {diagnostics}[, {opts}])\r\n  ```\r\n\r\n   while functions that read or query diagnostics do not (although in many cases one may be supplied optionally):\r\n\r\n   ```lua\r\n   vim.diagnostic.get({bufnr}[, {namespace}])\r\n   ```\r\n\r\n* We use our own severity levels to decouple `vim.diagnostic` from LSP. These are designed similarly to `vim.log.levels` and currently include:\r\n\r\n  ```lua\r\n  vim.diagnostic.severity.ERROR\r\n  vim.diagnostic.severity.WARN\r\n  vim.diagnostic.severity.INFO\r\n  vim.diagnostic.severity.HINT\r\n  ```\r\n\r\n  In practice, these match the LSP diagnostic severity levels exactly, but we should treat this as an interface and not assume that they are the same. The \"translation\" between the two severity types is handled transparently in `vim.lsp.diagnostic`.\r\n\r\n* The actual \"diagnostic\" data structure is: (**EDIT:** Updated 2021-09-09):\r\n\r\n  ```lua\r\n  {\r\n    lnum = <number>,\r\n    col = <number>,\r\n    end_lnum = <number>,\r\n    end_col = <number>,\r\n    severity = <vim.diagnostic.severity>,\r\n    message = <string>\r\n  }\r\n  ```\r\n\r\nThis differs from the LSP definition of a diagnostic, so we transform them in the handler functions in vim.lsp.diagnostic.\r\n\r\n## Configuration\r\n\r\nThe `vim.lsp.with` paradigm still works for configuring how LSP diagnostics are displayed, but this is a specific use-case for the `publishDiagnostics` handler. Configuration with `vim.diagnostic` is instead done with the `vim.diagnostic.config` function:\r\n\r\n```lua\r\nvim.diagnostic.config({\r\n    virtual_text = true,\r\n    signs = false,\r\n    underline = true,\r\n    update_in_insert = true,\r\n    severity_sort = false,\r\n}[, namespace])\r\n```\r\n\r\n(or alternatively passed directly to `set()` or `show()`.)\r\n\r\nWhen the `namespace` argument is `nil`, settings are set globally (i.e. for *all* diagnostic namespaces). This is what user's will typically use for their local configuration. Diagnostic producers can also set configuration options for their specific namespace, although this is generally discouraged in order to respect the user's global settings. All of the values in the table passed to `vim.diagnostic.config()` are resolved in the same way that they are in `on_publish_diagnostics`; that is, the value can be a boolean, a table, or a function:\r\n\r\n```lua\r\nvim.diagnostic.config({\r\n    virtual_text = function(namespace, bufnr)\r\n        -- Only enable virtual text in buffer 3\r\n        return bufnr == 3\r\n    end,\r\n})\r\n```\r\n\r\n## Misc Notes\r\n\r\n* `vim.diagnostic` currently depends on `vim.lsp.util` for floating window previews. I think this is okay for now, although ideally we'd want to decouple these completely.\r\n\r\n---\r\n\r\n@jose-elias-alvarez (null-ls) @mfussenegger (nvim-lint) @neovim/lsp ",
    "closed_at": "2021-09-16T21:23:43Z",
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r705635820"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/705635820"
                }
            },
            "author_association": "MEMBER",
            "body": "convention of lua, lsp, treesitter is:\r\n\r\n```suggestion\r\n        'section_fmt': lambda _: 'Lua module: vim.diagnostic',\r\n```",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-09T19:29:56Z",
            "diff_hunk": "@@ -187,6 +187,23 @@\n         'module_override': {},\n         'append_only': [],\n     },\n+    'diagnostic': {\n+        'mode': 'lua',\n+        'filename': 'diagnostic.txt',\n+        'section_start_token': '*diagnostic-api*',\n+        'section_order': [\n+            'diagnostic.lua',\n+        ],\n+        'files': os.path.join(base_dir, 'runtime/lua/vim/diagnostic.lua'),\n+        'file_patterns': '*.lua',\n+        'fn_name_prefix': '',\n+        'section_name': {'diagnostic.lua': 'diagnostic'},\n+        'section_fmt': lambda _: 'DIAGNOSTIC API',",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r705635820",
            "id": 705635820,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNTYzNTgyMA==",
            "original_commit_id": "cd74418cd48c18555a14a88556f2126df58c1fc7",
            "original_line": 201,
            "original_position": 15,
            "original_start_line": null,
            "path": "scripts/gen_vimdoc.py",
            "position": null,
            "pull_request_review_id": 750742624,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/705635820/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-09T19:29:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/705635820",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r705637852"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/705637852"
                }
            },
            "author_association": "MEMBER",
            "body": "not sure why treesitter docs don't have `vim.*` , but that is the convention for Lua functions in the `vim` module\r\n\r\n```suggestion\r\n        'fn_helptag_fmt': lambda fstem, name: f'*vim.{fstem}.{name}()*',\r\n```",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-09T19:33:19Z",
            "diff_hunk": "@@ -187,6 +187,23 @@\n         'module_override': {},\n         'append_only': [],\n     },\n+    'diagnostic': {\n+        'mode': 'lua',\n+        'filename': 'diagnostic.txt',\n+        'section_start_token': '*diagnostic-api*',\n+        'section_order': [\n+            'diagnostic.lua',\n+        ],\n+        'files': os.path.join(base_dir, 'runtime/lua/vim/diagnostic.lua'),\n+        'file_patterns': '*.lua',\n+        'fn_name_prefix': '',\n+        'section_name': {'diagnostic.lua': 'diagnostic'},\n+        'section_fmt': lambda _: 'DIAGNOSTIC API',\n+        'helptag_fmt': lambda _: f'*diagnostic-api*',\n+        'fn_helptag_fmt': lambda fstem, name: f'*{fstem}.{name}()*',",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r705637852",
            "id": 705637852,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNTYzNzg1Mg==",
            "original_commit_id": "cd74418cd48c18555a14a88556f2126df58c1fc7",
            "original_line": 203,
            "original_position": 17,
            "original_start_line": null,
            "path": "scripts/gen_vimdoc.py",
            "position": null,
            "pull_request_review_id": 750745446,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/705637852/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-09T19:33:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/705637852",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r705768332"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/705768332"
                }
            },
            "author_association": "MEMBER",
            "body": "1. move the helptags for all of these to `runtime/doc/deprecated.txt`\r\n    - in there, only need to move the new replacement, don't need to have full docs\r\n2. don't generate these docs (delete them from lsp.txt). No need for redundant docs.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-09T22:54:21Z",
            "diff_hunk": "@@ -1647,13 +1700,17 @@ show_line_diagnostics({opts}, {buf_nr}, {line_nr}, {client_id})\n show_position_diagnostics({opts}, {buf_nr}, {position})\n                 Open a floating window with the diagnostics from {position}\n \n+                Deprecated in favor of\n+                |vim.diagnostic.show_position_diagnostics()|",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r705768332",
            "id": 705768332,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNTc2ODMzMg==",
            "original_commit_id": "5e5031a2b2e425579f60ad42bb312734e784a590",
            "original_line": 1704,
            "original_position": 219,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 750909537,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/705768332/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-09T22:54:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/705768332",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r705831169"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/705831169"
                }
            },
            "author_association": "MEMBER",
            "body": "let's try to use \"events\" where possible, autocmds imply vimscript but really they're just events and we will eventually have Lua handlers for them.\r\n```suggestion\r\nEvents\t\t\t\t\t*diagnostic-events*\r\n```",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-10T01:35:35Z",
            "diff_hunk": "@@ -163,6 +163,16 @@ DiagnosticSignHint\n   Used for \"Hint\" signs in sign column.\n   See |vim.diagnostic.set_signs()|\n \n+==============================================================================\n+AUTOCOMMANDS\t\t\t\t\t*diagnostic-autocommands*",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r705831169",
            "id": 705831169,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNTgzMTE2OQ==",
            "original_commit_id": "4dfde37bf8707619bee945ecf05d5ee5f74dfb3c",
            "original_line": 167,
            "original_position": 5,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 750974654,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/705831169/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-10T01:35:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/705831169",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r705832417"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/705832417"
                }
            },
            "author_association": "MEMBER",
            "body": "helps a lot to move the functions to a separate `lsp/_deprecated.lua` file, if possible.  Avoids noise and avoids confused contributors.\r\n\r\nThis `lsp.diagnostic` module can load the `lsp._deprecated` and merge it with its own module, for back-compat. We do something similar in the test infra: https://github.com/neovim/neovim/blob/13748512f6d6dfb5895c2233d2e07480e00eb753/test/unit/helpers.lua#L865-L868",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-10T01:39:28Z",
            "diff_hunk": "@@ -453,7 +427,7 @@ end\n \n --- Set underline for given diagnostics\n ---\n---- Deprecated in favor of |vim.diagnostic.set_underline()|\n+---@deprecated Prefer |vim.diagnostic.set_underline()|",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r705832417",
            "id": 705832417,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNTgzMjQxNw==",
            "original_commit_id": "4dfde37bf8707619bee945ecf05d5ee5f74dfb3c",
            "original_line": 429,
            "original_position": 164,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 750976088,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/705832417/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-10T01:39:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/705832417",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706298417"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706298417"
                }
            },
            "author_association": "MEMBER",
            "body": "I'll push back on this a little bit: there are some local functions we use in `lsp/diagnostic.lua` to do the translation between LSP style data structures and `vim.diagnostic` data structures. If we split up that module, we either have to 1) duplicate those functions in both modules or 2) expose those local functions as part of the public interface. Both options are icky and I don't think worth the benefit of having a dedicated `_deprecated.lua` module.\r\n\r\nInstead, what if we just tuck all the deprecated functions down at the bottom and throw in a \"Deprecated\" header and fold markers.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-10T16:00:54Z",
            "diff_hunk": "@@ -453,7 +427,7 @@ end\n \n --- Set underline for given diagnostics\n ---\n---- Deprecated in favor of |vim.diagnostic.set_underline()|\n+---@deprecated Prefer |vim.diagnostic.set_underline()|",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706298417",
            "id": 706298417,
            "in_reply_to_id": 705832417,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjI5ODQxNw==",
            "original_commit_id": "4dfde37bf8707619bee945ecf05d5ee5f74dfb3c",
            "original_line": 429,
            "original_position": 164,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 751567763,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706298417/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-10T16:00:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706298417",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706590743"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706590743"
                }
            },
            "author_association": "MEMBER",
            "body": "should this be \"with this severity or higher\"?",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T09:44:25Z",
            "diff_hunk": "@@ -0,0 +1,616 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+\t\t\t\t\t\t\t*diagnostic-highlights*\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultWarn*\n+DiagnosticDefaultWarn\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultInfo*\n+DiagnosticDefaultInfo\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultHint*\n+DiagnosticDefaultHint\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+==============================================================================\n+Events\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed in a loaded buffer.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+clear({namespace}, {bufnr})                           *vim.diagnostic.clear()*\n+                Clear the currently displayed diagnostics.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Clear diagnostics in the given\n+                                 buffer. If omitted, diagnostics for the given\n+                                 namespace are cleared in all buffers.\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:- `false`: Disable this feature - `true`: Enable this\n+                    feature, use default settings. - `table`: Enable this\n+                    feature with overrides. - `function`: Function with\n+                    signature (namespace, bufnr) that returns any of the\n+                    above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                   |vim.diagnostic.set_underline()|\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                   |vim.diagnostic.set_virtual_text()|\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics |vim.diagnostic.set_signs()|\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({namespace}, {bufnr})                       *vim.diagnostic.disable()*\n+                Disable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, disable\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+enable({namespace}, {bufnr})                         *vim.diagnostic.enable()*\n+                Enable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, eanble\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+get({namespace}, {bufnr})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the given namespace or buffer.\n+\n+                With no arguments, return a list of all diagnostics.\n+\n+                If {namespace} is `nil` , retrieve all diagnostics associated\n+                with buffer {bufnr}. If {bufnr} is `nil` , retrieve all\n+                diagnostics associated with namespace {namespace}. Otherwise,\n+                retrieve diagnostics from namespace {namespace} associated\n+                with buffer {bufnr}.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil The namespace to get diagnostics\n+                                 from. If omitted, get diagnostics from all\n+                                 namespaces. be `nil` only when {bufnr} is not\n+                                 `nil` .\n+                    {bufnr}      number|nil The buffer number to get\n+                                 diagnistics from. If omitted, get diagnostics\n+                                 from all buffers.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({namespace}, {bufnr}, {severity})\n+                Get the number of diagnostics with the given severity.\n+\n+                Useful for showing diagnostic counts in statusline. eg: >\n+\n+                 function! DiagnosticStatus() abort\n+                   let sl = ''\n+                   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)\")} '\n+                   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)\")}'\n+                   return sl\n+                 endfunction\n+<\n+\n+                Then simply add `%{DiagnosticStatus()}` to your statusline.\n+\n+                Parameters: ~\n+                    {namespace}     number|nil Limit diagnostics to the given\n+                                    namespace. If `nil` , retrieve diagnostics\n+                                    from all namespaces.\n+                    {bufnr}         number|nil The buffer number. Defaults to\n+                                    the current buffer.\n+                    {severity|nil}  Return diagnostics for the given severity\n+                                    |vim.diagnostic.severity|. If omitted, all\n+                                    diagnositcs are returned.\n+\n+                                       *vim.diagnostic.get_line_diagnostics()*\n+get_line_diagnostics({bufnr}, {lnum}, {opts})\n+                Get diagnostics by line.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace. If `nil` , retrieve diagnostics\n+                                 from all namespaces.\n+                    {bufnr}      number|nil The buffer number. Defaults to the\n+                                 current buffer.\n+                    {lnum}       number|nil The line number. Defaults to the\n+                                 current line.\n+                    {opts}       table|nil A table with the following keys:\n+                                 • namespace: (number) Limit diagnostics to\n+                                   the given namespace.\n+                                 • severity: (|vim.diagnostic.severity|) Only\n+                                   return diagnostics with this severity.",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706590743",
            "id": 706590743,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjU5MDc0Mw==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 284,
            "original_position": 304,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 751905897,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706590743/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-11T09:44:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706590743",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1363104?v=4",
                "events_url": "https://api.github.com/users/bfredl/events{/privacy}",
                "followers_url": "https://api.github.com/users/bfredl/followers",
                "following_url": "https://api.github.com/users/bfredl/following{/other_user}",
                "gists_url": "https://api.github.com/users/bfredl/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/bfredl",
                "id": 1363104,
                "login": "bfredl",
                "node_id": "MDQ6VXNlcjEzNjMxMDQ=",
                "organizations_url": "https://api.github.com/users/bfredl/orgs",
                "received_events_url": "https://api.github.com/users/bfredl/received_events",
                "repos_url": "https://api.github.com/users/bfredl/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/bfredl/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/bfredl/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/bfredl"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706591156"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706591156"
                }
            },
            "author_association": "MEMBER",
            "body": "typo: \"diagnostics\"",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T09:48:40Z",
            "diff_hunk": "@@ -0,0 +1,616 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+\t\t\t\t\t\t\t*diagnostic-highlights*\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultWarn*\n+DiagnosticDefaultWarn\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultInfo*\n+DiagnosticDefaultInfo\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultHint*\n+DiagnosticDefaultHint\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+==============================================================================\n+Events\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed in a loaded buffer.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+clear({namespace}, {bufnr})                           *vim.diagnostic.clear()*\n+                Clear the currently displayed diagnostics.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Clear diagnostics in the given\n+                                 buffer. If omitted, diagnostics for the given\n+                                 namespace are cleared in all buffers.\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:- `false`: Disable this feature - `true`: Enable this\n+                    feature, use default settings. - `table`: Enable this\n+                    feature with overrides. - `function`: Function with\n+                    signature (namespace, bufnr) that returns any of the\n+                    above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                   |vim.diagnostic.set_underline()|\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                   |vim.diagnostic.set_virtual_text()|\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics |vim.diagnostic.set_signs()|\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({namespace}, {bufnr})                       *vim.diagnostic.disable()*\n+                Disable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, disable\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+enable({namespace}, {bufnr})                         *vim.diagnostic.enable()*\n+                Enable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, eanble\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+get({namespace}, {bufnr})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the given namespace or buffer.\n+\n+                With no arguments, return a list of all diagnostics.\n+\n+                If {namespace} is `nil` , retrieve all diagnostics associated\n+                with buffer {bufnr}. If {bufnr} is `nil` , retrieve all\n+                diagnostics associated with namespace {namespace}. Otherwise,\n+                retrieve diagnostics from namespace {namespace} associated\n+                with buffer {bufnr}.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil The namespace to get diagnostics\n+                                 from. If omitted, get diagnostics from all\n+                                 namespaces. be `nil` only when {bufnr} is not\n+                                 `nil` .\n+                    {bufnr}      number|nil The buffer number to get\n+                                 diagnistics from. If omitted, get diagnostics\n+                                 from all buffers.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({namespace}, {bufnr}, {severity})\n+                Get the number of diagnostics with the given severity.\n+\n+                Useful for showing diagnostic counts in statusline. eg: >\n+\n+                 function! DiagnosticStatus() abort\n+                   let sl = ''\n+                   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)\")} '\n+                   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)\")}'\n+                   return sl\n+                 endfunction\n+<\n+\n+                Then simply add `%{DiagnosticStatus()}` to your statusline.\n+\n+                Parameters: ~\n+                    {namespace}     number|nil Limit diagnostics to the given\n+                                    namespace. If `nil` , retrieve diagnostics\n+                                    from all namespaces.\n+                    {bufnr}         number|nil The buffer number. Defaults to\n+                                    the current buffer.\n+                    {severity|nil}  Return diagnostics for the given severity\n+                                    |vim.diagnostic.severity|. If omitted, all\n+                                    diagnositcs are returned.",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706591156",
            "id": 706591156,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjU5MTE1Ng==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 286,
            "original_position": 286,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 751906169,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706591156/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-11T09:48:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706591156",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706591363"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706591363"
                }
            },
            "author_association": "MEMBER",
            "body": "Looking at the code, I'd say no?",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T09:50:39Z",
            "diff_hunk": "@@ -0,0 +1,616 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+\t\t\t\t\t\t\t*diagnostic-highlights*\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultWarn*\n+DiagnosticDefaultWarn\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultInfo*\n+DiagnosticDefaultInfo\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultHint*\n+DiagnosticDefaultHint\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+==============================================================================\n+Events\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed in a loaded buffer.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+clear({namespace}, {bufnr})                           *vim.diagnostic.clear()*\n+                Clear the currently displayed diagnostics.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Clear diagnostics in the given\n+                                 buffer. If omitted, diagnostics for the given\n+                                 namespace are cleared in all buffers.\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:- `false`: Disable this feature - `true`: Enable this\n+                    feature, use default settings. - `table`: Enable this\n+                    feature with overrides. - `function`: Function with\n+                    signature (namespace, bufnr) that returns any of the\n+                    above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                   |vim.diagnostic.set_underline()|\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                   |vim.diagnostic.set_virtual_text()|\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics |vim.diagnostic.set_signs()|\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({namespace}, {bufnr})                       *vim.diagnostic.disable()*\n+                Disable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, disable\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+enable({namespace}, {bufnr})                         *vim.diagnostic.enable()*\n+                Enable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, eanble\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+get({namespace}, {bufnr})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the given namespace or buffer.\n+\n+                With no arguments, return a list of all diagnostics.\n+\n+                If {namespace} is `nil` , retrieve all diagnostics associated\n+                with buffer {bufnr}. If {bufnr} is `nil` , retrieve all\n+                diagnostics associated with namespace {namespace}. Otherwise,\n+                retrieve diagnostics from namespace {namespace} associated\n+                with buffer {bufnr}.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil The namespace to get diagnostics\n+                                 from. If omitted, get diagnostics from all\n+                                 namespaces. be `nil` only when {bufnr} is not\n+                                 `nil` .\n+                    {bufnr}      number|nil The buffer number to get\n+                                 diagnistics from. If omitted, get diagnostics\n+                                 from all buffers.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({namespace}, {bufnr}, {severity})\n+                Get the number of diagnostics with the given severity.\n+\n+                Useful for showing diagnostic counts in statusline. eg: >\n+\n+                 function! DiagnosticStatus() abort\n+                   let sl = ''\n+                   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)\")} '\n+                   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)\")}'\n+                   return sl\n+                 endfunction\n+<\n+\n+                Then simply add `%{DiagnosticStatus()}` to your statusline.\n+\n+                Parameters: ~\n+                    {namespace}     number|nil Limit diagnostics to the given\n+                                    namespace. If `nil` , retrieve diagnostics\n+                                    from all namespaces.\n+                    {bufnr}         number|nil The buffer number. Defaults to\n+                                    the current buffer.\n+                    {severity|nil}  Return diagnostics for the given severity\n+                                    |vim.diagnostic.severity|. If omitted, all\n+                                    diagnositcs are returned.\n+\n+                                       *vim.diagnostic.get_line_diagnostics()*\n+get_line_diagnostics({bufnr}, {lnum}, {opts})\n+                Get diagnostics by line.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace. If `nil` , retrieve diagnostics\n+                                 from all namespaces.\n+                    {bufnr}      number|nil The buffer number. Defaults to the\n+                                 current buffer.\n+                    {lnum}       number|nil The line number. Defaults to the\n+                                 current line.\n+                    {opts}       table|nil A table with the following keys:\n+                                 • namespace: (number) Limit diagnostics to\n+                                   the given namespace.\n+                                 • severity: (|vim.diagnostic.severity|) Only\n+                                   return diagnostics with this severity.",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706591363",
            "id": 706591363,
            "in_reply_to_id": 706590743,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjU5MTM2Mw==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 284,
            "original_position": 304,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 751906252,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706591363/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-11T09:50:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706591363",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706591458"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706591458"
                }
            },
            "author_association": "MEMBER",
            "body": "this name \"underline\" is a bit unfortunate, as it doesn't have to be a hl-underline. But IIUC this is mostly an internal function that plugins are not supposed to call directly? the spec file is using `diagnostic.set` only, as I would expect.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T09:51:18Z",
            "diff_hunk": "@@ -0,0 +1,616 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+\t\t\t\t\t\t\t*diagnostic-highlights*\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultWarn*\n+DiagnosticDefaultWarn\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultInfo*\n+DiagnosticDefaultInfo\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultHint*\n+DiagnosticDefaultHint\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+==============================================================================\n+Events\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed in a loaded buffer.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+clear({namespace}, {bufnr})                           *vim.diagnostic.clear()*\n+                Clear the currently displayed diagnostics.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Clear diagnostics in the given\n+                                 buffer. If omitted, diagnostics for the given\n+                                 namespace are cleared in all buffers.\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:- `false`: Disable this feature - `true`: Enable this\n+                    feature, use default settings. - `table`: Enable this\n+                    feature with overrides. - `function`: Function with\n+                    signature (namespace, bufnr) that returns any of the\n+                    above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                   |vim.diagnostic.set_underline()|\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                   |vim.diagnostic.set_virtual_text()|\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics |vim.diagnostic.set_signs()|\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({namespace}, {bufnr})                       *vim.diagnostic.disable()*\n+                Disable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, disable\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+enable({namespace}, {bufnr})                         *vim.diagnostic.enable()*\n+                Enable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, eanble\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+get({namespace}, {bufnr})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the given namespace or buffer.\n+\n+                With no arguments, return a list of all diagnostics.\n+\n+                If {namespace} is `nil` , retrieve all diagnostics associated\n+                with buffer {bufnr}. If {bufnr} is `nil` , retrieve all\n+                diagnostics associated with namespace {namespace}. Otherwise,\n+                retrieve diagnostics from namespace {namespace} associated\n+                with buffer {bufnr}.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil The namespace to get diagnostics\n+                                 from. If omitted, get diagnostics from all\n+                                 namespaces. be `nil` only when {bufnr} is not\n+                                 `nil` .\n+                    {bufnr}      number|nil The buffer number to get\n+                                 diagnistics from. If omitted, get diagnostics\n+                                 from all buffers.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({namespace}, {bufnr}, {severity})\n+                Get the number of diagnostics with the given severity.\n+\n+                Useful for showing diagnostic counts in statusline. eg: >\n+\n+                 function! DiagnosticStatus() abort\n+                   let sl = ''\n+                   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)\")} '\n+                   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)\")}'\n+                   return sl\n+                 endfunction\n+<\n+\n+                Then simply add `%{DiagnosticStatus()}` to your statusline.\n+\n+                Parameters: ~\n+                    {namespace}     number|nil Limit diagnostics to the given\n+                                    namespace. If `nil` , retrieve diagnostics\n+                                    from all namespaces.\n+                    {bufnr}         number|nil The buffer number. Defaults to\n+                                    the current buffer.\n+                    {severity|nil}  Return diagnostics for the given severity\n+                                    |vim.diagnostic.severity|. If omitted, all\n+                                    diagnositcs are returned.\n+\n+                                       *vim.diagnostic.get_line_diagnostics()*\n+get_line_diagnostics({bufnr}, {lnum}, {opts})\n+                Get diagnostics by line.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace. If `nil` , retrieve diagnostics\n+                                 from all namespaces.\n+                    {bufnr}      number|nil The buffer number. Defaults to the\n+                                 current buffer.\n+                    {lnum}       number|nil The line number. Defaults to the\n+                                 current line.\n+                    {opts}       table|nil A table with the following keys:\n+                                 • namespace: (number) Limit diagnostics to\n+                                   the given namespace.\n+                                 • severity: (|vim.diagnostic.severity|) Only\n+                                   return diagnostics with this severity.\n+                                   Overrides severity_limit.\n+                                   |vim.diagnostic.severity|\n+                                 • severity_limit: (|vim.diagnostic.severity|)\n+                                   Limit severity of diagnostics found. For\n+                                   example, vim.diagnostic.severity.WARN means\n+                                   both errors and warnings will be valid.\n+\n+                Return: ~\n+                    table Table with map of line number to list of\n+                    diagnostics.\n+\n+get_next({opts})                                   *vim.diagnostic.get_next()*\n+                Get the next diagnostic closest to the cursor position.\n+\n+                Parameters: ~\n+                    {opts}  table See |vim.diagnostic.goto_next()|\n+\n+                Return: ~\n+                    table Next diagnostic\n+\n+get_next_pos({opts})                           *vim.diagnostic.get_next_pos()*\n+                Return the position of the next diagnostic in the current\n+                buffer.\n+\n+                Parameters: ~\n+                    {opts}  table See |vim.diagnostic.goto_next()|\n+\n+                Return: ~\n+                    table Next diagnostic position as a (row, col) tuple.\n+\n+get_prev({opts})                                   *vim.diagnostic.get_prev()*\n+                Get the previous diagnostic closest to the cursor position.\n+\n+                Parameters: ~\n+                    {opts}  table See |vim.diagnostic.goto_next()|\n+\n+                Return: ~\n+                    table Previous diagnostic\n+\n+get_prev_pos({opts})                           *vim.diagnostic.get_prev_pos()*\n+                Return the position of the previous diagnostic in the current\n+                buffer.\n+\n+                Parameters: ~\n+                    {opts}  table See |vim.diagnostic.goto_next()|\n+\n+                Return: ~\n+                    table Previous diagnostic position as a (row, col) tuple.\n+\n+                                       *vim.diagnostic.get_virt_text_chunks()*\n+get_virt_text_chunks({line_diags}, {opts})\n+                Get virtual text chunks to display using\n+                |nvim_buf_set_extmark()|.\n+\n+                Parameters: ~\n+                    {line_diags}  table The diagnostics associated with the\n+                                  line |vim.diagnostic.get_line_diagnostics()|\n+                    {opts}        table See {opts} from\n+                                  |vim.diagnostic.set_virtual_text()|\n+\n+                Return: ~\n+                    an array of [text, hl_group] arrays. This can be passed\n+                    directly to the {virt_text} option of\n+                    |nvim_buf_set_extmark()|.\n+\n+goto_next({opts})                                 *vim.diagnostic.goto_next()*\n+                Move to the next diagnostic.\n+\n+                Parameters: ~\n+                    {opts}  table|nil Configuration table with the following\n+                            keys:\n+                            • namespace: (number) Only consider diagnostics\n+                              from the given namespace.\n+                            • cursor_position: (cursor position) Cursor\n+                              position as a (row, col) tuple. See\n+                              |nvim_win_get_cursor()|. Defaults to the current\n+                              cursor position.\n+                            • wrap: (boolean, default true) Whether to loop\n+                              around file or not. Similar to 'wrapscan'.\n+                            • severity: (|vim.diagnostic.severity|) Exclusive\n+                              severity to consider. Overrides {severity_limit}\n+                            • severity_limit: (|vim.diagnostic.severity|)\n+                              Limit severity of diagnostics found. For\n+                              example, vim.diagnostic.severity.WARN means both\n+                              errors and warnings will be valid.\n+                            • enable_popup: (boolean, default true) Call\n+                              |vim.diagnostic.show_line_diagnostics()| on\n+                              jump.\n+                            • popup_opts: (table) Table to pass as {opts}\n+                              parameter to\n+                              |vim.diagnostic.show_line_diagnostics()|\n+                            • win_id: (number, default 0) Window ID\n+\n+goto_prev({opts})                                 *vim.diagnostic.goto_prev()*\n+                Move to the previous diagnostic in the current buffer.\n+\n+                Parameters: ~\n+                    {opts}  table See |vim.diagnostic.goto_next()|\n+\n+redraw({namespace}, {bufnr})                         *vim.diagnostic.redraw()*\n+                Redraw diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number Redraw diagnostics for the given\n+                                 namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, redraw\n+                                 diagnostics for the given namespace in all\n+                                 buffers.\n+\n+reset({namespace}, {bufnr})                           *vim.diagnostic.reset()*\n+                Clear diagnotics and diagnostic cache.\n+\n+                Parameters: ~\n+                    {namespace}  number\n+                    {bufnr}      number|nil Reset diagnostics for the given\n+                                 buffer. If omitted, diagnostics are reset for\n+                                 all buffers.\n+\n+set({namespace}, {diagnostics}, {bufnr})                *vim.diagnostic.set()*\n+                Set diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}    number The diagnostic namespace\n+                    {diagnostics}  table A list of diagnostic items\n+                                   |diagnostic-structure|\n+                    {bufnr}        number|nil The buffer to set diagnostics\n+                                   for. Defaults to the current buffer.\n+\n+                                                  *vim.diagnostic.set_signs()*\n+set_signs({namespace}, {diagnostics}, {bufnr}, {opts})\n+                Set signs for given diagnostics.\n+\n+                Sign characters can be customized with the following commands:\n+>\n+\n+    sign define DiagnosticSignError text=E texthl=DiagnosticSignError linehl= numhl=\n+    sign define DiagnosticSignWarning text=W texthl=DiagnosticSignWarning linehl= numhl=\n+    sign define DiagnosticSignInformation text=I texthl=DiagnosticSignInformation linehl= numhl=\n+    sign define DiagnosticSignHint text=H texthl=DiagnosticSignHint linehl= numhl=\n+<\n+\n+                Parameters: ~\n+                    {namespace}        number The diagnostic namespace\n+                    {diagnostics|nil}  table A list of diagnostic items\n+                                       |diagnostic-structure|. If omitted the\n+                                       current diagnostics in the given buffer\n+                                       are used.\n+                    {bufnr}            number The buffer number\n+                    {opts}             table Configuration table with the\n+                                       following keys:\n+                                       • priority: Set the priority of the\n+                                         signs |sign-priority|.\n+                                       • severity_limit:\n+                                         (|vim.diagnostic.severity|) Limit\n+                                         severity of diagnostics found. For\n+                                         example,\n+                                         `vim.diagnostic.severity.WARN` means\n+                                         errors and warnings are valid.\n+\n+                                              *vim.diagnostic.set_underline()*\n+set_underline({namespace}, {diagnostics}, {bufnr}, {opts})",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706591458",
            "id": 706591458,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjU5MTQ1OA==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 465,
            "original_position": 465,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 751906285,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706591458/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-11T09:51:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706591458",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1363104?v=4",
                "events_url": "https://api.github.com/users/bfredl/events{/privacy}",
                "followers_url": "https://api.github.com/users/bfredl/followers",
                "following_url": "https://api.github.com/users/bfredl/following{/other_user}",
                "gists_url": "https://api.github.com/users/bfredl/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/bfredl",
                "id": 1363104,
                "login": "bfredl",
                "node_id": "MDQ6VXNlcjEzNjMxMDQ=",
                "organizations_url": "https://api.github.com/users/bfredl/orgs",
                "received_events_url": "https://api.github.com/users/bfredl/received_events",
                "repos_url": "https://api.github.com/users/bfredl/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/bfredl/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/bfredl/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/bfredl"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706591755"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706591755"
                }
            },
            "author_association": "MEMBER",
            "body": "similarly this reference doesn't seem useful, there is no info at `vim.diagnostic.set_underline()` what this means anyway, and similarlily for the `|vim.diagnostic.set_virtual_text()|` refs above. The _user-facing_ semantics of all of this is already documented at `*diagnostic-highlights*` right above.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T09:54:15Z",
            "diff_hunk": "@@ -0,0 +1,616 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+\t\t\t\t\t\t\t*diagnostic-highlights*\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultWarn*\n+DiagnosticDefaultWarn\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultInfo*\n+DiagnosticDefaultInfo\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultHint*\n+DiagnosticDefaultHint\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+  See |vim.diagnostic.set_underline()|",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706591755",
            "id": 706591755,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjU5MTc1NQ==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 108,
            "original_position": 108,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 751906436,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706591755/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-11T09:54:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706591755",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1363104?v=4",
                "events_url": "https://api.github.com/users/bfredl/events{/privacy}",
                "followers_url": "https://api.github.com/users/bfredl/followers",
                "following_url": "https://api.github.com/users/bfredl/following{/other_user}",
                "gists_url": "https://api.github.com/users/bfredl/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/bfredl",
                "id": 1363104,
                "login": "bfredl",
                "node_id": "MDQ6VXNlcjEzNjMxMDQ=",
                "organizations_url": "https://api.github.com/users/bfredl/orgs",
                "received_events_url": "https://api.github.com/users/bfredl/received_events",
                "repos_url": "https://api.github.com/users/bfredl/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/bfredl/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/bfredl/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/bfredl"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706591772"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706591772"
                }
            },
            "author_association": "MEMBER",
            "body": "Also, the following option `severity_limit` behaves as \"this or higher\".",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T09:54:27Z",
            "diff_hunk": "@@ -0,0 +1,616 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+\t\t\t\t\t\t\t*diagnostic-highlights*\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultWarn*\n+DiagnosticDefaultWarn\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultInfo*\n+DiagnosticDefaultInfo\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultHint*\n+DiagnosticDefaultHint\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+==============================================================================\n+Events\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed in a loaded buffer.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+clear({namespace}, {bufnr})                           *vim.diagnostic.clear()*\n+                Clear the currently displayed diagnostics.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Clear diagnostics in the given\n+                                 buffer. If omitted, diagnostics for the given\n+                                 namespace are cleared in all buffers.\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:- `false`: Disable this feature - `true`: Enable this\n+                    feature, use default settings. - `table`: Enable this\n+                    feature with overrides. - `function`: Function with\n+                    signature (namespace, bufnr) that returns any of the\n+                    above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                   |vim.diagnostic.set_underline()|\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                   |vim.diagnostic.set_virtual_text()|\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics |vim.diagnostic.set_signs()|\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({namespace}, {bufnr})                       *vim.diagnostic.disable()*\n+                Disable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, disable\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+enable({namespace}, {bufnr})                         *vim.diagnostic.enable()*\n+                Enable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, eanble\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+get({namespace}, {bufnr})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the given namespace or buffer.\n+\n+                With no arguments, return a list of all diagnostics.\n+\n+                If {namespace} is `nil` , retrieve all diagnostics associated\n+                with buffer {bufnr}. If {bufnr} is `nil` , retrieve all\n+                diagnostics associated with namespace {namespace}. Otherwise,\n+                retrieve diagnostics from namespace {namespace} associated\n+                with buffer {bufnr}.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil The namespace to get diagnostics\n+                                 from. If omitted, get diagnostics from all\n+                                 namespaces. be `nil` only when {bufnr} is not\n+                                 `nil` .\n+                    {bufnr}      number|nil The buffer number to get\n+                                 diagnistics from. If omitted, get diagnostics\n+                                 from all buffers.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({namespace}, {bufnr}, {severity})\n+                Get the number of diagnostics with the given severity.\n+\n+                Useful for showing diagnostic counts in statusline. eg: >\n+\n+                 function! DiagnosticStatus() abort\n+                   let sl = ''\n+                   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)\")} '\n+                   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)\")}'\n+                   return sl\n+                 endfunction\n+<\n+\n+                Then simply add `%{DiagnosticStatus()}` to your statusline.\n+\n+                Parameters: ~\n+                    {namespace}     number|nil Limit diagnostics to the given\n+                                    namespace. If `nil` , retrieve diagnostics\n+                                    from all namespaces.\n+                    {bufnr}         number|nil The buffer number. Defaults to\n+                                    the current buffer.\n+                    {severity|nil}  Return diagnostics for the given severity\n+                                    |vim.diagnostic.severity|. If omitted, all\n+                                    diagnositcs are returned.\n+\n+                                       *vim.diagnostic.get_line_diagnostics()*\n+get_line_diagnostics({bufnr}, {lnum}, {opts})\n+                Get diagnostics by line.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace. If `nil` , retrieve diagnostics\n+                                 from all namespaces.\n+                    {bufnr}      number|nil The buffer number. Defaults to the\n+                                 current buffer.\n+                    {lnum}       number|nil The line number. Defaults to the\n+                                 current line.\n+                    {opts}       table|nil A table with the following keys:\n+                                 • namespace: (number) Limit diagnostics to\n+                                   the given namespace.\n+                                 • severity: (|vim.diagnostic.severity|) Only\n+                                   return diagnostics with this severity.",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706591772",
            "id": 706591772,
            "in_reply_to_id": 706590743,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjU5MTc3Mg==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 284,
            "original_position": 304,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 751906446,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706591772/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-11T09:54:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706591772",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706592696"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706592696"
                }
            },
            "author_association": "MEMBER",
            "body": "Given that it said \"Overrides severity_limit.\" I would have expected it to behave like a limit, also given this is the behavior I'd expect as a _user_.   The expectation assumed here is that \"exact match\" is the common case and limit is some kind of special case, and I think it would be less surprising the other way around (alternatively `severity_limit` and `severity_only` and an error for a conflict to be neutral and explicit about behavior).",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T10:04:45Z",
            "diff_hunk": "@@ -0,0 +1,616 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+\t\t\t\t\t\t\t*diagnostic-highlights*\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultWarn*\n+DiagnosticDefaultWarn\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultInfo*\n+DiagnosticDefaultInfo\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultHint*\n+DiagnosticDefaultHint\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+==============================================================================\n+Events\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed in a loaded buffer.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+clear({namespace}, {bufnr})                           *vim.diagnostic.clear()*\n+                Clear the currently displayed diagnostics.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Clear diagnostics in the given\n+                                 buffer. If omitted, diagnostics for the given\n+                                 namespace are cleared in all buffers.\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:- `false`: Disable this feature - `true`: Enable this\n+                    feature, use default settings. - `table`: Enable this\n+                    feature with overrides. - `function`: Function with\n+                    signature (namespace, bufnr) that returns any of the\n+                    above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                   |vim.diagnostic.set_underline()|\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                   |vim.diagnostic.set_virtual_text()|\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics |vim.diagnostic.set_signs()|\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({namespace}, {bufnr})                       *vim.diagnostic.disable()*\n+                Disable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, disable\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+enable({namespace}, {bufnr})                         *vim.diagnostic.enable()*\n+                Enable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, eanble\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+get({namespace}, {bufnr})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the given namespace or buffer.\n+\n+                With no arguments, return a list of all diagnostics.\n+\n+                If {namespace} is `nil` , retrieve all diagnostics associated\n+                with buffer {bufnr}. If {bufnr} is `nil` , retrieve all\n+                diagnostics associated with namespace {namespace}. Otherwise,\n+                retrieve diagnostics from namespace {namespace} associated\n+                with buffer {bufnr}.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil The namespace to get diagnostics\n+                                 from. If omitted, get diagnostics from all\n+                                 namespaces. be `nil` only when {bufnr} is not\n+                                 `nil` .\n+                    {bufnr}      number|nil The buffer number to get\n+                                 diagnistics from. If omitted, get diagnostics\n+                                 from all buffers.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({namespace}, {bufnr}, {severity})\n+                Get the number of diagnostics with the given severity.\n+\n+                Useful for showing diagnostic counts in statusline. eg: >\n+\n+                 function! DiagnosticStatus() abort\n+                   let sl = ''\n+                   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)\")} '\n+                   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)\")}'\n+                   return sl\n+                 endfunction\n+<\n+\n+                Then simply add `%{DiagnosticStatus()}` to your statusline.\n+\n+                Parameters: ~\n+                    {namespace}     number|nil Limit diagnostics to the given\n+                                    namespace. If `nil` , retrieve diagnostics\n+                                    from all namespaces.\n+                    {bufnr}         number|nil The buffer number. Defaults to\n+                                    the current buffer.\n+                    {severity|nil}  Return diagnostics for the given severity\n+                                    |vim.diagnostic.severity|. If omitted, all\n+                                    diagnositcs are returned.\n+\n+                                       *vim.diagnostic.get_line_diagnostics()*\n+get_line_diagnostics({bufnr}, {lnum}, {opts})\n+                Get diagnostics by line.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace. If `nil` , retrieve diagnostics\n+                                 from all namespaces.\n+                    {bufnr}      number|nil The buffer number. Defaults to the\n+                                 current buffer.\n+                    {lnum}       number|nil The line number. Defaults to the\n+                                 current line.\n+                    {opts}       table|nil A table with the following keys:\n+                                 • namespace: (number) Limit diagnostics to\n+                                   the given namespace.\n+                                 • severity: (|vim.diagnostic.severity|) Only\n+                                   return diagnostics with this severity.",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706592696",
            "id": 706592696,
            "in_reply_to_id": 706590743,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjU5MjY5Ng==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 284,
            "original_position": 304,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 751907072,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706592696/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-11T10:04:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706592696",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1363104?v=4",
                "events_url": "https://api.github.com/users/bfredl/events{/privacy}",
                "followers_url": "https://api.github.com/users/bfredl/followers",
                "following_url": "https://api.github.com/users/bfredl/following{/other_user}",
                "gists_url": "https://api.github.com/users/bfredl/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/bfredl",
                "id": 1363104,
                "login": "bfredl",
                "node_id": "MDQ6VXNlcjEzNjMxMDQ=",
                "organizations_url": "https://api.github.com/users/bfredl/orgs",
                "received_events_url": "https://api.github.com/users/bfredl/received_events",
                "repos_url": "https://api.github.com/users/bfredl/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/bfredl/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/bfredl/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/bfredl"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706593643"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706593643"
                }
            },
            "author_association": "MEMBER",
            "body": "I think the behavior (and the documentation broadly) is good; the documentation also matches the (simple) implementation where `severity` is checked first.\r\n\r\nTwo suggestions for improvement:\r\n* switch the order, so that `limit` comes first; that makes the contrast clearer and gives context for the \"overrides\".\r\n* if `severity` should be renamed, I'd suggest `severity_level` -- and use that consistently, also in the code (e.g., `filter_by_severity_level` rather than `filter_at_severity_limit` -- which I had to read three times before noticing the difference to `filter_by_severity_limit`...)",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T10:13:15Z",
            "diff_hunk": "@@ -0,0 +1,616 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+\t\t\t\t\t\t\t*diagnostic-highlights*\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultWarn*\n+DiagnosticDefaultWarn\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultInfo*\n+DiagnosticDefaultInfo\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultHint*\n+DiagnosticDefaultHint\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+==============================================================================\n+Events\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed in a loaded buffer.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+clear({namespace}, {bufnr})                           *vim.diagnostic.clear()*\n+                Clear the currently displayed diagnostics.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Clear diagnostics in the given\n+                                 buffer. If omitted, diagnostics for the given\n+                                 namespace are cleared in all buffers.\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:- `false`: Disable this feature - `true`: Enable this\n+                    feature, use default settings. - `table`: Enable this\n+                    feature with overrides. - `function`: Function with\n+                    signature (namespace, bufnr) that returns any of the\n+                    above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                   |vim.diagnostic.set_underline()|\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                   |vim.diagnostic.set_virtual_text()|\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics |vim.diagnostic.set_signs()|\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({namespace}, {bufnr})                       *vim.diagnostic.disable()*\n+                Disable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, disable\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+enable({namespace}, {bufnr})                         *vim.diagnostic.enable()*\n+                Enable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, eanble\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+get({namespace}, {bufnr})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the given namespace or buffer.\n+\n+                With no arguments, return a list of all diagnostics.\n+\n+                If {namespace} is `nil` , retrieve all diagnostics associated\n+                with buffer {bufnr}. If {bufnr} is `nil` , retrieve all\n+                diagnostics associated with namespace {namespace}. Otherwise,\n+                retrieve diagnostics from namespace {namespace} associated\n+                with buffer {bufnr}.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil The namespace to get diagnostics\n+                                 from. If omitted, get diagnostics from all\n+                                 namespaces. be `nil` only when {bufnr} is not\n+                                 `nil` .\n+                    {bufnr}      number|nil The buffer number to get\n+                                 diagnistics from. If omitted, get diagnostics\n+                                 from all buffers.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({namespace}, {bufnr}, {severity})\n+                Get the number of diagnostics with the given severity.\n+\n+                Useful for showing diagnostic counts in statusline. eg: >\n+\n+                 function! DiagnosticStatus() abort\n+                   let sl = ''\n+                   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)\")} '\n+                   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)\")}'\n+                   return sl\n+                 endfunction\n+<\n+\n+                Then simply add `%{DiagnosticStatus()}` to your statusline.\n+\n+                Parameters: ~\n+                    {namespace}     number|nil Limit diagnostics to the given\n+                                    namespace. If `nil` , retrieve diagnostics\n+                                    from all namespaces.\n+                    {bufnr}         number|nil The buffer number. Defaults to\n+                                    the current buffer.\n+                    {severity|nil}  Return diagnostics for the given severity\n+                                    |vim.diagnostic.severity|. If omitted, all\n+                                    diagnositcs are returned.\n+\n+                                       *vim.diagnostic.get_line_diagnostics()*\n+get_line_diagnostics({bufnr}, {lnum}, {opts})\n+                Get diagnostics by line.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace. If `nil` , retrieve diagnostics\n+                                 from all namespaces.\n+                    {bufnr}      number|nil The buffer number. Defaults to the\n+                                 current buffer.\n+                    {lnum}       number|nil The line number. Defaults to the\n+                                 current line.\n+                    {opts}       table|nil A table with the following keys:\n+                                 • namespace: (number) Limit diagnostics to\n+                                   the given namespace.\n+                                 • severity: (|vim.diagnostic.severity|) Only\n+                                   return diagnostics with this severity.",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706593643",
            "id": 706593643,
            "in_reply_to_id": 706590743,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjU5MzY0Mw==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 284,
            "original_position": 304,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 751907582,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706593643/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-11T10:13:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706593643",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706593817"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706593817"
                }
            },
            "author_association": "MEMBER",
            "body": "And while we're at naming, I can't help but add my *ceterum censeo* that the inconsistent use of `diagnostic` and `diagnostics` is a mild but constant irritation...\r\n\r\nIf we do make a breaking change to the API (even with a compatibility layer to make it transparent), I'd love to take the opportunity to standardize on `vim.diagnostic**s**` everywhere!",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T10:15:36Z",
            "diff_hunk": "@@ -0,0 +1,616 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+\t\t\t\t\t\t\t*diagnostic-highlights*\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultWarn*\n+DiagnosticDefaultWarn\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultInfo*\n+DiagnosticDefaultInfo\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultHint*\n+DiagnosticDefaultHint\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+==============================================================================\n+Events\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed in a loaded buffer.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+clear({namespace}, {bufnr})                           *vim.diagnostic.clear()*\n+                Clear the currently displayed diagnostics.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Clear diagnostics in the given\n+                                 buffer. If omitted, diagnostics for the given\n+                                 namespace are cleared in all buffers.\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:- `false`: Disable this feature - `true`: Enable this\n+                    feature, use default settings. - `table`: Enable this\n+                    feature with overrides. - `function`: Function with\n+                    signature (namespace, bufnr) that returns any of the\n+                    above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                   |vim.diagnostic.set_underline()|\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                   |vim.diagnostic.set_virtual_text()|\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics |vim.diagnostic.set_signs()|\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({namespace}, {bufnr})                       *vim.diagnostic.disable()*\n+                Disable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, disable\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+enable({namespace}, {bufnr})                         *vim.diagnostic.enable()*\n+                Enable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, eanble\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+get({namespace}, {bufnr})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the given namespace or buffer.\n+\n+                With no arguments, return a list of all diagnostics.\n+\n+                If {namespace} is `nil` , retrieve all diagnostics associated\n+                with buffer {bufnr}. If {bufnr} is `nil` , retrieve all\n+                diagnostics associated with namespace {namespace}. Otherwise,\n+                retrieve diagnostics from namespace {namespace} associated\n+                with buffer {bufnr}.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil The namespace to get diagnostics\n+                                 from. If omitted, get diagnostics from all\n+                                 namespaces. be `nil` only when {bufnr} is not\n+                                 `nil` .\n+                    {bufnr}      number|nil The buffer number to get\n+                                 diagnistics from. If omitted, get diagnostics\n+                                 from all buffers.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({namespace}, {bufnr}, {severity})\n+                Get the number of diagnostics with the given severity.\n+\n+                Useful for showing diagnostic counts in statusline. eg: >\n+\n+                 function! DiagnosticStatus() abort\n+                   let sl = ''\n+                   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)\")} '\n+                   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)\")}'\n+                   return sl\n+                 endfunction\n+<\n+\n+                Then simply add `%{DiagnosticStatus()}` to your statusline.\n+\n+                Parameters: ~\n+                    {namespace}     number|nil Limit diagnostics to the given\n+                                    namespace. If `nil` , retrieve diagnostics\n+                                    from all namespaces.\n+                    {bufnr}         number|nil The buffer number. Defaults to\n+                                    the current buffer.\n+                    {severity|nil}  Return diagnostics for the given severity\n+                                    |vim.diagnostic.severity|. If omitted, all\n+                                    diagnositcs are returned.\n+\n+                                       *vim.diagnostic.get_line_diagnostics()*\n+get_line_diagnostics({bufnr}, {lnum}, {opts})\n+                Get diagnostics by line.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace. If `nil` , retrieve diagnostics\n+                                 from all namespaces.\n+                    {bufnr}      number|nil The buffer number. Defaults to the\n+                                 current buffer.\n+                    {lnum}       number|nil The line number. Defaults to the\n+                                 current line.\n+                    {opts}       table|nil A table with the following keys:\n+                                 • namespace: (number) Limit diagnostics to\n+                                   the given namespace.\n+                                 • severity: (|vim.diagnostic.severity|) Only\n+                                   return diagnostics with this severity.",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706593817",
            "id": 706593817,
            "in_reply_to_id": 706590743,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjU5MzgxNw==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 284,
            "original_position": 304,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 751907684,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706593817/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-11T10:15:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706593817",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706599902"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706599902"
                }
            },
            "author_association": "MEMBER",
            "body": "As promoting this to _top level_ core API will substantially increase the direct usage of this API among plugins and users (as opposed to indirectly by activating a LSP config), I do think it is worthwhile to do some polish at the API at the same time, even if this implies a breaking change for some existing usages (no opinion either way on a compat layer)",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T11:13:28Z",
            "diff_hunk": "@@ -0,0 +1,616 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+\t\t\t\t\t\t\t*diagnostic-highlights*\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultWarn*\n+DiagnosticDefaultWarn\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultInfo*\n+DiagnosticDefaultInfo\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultHint*\n+DiagnosticDefaultHint\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+==============================================================================\n+Events\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed in a loaded buffer.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+clear({namespace}, {bufnr})                           *vim.diagnostic.clear()*\n+                Clear the currently displayed diagnostics.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Clear diagnostics in the given\n+                                 buffer. If omitted, diagnostics for the given\n+                                 namespace are cleared in all buffers.\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:- `false`: Disable this feature - `true`: Enable this\n+                    feature, use default settings. - `table`: Enable this\n+                    feature with overrides. - `function`: Function with\n+                    signature (namespace, bufnr) that returns any of the\n+                    above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                   |vim.diagnostic.set_underline()|\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                   |vim.diagnostic.set_virtual_text()|\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics |vim.diagnostic.set_signs()|\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({namespace}, {bufnr})                       *vim.diagnostic.disable()*\n+                Disable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, disable\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+enable({namespace}, {bufnr})                         *vim.diagnostic.enable()*\n+                Enable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, eanble\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+get({namespace}, {bufnr})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the given namespace or buffer.\n+\n+                With no arguments, return a list of all diagnostics.\n+\n+                If {namespace} is `nil` , retrieve all diagnostics associated\n+                with buffer {bufnr}. If {bufnr} is `nil` , retrieve all\n+                diagnostics associated with namespace {namespace}. Otherwise,\n+                retrieve diagnostics from namespace {namespace} associated\n+                with buffer {bufnr}.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil The namespace to get diagnostics\n+                                 from. If omitted, get diagnostics from all\n+                                 namespaces. be `nil` only when {bufnr} is not\n+                                 `nil` .\n+                    {bufnr}      number|nil The buffer number to get\n+                                 diagnistics from. If omitted, get diagnostics\n+                                 from all buffers.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({namespace}, {bufnr}, {severity})\n+                Get the number of diagnostics with the given severity.\n+\n+                Useful for showing diagnostic counts in statusline. eg: >\n+\n+                 function! DiagnosticStatus() abort\n+                   let sl = ''\n+                   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)\")} '\n+                   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)\")}'\n+                   return sl\n+                 endfunction\n+<\n+\n+                Then simply add `%{DiagnosticStatus()}` to your statusline.\n+\n+                Parameters: ~\n+                    {namespace}     number|nil Limit diagnostics to the given\n+                                    namespace. If `nil` , retrieve diagnostics\n+                                    from all namespaces.\n+                    {bufnr}         number|nil The buffer number. Defaults to\n+                                    the current buffer.\n+                    {severity|nil}  Return diagnostics for the given severity\n+                                    |vim.diagnostic.severity|. If omitted, all\n+                                    diagnositcs are returned.\n+\n+                                       *vim.diagnostic.get_line_diagnostics()*\n+get_line_diagnostics({bufnr}, {lnum}, {opts})\n+                Get diagnostics by line.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace. If `nil` , retrieve diagnostics\n+                                 from all namespaces.\n+                    {bufnr}      number|nil The buffer number. Defaults to the\n+                                 current buffer.\n+                    {lnum}       number|nil The line number. Defaults to the\n+                                 current line.\n+                    {opts}       table|nil A table with the following keys:\n+                                 • namespace: (number) Limit diagnostics to\n+                                   the given namespace.\n+                                 • severity: (|vim.diagnostic.severity|) Only\n+                                   return diagnostics with this severity.",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706599902",
            "id": 706599902,
            "in_reply_to_id": 706590743,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjU5OTkwMg==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 284,
            "original_position": 304,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 751911033,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706599902/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-11T11:13:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706599902",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1363104?v=4",
                "events_url": "https://api.github.com/users/bfredl/events{/privacy}",
                "followers_url": "https://api.github.com/users/bfredl/followers",
                "following_url": "https://api.github.com/users/bfredl/following{/other_user}",
                "gists_url": "https://api.github.com/users/bfredl/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/bfredl",
                "id": 1363104,
                "login": "bfredl",
                "node_id": "MDQ6VXNlcjEzNjMxMDQ=",
                "organizations_url": "https://api.github.com/users/bfredl/orgs",
                "received_events_url": "https://api.github.com/users/bfredl/received_events",
                "repos_url": "https://api.github.com/users/bfredl/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/bfredl/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/bfredl/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/bfredl"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706607287"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706607287"
                }
            },
            "author_association": "MEMBER",
            "body": "I wonder if we could remove both `reset` and `clear` (at least from public API) and replace them with `set` (using empty an empty table) + `redraw`.\r\n\r\nWithout reading the docs, it is not obvious what the difference between the two is",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T12:28:09Z",
            "diff_hunk": "@@ -0,0 +1,1377 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_to_severity_limit(severity, diagnostics)\n+  local filter_level = to_severity(severity)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity == filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function filter_by_severity_limit(severity_limit, diagnostics)\n+  local filter_level = to_severity(severity_limit)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity <= filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function valid_severity()\n+  return function(severity)\n+    if type(severity) == 'string' then\n+      return to_severity(severity) ~= nil\n+    elseif type(severity) == 'number' then\n+      return M.severity[severity] ~= nil\n+    end\n+  end, \"Invalid value for 'severity' parameter\"\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local default_highlight_map = make_highlight_map(\"Default\")\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_lines = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_counts = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function diagnostic_counts(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local counts = {}\n+  for _, diagnostic in pairs(diagnostics) do\n+    if diagnostic.severity then\n+      local val = counts[diagnostic.severity]\n+      if val == nil then\n+        val = 0\n+      end\n+\n+      counts[diagnostic.severity] = val + 1\n+    end\n+  end\n+\n+  return counts\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+  diagnostic_cache_lines[bufnr][namespace] = diagnostic_lines(diagnostics)\n+  diagnostic_cache_counts[bufnr][namespace] = diagnostic_counts(diagnostics)\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+  diagnostic_cache_lines[bufnr][namespace] = nil\n+  diagnostic_cache_counts[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+\n+--- Display diagnostics for the buffer with the given options.\n+---@private\n+local function display(namespace, diagnostics, bufnr, opts)\n+  if diagnostic_disabled[bufnr][namespace] then\n+    return\n+  end\n+\n+  M.clear(namespace, bufnr)\n+\n+  diagnostics = diagnostics or M.get(namespace, bufnr)\n+\n+  if not diagnostics or vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+\n+  opts = get_resolved_options(opts, namespace, bufnr)\n+\n+  if opts.update_in_insert then\n+    clear_scheduled_display(namespace, bufnr)\n+  else\n+    local mode = vim.api.nvim_get_mode()\n+    if string.sub(mode.mode, 1, 1) == 'i' then\n+      schedule_display(namespace, bufnr, opts)\n+      return\n+    end\n+  end\n+\n+  if opts.underline then\n+    M.set_underline(namespace, diagnostics, bufnr, opts.underline)\n+  end\n+\n+  if opts.virtual_text then\n+    M.set_virtual_text(namespace, diagnostics, bufnr, opts.virtual_text)\n+  end\n+\n+  if opts.signs then\n+    M.set_signs(namespace, diagnostics, bufnr, opts.signs)\n+  end\n+\n+  save_extmarks(namespace, bufnr)\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---\n+--- The floating window can be customized with the following highlight groups:\n+--- <pre>\n+--- DiagnosticsFloatingError\n+--- DiagnosticsFloatingWarning\n+--- DiagnosticsFloatingInformation\n+--- DiagnosticsFloatingHint\n+--- </pre>\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local diagnostics = M.get(opts.namespace, opts.bufnr)\n+  local items = vim.tbl_filter(function(d)\n+    local severity = to_severity(opts.severity)\n+    if severity then\n+      return d.severity == severity\n+    end\n+    local severity_limit = to_severity(opts.severity_limit)\n+    if severity_limit then\n+      return d.severity <= severity_limit\n+    end\n+    return true\n+  end, diagnostics_to_list_items(diagnostics))\n+  if loclist then\n+    vim.fn.setloclist(0, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+--- Create links to Lsp* groups for backward compatibility (this should\n+--- eventually be removed)\n+---@private\n+local function make_compat_highlight_link(name)\n+  local from = name:gsub(\"^Diagnostic\", \"LspDiagnostics\"):gsub(\"Info\", \"Information\"):gsub(\"Warn\", \"Warning\")\n+  vim.highlight.link(from, name, false)\n+end\n+\n+---@private\n+local function define_default_signs_and_highlights()\n+  ---@private\n+  local function define_default_sign(name, properties)\n+    if vim.tbl_isempty(vim.fn.sign_getdefined(name)) then\n+      vim.fn.sign_define(name, properties)\n+    end\n+  end\n+\n+  -- Initialize default diagnostic highlights\n+  for severity, hi_info in pairs(diagnostic_severities) do\n+    local default_highlight_name = default_highlight_map[severity]\n+    vim.highlight.create(default_highlight_name, hi_info, true)\n+\n+    -- Default link all corresponding highlights to the default highlight\n+    vim.highlight.link(virtual_text_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(floating_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(sign_highlight_map[severity], default_highlight_name, false)\n+\n+    make_compat_highlight_link(default_highlight_name)\n+    make_compat_highlight_link(virtual_text_highlight_map[severity])\n+    make_compat_highlight_link(floating_highlight_map[severity])\n+    make_compat_highlight_link(sign_highlight_map[severity])\n+  end\n+\n+  -- Create all signs\n+  for severity, sign_hl_name in pairs(sign_highlight_map) do\n+    local severity_name = M.severity[severity]\n+\n+    define_default_sign(sign_hl_name, {\n+      text = (severity_name or 'U'):sub(1, 1),\n+      texthl = sign_hl_name,\n+      linehl = '',\n+      numhl = '',\n+    })\n+  end\n+\n+  -- Initialize Underline highlights\n+  for severity, underline_highlight_name in pairs(underline_highlight_map) do\n+    vim.highlight.create(underline_highlight_name, {\n+      cterm = 'underline',\n+      gui   = 'underline',\n+      guisp = diagnostic_severities[severity].guifg\n+    }, true)\n+    make_compat_highlight_link(underline_highlight_name)\n+  end\n+end\n+\n+define_default_signs_and_highlights()\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics |vim.diagnostic.set_underline()|\n+---       - virtual_text: (default true) Use virtual text for diagnostics |vim.diagnostic.set_virtual_text()|\n+---       - signs: (default true) Use signs for diagnostics |vim.diagnostic.set_signs()|\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    M.redraw(namespace)\n+  else\n+    for k in pairs(all_namespaces) do\n+      M.redraw(k)\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param bufnr number|nil The buffer to set diagnostics for. Defaults to the current buffer.\n+function M.set(namespace, diagnostics, bufnr)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    bufnr = {bufnr, 'n', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  bufnr = get_bufnr(bufnr)\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    display(namespace, diagnostics, bufnr)\n+  end\n+end\n+\n+--- Get all diagnostics for the given namespace or buffer.\n+---\n+--- With no arguments, return a list of all diagnostics.\n+---\n+--- If {namespace} is `nil`, retrieve all diagnostics associated with buffer\n+--- {bufnr}. If {bufnr} is `nil`, retrieve all diagnostics associated with\n+--- namespace {namespace}. Otherwise, retrieve diagnostics from namespace\n+--- {namespace} associated with buffer {bufnr}.\n+---\n+---@param namespace number|nil The namespace to get diagnostics from. If\n+---                            omitted, get diagnostics from all namespaces.\n+---                            be `nil` only when {bufnr} is not `nil`.\n+---@param bufnr number|nil The buffer number to get diagnistics from. If\n+---                        omitted, get diagnostics from all buffers.\n+---@return table A list of diagnostic items |diagnostic-structure|.\n+function M.get(namespace, bufnr)\n+  vim.validate {\n+    namespace = { namespace, 'n', true },\n+    bufnr = { bufnr, 'n', true },\n+  }\n+\n+  local diagnostics = {}\n+  if namespace == nil and bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, v in pairs(t) do\n+        for _, diagnostic in ipairs(v) do\n+          table.insert(diagnostics, diagnostic)\n+        end\n+      end\n+    end\n+  elseif namespace == nil then\n+    for iter_namespace in pairs(diagnostic_cache[bufnr]) do\n+      for _, diagnostic in ipairs(diagnostic_cache[bufnr][iter_namespace]) do\n+        table.insert(diagnostics, diagnostic)\n+      end\n+    end\n+  elseif bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, diagnostic in ipairs(t[namespace] or {}) do\n+        table.insert(diagnostics, diagnostic)\n+      end\n+    end\n+  else\n+    for _, diagnostic in ipairs(diagnostic_cache[bufnr][namespace] or {}) do\n+      table.insert(diagnostics, diagnostic)\n+    end\n+  end\n+  return diagnostics\n+end\n+\n+--- Get diagnostics by line.\n+---\n+---@param namespace number|nil Limit diagnostics to the given namespace. If `nil`, retrieve\n+---                            diagnostics from all namespaces.\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param lnum number|nil The line number. Defaults to the current line.\n+---@param opts table|nil A table with the following keys:\n+---                        - namespace: (number) Limit diagnostics to the given namespace.\n+---                        - severity: (|vim.diagnostic.severity|) Only return diagnostics with this\n+---                                    severity. Overrides severity_limit. |vim.diagnostic.severity|\n+---                        - severity_limit: (|vim.diagnostic.severity|) Limit severity of\n+---                                          diagnostics found. For example,\n+---                                          vim.diagnostic.severity.WARN means both errors and\n+---                                          warnings will be valid.\n+---@return table Table with map of line number to list of diagnostics.\n+--               Structured: { [1] = {...}, [5] = {.... } }\n+function M.get_line_diagnostics(bufnr, lnum, opts)\n+  vim.validate {\n+    bufnr = { bufnr, 'n', true },\n+    lnum = { lnum, 'n', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  opts = opts or {}\n+\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  lnum = lnum or vim.api.nvim_win_get_cursor(0)[1] - 1\n+\n+  local ns_get_diags = function(iter_namespace)\n+    return (diagnostic_cache_lines[bufnr][iter_namespace] or {})[lnum] or {}\n+  end\n+\n+  local line_diagnostics\n+  if opts.namespace == nil then\n+    line_diagnostics = {}\n+    for iter_namespace, _ in pairs(diagnostic_cache_lines[bufnr]) do\n+      for _, diagnostic in ipairs(ns_get_diags(iter_namespace)) do\n+        table.insert(line_diagnostics, diagnostic)\n+      end\n+    end\n+  else\n+    line_diagnostics = vim.deepcopy(ns_get_diags(opts.namespace))\n+  end\n+\n+  if opts.severity then\n+    line_diagnostics = filter_to_severity_limit(opts.severity, line_diagnostics)\n+  elseif opts.severity_limit then\n+    line_diagnostics = filter_by_severity_limit(opts.severity_limit, line_diagnostics)\n+  end\n+\n+  table.sort(line_diagnostics, function(a, b) return a.severity < b.severity end)\n+\n+  return line_diagnostics\n+end\n+\n+--- Get the number of diagnostics with the given severity.\n+---\n+--- Useful for showing diagnostic counts in statusline. eg:\n+--- <pre>\n+--- function! DiagnosticStatus() abort\n+---   let sl = ''\n+---   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)\")} '\n+---   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)\")}'\n+---   return sl\n+--- endfunction\n+--- </pre>\n+---\n+--- Then simply add `%{DiagnosticStatus()}` to your statusline.\n+---\n+---@param namespace number|nil Limit diagnostics to the given namespace. If `nil`, retrieve\n+---                            diagnostics from all namespaces.\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param severity|nil Return diagnostics for the given severity |vim.diagnostic.severity|. If\n+---                    omitted, all diagnositcs are returned.\n+function M.get_count(namespace, bufnr, severity)\n+  vim.validate {\n+    namespace = { namespace, 'n', true },\n+    bufnr = { bufnr, 'n', true },\n+    severity = { severity, valid_severity() },\n+  }\n+\n+  if namespace == nil then\n+    local total = 0\n+    for ns in pairs(diagnostic_cache_counts[bufnr]) do\n+      total = total + M.get_count(ns, bufnr, severity)\n+    end\n+    return total\n+  end\n+\n+  return (diagnostic_cache_counts[bufnr][namespace] or {})[to_severity(severity)] or 0\n+end\n+\n+-- Diagnostic Movements {{{\n+\n+local next_diagnostic = function(position, search_forward, bufnr, opts, namespace)\n+  position[1] = position[1] - 1\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  local wrap = vim.F.if_nil(opts.wrap, true)\n+  local line_count = vim.api.nvim_buf_line_count(bufnr)\n+  opts.namespace = namespace\n+  for i = 0, line_count do\n+    local offset = i * (search_forward and 1 or -1)\n+    local lnum = position[1] + offset\n+    if lnum < 0 or lnum >= line_count then\n+      if not wrap then\n+        return\n+      end\n+      lnum = (lnum + line_count) % line_count\n+    end\n+    local line_diagnostics = M.get_line_diagnostics(bufnr, lnum, opts)\n+    if line_diagnostics and not vim.tbl_isempty(line_diagnostics) then\n+      local sort_diagnostics, is_next\n+      if search_forward then\n+        sort_diagnostics = function(a, b) return a.col < b.col end\n+        is_next = function(diagnostic) return diagnostic.col > position[2] end\n+      else\n+        sort_diagnostics = function(a, b) return a.col > b.col end\n+        is_next = function(diagnostic) return diagnostic.col < position[2] end\n+      end\n+      table.sort(line_diagnostics, sort_diagnostics)\n+      if i == 0 then\n+        for _, v in pairs(line_diagnostics) do\n+          if is_next(v) then\n+            return v\n+          end\n+        end\n+      else\n+        return line_diagnostics[1]\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function diagnostic_pos(opts, diagnostic)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+\n+  if not diagnostic then\n+    return false\n+  end\n+\n+  local lnum, col = diagnostic.lnum, diagnostic.col\n+  if col > 0 then\n+    if not vim.api.nvim_buf_is_loaded(bufnr) then\n+      vim.fn.bufload(bufnr)\n+    end\n+\n+    local line = vim.api.nvim_buf_get_lines(bufnr, lnum, lnum + 1, true)[1]\n+    if line then\n+      local ok, result = pcall(vim.str_byteindex, line, col)\n+\n+      if ok then\n+        col = result\n+      end\n+    end\n+  end\n+\n+  return {lnum, col}\n+end\n+\n+---@private\n+local function diagnostic_move_pos(name, opts, pos)\n+  opts = opts or {}\n+\n+  local enable_popup = vim.F.if_nil(opts.enable_popup, true)\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+\n+  if not pos then\n+    print(string.format(\"%s: No more valid diagnostics to move to.\", name))\n+    return\n+  end\n+\n+  vim.api.nvim_win_set_cursor(win_id, {pos[1] + 1, pos[2]})\n+\n+  if enable_popup then\n+    -- This is a bit weird... I'm surprised that we need to wait til the next tick to do this.\n+    vim.schedule(function()\n+      M.show_position_diagnostics(opts.popup_opts, vim.api.nvim_win_get_buf(win_id))\n+    end)\n+  end\n+end\n+\n+--- Get the previous diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic\n+function M.get_prev(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, false, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the previous diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic position as a (row, col) tuple.\n+function M.get_prev_pos(opts)\n+  return diagnostic_pos(\n+    opts,\n+    M.get_prev(opts)\n+  )\n+end\n+\n+--- Move to the previous diagnostic in the current buffer.\n+---@param opts table See |vim.diagnostic.goto_next()|\n+function M.goto_prev(opts)\n+  return diagnostic_move_pos(\n+    \"DiagnosticPrevious\",\n+    opts,\n+    M.get_prev_pos(opts)\n+  )\n+end\n+\n+--- Get the next diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic\n+function M.get_next(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, true, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the next diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic position as a (row, col) tuple.\n+function M.get_next_pos(opts)\n+  return diagnostic_pos(\n+    opts,\n+    M.get_next(opts)\n+  )\n+end\n+\n+--- Move to the next diagnostic.\n+---\n+---@param opts table|nil Configuration table with the following keys:\n+---         - namespace: (number) Only consider diagnostics from the given namespace.\n+---         - cursor_position: (cursor position) Cursor position as a (row, col) tuple. See\n+---                          |nvim_win_get_cursor()|. Defaults to the current cursor position.\n+---         - wrap: (boolean, default true) Whether to loop around file or not. Similar to 'wrapscan'.\n+---         - severity: (|vim.diagnostic.severity|) Exclusive severity to consider.\n+---                   Overrides {severity_limit}\n+---         - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                         example, vim.diagnostic.severity.WARN means both errors and warnings\n+---                         will be valid.\n+---         - enable_popup: (boolean, default true) Call |vim.diagnostic.show_line_diagnostics()|\n+---                       on jump.\n+---         - popup_opts: (table) Table to pass as {opts} parameter to\n+---                     |vim.diagnostic.show_line_diagnostics()|\n+---         - win_id: (number, default 0) Window ID\n+function M.goto_next(opts)\n+  return diagnostic_move_pos(\n+    \"DiagnosticNext\",\n+    opts,\n+    M.get_next_pos(opts)\n+  )\n+end\n+\n+-- Diagnostic Setters {{{\n+\n+--- Set signs for given diagnostics.\n+---\n+--- Sign characters can be customized with the following commands:\n+---\n+--- <pre>\n+--- sign define DiagnosticSignError text=E texthl=DiagnosticSignError linehl= numhl=\n+--- sign define DiagnosticSignWarning text=W texthl=DiagnosticSignWarning linehl= numhl=\n+--- sign define DiagnosticSignInformation text=I texthl=DiagnosticSignInformation linehl= numhl=\n+--- sign define DiagnosticSignHint text=H texthl=DiagnosticSignHint linehl= numhl=\n+--- </pre>\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics|nil table A list of diagnostic items |diagnostic-structure|. If omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param bufnr number The buffer number\n+---@param opts table Configuration table with the following keys:\n+---            - priority: Set the priority of the signs |sign-priority|.\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                           example, `vim.diagnostic.severity.WARN` means errors and warnings are\n+---                           valid.\n+function M.set_signs(namespace, diagnostics, bufnr, opts)\n+  opts = get_resolved_options({ signs = opts }, namespace, bufnr).signs\n+\n+  if not diagnostics then\n+    diagnostics = diagnostic_cache[bufnr][namespace]\n+  end\n+\n+  if not diagnostics then\n+    return\n+  end\n+\n+  bufnr = get_bufnr(bufnr)\n+  diagnostics = filter_by_severity_limit(opts.severity_limit, diagnostics)\n+\n+  local ns = get_namespace(namespace)\n+\n+  local ok = true\n+  for _, diagnostic in ipairs(diagnostics) do\n+    ok = ok and pcall(vim.fn.sign_place,\n+      0,\n+      ns.sign_group,\n+      sign_highlight_map[diagnostic.severity],\n+      bufnr,\n+      {\n+        priority = opts.priority,\n+        lnum = diagnostic.lnum + 1\n+      }\n+    )\n+  end\n+end\n+\n+--- Set underline for given diagnostics.\n+---\n+--- Underline highlights can be customized by changing the following |:highlight| groups.\n+---\n+--- <pre>\n+--- DiagnosticUnderlineError\n+--- DiagnosticUnderlineWarning\n+--- DiagnosticUnderlineInformation\n+--- DiagnosticUnderlineHint\n+--- </pre>\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics|nil table A list of diagnostic items |diagnostic-structure|. If omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param bufnr number The buffer number\n+---@param opts table Configuration table with the following keys:\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                           example, `vim.diagnostic.severity.WARN` means errors and warnings are\n+---                           valid.\n+function M.set_underline(namespace, diagnostics, bufnr, opts)\n+  opts = get_resolved_options({ underline = opts }, namespace, bufnr).underline\n+\n+  diagnostics = filter_by_severity_limit(opts.severity_limit, diagnostics)\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local higroup = underline_highlight_map[diagnostic.severity]\n+\n+    if higroup == nil then\n+      -- Default to error if we don't have a highlight associated\n+      higroup = underline_highlight_map.Error\n+    end\n+\n+    vim.highlight.range(\n+      bufnr,\n+      namespace,\n+      higroup,\n+      { diagnostic.lnum, diagnostic.col },\n+      { diagnostic.end_lnum, diagnostic.end_col }\n+    )\n+  end\n+end\n+\n+--- Set virtual text for given diagnostics.\n+---\n+--- Virtual text highlights can be customized by changing the following |:highlight| groups.\n+---\n+--- <pre>\n+--- DiagnosticVirtualTextError\n+--- DiagnosticVirtualTextWarning\n+--- DiagnosticVirtualTextInformation\n+--- DiagnosticVirtualTextHint\n+--- </pre>\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics|nil table A list of diagnostic items |diagnostic-structure|. If omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param bufnr number The buffer number\n+---@param opts table Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line\n+---            - spacing: (number) Number of spaces to insert before virtual text\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                           example, `vim.diagnostic.severity.WARN` means errors and warnings are\n+---                           valid.\n+function M.set_virtual_text(namespace, diagnostics, bufnr, opts)\n+  opts = get_resolved_options({ virtual_text = opts }, namespace, bufnr).virtual_text\n+\n+  local buffer_line_diagnostics\n+  if diagnostics then\n+    buffer_line_diagnostics = diagnostic_lines(diagnostics)\n+  else\n+    buffer_line_diagnostics = diagnostic_cache_lines[bufnr][namespace]\n+  end\n+\n+  if not buffer_line_diagnostics then\n+    return nil\n+  end\n+\n+  for line, line_diagnostics in pairs(buffer_line_diagnostics) do\n+    line_diagnostics = filter_by_severity_limit(opts.severity_limit, line_diagnostics)\n+    local virt_texts = M.get_virt_text_chunks(line_diagnostics, opts)\n+\n+    if virt_texts then\n+      vim.api.nvim_buf_set_extmark(bufnr, namespace, line, 0, {\n+        hl_mode = \"combine\",\n+        virt_text = virt_texts,\n+      })\n+    end\n+  end\n+end\n+\n+--- Get virtual text chunks to display using |nvim_buf_set_extmark()|.\n+---\n+---@param line_diags table The diagnostics associated with the line\n+---                  |vim.diagnostic.get_line_diagnostics()|\n+---@param opts table See {opts} from |vim.diagnostic.set_virtual_text()|\n+---@return an array of [text, hl_group] arrays. This can be passed directly to\n+---        the {virt_text} option of |nvim_buf_set_extmark()|.\n+function M.get_virt_text_chunks(line_diags, opts)\n+  if #line_diags == 0 then\n+    return nil\n+  end\n+\n+  opts = opts or {}\n+  local prefix = opts.prefix or \"■\"\n+  local spacing = opts.spacing or 4\n+\n+  -- Create a little more space between virtual text and contents\n+  local virt_texts = {{string.rep(\" \", spacing)}}\n+\n+  for i = 1, #line_diags - 1 do\n+    table.insert(virt_texts, {prefix, virtual_text_highlight_map[line_diags[i].severity]})\n+  end\n+  local last = line_diags[#line_diags]\n+\n+  -- TODO(tjdevries): Allow different servers to be shown first somehow?\n+  -- TODO(tjdevries): Display server name associated with these?\n+  if last.message then\n+    table.insert(\n+      virt_texts,\n+      {\n+        string.format(\"%s %s\", prefix, last.message:gsub(\"\\r\", \"\"):gsub(\"\\n\", \"  \")),\n+        virtual_text_highlight_map[last.severity]\n+      }\n+    )\n+\n+    return virt_texts\n+  end\n+end\n+\n+--- Clear the currently displayed diagnostics.\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number|nil Clear diagnostics in the given buffer. If omitted, diagnostics for\n+---             the given namespace are cleared in all buffers.\n+function M.clear(namespace, bufnr)\n+  vim.validate {\n+    namespace = { namespace, 'n' },\n+    bufnr = { bufnr, 'n', true },\n+  }\n+\n+  if bufnr == nil then\n+    for k, v in pairs(diagnostic_cache_extmarks) do\n+      if v[namespace] then\n+        M.clear(namespace, k)\n+      end\n+    end\n+  else\n+    bufnr = get_bufnr(bufnr)\n+    diagnostic_cache_extmarks[bufnr][namespace] = {}\n+\n+    local ns = get_namespace(namespace)\n+\n+    -- clear sign group\n+    vim.fn.sign_unplace(ns.sign_group, {buffer=bufnr})\n+\n+    -- clear virtual text namespace\n+    vim.api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+  end\n+end\n+\n+--- Callback scheduled when leaving Insert mode.\n+---\n+--- This function must be exported publicly so that it is available to be called from the Vimscript\n+--- autocommand.\n+---\n+--- See @ref schedule_display()\n+---\n+---@private\n+function M._execute_scheduled_display(namespace, bufnr)\n+  local args = bufs_waiting_to_update[bufnr][namespace]\n+  if not args then\n+    return\n+  end\n+\n+  -- Clear the args so we don't display unnecessarily.\n+  bufs_waiting_to_update[bufnr][namespace] = nil\n+\n+  display(namespace, nil, bufnr, args)\n+end\n+\n+--- Redraw diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number Redraw diagnostics for the given\n+---                 namespace\n+---@param bufnr number|nil Buffer handle. If omitted, redraw diagnostics for the given namespace in\n+---             all buffers.\n+function M.redraw(namespace, bufnr)\n+  if bufnr == nil then\n+    for k, v in pairs(diagnostic_cache) do\n+      if v[namespace] then\n+        M.redraw(namespace, k)\n+      end\n+    end\n+  else\n+    local diagnostics = M.get(namespace, bufnr)\n+    display(namespace, diagnostics, bufnr)\n+  end\n+end\n+\n+--- Open a floating window with the diagnostics at the given position.\n+---\n+---@param opts table|nil Configuration table with the same keys as\n+---            |vim.lsp.util.open_floatin_preview()| in addition to the following:\n+---            - namespace: (number) Limit diagnostics to the given namespace\n+---            - severity: (|vim.diagnostic.severity|) Only return diagnostics with this\n+---                        severity. Overrides severity_limit\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics\n+---                            found. For example, `vim.diagnostic.severity.WARN` means\n+---                            errors and warnings are valid.\n+---            - show_header: (boolean, default true) Show \"Diagnostics:\" header\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param position table|nil The (0,0)-indexed position. Defaults to the current cursor position.\n+---@return table {popup_bufnr, win_id}\n+function M.show_position_diagnostics(opts, bufnr, position)\n+  vim.validate {\n+    opts = { opts, 't', true },\n+    bufnr = { bufnr, 'n', true },\n+    position = { position, 't', true },\n+  }\n+\n+  opts = opts or {}\n+  opts.focus_id = \"position_diagnostics\"\n+  bufnr = get_bufnr(bufnr)\n+  if not position then\n+    local curr_position = vim.api.nvim_win_get_cursor(0)\n+    curr_position[1] = curr_position[1] - 1\n+    position = curr_position\n+  end\n+  local match_position_predicate = function(diag)\n+    return position[1] == diag.lnum and\n+    position[2] >= diag.col and\n+    (position[2] <= diag.end_col or position[1] < diag.end_lnum)\n+  end\n+  local position_diagnostics = vim.tbl_filter(match_position_predicate, M.get(opts.namespace, bufnr))\n+  if opts.severity then\n+    position_diagnostics = filter_to_severity_limit(opts.severity, position_diagnostics)\n+  elseif opts.severity_limit then\n+    position_diagnostics = filter_by_severity_limit(opts.severity_limit, position_diagnostics)\n+  end\n+  table.sort(position_diagnostics, function(a, b) return a.severity < b.severity end)\n+  return show_diagnostics(opts, position_diagnostics)\n+end\n+\n+--- Open a floating window with the diagnostics from the given line.\n+\n+---@param opts table Configuration table. See |vim.diagnostic.show_position_diagnostics()|.\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param lnum number|nil The line number. Defaults to line number of cursor.\n+---@return table {popup_bufnr, win_id}\n+function M.show_line_diagnostics(opts, bufnr, lnum)\n+  vim.validate {\n+    opts = { opts, 't', true },\n+    bufnr = { bufnr, 'n', true },\n+    lnum = { lnum, 'n', true },\n+  }\n+\n+  opts = opts or {}\n+  opts.focus_id = \"line_diagnostics\"\n+  lnum = lnum or (vim.api.nvim_win_get_cursor(0)[1] - 1)\n+  local line_diagnostics = M.get_line_diagnostics(bufnr, lnum, opts)\n+  return show_diagnostics(opts, line_diagnostics)\n+end\n+\n+--- Clear diagnotics and diagnostic cache.\n+---\n+---@param namespace number\n+---@param bufnr number|nil Reset diagnostics for the given buffer. If omitted,\n+---             diagnostics are reset for all buffers.\n+function M.reset(namespace, bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706607287",
            "id": 706607287,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjYwNzI4Nw==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 1095,
            "original_position": 1283,
            "original_start_line": 1278,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 751915267,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706607287/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-11T13:00:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706607287",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706607910"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706607910"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n```\r\n\r\nI think if we decouple the display from `set` we'd give users a lot more flexibility. It would be easy enough for users to call `redraw` following a `set` call, but the other way around (*not* displaying is not possible)\r\n\r\n(Maybe we rename `redraw` to `draw` ?)",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T12:33:57Z",
            "diff_hunk": "@@ -0,0 +1,1377 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_to_severity_limit(severity, diagnostics)\n+  local filter_level = to_severity(severity)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity == filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function filter_by_severity_limit(severity_limit, diagnostics)\n+  local filter_level = to_severity(severity_limit)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity <= filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function valid_severity()\n+  return function(severity)\n+    if type(severity) == 'string' then\n+      return to_severity(severity) ~= nil\n+    elseif type(severity) == 'number' then\n+      return M.severity[severity] ~= nil\n+    end\n+  end, \"Invalid value for 'severity' parameter\"\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local default_highlight_map = make_highlight_map(\"Default\")\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_lines = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_counts = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function diagnostic_counts(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local counts = {}\n+  for _, diagnostic in pairs(diagnostics) do\n+    if diagnostic.severity then\n+      local val = counts[diagnostic.severity]\n+      if val == nil then\n+        val = 0\n+      end\n+\n+      counts[diagnostic.severity] = val + 1\n+    end\n+  end\n+\n+  return counts\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+  diagnostic_cache_lines[bufnr][namespace] = diagnostic_lines(diagnostics)\n+  diagnostic_cache_counts[bufnr][namespace] = diagnostic_counts(diagnostics)\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+  diagnostic_cache_lines[bufnr][namespace] = nil\n+  diagnostic_cache_counts[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+\n+--- Display diagnostics for the buffer with the given options.\n+---@private\n+local function display(namespace, diagnostics, bufnr, opts)\n+  if diagnostic_disabled[bufnr][namespace] then\n+    return\n+  end\n+\n+  M.clear(namespace, bufnr)\n+\n+  diagnostics = diagnostics or M.get(namespace, bufnr)\n+\n+  if not diagnostics or vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+\n+  opts = get_resolved_options(opts, namespace, bufnr)\n+\n+  if opts.update_in_insert then\n+    clear_scheduled_display(namespace, bufnr)\n+  else\n+    local mode = vim.api.nvim_get_mode()\n+    if string.sub(mode.mode, 1, 1) == 'i' then\n+      schedule_display(namespace, bufnr, opts)\n+      return\n+    end\n+  end\n+\n+  if opts.underline then\n+    M.set_underline(namespace, diagnostics, bufnr, opts.underline)\n+  end\n+\n+  if opts.virtual_text then\n+    M.set_virtual_text(namespace, diagnostics, bufnr, opts.virtual_text)\n+  end\n+\n+  if opts.signs then\n+    M.set_signs(namespace, diagnostics, bufnr, opts.signs)\n+  end\n+\n+  save_extmarks(namespace, bufnr)\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---\n+--- The floating window can be customized with the following highlight groups:\n+--- <pre>\n+--- DiagnosticsFloatingError\n+--- DiagnosticsFloatingWarning\n+--- DiagnosticsFloatingInformation\n+--- DiagnosticsFloatingHint\n+--- </pre>\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local diagnostics = M.get(opts.namespace, opts.bufnr)\n+  local items = vim.tbl_filter(function(d)\n+    local severity = to_severity(opts.severity)\n+    if severity then\n+      return d.severity == severity\n+    end\n+    local severity_limit = to_severity(opts.severity_limit)\n+    if severity_limit then\n+      return d.severity <= severity_limit\n+    end\n+    return true\n+  end, diagnostics_to_list_items(diagnostics))\n+  if loclist then\n+    vim.fn.setloclist(0, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+--- Create links to Lsp* groups for backward compatibility (this should\n+--- eventually be removed)\n+---@private\n+local function make_compat_highlight_link(name)\n+  local from = name:gsub(\"^Diagnostic\", \"LspDiagnostics\"):gsub(\"Info\", \"Information\"):gsub(\"Warn\", \"Warning\")\n+  vim.highlight.link(from, name, false)\n+end\n+\n+---@private\n+local function define_default_signs_and_highlights()\n+  ---@private\n+  local function define_default_sign(name, properties)\n+    if vim.tbl_isempty(vim.fn.sign_getdefined(name)) then\n+      vim.fn.sign_define(name, properties)\n+    end\n+  end\n+\n+  -- Initialize default diagnostic highlights\n+  for severity, hi_info in pairs(diagnostic_severities) do\n+    local default_highlight_name = default_highlight_map[severity]\n+    vim.highlight.create(default_highlight_name, hi_info, true)\n+\n+    -- Default link all corresponding highlights to the default highlight\n+    vim.highlight.link(virtual_text_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(floating_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(sign_highlight_map[severity], default_highlight_name, false)\n+\n+    make_compat_highlight_link(default_highlight_name)\n+    make_compat_highlight_link(virtual_text_highlight_map[severity])\n+    make_compat_highlight_link(floating_highlight_map[severity])\n+    make_compat_highlight_link(sign_highlight_map[severity])\n+  end\n+\n+  -- Create all signs\n+  for severity, sign_hl_name in pairs(sign_highlight_map) do\n+    local severity_name = M.severity[severity]\n+\n+    define_default_sign(sign_hl_name, {\n+      text = (severity_name or 'U'):sub(1, 1),\n+      texthl = sign_hl_name,\n+      linehl = '',\n+      numhl = '',\n+    })\n+  end\n+\n+  -- Initialize Underline highlights\n+  for severity, underline_highlight_name in pairs(underline_highlight_map) do\n+    vim.highlight.create(underline_highlight_name, {\n+      cterm = 'underline',\n+      gui   = 'underline',\n+      guisp = diagnostic_severities[severity].guifg\n+    }, true)\n+    make_compat_highlight_link(underline_highlight_name)\n+  end\n+end\n+\n+define_default_signs_and_highlights()\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics |vim.diagnostic.set_underline()|\n+---       - virtual_text: (default true) Use virtual text for diagnostics |vim.diagnostic.set_virtual_text()|\n+---       - signs: (default true) Use signs for diagnostics |vim.diagnostic.set_signs()|\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    M.redraw(namespace)\n+  else\n+    for k in pairs(all_namespaces) do\n+      M.redraw(k)\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param bufnr number|nil The buffer to set diagnostics for. Defaults to the current buffer.\n+function M.set(namespace, diagnostics, bufnr)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    bufnr = {bufnr, 'n', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  bufnr = get_bufnr(bufnr)\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    display(namespace, diagnostics, bufnr)\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706607910",
            "id": 706607910,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjYwNzkxMA==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 519,
            "original_position": 640,
            "original_start_line": 638,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 751915267,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706607910/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-11T13:00:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706607910",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706608815"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706608815"
                }
            },
            "author_association": "MEMBER",
            "body": "I think if we decouple `set` from `(re)draw` we may not need an explicit `disable` and `enable` anymore",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T12:42:34Z",
            "diff_hunk": "@@ -0,0 +1,1377 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_to_severity_limit(severity, diagnostics)\n+  local filter_level = to_severity(severity)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity == filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function filter_by_severity_limit(severity_limit, diagnostics)\n+  local filter_level = to_severity(severity_limit)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity <= filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function valid_severity()\n+  return function(severity)\n+    if type(severity) == 'string' then\n+      return to_severity(severity) ~= nil\n+    elseif type(severity) == 'number' then\n+      return M.severity[severity] ~= nil\n+    end\n+  end, \"Invalid value for 'severity' parameter\"\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local default_highlight_map = make_highlight_map(\"Default\")\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_lines = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_counts = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function diagnostic_counts(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local counts = {}\n+  for _, diagnostic in pairs(diagnostics) do\n+    if diagnostic.severity then\n+      local val = counts[diagnostic.severity]\n+      if val == nil then\n+        val = 0\n+      end\n+\n+      counts[diagnostic.severity] = val + 1\n+    end\n+  end\n+\n+  return counts\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+  diagnostic_cache_lines[bufnr][namespace] = diagnostic_lines(diagnostics)\n+  diagnostic_cache_counts[bufnr][namespace] = diagnostic_counts(diagnostics)\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+  diagnostic_cache_lines[bufnr][namespace] = nil\n+  diagnostic_cache_counts[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+\n+--- Display diagnostics for the buffer with the given options.\n+---@private\n+local function display(namespace, diagnostics, bufnr, opts)\n+  if diagnostic_disabled[bufnr][namespace] then\n+    return\n+  end\n+\n+  M.clear(namespace, bufnr)\n+\n+  diagnostics = diagnostics or M.get(namespace, bufnr)\n+\n+  if not diagnostics or vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+\n+  opts = get_resolved_options(opts, namespace, bufnr)\n+\n+  if opts.update_in_insert then\n+    clear_scheduled_display(namespace, bufnr)\n+  else\n+    local mode = vim.api.nvim_get_mode()\n+    if string.sub(mode.mode, 1, 1) == 'i' then\n+      schedule_display(namespace, bufnr, opts)\n+      return\n+    end\n+  end\n+\n+  if opts.underline then\n+    M.set_underline(namespace, diagnostics, bufnr, opts.underline)\n+  end\n+\n+  if opts.virtual_text then\n+    M.set_virtual_text(namespace, diagnostics, bufnr, opts.virtual_text)\n+  end\n+\n+  if opts.signs then\n+    M.set_signs(namespace, diagnostics, bufnr, opts.signs)\n+  end\n+\n+  save_extmarks(namespace, bufnr)\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---\n+--- The floating window can be customized with the following highlight groups:\n+--- <pre>\n+--- DiagnosticsFloatingError\n+--- DiagnosticsFloatingWarning\n+--- DiagnosticsFloatingInformation\n+--- DiagnosticsFloatingHint\n+--- </pre>\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local diagnostics = M.get(opts.namespace, opts.bufnr)\n+  local items = vim.tbl_filter(function(d)\n+    local severity = to_severity(opts.severity)\n+    if severity then\n+      return d.severity == severity\n+    end\n+    local severity_limit = to_severity(opts.severity_limit)\n+    if severity_limit then\n+      return d.severity <= severity_limit\n+    end\n+    return true\n+  end, diagnostics_to_list_items(diagnostics))\n+  if loclist then\n+    vim.fn.setloclist(0, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+--- Create links to Lsp* groups for backward compatibility (this should\n+--- eventually be removed)\n+---@private\n+local function make_compat_highlight_link(name)\n+  local from = name:gsub(\"^Diagnostic\", \"LspDiagnostics\"):gsub(\"Info\", \"Information\"):gsub(\"Warn\", \"Warning\")\n+  vim.highlight.link(from, name, false)\n+end\n+\n+---@private\n+local function define_default_signs_and_highlights()\n+  ---@private\n+  local function define_default_sign(name, properties)\n+    if vim.tbl_isempty(vim.fn.sign_getdefined(name)) then\n+      vim.fn.sign_define(name, properties)\n+    end\n+  end\n+\n+  -- Initialize default diagnostic highlights\n+  for severity, hi_info in pairs(diagnostic_severities) do\n+    local default_highlight_name = default_highlight_map[severity]\n+    vim.highlight.create(default_highlight_name, hi_info, true)\n+\n+    -- Default link all corresponding highlights to the default highlight\n+    vim.highlight.link(virtual_text_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(floating_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(sign_highlight_map[severity], default_highlight_name, false)\n+\n+    make_compat_highlight_link(default_highlight_name)\n+    make_compat_highlight_link(virtual_text_highlight_map[severity])\n+    make_compat_highlight_link(floating_highlight_map[severity])\n+    make_compat_highlight_link(sign_highlight_map[severity])\n+  end\n+\n+  -- Create all signs\n+  for severity, sign_hl_name in pairs(sign_highlight_map) do\n+    local severity_name = M.severity[severity]\n+\n+    define_default_sign(sign_hl_name, {\n+      text = (severity_name or 'U'):sub(1, 1),\n+      texthl = sign_hl_name,\n+      linehl = '',\n+      numhl = '',\n+    })\n+  end\n+\n+  -- Initialize Underline highlights\n+  for severity, underline_highlight_name in pairs(underline_highlight_map) do\n+    vim.highlight.create(underline_highlight_name, {\n+      cterm = 'underline',\n+      gui   = 'underline',\n+      guisp = diagnostic_severities[severity].guifg\n+    }, true)\n+    make_compat_highlight_link(underline_highlight_name)\n+  end\n+end\n+\n+define_default_signs_and_highlights()\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics |vim.diagnostic.set_underline()|\n+---       - virtual_text: (default true) Use virtual text for diagnostics |vim.diagnostic.set_virtual_text()|\n+---       - signs: (default true) Use signs for diagnostics |vim.diagnostic.set_signs()|\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    M.redraw(namespace)\n+  else\n+    for k in pairs(all_namespaces) do\n+      M.redraw(k)\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param bufnr number|nil The buffer to set diagnostics for. Defaults to the current buffer.\n+function M.set(namespace, diagnostics, bufnr)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    bufnr = {bufnr, 'n', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  bufnr = get_bufnr(bufnr)\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    display(namespace, diagnostics, bufnr)\n+  end\n+end\n+\n+--- Get all diagnostics for the given namespace or buffer.\n+---\n+--- With no arguments, return a list of all diagnostics.\n+---\n+--- If {namespace} is `nil`, retrieve all diagnostics associated with buffer\n+--- {bufnr}. If {bufnr} is `nil`, retrieve all diagnostics associated with\n+--- namespace {namespace}. Otherwise, retrieve diagnostics from namespace\n+--- {namespace} associated with buffer {bufnr}.\n+---\n+---@param namespace number|nil The namespace to get diagnostics from. If\n+---                            omitted, get diagnostics from all namespaces.\n+---                            be `nil` only when {bufnr} is not `nil`.\n+---@param bufnr number|nil The buffer number to get diagnistics from. If\n+---                        omitted, get diagnostics from all buffers.\n+---@return table A list of diagnostic items |diagnostic-structure|.\n+function M.get(namespace, bufnr)\n+  vim.validate {\n+    namespace = { namespace, 'n', true },\n+    bufnr = { bufnr, 'n', true },\n+  }\n+\n+  local diagnostics = {}\n+  if namespace == nil and bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, v in pairs(t) do\n+        for _, diagnostic in ipairs(v) do\n+          table.insert(diagnostics, diagnostic)\n+        end\n+      end\n+    end\n+  elseif namespace == nil then\n+    for iter_namespace in pairs(diagnostic_cache[bufnr]) do\n+      for _, diagnostic in ipairs(diagnostic_cache[bufnr][iter_namespace]) do\n+        table.insert(diagnostics, diagnostic)\n+      end\n+    end\n+  elseif bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, diagnostic in ipairs(t[namespace] or {}) do\n+        table.insert(diagnostics, diagnostic)\n+      end\n+    end\n+  else\n+    for _, diagnostic in ipairs(diagnostic_cache[bufnr][namespace] or {}) do\n+      table.insert(diagnostics, diagnostic)\n+    end\n+  end\n+  return diagnostics\n+end\n+\n+--- Get diagnostics by line.\n+---\n+---@param namespace number|nil Limit diagnostics to the given namespace. If `nil`, retrieve\n+---                            diagnostics from all namespaces.\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param lnum number|nil The line number. Defaults to the current line.\n+---@param opts table|nil A table with the following keys:\n+---                        - namespace: (number) Limit diagnostics to the given namespace.\n+---                        - severity: (|vim.diagnostic.severity|) Only return diagnostics with this\n+---                                    severity. Overrides severity_limit. |vim.diagnostic.severity|\n+---                        - severity_limit: (|vim.diagnostic.severity|) Limit severity of\n+---                                          diagnostics found. For example,\n+---                                          vim.diagnostic.severity.WARN means both errors and\n+---                                          warnings will be valid.\n+---@return table Table with map of line number to list of diagnostics.\n+--               Structured: { [1] = {...}, [5] = {.... } }\n+function M.get_line_diagnostics(bufnr, lnum, opts)\n+  vim.validate {\n+    bufnr = { bufnr, 'n', true },\n+    lnum = { lnum, 'n', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  opts = opts or {}\n+\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  lnum = lnum or vim.api.nvim_win_get_cursor(0)[1] - 1\n+\n+  local ns_get_diags = function(iter_namespace)\n+    return (diagnostic_cache_lines[bufnr][iter_namespace] or {})[lnum] or {}\n+  end\n+\n+  local line_diagnostics\n+  if opts.namespace == nil then\n+    line_diagnostics = {}\n+    for iter_namespace, _ in pairs(diagnostic_cache_lines[bufnr]) do\n+      for _, diagnostic in ipairs(ns_get_diags(iter_namespace)) do\n+        table.insert(line_diagnostics, diagnostic)\n+      end\n+    end\n+  else\n+    line_diagnostics = vim.deepcopy(ns_get_diags(opts.namespace))\n+  end\n+\n+  if opts.severity then\n+    line_diagnostics = filter_to_severity_limit(opts.severity, line_diagnostics)\n+  elseif opts.severity_limit then\n+    line_diagnostics = filter_by_severity_limit(opts.severity_limit, line_diagnostics)\n+  end\n+\n+  table.sort(line_diagnostics, function(a, b) return a.severity < b.severity end)\n+\n+  return line_diagnostics\n+end\n+\n+--- Get the number of diagnostics with the given severity.\n+---\n+--- Useful for showing diagnostic counts in statusline. eg:\n+--- <pre>\n+--- function! DiagnosticStatus() abort\n+---   let sl = ''\n+---   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)\")} '\n+---   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)\")}'\n+---   return sl\n+--- endfunction\n+--- </pre>\n+---\n+--- Then simply add `%{DiagnosticStatus()}` to your statusline.\n+---\n+---@param namespace number|nil Limit diagnostics to the given namespace. If `nil`, retrieve\n+---                            diagnostics from all namespaces.\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param severity|nil Return diagnostics for the given severity |vim.diagnostic.severity|. If\n+---                    omitted, all diagnositcs are returned.\n+function M.get_count(namespace, bufnr, severity)\n+  vim.validate {\n+    namespace = { namespace, 'n', true },\n+    bufnr = { bufnr, 'n', true },\n+    severity = { severity, valid_severity() },\n+  }\n+\n+  if namespace == nil then\n+    local total = 0\n+    for ns in pairs(diagnostic_cache_counts[bufnr]) do\n+      total = total + M.get_count(ns, bufnr, severity)\n+    end\n+    return total\n+  end\n+\n+  return (diagnostic_cache_counts[bufnr][namespace] or {})[to_severity(severity)] or 0\n+end\n+\n+-- Diagnostic Movements {{{\n+\n+local next_diagnostic = function(position, search_forward, bufnr, opts, namespace)\n+  position[1] = position[1] - 1\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  local wrap = vim.F.if_nil(opts.wrap, true)\n+  local line_count = vim.api.nvim_buf_line_count(bufnr)\n+  opts.namespace = namespace\n+  for i = 0, line_count do\n+    local offset = i * (search_forward and 1 or -1)\n+    local lnum = position[1] + offset\n+    if lnum < 0 or lnum >= line_count then\n+      if not wrap then\n+        return\n+      end\n+      lnum = (lnum + line_count) % line_count\n+    end\n+    local line_diagnostics = M.get_line_diagnostics(bufnr, lnum, opts)\n+    if line_diagnostics and not vim.tbl_isempty(line_diagnostics) then\n+      local sort_diagnostics, is_next\n+      if search_forward then\n+        sort_diagnostics = function(a, b) return a.col < b.col end\n+        is_next = function(diagnostic) return diagnostic.col > position[2] end\n+      else\n+        sort_diagnostics = function(a, b) return a.col > b.col end\n+        is_next = function(diagnostic) return diagnostic.col < position[2] end\n+      end\n+      table.sort(line_diagnostics, sort_diagnostics)\n+      if i == 0 then\n+        for _, v in pairs(line_diagnostics) do\n+          if is_next(v) then\n+            return v\n+          end\n+        end\n+      else\n+        return line_diagnostics[1]\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function diagnostic_pos(opts, diagnostic)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+\n+  if not diagnostic then\n+    return false\n+  end\n+\n+  local lnum, col = diagnostic.lnum, diagnostic.col\n+  if col > 0 then\n+    if not vim.api.nvim_buf_is_loaded(bufnr) then\n+      vim.fn.bufload(bufnr)\n+    end\n+\n+    local line = vim.api.nvim_buf_get_lines(bufnr, lnum, lnum + 1, true)[1]\n+    if line then\n+      local ok, result = pcall(vim.str_byteindex, line, col)\n+\n+      if ok then\n+        col = result\n+      end\n+    end\n+  end\n+\n+  return {lnum, col}\n+end\n+\n+---@private\n+local function diagnostic_move_pos(name, opts, pos)\n+  opts = opts or {}\n+\n+  local enable_popup = vim.F.if_nil(opts.enable_popup, true)\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+\n+  if not pos then\n+    print(string.format(\"%s: No more valid diagnostics to move to.\", name))\n+    return\n+  end\n+\n+  vim.api.nvim_win_set_cursor(win_id, {pos[1] + 1, pos[2]})\n+\n+  if enable_popup then\n+    -- This is a bit weird... I'm surprised that we need to wait til the next tick to do this.\n+    vim.schedule(function()\n+      M.show_position_diagnostics(opts.popup_opts, vim.api.nvim_win_get_buf(win_id))\n+    end)\n+  end\n+end\n+\n+--- Get the previous diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic\n+function M.get_prev(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, false, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the previous diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic position as a (row, col) tuple.\n+function M.get_prev_pos(opts)\n+  return diagnostic_pos(\n+    opts,\n+    M.get_prev(opts)\n+  )\n+end\n+\n+--- Move to the previous diagnostic in the current buffer.\n+---@param opts table See |vim.diagnostic.goto_next()|\n+function M.goto_prev(opts)\n+  return diagnostic_move_pos(\n+    \"DiagnosticPrevious\",\n+    opts,\n+    M.get_prev_pos(opts)\n+  )\n+end\n+\n+--- Get the next diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic\n+function M.get_next(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, true, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the next diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic position as a (row, col) tuple.\n+function M.get_next_pos(opts)\n+  return diagnostic_pos(\n+    opts,\n+    M.get_next(opts)\n+  )\n+end\n+\n+--- Move to the next diagnostic.\n+---\n+---@param opts table|nil Configuration table with the following keys:\n+---         - namespace: (number) Only consider diagnostics from the given namespace.\n+---         - cursor_position: (cursor position) Cursor position as a (row, col) tuple. See\n+---                          |nvim_win_get_cursor()|. Defaults to the current cursor position.\n+---         - wrap: (boolean, default true) Whether to loop around file or not. Similar to 'wrapscan'.\n+---         - severity: (|vim.diagnostic.severity|) Exclusive severity to consider.\n+---                   Overrides {severity_limit}\n+---         - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                         example, vim.diagnostic.severity.WARN means both errors and warnings\n+---                         will be valid.\n+---         - enable_popup: (boolean, default true) Call |vim.diagnostic.show_line_diagnostics()|\n+---                       on jump.\n+---         - popup_opts: (table) Table to pass as {opts} parameter to\n+---                     |vim.diagnostic.show_line_diagnostics()|\n+---         - win_id: (number, default 0) Window ID\n+function M.goto_next(opts)\n+  return diagnostic_move_pos(\n+    \"DiagnosticNext\",\n+    opts,\n+    M.get_next_pos(opts)\n+  )\n+end\n+\n+-- Diagnostic Setters {{{\n+\n+--- Set signs for given diagnostics.\n+---\n+--- Sign characters can be customized with the following commands:\n+---\n+--- <pre>\n+--- sign define DiagnosticSignError text=E texthl=DiagnosticSignError linehl= numhl=\n+--- sign define DiagnosticSignWarning text=W texthl=DiagnosticSignWarning linehl= numhl=\n+--- sign define DiagnosticSignInformation text=I texthl=DiagnosticSignInformation linehl= numhl=\n+--- sign define DiagnosticSignHint text=H texthl=DiagnosticSignHint linehl= numhl=\n+--- </pre>\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics|nil table A list of diagnostic items |diagnostic-structure|. If omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param bufnr number The buffer number\n+---@param opts table Configuration table with the following keys:\n+---            - priority: Set the priority of the signs |sign-priority|.\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                           example, `vim.diagnostic.severity.WARN` means errors and warnings are\n+---                           valid.\n+function M.set_signs(namespace, diagnostics, bufnr, opts)\n+  opts = get_resolved_options({ signs = opts }, namespace, bufnr).signs\n+\n+  if not diagnostics then\n+    diagnostics = diagnostic_cache[bufnr][namespace]\n+  end\n+\n+  if not diagnostics then\n+    return\n+  end\n+\n+  bufnr = get_bufnr(bufnr)\n+  diagnostics = filter_by_severity_limit(opts.severity_limit, diagnostics)\n+\n+  local ns = get_namespace(namespace)\n+\n+  local ok = true\n+  for _, diagnostic in ipairs(diagnostics) do\n+    ok = ok and pcall(vim.fn.sign_place,\n+      0,\n+      ns.sign_group,\n+      sign_highlight_map[diagnostic.severity],\n+      bufnr,\n+      {\n+        priority = opts.priority,\n+        lnum = diagnostic.lnum + 1\n+      }\n+    )\n+  end\n+end\n+\n+--- Set underline for given diagnostics.\n+---\n+--- Underline highlights can be customized by changing the following |:highlight| groups.\n+---\n+--- <pre>\n+--- DiagnosticUnderlineError\n+--- DiagnosticUnderlineWarning\n+--- DiagnosticUnderlineInformation\n+--- DiagnosticUnderlineHint\n+--- </pre>\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics|nil table A list of diagnostic items |diagnostic-structure|. If omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param bufnr number The buffer number\n+---@param opts table Configuration table with the following keys:\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                           example, `vim.diagnostic.severity.WARN` means errors and warnings are\n+---                           valid.\n+function M.set_underline(namespace, diagnostics, bufnr, opts)\n+  opts = get_resolved_options({ underline = opts }, namespace, bufnr).underline\n+\n+  diagnostics = filter_by_severity_limit(opts.severity_limit, diagnostics)\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local higroup = underline_highlight_map[diagnostic.severity]\n+\n+    if higroup == nil then\n+      -- Default to error if we don't have a highlight associated\n+      higroup = underline_highlight_map.Error\n+    end\n+\n+    vim.highlight.range(\n+      bufnr,\n+      namespace,\n+      higroup,\n+      { diagnostic.lnum, diagnostic.col },\n+      { diagnostic.end_lnum, diagnostic.end_col }\n+    )\n+  end\n+end\n+\n+--- Set virtual text for given diagnostics.\n+---\n+--- Virtual text highlights can be customized by changing the following |:highlight| groups.\n+---\n+--- <pre>\n+--- DiagnosticVirtualTextError\n+--- DiagnosticVirtualTextWarning\n+--- DiagnosticVirtualTextInformation\n+--- DiagnosticVirtualTextHint\n+--- </pre>\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics|nil table A list of diagnostic items |diagnostic-structure|. If omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param bufnr number The buffer number\n+---@param opts table Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line\n+---            - spacing: (number) Number of spaces to insert before virtual text\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                           example, `vim.diagnostic.severity.WARN` means errors and warnings are\n+---                           valid.\n+function M.set_virtual_text(namespace, diagnostics, bufnr, opts)\n+  opts = get_resolved_options({ virtual_text = opts }, namespace, bufnr).virtual_text\n+\n+  local buffer_line_diagnostics\n+  if diagnostics then\n+    buffer_line_diagnostics = diagnostic_lines(diagnostics)\n+  else\n+    buffer_line_diagnostics = diagnostic_cache_lines[bufnr][namespace]\n+  end\n+\n+  if not buffer_line_diagnostics then\n+    return nil\n+  end\n+\n+  for line, line_diagnostics in pairs(buffer_line_diagnostics) do\n+    line_diagnostics = filter_by_severity_limit(opts.severity_limit, line_diagnostics)\n+    local virt_texts = M.get_virt_text_chunks(line_diagnostics, opts)\n+\n+    if virt_texts then\n+      vim.api.nvim_buf_set_extmark(bufnr, namespace, line, 0, {\n+        hl_mode = \"combine\",\n+        virt_text = virt_texts,\n+      })\n+    end\n+  end\n+end\n+\n+--- Get virtual text chunks to display using |nvim_buf_set_extmark()|.\n+---\n+---@param line_diags table The diagnostics associated with the line\n+---                  |vim.diagnostic.get_line_diagnostics()|\n+---@param opts table See {opts} from |vim.diagnostic.set_virtual_text()|\n+---@return an array of [text, hl_group] arrays. This can be passed directly to\n+---        the {virt_text} option of |nvim_buf_set_extmark()|.\n+function M.get_virt_text_chunks(line_diags, opts)\n+  if #line_diags == 0 then\n+    return nil\n+  end\n+\n+  opts = opts or {}\n+  local prefix = opts.prefix or \"■\"\n+  local spacing = opts.spacing or 4\n+\n+  -- Create a little more space between virtual text and contents\n+  local virt_texts = {{string.rep(\" \", spacing)}}\n+\n+  for i = 1, #line_diags - 1 do\n+    table.insert(virt_texts, {prefix, virtual_text_highlight_map[line_diags[i].severity]})\n+  end\n+  local last = line_diags[#line_diags]\n+\n+  -- TODO(tjdevries): Allow different servers to be shown first somehow?\n+  -- TODO(tjdevries): Display server name associated with these?\n+  if last.message then\n+    table.insert(\n+      virt_texts,\n+      {\n+        string.format(\"%s %s\", prefix, last.message:gsub(\"\\r\", \"\"):gsub(\"\\n\", \"  \")),\n+        virtual_text_highlight_map[last.severity]\n+      }\n+    )\n+\n+    return virt_texts\n+  end\n+end\n+\n+--- Clear the currently displayed diagnostics.\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number|nil Clear diagnostics in the given buffer. If omitted, diagnostics for\n+---             the given namespace are cleared in all buffers.\n+function M.clear(namespace, bufnr)\n+  vim.validate {\n+    namespace = { namespace, 'n' },\n+    bufnr = { bufnr, 'n', true },\n+  }\n+\n+  if bufnr == nil then\n+    for k, v in pairs(diagnostic_cache_extmarks) do\n+      if v[namespace] then\n+        M.clear(namespace, k)\n+      end\n+    end\n+  else\n+    bufnr = get_bufnr(bufnr)\n+    diagnostic_cache_extmarks[bufnr][namespace] = {}\n+\n+    local ns = get_namespace(namespace)\n+\n+    -- clear sign group\n+    vim.fn.sign_unplace(ns.sign_group, {buffer=bufnr})\n+\n+    -- clear virtual text namespace\n+    vim.api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+  end\n+end\n+\n+--- Callback scheduled when leaving Insert mode.\n+---\n+--- This function must be exported publicly so that it is available to be called from the Vimscript\n+--- autocommand.\n+---\n+--- See @ref schedule_display()\n+---\n+---@private\n+function M._execute_scheduled_display(namespace, bufnr)\n+  local args = bufs_waiting_to_update[bufnr][namespace]\n+  if not args then\n+    return\n+  end\n+\n+  -- Clear the args so we don't display unnecessarily.\n+  bufs_waiting_to_update[bufnr][namespace] = nil\n+\n+  display(namespace, nil, bufnr, args)\n+end\n+\n+--- Redraw diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number Redraw diagnostics for the given\n+---                 namespace\n+---@param bufnr number|nil Buffer handle. If omitted, redraw diagnostics for the given namespace in\n+---             all buffers.\n+function M.redraw(namespace, bufnr)\n+  if bufnr == nil then\n+    for k, v in pairs(diagnostic_cache) do\n+      if v[namespace] then\n+        M.redraw(namespace, k)\n+      end\n+    end\n+  else\n+    local diagnostics = M.get(namespace, bufnr)\n+    display(namespace, diagnostics, bufnr)\n+  end\n+end\n+\n+--- Open a floating window with the diagnostics at the given position.\n+---\n+---@param opts table|nil Configuration table with the same keys as\n+---            |vim.lsp.util.open_floatin_preview()| in addition to the following:\n+---            - namespace: (number) Limit diagnostics to the given namespace\n+---            - severity: (|vim.diagnostic.severity|) Only return diagnostics with this\n+---                        severity. Overrides severity_limit\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics\n+---                            found. For example, `vim.diagnostic.severity.WARN` means\n+---                            errors and warnings are valid.\n+---            - show_header: (boolean, default true) Show \"Diagnostics:\" header\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param position table|nil The (0,0)-indexed position. Defaults to the current cursor position.\n+---@return table {popup_bufnr, win_id}\n+function M.show_position_diagnostics(opts, bufnr, position)\n+  vim.validate {\n+    opts = { opts, 't', true },\n+    bufnr = { bufnr, 'n', true },\n+    position = { position, 't', true },\n+  }\n+\n+  opts = opts or {}\n+  opts.focus_id = \"position_diagnostics\"\n+  bufnr = get_bufnr(bufnr)\n+  if not position then\n+    local curr_position = vim.api.nvim_win_get_cursor(0)\n+    curr_position[1] = curr_position[1] - 1\n+    position = curr_position\n+  end\n+  local match_position_predicate = function(diag)\n+    return position[1] == diag.lnum and\n+    position[2] >= diag.col and\n+    (position[2] <= diag.end_col or position[1] < diag.end_lnum)\n+  end\n+  local position_diagnostics = vim.tbl_filter(match_position_predicate, M.get(opts.namespace, bufnr))\n+  if opts.severity then\n+    position_diagnostics = filter_to_severity_limit(opts.severity, position_diagnostics)\n+  elseif opts.severity_limit then\n+    position_diagnostics = filter_by_severity_limit(opts.severity_limit, position_diagnostics)\n+  end\n+  table.sort(position_diagnostics, function(a, b) return a.severity < b.severity end)\n+  return show_diagnostics(opts, position_diagnostics)\n+end\n+\n+--- Open a floating window with the diagnostics from the given line.\n+\n+---@param opts table Configuration table. See |vim.diagnostic.show_position_diagnostics()|.\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param lnum number|nil The line number. Defaults to line number of cursor.\n+---@return table {popup_bufnr, win_id}\n+function M.show_line_diagnostics(opts, bufnr, lnum)\n+  vim.validate {\n+    opts = { opts, 't', true },\n+    bufnr = { bufnr, 'n', true },\n+    lnum = { lnum, 'n', true },\n+  }\n+\n+  opts = opts or {}\n+  opts.focus_id = \"line_diagnostics\"\n+  lnum = lnum or (vim.api.nvim_win_get_cursor(0)[1] - 1)\n+  local line_diagnostics = M.get_line_diagnostics(bufnr, lnum, opts)\n+  return show_diagnostics(opts, line_diagnostics)\n+end\n+\n+--- Clear diagnotics and diagnostic cache.\n+---\n+---@param namespace number\n+---@param bufnr number|nil Reset diagnostics for the given buffer. If omitted,\n+---             diagnostics are reset for all buffers.\n+function M.reset(namespace, bufnr)\n+  if bufnr == nil then\n+    for iter_bufnr, namespaces in pairs(diagnostic_cache) do\n+      if namespaces[namespace] then\n+        M.reset(namespace, iter_bufnr)\n+      end\n+    end\n+  else\n+    clear_diagnostic_cache(namespace, bufnr)\n+    M.clear(namespace, bufnr)\n+  end\n+end\n+\n+--- Add diagnostics to the quickfix list.\n+---\n+--- By default, adds diagnostics from all buffers and namespaces.\n+---\n+---@param opts table|nil Configuration table with the following keys:\n+---         - namespace: (number) Only add diagnostics from the given namespace.\n+---         - bufnr: (number) Only add diagnostics from the given buffer\n+---         - open: (boolean, default true) Open quickfix list after set\n+---         - title: (string) Title of quickfix list. Defaults to \"Diagnostics\"\n+---         - severity: (|vim.diagnostic.severity|) Exclusive severity to consider. Overrides\n+---                     {severity_limit}\n+---         - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                           example, `vim.diagnostic.severity.WARN` means errors and warnings are\n+---                           valid.\n+function M.setqflist(opts)\n+  set_list(false, opts)\n+end\n+\n+--- Add diagnostics to the location list.\n+---\n+--- By default, adds diagnostics for the current buffer in all namespaces.\n+---\n+---@param opts table|nil Configuration table with the following keys:\n+---         - namespace: (number) Only add diagnostics from the given namespace.\n+---         - bufnr: (number, default 0) Only add diagnostics from the given buffer\n+---         - open: (boolean, default true) Open the location list list after set\n+---         - title: (string) Title of the location list. Defaults to \"Diagnostics\"\n+---         - severity: (|vim.diagnostic.severity|) Exclusive severity to\n+---                   consider. Overrides {severity_limit}\n+---         - severity_limit: (|vim.diagnostic.severity|) Limit severity of\n+---                         diagnostics found. For example,\n+---                         `vim.diagnostic.severity.WARN` means errors and\n+---                         warnings are valid.\n+function M.setloclist(opts)\n+  opts = opts or {}\n+  opts.bufnr = opts.bufnr or 0\n+  set_list(true, opts)\n+end\n+\n+--- Disable diagnostics for the given namespace and buffer.\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number|nil Buffer handle. If omitted, disable diagnostics for all buffers in the\n+---             given namespace\n+function M.disable(namespace, bufnr)\n+  if bufnr == nil then\n+    for k, v in pairs(diagnostic_cache) do\n+      if v[namespace] then\n+        M.disable(namespace, k)\n+      end\n+    end\n+  else\n+    diagnostic_disabled[bufnr][namespace] = true\n+    M.clear(namespace, bufnr)\n+  end\n+end\n+\n+--- Enable diagnostics for the given namespace and buffer.\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number|nil Buffer handle. If omitted, eanble diagnostics for all buffers in the\n+---             given namespace\n+function M.enable(namespace, bufnr)\n+  if bufnr == nil then\n+    for k, v in pairs(diagnostic_disabled) do\n+      if v ~= nil then\n+        M.enable(namespace, k)\n+      end\n+    end\n+  else\n+    if not diagnostic_disabled[bufnr][namespace] then\n+      return\n+    end\n+\n+    diagnostic_disabled[bufnr][namespace] = nil\n+\n+    M.redraw(namespace, bufnr)\n+  end\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706608815",
            "id": 706608815,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjYwODgxNQ==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 1173,
            "original_position": 1372,
            "original_start_line": 1335,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 751915267,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706608815/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-11T13:00:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706608815",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706609075"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706609075"
                }
            },
            "author_association": "MEMBER",
            "body": "I wonder if we should expose this and remove the `setloclist` / `setqflist` functions instead and point users to using `vim.fn.setloclist` directly.\r\n",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T12:46:03Z",
            "diff_hunk": "@@ -0,0 +1,1377 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_to_severity_limit(severity, diagnostics)\n+  local filter_level = to_severity(severity)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity == filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function filter_by_severity_limit(severity_limit, diagnostics)\n+  local filter_level = to_severity(severity_limit)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity <= filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function valid_severity()\n+  return function(severity)\n+    if type(severity) == 'string' then\n+      return to_severity(severity) ~= nil\n+    elseif type(severity) == 'number' then\n+      return M.severity[severity] ~= nil\n+    end\n+  end, \"Invalid value for 'severity' parameter\"\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local default_highlight_map = make_highlight_map(\"Default\")\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_lines = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_counts = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function diagnostic_counts(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local counts = {}\n+  for _, diagnostic in pairs(diagnostics) do\n+    if diagnostic.severity then\n+      local val = counts[diagnostic.severity]\n+      if val == nil then\n+        val = 0\n+      end\n+\n+      counts[diagnostic.severity] = val + 1\n+    end\n+  end\n+\n+  return counts\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+  diagnostic_cache_lines[bufnr][namespace] = diagnostic_lines(diagnostics)\n+  diagnostic_cache_counts[bufnr][namespace] = diagnostic_counts(diagnostics)\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+  diagnostic_cache_lines[bufnr][namespace] = nil\n+  diagnostic_cache_counts[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+\n+--- Display diagnostics for the buffer with the given options.\n+---@private\n+local function display(namespace, diagnostics, bufnr, opts)\n+  if diagnostic_disabled[bufnr][namespace] then\n+    return\n+  end\n+\n+  M.clear(namespace, bufnr)\n+\n+  diagnostics = diagnostics or M.get(namespace, bufnr)\n+\n+  if not diagnostics or vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+\n+  opts = get_resolved_options(opts, namespace, bufnr)\n+\n+  if opts.update_in_insert then\n+    clear_scheduled_display(namespace, bufnr)\n+  else\n+    local mode = vim.api.nvim_get_mode()\n+    if string.sub(mode.mode, 1, 1) == 'i' then\n+      schedule_display(namespace, bufnr, opts)\n+      return\n+    end\n+  end\n+\n+  if opts.underline then\n+    M.set_underline(namespace, diagnostics, bufnr, opts.underline)\n+  end\n+\n+  if opts.virtual_text then\n+    M.set_virtual_text(namespace, diagnostics, bufnr, opts.virtual_text)\n+  end\n+\n+  if opts.signs then\n+    M.set_signs(namespace, diagnostics, bufnr, opts.signs)\n+  end\n+\n+  save_extmarks(namespace, bufnr)\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---\n+--- The floating window can be customized with the following highlight groups:\n+--- <pre>\n+--- DiagnosticsFloatingError\n+--- DiagnosticsFloatingWarning\n+--- DiagnosticsFloatingInformation\n+--- DiagnosticsFloatingHint\n+--- </pre>\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706609075",
            "id": 706609075,
            "line": 384,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjYwOTA3NQ==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 384,
            "original_position": 448,
            "original_start_line": null,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": 384,
            "pull_request_review_id": 751915267,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706609075/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-11T13:00:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706609075",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706609179"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706609179"
                }
            },
            "author_association": "MEMBER",
            "body": "*If* we choose to decouple redraw from set, we should probably remove this option here.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T12:47:18Z",
            "diff_hunk": "@@ -0,0 +1,1377 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_to_severity_limit(severity, diagnostics)\n+  local filter_level = to_severity(severity)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity == filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function filter_by_severity_limit(severity_limit, diagnostics)\n+  local filter_level = to_severity(severity_limit)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity <= filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function valid_severity()\n+  return function(severity)\n+    if type(severity) == 'string' then\n+      return to_severity(severity) ~= nil\n+    elseif type(severity) == 'number' then\n+      return M.severity[severity] ~= nil\n+    end\n+  end, \"Invalid value for 'severity' parameter\"\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local default_highlight_map = make_highlight_map(\"Default\")\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_lines = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_counts = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function diagnostic_counts(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local counts = {}\n+  for _, diagnostic in pairs(diagnostics) do\n+    if diagnostic.severity then\n+      local val = counts[diagnostic.severity]\n+      if val == nil then\n+        val = 0\n+      end\n+\n+      counts[diagnostic.severity] = val + 1\n+    end\n+  end\n+\n+  return counts\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+  diagnostic_cache_lines[bufnr][namespace] = diagnostic_lines(diagnostics)\n+  diagnostic_cache_counts[bufnr][namespace] = diagnostic_counts(diagnostics)\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+  diagnostic_cache_lines[bufnr][namespace] = nil\n+  diagnostic_cache_counts[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+\n+--- Display diagnostics for the buffer with the given options.\n+---@private\n+local function display(namespace, diagnostics, bufnr, opts)\n+  if diagnostic_disabled[bufnr][namespace] then\n+    return\n+  end\n+\n+  M.clear(namespace, bufnr)\n+\n+  diagnostics = diagnostics or M.get(namespace, bufnr)\n+\n+  if not diagnostics or vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+\n+  opts = get_resolved_options(opts, namespace, bufnr)\n+\n+  if opts.update_in_insert then\n+    clear_scheduled_display(namespace, bufnr)\n+  else\n+    local mode = vim.api.nvim_get_mode()\n+    if string.sub(mode.mode, 1, 1) == 'i' then\n+      schedule_display(namespace, bufnr, opts)\n+      return\n+    end\n+  end\n+\n+  if opts.underline then\n+    M.set_underline(namespace, diagnostics, bufnr, opts.underline)\n+  end\n+\n+  if opts.virtual_text then\n+    M.set_virtual_text(namespace, diagnostics, bufnr, opts.virtual_text)\n+  end\n+\n+  if opts.signs then\n+    M.set_signs(namespace, diagnostics, bufnr, opts.signs)\n+  end\n+\n+  save_extmarks(namespace, bufnr)\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---\n+--- The floating window can be customized with the following highlight groups:\n+--- <pre>\n+--- DiagnosticsFloatingError\n+--- DiagnosticsFloatingWarning\n+--- DiagnosticsFloatingInformation\n+--- DiagnosticsFloatingHint\n+--- </pre>\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local diagnostics = M.get(opts.namespace, opts.bufnr)\n+  local items = vim.tbl_filter(function(d)\n+    local severity = to_severity(opts.severity)\n+    if severity then\n+      return d.severity == severity\n+    end\n+    local severity_limit = to_severity(opts.severity_limit)\n+    if severity_limit then\n+      return d.severity <= severity_limit\n+    end\n+    return true\n+  end, diagnostics_to_list_items(diagnostics))\n+  if loclist then\n+    vim.fn.setloclist(0, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+--- Create links to Lsp* groups for backward compatibility (this should\n+--- eventually be removed)\n+---@private\n+local function make_compat_highlight_link(name)\n+  local from = name:gsub(\"^Diagnostic\", \"LspDiagnostics\"):gsub(\"Info\", \"Information\"):gsub(\"Warn\", \"Warning\")\n+  vim.highlight.link(from, name, false)\n+end\n+\n+---@private\n+local function define_default_signs_and_highlights()\n+  ---@private\n+  local function define_default_sign(name, properties)\n+    if vim.tbl_isempty(vim.fn.sign_getdefined(name)) then\n+      vim.fn.sign_define(name, properties)\n+    end\n+  end\n+\n+  -- Initialize default diagnostic highlights\n+  for severity, hi_info in pairs(diagnostic_severities) do\n+    local default_highlight_name = default_highlight_map[severity]\n+    vim.highlight.create(default_highlight_name, hi_info, true)\n+\n+    -- Default link all corresponding highlights to the default highlight\n+    vim.highlight.link(virtual_text_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(floating_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(sign_highlight_map[severity], default_highlight_name, false)\n+\n+    make_compat_highlight_link(default_highlight_name)\n+    make_compat_highlight_link(virtual_text_highlight_map[severity])\n+    make_compat_highlight_link(floating_highlight_map[severity])\n+    make_compat_highlight_link(sign_highlight_map[severity])\n+  end\n+\n+  -- Create all signs\n+  for severity, sign_hl_name in pairs(sign_highlight_map) do\n+    local severity_name = M.severity[severity]\n+\n+    define_default_sign(sign_hl_name, {\n+      text = (severity_name or 'U'):sub(1, 1),\n+      texthl = sign_hl_name,\n+      linehl = '',\n+      numhl = '',\n+    })\n+  end\n+\n+  -- Initialize Underline highlights\n+  for severity, underline_highlight_name in pairs(underline_highlight_map) do\n+    vim.highlight.create(underline_highlight_name, {\n+      cterm = 'underline',\n+      gui   = 'underline',\n+      guisp = diagnostic_severities[severity].guifg\n+    }, true)\n+    make_compat_highlight_link(underline_highlight_name)\n+  end\n+end\n+\n+define_default_signs_and_highlights()\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics |vim.diagnostic.set_underline()|\n+---       - virtual_text: (default true) Use virtual text for diagnostics |vim.diagnostic.set_virtual_text()|\n+---       - signs: (default true) Use signs for diagnostics |vim.diagnostic.set_signs()|\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706609179",
            "id": 706609179,
            "line": 441,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjYwOTE3OQ==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 441,
            "original_position": 573,
            "original_start_line": 572,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": 441,
            "pull_request_review_id": 751915267,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706609179/reactions"
            },
            "side": "RIGHT",
            "start_line": 440,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-11T13:00:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706609179",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706609565"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706609565"
                }
            },
            "author_association": "MEMBER",
            "body": "`Position` in LSP uses UTF16 offsets (or UTF8, `vim.lsp.client` contains an `offset_encoding` property that indices which one is the case)\r\n\r\nWe'd have to convert this here (which is potentially expensive, as we'd have to read the filesystem and diagnostics may be updated quite often).\r\n\r\nAn alternative would be to store the `col` format as part of the diagnostics and make the conversion to byte column lazy?",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T12:50:51Z",
            "diff_hunk": "@@ -57,338 +13,241 @@ end\n \n local M = {}\n \n--- Diagnostic Highlights {{{\n-\n--- TODO(tjdevries): Determine how to generate documentation for these\n---                  and how to configure them to be easy for users.\n---\n---                  For now, just use the following script. It should work pretty good.\n---[[\n-local levels = {\"Error\", \"Warning\", \"Information\", \"Hint\" }\n-\n-local all_info = {\n-  { \"Default\", \"Used as the base highlight group, other highlight groups link to\", },\n-  { \"VirtualText\", 'Used for \"%s\" diagnostic virtual text.\\n  See |vim.lsp.diagnostic.set_virtual_text()|', },\n-  { \"Underline\", 'Used to underline \"%s\" diagnostics.\\n  See |vim.lsp.diagnostic.set_underline()|', },\n-  { \"Floating\", 'Used to color \"%s\" diagnostic messages in diagnostics float.\\n  See |vim.lsp.diagnostic.show_line_diagnostics()|', },\n-  { \"Sign\", 'Used for \"%s\" signs in sing column.\\n  See |vim.lsp.diagnostic.set_signs()|', },\n-}\n-\n-local results = {}\n-for _, info in ipairs(all_info) do\n-  for _, level in ipairs(levels) do\n-    local name = info[1]\n-    local description = info[2]\n-    local fullname = string.format(\"Lsp%s%s\", name, level)\n-    table.insert(results, string.format(\n-      \"%78s\", string.format(\"*hl-%s*\", fullname))\n-    )\n-\n-    table.insert(results, fullname)\n-    table.insert(results, string.format(\"  %s\", description))\n-    table.insert(results, \"\")\n-  end\n-end\n-\n--- print(table.concat(results, '\\n'))\n-vim.fn.setreg(\"*\", table.concat(results, '\\n'))\n---]]\n-\n-local diagnostic_severities = {\n-  [DiagnosticSeverity.Error]       = { guifg = \"Red\" };\n-  [DiagnosticSeverity.Warning]     = { guifg = \"Orange\" };\n-  [DiagnosticSeverity.Information] = { guifg = \"LightBlue\" };\n-  [DiagnosticSeverity.Hint]        = { guifg = \"LightGrey\" };\n-}\n-\n--- Make a map from DiagnosticSeverity -> Highlight Name\n-local make_highlight_map = function(base_name)\n-  local result = {}\n-  for k, _ in pairs(diagnostic_severities) do\n-    result[k] = \"LspDiagnostics\" .. base_name .. DiagnosticSeverity[k]\n-  end\n-\n-  return result\n-end\n-\n-local default_highlight_map = make_highlight_map(\"Default\")\n-local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n-local underline_highlight_map = make_highlight_map(\"Underline\")\n-local floating_highlight_map = make_highlight_map(\"Floating\")\n-local sign_highlight_map = make_highlight_map(\"Sign\")\n-\n--- }}}\n--- Diagnostic Namespaces {{{\n local DEFAULT_CLIENT_ID = -1\n-local get_client_id = function(client_id)\n+---@private\n+local function get_client_id(client_id)\n   if client_id == nil then\n     client_id = DEFAULT_CLIENT_ID\n   end\n \n   return client_id\n end\n \n-local get_bufnr = function(bufnr)\n+---@private\n+local function get_bufnr(bufnr)\n   if not bufnr then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   elseif bufnr == 0 then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   end\n \n   return bufnr\n end\n \n-\n---- Create a namespace table, used to track a client's buffer local items\n-local _make_namespace_table = function(namespace, api_namespace)\n-  vim.validate { namespace = { namespace, 's' } }\n-\n-  return setmetatable({\n-    [DEFAULT_CLIENT_ID] = api.nvim_create_namespace(namespace)\n-  }, {\n-    __index = function(t, client_id)\n-      client_id = get_client_id(client_id)\n-\n-      if rawget(t, client_id) == nil then\n-        local value = string.format(\"%s:%s\", namespace, client_id)\n-\n-        if api_namespace then\n-          value = api.nvim_create_namespace(value)\n-        end\n-\n-        rawset(t, client_id, value)\n-      end\n-\n-      return rawget(t, client_id)\n-    end\n-  })\n+---@private\n+local function severity_lsp_to_vim(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.lsp.protocol.DiagnosticSeverity[severity]\n+  end\n+  return severity\n end\n \n-local _diagnostic_namespaces = _make_namespace_table(\"vim_lsp_diagnostics\", true)\n-local _sign_namespaces = _make_namespace_table(\"vim_lsp_signs\", false)\n-\n ---@private\n-function M._get_diagnostic_namespace(client_id)\n-  return _diagnostic_namespaces[client_id]\n+local function severity_vim_to_lsp(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.diagnostic.severity[severity]\n+  end\n+  return severity\n end\n \n ---@private\n-function M._get_sign_namespace(client_id)\n-  return _sign_namespaces[client_id]\n+local function diagnostic_lsp_to_vim(diagnostics)\n+  return vim.tbl_map(function(diagnostic)\n+    local start = diagnostic.range.start\n+    local _end = diagnostic.range[\"end\"]\n+    return {\n+      lnum = start.line,\n+      col = start.character,\n+      end_lnum = _end.line,\n+      end_col = _end.character,",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706609565",
            "id": 706609565,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjYwOTU2NQ==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 62,
            "original_position": 196,
            "original_start_line": 59,
            "path": "runtime/lua/vim/lsp/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 751915267,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706609565/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-11T13:00:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706609565",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706609675"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706609675"
                }
            },
            "author_association": "MEMBER",
            "body": "See comment further above about UTF16/8 offsets",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T12:51:46Z",
            "diff_hunk": "@@ -57,338 +13,241 @@ end\n \n local M = {}\n \n--- Diagnostic Highlights {{{\n-\n--- TODO(tjdevries): Determine how to generate documentation for these\n---                  and how to configure them to be easy for users.\n---\n---                  For now, just use the following script. It should work pretty good.\n---[[\n-local levels = {\"Error\", \"Warning\", \"Information\", \"Hint\" }\n-\n-local all_info = {\n-  { \"Default\", \"Used as the base highlight group, other highlight groups link to\", },\n-  { \"VirtualText\", 'Used for \"%s\" diagnostic virtual text.\\n  See |vim.lsp.diagnostic.set_virtual_text()|', },\n-  { \"Underline\", 'Used to underline \"%s\" diagnostics.\\n  See |vim.lsp.diagnostic.set_underline()|', },\n-  { \"Floating\", 'Used to color \"%s\" diagnostic messages in diagnostics float.\\n  See |vim.lsp.diagnostic.show_line_diagnostics()|', },\n-  { \"Sign\", 'Used for \"%s\" signs in sing column.\\n  See |vim.lsp.diagnostic.set_signs()|', },\n-}\n-\n-local results = {}\n-for _, info in ipairs(all_info) do\n-  for _, level in ipairs(levels) do\n-    local name = info[1]\n-    local description = info[2]\n-    local fullname = string.format(\"Lsp%s%s\", name, level)\n-    table.insert(results, string.format(\n-      \"%78s\", string.format(\"*hl-%s*\", fullname))\n-    )\n-\n-    table.insert(results, fullname)\n-    table.insert(results, string.format(\"  %s\", description))\n-    table.insert(results, \"\")\n-  end\n-end\n-\n--- print(table.concat(results, '\\n'))\n-vim.fn.setreg(\"*\", table.concat(results, '\\n'))\n---]]\n-\n-local diagnostic_severities = {\n-  [DiagnosticSeverity.Error]       = { guifg = \"Red\" };\n-  [DiagnosticSeverity.Warning]     = { guifg = \"Orange\" };\n-  [DiagnosticSeverity.Information] = { guifg = \"LightBlue\" };\n-  [DiagnosticSeverity.Hint]        = { guifg = \"LightGrey\" };\n-}\n-\n--- Make a map from DiagnosticSeverity -> Highlight Name\n-local make_highlight_map = function(base_name)\n-  local result = {}\n-  for k, _ in pairs(diagnostic_severities) do\n-    result[k] = \"LspDiagnostics\" .. base_name .. DiagnosticSeverity[k]\n-  end\n-\n-  return result\n-end\n-\n-local default_highlight_map = make_highlight_map(\"Default\")\n-local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n-local underline_highlight_map = make_highlight_map(\"Underline\")\n-local floating_highlight_map = make_highlight_map(\"Floating\")\n-local sign_highlight_map = make_highlight_map(\"Sign\")\n-\n--- }}}\n--- Diagnostic Namespaces {{{\n local DEFAULT_CLIENT_ID = -1\n-local get_client_id = function(client_id)\n+---@private\n+local function get_client_id(client_id)\n   if client_id == nil then\n     client_id = DEFAULT_CLIENT_ID\n   end\n \n   return client_id\n end\n \n-local get_bufnr = function(bufnr)\n+---@private\n+local function get_bufnr(bufnr)\n   if not bufnr then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   elseif bufnr == 0 then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   end\n \n   return bufnr\n end\n \n-\n---- Create a namespace table, used to track a client's buffer local items\n-local _make_namespace_table = function(namespace, api_namespace)\n-  vim.validate { namespace = { namespace, 's' } }\n-\n-  return setmetatable({\n-    [DEFAULT_CLIENT_ID] = api.nvim_create_namespace(namespace)\n-  }, {\n-    __index = function(t, client_id)\n-      client_id = get_client_id(client_id)\n-\n-      if rawget(t, client_id) == nil then\n-        local value = string.format(\"%s:%s\", namespace, client_id)\n-\n-        if api_namespace then\n-          value = api.nvim_create_namespace(value)\n-        end\n-\n-        rawset(t, client_id, value)\n-      end\n-\n-      return rawget(t, client_id)\n-    end\n-  })\n+---@private\n+local function severity_lsp_to_vim(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.lsp.protocol.DiagnosticSeverity[severity]\n+  end\n+  return severity\n end\n \n-local _diagnostic_namespaces = _make_namespace_table(\"vim_lsp_diagnostics\", true)\n-local _sign_namespaces = _make_namespace_table(\"vim_lsp_signs\", false)\n-\n ---@private\n-function M._get_diagnostic_namespace(client_id)\n-  return _diagnostic_namespaces[client_id]\n+local function severity_vim_to_lsp(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.diagnostic.severity[severity]\n+  end\n+  return severity\n end\n \n ---@private\n-function M._get_sign_namespace(client_id)\n-  return _sign_namespaces[client_id]\n+local function diagnostic_lsp_to_vim(diagnostics)\n+  return vim.tbl_map(function(diagnostic)\n+    local start = diagnostic.range.start\n+    local _end = diagnostic.range[\"end\"]\n+    return {\n+      lnum = start.line,\n+      col = start.character,\n+      end_lnum = _end.line,\n+      end_col = _end.character,\n+      severity = severity_lsp_to_vim(diagnostic.severity),\n+      message = diagnostic.message\n+    }\n+  end, diagnostics)\n end\n--- }}}\n--- Diagnostic Buffer & Client metatables {{{\n-local bufnr_and_client_cacher_mt = {\n-  __index = function(t, bufnr)\n-    if bufnr == 0 or bufnr == nil then\n-      bufnr = vim.api.nvim_get_current_buf()\n-    end\n-\n-    if rawget(t, bufnr) == nil then\n-      rawset(t, bufnr, {})\n-    end\n-\n-    return rawget(t, bufnr)\n-  end,\n-\n-  __newindex = function(t, bufnr, v)\n-    if bufnr == 0 or bufnr == nil then\n-      bufnr = vim.api.nvim_get_current_buf()\n-    end\n-\n-    rawset(t, bufnr, v)\n-  end,\n-}\n--- }}}\n--- Diagnostic Saving & Caching {{{\n-local _diagnostic_cleanup = setmetatable({}, bufnr_and_client_cacher_mt)\n-local diagnostic_cache = setmetatable({}, bufnr_and_client_cacher_mt)\n-local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_client_cacher_mt)\n-local diagnostic_cache_lines = setmetatable({}, bufnr_and_client_cacher_mt)\n-local diagnostic_cache_counts = setmetatable({}, bufnr_and_client_cacher_mt)\n-local diagnostic_attached_buffers = {}\n \n--- Disabled buffers and clients\n-local diagnostic_disabled = setmetatable({}, bufnr_and_client_cacher_mt)\n+---@private\n+local function diagnostic_vim_to_lsp(diagnostics)\n+  return vim.tbl_map(function(diagnostic)\n+    return {\n+      range = {\n+        start = {\n+          line = diagnostic.lnum,\n+          character = diagnostic.col,\n+        },\n+        [\"end\"] = {\n+          line = diagnostic.end_lnum,\n+          character = diagnostic.end_col,\n+        },\n+      },",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706609675",
            "id": 706609675,
            "line": 113,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjYwOTY3NQ==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 113,
            "original_position": 249,
            "original_start_line": 73,
            "path": "runtime/lua/vim/lsp/diagnostic.lua",
            "position": 356,
            "pull_request_review_id": 751915267,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706609675/reactions"
            },
            "side": "RIGHT",
            "start_line": 104,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-11T13:00:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706609675",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706626606"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706626606"
                }
            },
            "author_association": "MEMBER",
            "body": "`clear()` simply removes decorations while `reset()` also actually removes diagnostics. So `reset()` could be replaced with `set(ns, {})`. I'm not sure how useful it is to expose `clear()` publicly, since in practice it's basically the same as `disable()`.\r\n",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T15:32:49Z",
            "diff_hunk": "@@ -0,0 +1,1377 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_to_severity_limit(severity, diagnostics)\n+  local filter_level = to_severity(severity)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity == filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function filter_by_severity_limit(severity_limit, diagnostics)\n+  local filter_level = to_severity(severity_limit)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity <= filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function valid_severity()\n+  return function(severity)\n+    if type(severity) == 'string' then\n+      return to_severity(severity) ~= nil\n+    elseif type(severity) == 'number' then\n+      return M.severity[severity] ~= nil\n+    end\n+  end, \"Invalid value for 'severity' parameter\"\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local default_highlight_map = make_highlight_map(\"Default\")\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_lines = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_counts = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function diagnostic_counts(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local counts = {}\n+  for _, diagnostic in pairs(diagnostics) do\n+    if diagnostic.severity then\n+      local val = counts[diagnostic.severity]\n+      if val == nil then\n+        val = 0\n+      end\n+\n+      counts[diagnostic.severity] = val + 1\n+    end\n+  end\n+\n+  return counts\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+  diagnostic_cache_lines[bufnr][namespace] = diagnostic_lines(diagnostics)\n+  diagnostic_cache_counts[bufnr][namespace] = diagnostic_counts(diagnostics)\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+  diagnostic_cache_lines[bufnr][namespace] = nil\n+  diagnostic_cache_counts[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+\n+--- Display diagnostics for the buffer with the given options.\n+---@private\n+local function display(namespace, diagnostics, bufnr, opts)\n+  if diagnostic_disabled[bufnr][namespace] then\n+    return\n+  end\n+\n+  M.clear(namespace, bufnr)\n+\n+  diagnostics = diagnostics or M.get(namespace, bufnr)\n+\n+  if not diagnostics or vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+\n+  opts = get_resolved_options(opts, namespace, bufnr)\n+\n+  if opts.update_in_insert then\n+    clear_scheduled_display(namespace, bufnr)\n+  else\n+    local mode = vim.api.nvim_get_mode()\n+    if string.sub(mode.mode, 1, 1) == 'i' then\n+      schedule_display(namespace, bufnr, opts)\n+      return\n+    end\n+  end\n+\n+  if opts.underline then\n+    M.set_underline(namespace, diagnostics, bufnr, opts.underline)\n+  end\n+\n+  if opts.virtual_text then\n+    M.set_virtual_text(namespace, diagnostics, bufnr, opts.virtual_text)\n+  end\n+\n+  if opts.signs then\n+    M.set_signs(namespace, diagnostics, bufnr, opts.signs)\n+  end\n+\n+  save_extmarks(namespace, bufnr)\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---\n+--- The floating window can be customized with the following highlight groups:\n+--- <pre>\n+--- DiagnosticsFloatingError\n+--- DiagnosticsFloatingWarning\n+--- DiagnosticsFloatingInformation\n+--- DiagnosticsFloatingHint\n+--- </pre>\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local diagnostics = M.get(opts.namespace, opts.bufnr)\n+  local items = vim.tbl_filter(function(d)\n+    local severity = to_severity(opts.severity)\n+    if severity then\n+      return d.severity == severity\n+    end\n+    local severity_limit = to_severity(opts.severity_limit)\n+    if severity_limit then\n+      return d.severity <= severity_limit\n+    end\n+    return true\n+  end, diagnostics_to_list_items(diagnostics))\n+  if loclist then\n+    vim.fn.setloclist(0, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+--- Create links to Lsp* groups for backward compatibility (this should\n+--- eventually be removed)\n+---@private\n+local function make_compat_highlight_link(name)\n+  local from = name:gsub(\"^Diagnostic\", \"LspDiagnostics\"):gsub(\"Info\", \"Information\"):gsub(\"Warn\", \"Warning\")\n+  vim.highlight.link(from, name, false)\n+end\n+\n+---@private\n+local function define_default_signs_and_highlights()\n+  ---@private\n+  local function define_default_sign(name, properties)\n+    if vim.tbl_isempty(vim.fn.sign_getdefined(name)) then\n+      vim.fn.sign_define(name, properties)\n+    end\n+  end\n+\n+  -- Initialize default diagnostic highlights\n+  for severity, hi_info in pairs(diagnostic_severities) do\n+    local default_highlight_name = default_highlight_map[severity]\n+    vim.highlight.create(default_highlight_name, hi_info, true)\n+\n+    -- Default link all corresponding highlights to the default highlight\n+    vim.highlight.link(virtual_text_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(floating_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(sign_highlight_map[severity], default_highlight_name, false)\n+\n+    make_compat_highlight_link(default_highlight_name)\n+    make_compat_highlight_link(virtual_text_highlight_map[severity])\n+    make_compat_highlight_link(floating_highlight_map[severity])\n+    make_compat_highlight_link(sign_highlight_map[severity])\n+  end\n+\n+  -- Create all signs\n+  for severity, sign_hl_name in pairs(sign_highlight_map) do\n+    local severity_name = M.severity[severity]\n+\n+    define_default_sign(sign_hl_name, {\n+      text = (severity_name or 'U'):sub(1, 1),\n+      texthl = sign_hl_name,\n+      linehl = '',\n+      numhl = '',\n+    })\n+  end\n+\n+  -- Initialize Underline highlights\n+  for severity, underline_highlight_name in pairs(underline_highlight_map) do\n+    vim.highlight.create(underline_highlight_name, {\n+      cterm = 'underline',\n+      gui   = 'underline',\n+      guisp = diagnostic_severities[severity].guifg\n+    }, true)\n+    make_compat_highlight_link(underline_highlight_name)\n+  end\n+end\n+\n+define_default_signs_and_highlights()\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics |vim.diagnostic.set_underline()|\n+---       - virtual_text: (default true) Use virtual text for diagnostics |vim.diagnostic.set_virtual_text()|\n+---       - signs: (default true) Use signs for diagnostics |vim.diagnostic.set_signs()|\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    M.redraw(namespace)\n+  else\n+    for k in pairs(all_namespaces) do\n+      M.redraw(k)\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param bufnr number|nil The buffer to set diagnostics for. Defaults to the current buffer.\n+function M.set(namespace, diagnostics, bufnr)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    bufnr = {bufnr, 'n', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  bufnr = get_bufnr(bufnr)\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    display(namespace, diagnostics, bufnr)\n+  end\n+end\n+\n+--- Get all diagnostics for the given namespace or buffer.\n+---\n+--- With no arguments, return a list of all diagnostics.\n+---\n+--- If {namespace} is `nil`, retrieve all diagnostics associated with buffer\n+--- {bufnr}. If {bufnr} is `nil`, retrieve all diagnostics associated with\n+--- namespace {namespace}. Otherwise, retrieve diagnostics from namespace\n+--- {namespace} associated with buffer {bufnr}.\n+---\n+---@param namespace number|nil The namespace to get diagnostics from. If\n+---                            omitted, get diagnostics from all namespaces.\n+---                            be `nil` only when {bufnr} is not `nil`.\n+---@param bufnr number|nil The buffer number to get diagnistics from. If\n+---                        omitted, get diagnostics from all buffers.\n+---@return table A list of diagnostic items |diagnostic-structure|.\n+function M.get(namespace, bufnr)\n+  vim.validate {\n+    namespace = { namespace, 'n', true },\n+    bufnr = { bufnr, 'n', true },\n+  }\n+\n+  local diagnostics = {}\n+  if namespace == nil and bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, v in pairs(t) do\n+        for _, diagnostic in ipairs(v) do\n+          table.insert(diagnostics, diagnostic)\n+        end\n+      end\n+    end\n+  elseif namespace == nil then\n+    for iter_namespace in pairs(diagnostic_cache[bufnr]) do\n+      for _, diagnostic in ipairs(diagnostic_cache[bufnr][iter_namespace]) do\n+        table.insert(diagnostics, diagnostic)\n+      end\n+    end\n+  elseif bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, diagnostic in ipairs(t[namespace] or {}) do\n+        table.insert(diagnostics, diagnostic)\n+      end\n+    end\n+  else\n+    for _, diagnostic in ipairs(diagnostic_cache[bufnr][namespace] or {}) do\n+      table.insert(diagnostics, diagnostic)\n+    end\n+  end\n+  return diagnostics\n+end\n+\n+--- Get diagnostics by line.\n+---\n+---@param namespace number|nil Limit diagnostics to the given namespace. If `nil`, retrieve\n+---                            diagnostics from all namespaces.\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param lnum number|nil The line number. Defaults to the current line.\n+---@param opts table|nil A table with the following keys:\n+---                        - namespace: (number) Limit diagnostics to the given namespace.\n+---                        - severity: (|vim.diagnostic.severity|) Only return diagnostics with this\n+---                                    severity. Overrides severity_limit. |vim.diagnostic.severity|\n+---                        - severity_limit: (|vim.diagnostic.severity|) Limit severity of\n+---                                          diagnostics found. For example,\n+---                                          vim.diagnostic.severity.WARN means both errors and\n+---                                          warnings will be valid.\n+---@return table Table with map of line number to list of diagnostics.\n+--               Structured: { [1] = {...}, [5] = {.... } }\n+function M.get_line_diagnostics(bufnr, lnum, opts)\n+  vim.validate {\n+    bufnr = { bufnr, 'n', true },\n+    lnum = { lnum, 'n', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  opts = opts or {}\n+\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  lnum = lnum or vim.api.nvim_win_get_cursor(0)[1] - 1\n+\n+  local ns_get_diags = function(iter_namespace)\n+    return (diagnostic_cache_lines[bufnr][iter_namespace] or {})[lnum] or {}\n+  end\n+\n+  local line_diagnostics\n+  if opts.namespace == nil then\n+    line_diagnostics = {}\n+    for iter_namespace, _ in pairs(diagnostic_cache_lines[bufnr]) do\n+      for _, diagnostic in ipairs(ns_get_diags(iter_namespace)) do\n+        table.insert(line_diagnostics, diagnostic)\n+      end\n+    end\n+  else\n+    line_diagnostics = vim.deepcopy(ns_get_diags(opts.namespace))\n+  end\n+\n+  if opts.severity then\n+    line_diagnostics = filter_to_severity_limit(opts.severity, line_diagnostics)\n+  elseif opts.severity_limit then\n+    line_diagnostics = filter_by_severity_limit(opts.severity_limit, line_diagnostics)\n+  end\n+\n+  table.sort(line_diagnostics, function(a, b) return a.severity < b.severity end)\n+\n+  return line_diagnostics\n+end\n+\n+--- Get the number of diagnostics with the given severity.\n+---\n+--- Useful for showing diagnostic counts in statusline. eg:\n+--- <pre>\n+--- function! DiagnosticStatus() abort\n+---   let sl = ''\n+---   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)\")} '\n+---   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)\")}'\n+---   return sl\n+--- endfunction\n+--- </pre>\n+---\n+--- Then simply add `%{DiagnosticStatus()}` to your statusline.\n+---\n+---@param namespace number|nil Limit diagnostics to the given namespace. If `nil`, retrieve\n+---                            diagnostics from all namespaces.\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param severity|nil Return diagnostics for the given severity |vim.diagnostic.severity|. If\n+---                    omitted, all diagnositcs are returned.\n+function M.get_count(namespace, bufnr, severity)\n+  vim.validate {\n+    namespace = { namespace, 'n', true },\n+    bufnr = { bufnr, 'n', true },\n+    severity = { severity, valid_severity() },\n+  }\n+\n+  if namespace == nil then\n+    local total = 0\n+    for ns in pairs(diagnostic_cache_counts[bufnr]) do\n+      total = total + M.get_count(ns, bufnr, severity)\n+    end\n+    return total\n+  end\n+\n+  return (diagnostic_cache_counts[bufnr][namespace] or {})[to_severity(severity)] or 0\n+end\n+\n+-- Diagnostic Movements {{{\n+\n+local next_diagnostic = function(position, search_forward, bufnr, opts, namespace)\n+  position[1] = position[1] - 1\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  local wrap = vim.F.if_nil(opts.wrap, true)\n+  local line_count = vim.api.nvim_buf_line_count(bufnr)\n+  opts.namespace = namespace\n+  for i = 0, line_count do\n+    local offset = i * (search_forward and 1 or -1)\n+    local lnum = position[1] + offset\n+    if lnum < 0 or lnum >= line_count then\n+      if not wrap then\n+        return\n+      end\n+      lnum = (lnum + line_count) % line_count\n+    end\n+    local line_diagnostics = M.get_line_diagnostics(bufnr, lnum, opts)\n+    if line_diagnostics and not vim.tbl_isempty(line_diagnostics) then\n+      local sort_diagnostics, is_next\n+      if search_forward then\n+        sort_diagnostics = function(a, b) return a.col < b.col end\n+        is_next = function(diagnostic) return diagnostic.col > position[2] end\n+      else\n+        sort_diagnostics = function(a, b) return a.col > b.col end\n+        is_next = function(diagnostic) return diagnostic.col < position[2] end\n+      end\n+      table.sort(line_diagnostics, sort_diagnostics)\n+      if i == 0 then\n+        for _, v in pairs(line_diagnostics) do\n+          if is_next(v) then\n+            return v\n+          end\n+        end\n+      else\n+        return line_diagnostics[1]\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function diagnostic_pos(opts, diagnostic)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+\n+  if not diagnostic then\n+    return false\n+  end\n+\n+  local lnum, col = diagnostic.lnum, diagnostic.col\n+  if col > 0 then\n+    if not vim.api.nvim_buf_is_loaded(bufnr) then\n+      vim.fn.bufload(bufnr)\n+    end\n+\n+    local line = vim.api.nvim_buf_get_lines(bufnr, lnum, lnum + 1, true)[1]\n+    if line then\n+      local ok, result = pcall(vim.str_byteindex, line, col)\n+\n+      if ok then\n+        col = result\n+      end\n+    end\n+  end\n+\n+  return {lnum, col}\n+end\n+\n+---@private\n+local function diagnostic_move_pos(name, opts, pos)\n+  opts = opts or {}\n+\n+  local enable_popup = vim.F.if_nil(opts.enable_popup, true)\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+\n+  if not pos then\n+    print(string.format(\"%s: No more valid diagnostics to move to.\", name))\n+    return\n+  end\n+\n+  vim.api.nvim_win_set_cursor(win_id, {pos[1] + 1, pos[2]})\n+\n+  if enable_popup then\n+    -- This is a bit weird... I'm surprised that we need to wait til the next tick to do this.\n+    vim.schedule(function()\n+      M.show_position_diagnostics(opts.popup_opts, vim.api.nvim_win_get_buf(win_id))\n+    end)\n+  end\n+end\n+\n+--- Get the previous diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic\n+function M.get_prev(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, false, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the previous diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic position as a (row, col) tuple.\n+function M.get_prev_pos(opts)\n+  return diagnostic_pos(\n+    opts,\n+    M.get_prev(opts)\n+  )\n+end\n+\n+--- Move to the previous diagnostic in the current buffer.\n+---@param opts table See |vim.diagnostic.goto_next()|\n+function M.goto_prev(opts)\n+  return diagnostic_move_pos(\n+    \"DiagnosticPrevious\",\n+    opts,\n+    M.get_prev_pos(opts)\n+  )\n+end\n+\n+--- Get the next diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic\n+function M.get_next(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, true, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the next diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic position as a (row, col) tuple.\n+function M.get_next_pos(opts)\n+  return diagnostic_pos(\n+    opts,\n+    M.get_next(opts)\n+  )\n+end\n+\n+--- Move to the next diagnostic.\n+---\n+---@param opts table|nil Configuration table with the following keys:\n+---         - namespace: (number) Only consider diagnostics from the given namespace.\n+---         - cursor_position: (cursor position) Cursor position as a (row, col) tuple. See\n+---                          |nvim_win_get_cursor()|. Defaults to the current cursor position.\n+---         - wrap: (boolean, default true) Whether to loop around file or not. Similar to 'wrapscan'.\n+---         - severity: (|vim.diagnostic.severity|) Exclusive severity to consider.\n+---                   Overrides {severity_limit}\n+---         - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                         example, vim.diagnostic.severity.WARN means both errors and warnings\n+---                         will be valid.\n+---         - enable_popup: (boolean, default true) Call |vim.diagnostic.show_line_diagnostics()|\n+---                       on jump.\n+---         - popup_opts: (table) Table to pass as {opts} parameter to\n+---                     |vim.diagnostic.show_line_diagnostics()|\n+---         - win_id: (number, default 0) Window ID\n+function M.goto_next(opts)\n+  return diagnostic_move_pos(\n+    \"DiagnosticNext\",\n+    opts,\n+    M.get_next_pos(opts)\n+  )\n+end\n+\n+-- Diagnostic Setters {{{\n+\n+--- Set signs for given diagnostics.\n+---\n+--- Sign characters can be customized with the following commands:\n+---\n+--- <pre>\n+--- sign define DiagnosticSignError text=E texthl=DiagnosticSignError linehl= numhl=\n+--- sign define DiagnosticSignWarning text=W texthl=DiagnosticSignWarning linehl= numhl=\n+--- sign define DiagnosticSignInformation text=I texthl=DiagnosticSignInformation linehl= numhl=\n+--- sign define DiagnosticSignHint text=H texthl=DiagnosticSignHint linehl= numhl=\n+--- </pre>\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics|nil table A list of diagnostic items |diagnostic-structure|. If omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param bufnr number The buffer number\n+---@param opts table Configuration table with the following keys:\n+---            - priority: Set the priority of the signs |sign-priority|.\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                           example, `vim.diagnostic.severity.WARN` means errors and warnings are\n+---                           valid.\n+function M.set_signs(namespace, diagnostics, bufnr, opts)\n+  opts = get_resolved_options({ signs = opts }, namespace, bufnr).signs\n+\n+  if not diagnostics then\n+    diagnostics = diagnostic_cache[bufnr][namespace]\n+  end\n+\n+  if not diagnostics then\n+    return\n+  end\n+\n+  bufnr = get_bufnr(bufnr)\n+  diagnostics = filter_by_severity_limit(opts.severity_limit, diagnostics)\n+\n+  local ns = get_namespace(namespace)\n+\n+  local ok = true\n+  for _, diagnostic in ipairs(diagnostics) do\n+    ok = ok and pcall(vim.fn.sign_place,\n+      0,\n+      ns.sign_group,\n+      sign_highlight_map[diagnostic.severity],\n+      bufnr,\n+      {\n+        priority = opts.priority,\n+        lnum = diagnostic.lnum + 1\n+      }\n+    )\n+  end\n+end\n+\n+--- Set underline for given diagnostics.\n+---\n+--- Underline highlights can be customized by changing the following |:highlight| groups.\n+---\n+--- <pre>\n+--- DiagnosticUnderlineError\n+--- DiagnosticUnderlineWarning\n+--- DiagnosticUnderlineInformation\n+--- DiagnosticUnderlineHint\n+--- </pre>\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics|nil table A list of diagnostic items |diagnostic-structure|. If omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param bufnr number The buffer number\n+---@param opts table Configuration table with the following keys:\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                           example, `vim.diagnostic.severity.WARN` means errors and warnings are\n+---                           valid.\n+function M.set_underline(namespace, diagnostics, bufnr, opts)\n+  opts = get_resolved_options({ underline = opts }, namespace, bufnr).underline\n+\n+  diagnostics = filter_by_severity_limit(opts.severity_limit, diagnostics)\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local higroup = underline_highlight_map[diagnostic.severity]\n+\n+    if higroup == nil then\n+      -- Default to error if we don't have a highlight associated\n+      higroup = underline_highlight_map.Error\n+    end\n+\n+    vim.highlight.range(\n+      bufnr,\n+      namespace,\n+      higroup,\n+      { diagnostic.lnum, diagnostic.col },\n+      { diagnostic.end_lnum, diagnostic.end_col }\n+    )\n+  end\n+end\n+\n+--- Set virtual text for given diagnostics.\n+---\n+--- Virtual text highlights can be customized by changing the following |:highlight| groups.\n+---\n+--- <pre>\n+--- DiagnosticVirtualTextError\n+--- DiagnosticVirtualTextWarning\n+--- DiagnosticVirtualTextInformation\n+--- DiagnosticVirtualTextHint\n+--- </pre>\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics|nil table A list of diagnostic items |diagnostic-structure|. If omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param bufnr number The buffer number\n+---@param opts table Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line\n+---            - spacing: (number) Number of spaces to insert before virtual text\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                           example, `vim.diagnostic.severity.WARN` means errors and warnings are\n+---                           valid.\n+function M.set_virtual_text(namespace, diagnostics, bufnr, opts)\n+  opts = get_resolved_options({ virtual_text = opts }, namespace, bufnr).virtual_text\n+\n+  local buffer_line_diagnostics\n+  if diagnostics then\n+    buffer_line_diagnostics = diagnostic_lines(diagnostics)\n+  else\n+    buffer_line_diagnostics = diagnostic_cache_lines[bufnr][namespace]\n+  end\n+\n+  if not buffer_line_diagnostics then\n+    return nil\n+  end\n+\n+  for line, line_diagnostics in pairs(buffer_line_diagnostics) do\n+    line_diagnostics = filter_by_severity_limit(opts.severity_limit, line_diagnostics)\n+    local virt_texts = M.get_virt_text_chunks(line_diagnostics, opts)\n+\n+    if virt_texts then\n+      vim.api.nvim_buf_set_extmark(bufnr, namespace, line, 0, {\n+        hl_mode = \"combine\",\n+        virt_text = virt_texts,\n+      })\n+    end\n+  end\n+end\n+\n+--- Get virtual text chunks to display using |nvim_buf_set_extmark()|.\n+---\n+---@param line_diags table The diagnostics associated with the line\n+---                  |vim.diagnostic.get_line_diagnostics()|\n+---@param opts table See {opts} from |vim.diagnostic.set_virtual_text()|\n+---@return an array of [text, hl_group] arrays. This can be passed directly to\n+---        the {virt_text} option of |nvim_buf_set_extmark()|.\n+function M.get_virt_text_chunks(line_diags, opts)\n+  if #line_diags == 0 then\n+    return nil\n+  end\n+\n+  opts = opts or {}\n+  local prefix = opts.prefix or \"■\"\n+  local spacing = opts.spacing or 4\n+\n+  -- Create a little more space between virtual text and contents\n+  local virt_texts = {{string.rep(\" \", spacing)}}\n+\n+  for i = 1, #line_diags - 1 do\n+    table.insert(virt_texts, {prefix, virtual_text_highlight_map[line_diags[i].severity]})\n+  end\n+  local last = line_diags[#line_diags]\n+\n+  -- TODO(tjdevries): Allow different servers to be shown first somehow?\n+  -- TODO(tjdevries): Display server name associated with these?\n+  if last.message then\n+    table.insert(\n+      virt_texts,\n+      {\n+        string.format(\"%s %s\", prefix, last.message:gsub(\"\\r\", \"\"):gsub(\"\\n\", \"  \")),\n+        virtual_text_highlight_map[last.severity]\n+      }\n+    )\n+\n+    return virt_texts\n+  end\n+end\n+\n+--- Clear the currently displayed diagnostics.\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number|nil Clear diagnostics in the given buffer. If omitted, diagnostics for\n+---             the given namespace are cleared in all buffers.\n+function M.clear(namespace, bufnr)\n+  vim.validate {\n+    namespace = { namespace, 'n' },\n+    bufnr = { bufnr, 'n', true },\n+  }\n+\n+  if bufnr == nil then\n+    for k, v in pairs(diagnostic_cache_extmarks) do\n+      if v[namespace] then\n+        M.clear(namespace, k)\n+      end\n+    end\n+  else\n+    bufnr = get_bufnr(bufnr)\n+    diagnostic_cache_extmarks[bufnr][namespace] = {}\n+\n+    local ns = get_namespace(namespace)\n+\n+    -- clear sign group\n+    vim.fn.sign_unplace(ns.sign_group, {buffer=bufnr})\n+\n+    -- clear virtual text namespace\n+    vim.api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+  end\n+end\n+\n+--- Callback scheduled when leaving Insert mode.\n+---\n+--- This function must be exported publicly so that it is available to be called from the Vimscript\n+--- autocommand.\n+---\n+--- See @ref schedule_display()\n+---\n+---@private\n+function M._execute_scheduled_display(namespace, bufnr)\n+  local args = bufs_waiting_to_update[bufnr][namespace]\n+  if not args then\n+    return\n+  end\n+\n+  -- Clear the args so we don't display unnecessarily.\n+  bufs_waiting_to_update[bufnr][namespace] = nil\n+\n+  display(namespace, nil, bufnr, args)\n+end\n+\n+--- Redraw diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number Redraw diagnostics for the given\n+---                 namespace\n+---@param bufnr number|nil Buffer handle. If omitted, redraw diagnostics for the given namespace in\n+---             all buffers.\n+function M.redraw(namespace, bufnr)\n+  if bufnr == nil then\n+    for k, v in pairs(diagnostic_cache) do\n+      if v[namespace] then\n+        M.redraw(namespace, k)\n+      end\n+    end\n+  else\n+    local diagnostics = M.get(namespace, bufnr)\n+    display(namespace, diagnostics, bufnr)\n+  end\n+end\n+\n+--- Open a floating window with the diagnostics at the given position.\n+---\n+---@param opts table|nil Configuration table with the same keys as\n+---            |vim.lsp.util.open_floatin_preview()| in addition to the following:\n+---            - namespace: (number) Limit diagnostics to the given namespace\n+---            - severity: (|vim.diagnostic.severity|) Only return diagnostics with this\n+---                        severity. Overrides severity_limit\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics\n+---                            found. For example, `vim.diagnostic.severity.WARN` means\n+---                            errors and warnings are valid.\n+---            - show_header: (boolean, default true) Show \"Diagnostics:\" header\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param position table|nil The (0,0)-indexed position. Defaults to the current cursor position.\n+---@return table {popup_bufnr, win_id}\n+function M.show_position_diagnostics(opts, bufnr, position)\n+  vim.validate {\n+    opts = { opts, 't', true },\n+    bufnr = { bufnr, 'n', true },\n+    position = { position, 't', true },\n+  }\n+\n+  opts = opts or {}\n+  opts.focus_id = \"position_diagnostics\"\n+  bufnr = get_bufnr(bufnr)\n+  if not position then\n+    local curr_position = vim.api.nvim_win_get_cursor(0)\n+    curr_position[1] = curr_position[1] - 1\n+    position = curr_position\n+  end\n+  local match_position_predicate = function(diag)\n+    return position[1] == diag.lnum and\n+    position[2] >= diag.col and\n+    (position[2] <= diag.end_col or position[1] < diag.end_lnum)\n+  end\n+  local position_diagnostics = vim.tbl_filter(match_position_predicate, M.get(opts.namespace, bufnr))\n+  if opts.severity then\n+    position_diagnostics = filter_to_severity_limit(opts.severity, position_diagnostics)\n+  elseif opts.severity_limit then\n+    position_diagnostics = filter_by_severity_limit(opts.severity_limit, position_diagnostics)\n+  end\n+  table.sort(position_diagnostics, function(a, b) return a.severity < b.severity end)\n+  return show_diagnostics(opts, position_diagnostics)\n+end\n+\n+--- Open a floating window with the diagnostics from the given line.\n+\n+---@param opts table Configuration table. See |vim.diagnostic.show_position_diagnostics()|.\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param lnum number|nil The line number. Defaults to line number of cursor.\n+---@return table {popup_bufnr, win_id}\n+function M.show_line_diagnostics(opts, bufnr, lnum)\n+  vim.validate {\n+    opts = { opts, 't', true },\n+    bufnr = { bufnr, 'n', true },\n+    lnum = { lnum, 'n', true },\n+  }\n+\n+  opts = opts or {}\n+  opts.focus_id = \"line_diagnostics\"\n+  lnum = lnum or (vim.api.nvim_win_get_cursor(0)[1] - 1)\n+  local line_diagnostics = M.get_line_diagnostics(bufnr, lnum, opts)\n+  return show_diagnostics(opts, line_diagnostics)\n+end\n+\n+--- Clear diagnotics and diagnostic cache.\n+---\n+---@param namespace number\n+---@param bufnr number|nil Reset diagnostics for the given buffer. If omitted,\n+---             diagnostics are reset for all buffers.\n+function M.reset(namespace, bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706626606",
            "id": 706626606,
            "in_reply_to_id": 706607287,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjYyNjYwNg==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 1095,
            "original_position": 1283,
            "original_start_line": 1278,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 751926994,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706626606/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-11T15:32:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706626606",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706627397"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706627397"
                }
            },
            "author_association": "MEMBER",
            "body": "I did consider this, but it introduces a lot of boiler plate.\r\n\r\nBefore:\r\n\r\n```lua\r\nvim.diagnostic.setqflist()\r\n```\r\n\r\nAfter:\r\n\r\n```lua\r\nlocal diagnostics = vim.diagnostic.get()\r\nlocal items = vim.diagnostic.diagnostics_to_list_items(diagnostics)\r\nvim.fn.setqflist({}, ' ', { items = items })\r\n```\r\n\r\nEven more so if you want to use `setloclist` for buffer-local diagnostics.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T15:39:33Z",
            "diff_hunk": "@@ -0,0 +1,1377 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_to_severity_limit(severity, diagnostics)\n+  local filter_level = to_severity(severity)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity == filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function filter_by_severity_limit(severity_limit, diagnostics)\n+  local filter_level = to_severity(severity_limit)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity <= filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function valid_severity()\n+  return function(severity)\n+    if type(severity) == 'string' then\n+      return to_severity(severity) ~= nil\n+    elseif type(severity) == 'number' then\n+      return M.severity[severity] ~= nil\n+    end\n+  end, \"Invalid value for 'severity' parameter\"\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local default_highlight_map = make_highlight_map(\"Default\")\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_lines = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_counts = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function diagnostic_counts(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local counts = {}\n+  for _, diagnostic in pairs(diagnostics) do\n+    if diagnostic.severity then\n+      local val = counts[diagnostic.severity]\n+      if val == nil then\n+        val = 0\n+      end\n+\n+      counts[diagnostic.severity] = val + 1\n+    end\n+  end\n+\n+  return counts\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+  diagnostic_cache_lines[bufnr][namespace] = diagnostic_lines(diagnostics)\n+  diagnostic_cache_counts[bufnr][namespace] = diagnostic_counts(diagnostics)\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+  diagnostic_cache_lines[bufnr][namespace] = nil\n+  diagnostic_cache_counts[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+\n+--- Display diagnostics for the buffer with the given options.\n+---@private\n+local function display(namespace, diagnostics, bufnr, opts)\n+  if diagnostic_disabled[bufnr][namespace] then\n+    return\n+  end\n+\n+  M.clear(namespace, bufnr)\n+\n+  diagnostics = diagnostics or M.get(namespace, bufnr)\n+\n+  if not diagnostics or vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+\n+  opts = get_resolved_options(opts, namespace, bufnr)\n+\n+  if opts.update_in_insert then\n+    clear_scheduled_display(namespace, bufnr)\n+  else\n+    local mode = vim.api.nvim_get_mode()\n+    if string.sub(mode.mode, 1, 1) == 'i' then\n+      schedule_display(namespace, bufnr, opts)\n+      return\n+    end\n+  end\n+\n+  if opts.underline then\n+    M.set_underline(namespace, diagnostics, bufnr, opts.underline)\n+  end\n+\n+  if opts.virtual_text then\n+    M.set_virtual_text(namespace, diagnostics, bufnr, opts.virtual_text)\n+  end\n+\n+  if opts.signs then\n+    M.set_signs(namespace, diagnostics, bufnr, opts.signs)\n+  end\n+\n+  save_extmarks(namespace, bufnr)\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---\n+--- The floating window can be customized with the following highlight groups:\n+--- <pre>\n+--- DiagnosticsFloatingError\n+--- DiagnosticsFloatingWarning\n+--- DiagnosticsFloatingInformation\n+--- DiagnosticsFloatingHint\n+--- </pre>\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706627397",
            "id": 706627397,
            "in_reply_to_id": 706609075,
            "line": 384,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjYyNzM5Nw==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 384,
            "original_position": 448,
            "original_start_line": null,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": 384,
            "pull_request_review_id": 751927496,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706627397/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-11T15:39:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706627397",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706627977"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706627977"
                }
            },
            "author_association": "MEMBER",
            "body": "I guess it depends on who you mean by \"users\". As an end-user (e.g. someone using a plugin to display diagnostics), I want to be able to simply call `enable()` or `disable()` to mean \"do show diagnostics\" or \"do not show diagnostics\". I don't want to be on the hook for displaying them myself.\r\n\r\nFor plugins who are users of the diagnostic API I think this makes a little more sense, although I suspect in the vast majority of cases when diagnostics are set they should also be displayed (assuming the user has enabled diagnostics in the buffer).  We could add an optional parameter to `set` to disable automatically displaying diagnostics for the other cases though.\r\n\r\n> (Maybe we rename redraw to draw ?)\r\n\r\nWe can probably combine `redraw()` and `display()` and just expose `display()`.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T15:45:10Z",
            "diff_hunk": "@@ -0,0 +1,1377 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_to_severity_limit(severity, diagnostics)\n+  local filter_level = to_severity(severity)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity == filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function filter_by_severity_limit(severity_limit, diagnostics)\n+  local filter_level = to_severity(severity_limit)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity <= filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function valid_severity()\n+  return function(severity)\n+    if type(severity) == 'string' then\n+      return to_severity(severity) ~= nil\n+    elseif type(severity) == 'number' then\n+      return M.severity[severity] ~= nil\n+    end\n+  end, \"Invalid value for 'severity' parameter\"\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local default_highlight_map = make_highlight_map(\"Default\")\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_lines = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_counts = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function diagnostic_counts(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local counts = {}\n+  for _, diagnostic in pairs(diagnostics) do\n+    if diagnostic.severity then\n+      local val = counts[diagnostic.severity]\n+      if val == nil then\n+        val = 0\n+      end\n+\n+      counts[diagnostic.severity] = val + 1\n+    end\n+  end\n+\n+  return counts\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+  diagnostic_cache_lines[bufnr][namespace] = diagnostic_lines(diagnostics)\n+  diagnostic_cache_counts[bufnr][namespace] = diagnostic_counts(diagnostics)\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+  diagnostic_cache_lines[bufnr][namespace] = nil\n+  diagnostic_cache_counts[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+\n+--- Display diagnostics for the buffer with the given options.\n+---@private\n+local function display(namespace, diagnostics, bufnr, opts)\n+  if diagnostic_disabled[bufnr][namespace] then\n+    return\n+  end\n+\n+  M.clear(namespace, bufnr)\n+\n+  diagnostics = diagnostics or M.get(namespace, bufnr)\n+\n+  if not diagnostics or vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+\n+  opts = get_resolved_options(opts, namespace, bufnr)\n+\n+  if opts.update_in_insert then\n+    clear_scheduled_display(namespace, bufnr)\n+  else\n+    local mode = vim.api.nvim_get_mode()\n+    if string.sub(mode.mode, 1, 1) == 'i' then\n+      schedule_display(namespace, bufnr, opts)\n+      return\n+    end\n+  end\n+\n+  if opts.underline then\n+    M.set_underline(namespace, diagnostics, bufnr, opts.underline)\n+  end\n+\n+  if opts.virtual_text then\n+    M.set_virtual_text(namespace, diagnostics, bufnr, opts.virtual_text)\n+  end\n+\n+  if opts.signs then\n+    M.set_signs(namespace, diagnostics, bufnr, opts.signs)\n+  end\n+\n+  save_extmarks(namespace, bufnr)\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---\n+--- The floating window can be customized with the following highlight groups:\n+--- <pre>\n+--- DiagnosticsFloatingError\n+--- DiagnosticsFloatingWarning\n+--- DiagnosticsFloatingInformation\n+--- DiagnosticsFloatingHint\n+--- </pre>\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local diagnostics = M.get(opts.namespace, opts.bufnr)\n+  local items = vim.tbl_filter(function(d)\n+    local severity = to_severity(opts.severity)\n+    if severity then\n+      return d.severity == severity\n+    end\n+    local severity_limit = to_severity(opts.severity_limit)\n+    if severity_limit then\n+      return d.severity <= severity_limit\n+    end\n+    return true\n+  end, diagnostics_to_list_items(diagnostics))\n+  if loclist then\n+    vim.fn.setloclist(0, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+--- Create links to Lsp* groups for backward compatibility (this should\n+--- eventually be removed)\n+---@private\n+local function make_compat_highlight_link(name)\n+  local from = name:gsub(\"^Diagnostic\", \"LspDiagnostics\"):gsub(\"Info\", \"Information\"):gsub(\"Warn\", \"Warning\")\n+  vim.highlight.link(from, name, false)\n+end\n+\n+---@private\n+local function define_default_signs_and_highlights()\n+  ---@private\n+  local function define_default_sign(name, properties)\n+    if vim.tbl_isempty(vim.fn.sign_getdefined(name)) then\n+      vim.fn.sign_define(name, properties)\n+    end\n+  end\n+\n+  -- Initialize default diagnostic highlights\n+  for severity, hi_info in pairs(diagnostic_severities) do\n+    local default_highlight_name = default_highlight_map[severity]\n+    vim.highlight.create(default_highlight_name, hi_info, true)\n+\n+    -- Default link all corresponding highlights to the default highlight\n+    vim.highlight.link(virtual_text_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(floating_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(sign_highlight_map[severity], default_highlight_name, false)\n+\n+    make_compat_highlight_link(default_highlight_name)\n+    make_compat_highlight_link(virtual_text_highlight_map[severity])\n+    make_compat_highlight_link(floating_highlight_map[severity])\n+    make_compat_highlight_link(sign_highlight_map[severity])\n+  end\n+\n+  -- Create all signs\n+  for severity, sign_hl_name in pairs(sign_highlight_map) do\n+    local severity_name = M.severity[severity]\n+\n+    define_default_sign(sign_hl_name, {\n+      text = (severity_name or 'U'):sub(1, 1),\n+      texthl = sign_hl_name,\n+      linehl = '',\n+      numhl = '',\n+    })\n+  end\n+\n+  -- Initialize Underline highlights\n+  for severity, underline_highlight_name in pairs(underline_highlight_map) do\n+    vim.highlight.create(underline_highlight_name, {\n+      cterm = 'underline',\n+      gui   = 'underline',\n+      guisp = diagnostic_severities[severity].guifg\n+    }, true)\n+    make_compat_highlight_link(underline_highlight_name)\n+  end\n+end\n+\n+define_default_signs_and_highlights()\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics |vim.diagnostic.set_underline()|\n+---       - virtual_text: (default true) Use virtual text for diagnostics |vim.diagnostic.set_virtual_text()|\n+---       - signs: (default true) Use signs for diagnostics |vim.diagnostic.set_signs()|\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    M.redraw(namespace)\n+  else\n+    for k in pairs(all_namespaces) do\n+      M.redraw(k)\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param bufnr number|nil The buffer to set diagnostics for. Defaults to the current buffer.\n+function M.set(namespace, diagnostics, bufnr)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    bufnr = {bufnr, 'n', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  bufnr = get_bufnr(bufnr)\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    display(namespace, diagnostics, bufnr)\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706627977",
            "id": 706627977,
            "in_reply_to_id": 706607910,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjYyNzk3Nw==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 519,
            "original_position": 640,
            "original_start_line": 638,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 751927830,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706627977/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-11T15:45:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706627977",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706628195"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706628195"
                }
            },
            "author_association": "MEMBER",
            "body": "I don't think we need to expose the `set_*` functions publicly either; however, they are still used in LSP so we'll need to expose them privately for that purpose at least.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T15:47:56Z",
            "diff_hunk": "@@ -0,0 +1,616 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+\t\t\t\t\t\t\t*diagnostic-highlights*\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultWarn*\n+DiagnosticDefaultWarn\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultInfo*\n+DiagnosticDefaultInfo\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultHint*\n+DiagnosticDefaultHint\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+  See |vim.diagnostic.set_underline()|",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706628195",
            "id": 706628195,
            "in_reply_to_id": 706591755,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjYyODE5NQ==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 108,
            "original_position": 108,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 751927993,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706628195/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-11T15:47:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706628195",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706631462"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706631462"
                }
            },
            "author_association": "MEMBER",
            "body": "They can be public (and documented), they should just not be at the _forefront_ of documentation like this.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-11T16:18:10Z",
            "diff_hunk": "@@ -0,0 +1,616 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+\t\t\t\t\t\t\t*diagnostic-highlights*\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultWarn*\n+DiagnosticDefaultWarn\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultInfo*\n+DiagnosticDefaultInfo\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultHint*\n+DiagnosticDefaultHint\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+  See |vim.diagnostic.set_underline()|",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706631462",
            "id": 706631462,
            "in_reply_to_id": 706591755,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjYzMTQ2Mg==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 108,
            "original_position": 108,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 751930045,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706631462/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-11T16:18:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706631462",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1363104?v=4",
                "events_url": "https://api.github.com/users/bfredl/events{/privacy}",
                "followers_url": "https://api.github.com/users/bfredl/followers",
                "following_url": "https://api.github.com/users/bfredl/following{/other_user}",
                "gists_url": "https://api.github.com/users/bfredl/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/bfredl",
                "id": 1363104,
                "login": "bfredl",
                "node_id": "MDQ6VXNlcjEzNjMxMDQ=",
                "organizations_url": "https://api.github.com/users/bfredl/orgs",
                "received_events_url": "https://api.github.com/users/bfredl/received_events",
                "repos_url": "https://api.github.com/users/bfredl/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/bfredl/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/bfredl/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/bfredl"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706864134"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706864134"
                }
            },
            "author_association": "MEMBER",
            "body": "One useful part of `reset()` is that it can be used without a `bufnr` argument to remove all diagnostics managed by a particular namespace. This can't be done with `set()`.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-12T16:51:44Z",
            "diff_hunk": "@@ -0,0 +1,1377 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_to_severity_limit(severity, diagnostics)\n+  local filter_level = to_severity(severity)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity == filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function filter_by_severity_limit(severity_limit, diagnostics)\n+  local filter_level = to_severity(severity_limit)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity <= filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function valid_severity()\n+  return function(severity)\n+    if type(severity) == 'string' then\n+      return to_severity(severity) ~= nil\n+    elseif type(severity) == 'number' then\n+      return M.severity[severity] ~= nil\n+    end\n+  end, \"Invalid value for 'severity' parameter\"\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local default_highlight_map = make_highlight_map(\"Default\")\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_lines = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_counts = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function diagnostic_counts(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local counts = {}\n+  for _, diagnostic in pairs(diagnostics) do\n+    if diagnostic.severity then\n+      local val = counts[diagnostic.severity]\n+      if val == nil then\n+        val = 0\n+      end\n+\n+      counts[diagnostic.severity] = val + 1\n+    end\n+  end\n+\n+  return counts\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+  diagnostic_cache_lines[bufnr][namespace] = diagnostic_lines(diagnostics)\n+  diagnostic_cache_counts[bufnr][namespace] = diagnostic_counts(diagnostics)\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+  diagnostic_cache_lines[bufnr][namespace] = nil\n+  diagnostic_cache_counts[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+\n+--- Display diagnostics for the buffer with the given options.\n+---@private\n+local function display(namespace, diagnostics, bufnr, opts)\n+  if diagnostic_disabled[bufnr][namespace] then\n+    return\n+  end\n+\n+  M.clear(namespace, bufnr)\n+\n+  diagnostics = diagnostics or M.get(namespace, bufnr)\n+\n+  if not diagnostics or vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+\n+  opts = get_resolved_options(opts, namespace, bufnr)\n+\n+  if opts.update_in_insert then\n+    clear_scheduled_display(namespace, bufnr)\n+  else\n+    local mode = vim.api.nvim_get_mode()\n+    if string.sub(mode.mode, 1, 1) == 'i' then\n+      schedule_display(namespace, bufnr, opts)\n+      return\n+    end\n+  end\n+\n+  if opts.underline then\n+    M.set_underline(namespace, diagnostics, bufnr, opts.underline)\n+  end\n+\n+  if opts.virtual_text then\n+    M.set_virtual_text(namespace, diagnostics, bufnr, opts.virtual_text)\n+  end\n+\n+  if opts.signs then\n+    M.set_signs(namespace, diagnostics, bufnr, opts.signs)\n+  end\n+\n+  save_extmarks(namespace, bufnr)\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---\n+--- The floating window can be customized with the following highlight groups:\n+--- <pre>\n+--- DiagnosticsFloatingError\n+--- DiagnosticsFloatingWarning\n+--- DiagnosticsFloatingInformation\n+--- DiagnosticsFloatingHint\n+--- </pre>\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local diagnostics = M.get(opts.namespace, opts.bufnr)\n+  local items = vim.tbl_filter(function(d)\n+    local severity = to_severity(opts.severity)\n+    if severity then\n+      return d.severity == severity\n+    end\n+    local severity_limit = to_severity(opts.severity_limit)\n+    if severity_limit then\n+      return d.severity <= severity_limit\n+    end\n+    return true\n+  end, diagnostics_to_list_items(diagnostics))\n+  if loclist then\n+    vim.fn.setloclist(0, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+--- Create links to Lsp* groups for backward compatibility (this should\n+--- eventually be removed)\n+---@private\n+local function make_compat_highlight_link(name)\n+  local from = name:gsub(\"^Diagnostic\", \"LspDiagnostics\"):gsub(\"Info\", \"Information\"):gsub(\"Warn\", \"Warning\")\n+  vim.highlight.link(from, name, false)\n+end\n+\n+---@private\n+local function define_default_signs_and_highlights()\n+  ---@private\n+  local function define_default_sign(name, properties)\n+    if vim.tbl_isempty(vim.fn.sign_getdefined(name)) then\n+      vim.fn.sign_define(name, properties)\n+    end\n+  end\n+\n+  -- Initialize default diagnostic highlights\n+  for severity, hi_info in pairs(diagnostic_severities) do\n+    local default_highlight_name = default_highlight_map[severity]\n+    vim.highlight.create(default_highlight_name, hi_info, true)\n+\n+    -- Default link all corresponding highlights to the default highlight\n+    vim.highlight.link(virtual_text_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(floating_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(sign_highlight_map[severity], default_highlight_name, false)\n+\n+    make_compat_highlight_link(default_highlight_name)\n+    make_compat_highlight_link(virtual_text_highlight_map[severity])\n+    make_compat_highlight_link(floating_highlight_map[severity])\n+    make_compat_highlight_link(sign_highlight_map[severity])\n+  end\n+\n+  -- Create all signs\n+  for severity, sign_hl_name in pairs(sign_highlight_map) do\n+    local severity_name = M.severity[severity]\n+\n+    define_default_sign(sign_hl_name, {\n+      text = (severity_name or 'U'):sub(1, 1),\n+      texthl = sign_hl_name,\n+      linehl = '',\n+      numhl = '',\n+    })\n+  end\n+\n+  -- Initialize Underline highlights\n+  for severity, underline_highlight_name in pairs(underline_highlight_map) do\n+    vim.highlight.create(underline_highlight_name, {\n+      cterm = 'underline',\n+      gui   = 'underline',\n+      guisp = diagnostic_severities[severity].guifg\n+    }, true)\n+    make_compat_highlight_link(underline_highlight_name)\n+  end\n+end\n+\n+define_default_signs_and_highlights()\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics |vim.diagnostic.set_underline()|\n+---       - virtual_text: (default true) Use virtual text for diagnostics |vim.diagnostic.set_virtual_text()|\n+---       - signs: (default true) Use signs for diagnostics |vim.diagnostic.set_signs()|\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    M.redraw(namespace)\n+  else\n+    for k in pairs(all_namespaces) do\n+      M.redraw(k)\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param bufnr number|nil The buffer to set diagnostics for. Defaults to the current buffer.\n+function M.set(namespace, diagnostics, bufnr)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    bufnr = {bufnr, 'n', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  bufnr = get_bufnr(bufnr)\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    display(namespace, diagnostics, bufnr)\n+  end\n+end\n+\n+--- Get all diagnostics for the given namespace or buffer.\n+---\n+--- With no arguments, return a list of all diagnostics.\n+---\n+--- If {namespace} is `nil`, retrieve all diagnostics associated with buffer\n+--- {bufnr}. If {bufnr} is `nil`, retrieve all diagnostics associated with\n+--- namespace {namespace}. Otherwise, retrieve diagnostics from namespace\n+--- {namespace} associated with buffer {bufnr}.\n+---\n+---@param namespace number|nil The namespace to get diagnostics from. If\n+---                            omitted, get diagnostics from all namespaces.\n+---                            be `nil` only when {bufnr} is not `nil`.\n+---@param bufnr number|nil The buffer number to get diagnistics from. If\n+---                        omitted, get diagnostics from all buffers.\n+---@return table A list of diagnostic items |diagnostic-structure|.\n+function M.get(namespace, bufnr)\n+  vim.validate {\n+    namespace = { namespace, 'n', true },\n+    bufnr = { bufnr, 'n', true },\n+  }\n+\n+  local diagnostics = {}\n+  if namespace == nil and bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, v in pairs(t) do\n+        for _, diagnostic in ipairs(v) do\n+          table.insert(diagnostics, diagnostic)\n+        end\n+      end\n+    end\n+  elseif namespace == nil then\n+    for iter_namespace in pairs(diagnostic_cache[bufnr]) do\n+      for _, diagnostic in ipairs(diagnostic_cache[bufnr][iter_namespace]) do\n+        table.insert(diagnostics, diagnostic)\n+      end\n+    end\n+  elseif bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, diagnostic in ipairs(t[namespace] or {}) do\n+        table.insert(diagnostics, diagnostic)\n+      end\n+    end\n+  else\n+    for _, diagnostic in ipairs(diagnostic_cache[bufnr][namespace] or {}) do\n+      table.insert(diagnostics, diagnostic)\n+    end\n+  end\n+  return diagnostics\n+end\n+\n+--- Get diagnostics by line.\n+---\n+---@param namespace number|nil Limit diagnostics to the given namespace. If `nil`, retrieve\n+---                            diagnostics from all namespaces.\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param lnum number|nil The line number. Defaults to the current line.\n+---@param opts table|nil A table with the following keys:\n+---                        - namespace: (number) Limit diagnostics to the given namespace.\n+---                        - severity: (|vim.diagnostic.severity|) Only return diagnostics with this\n+---                                    severity. Overrides severity_limit. |vim.diagnostic.severity|\n+---                        - severity_limit: (|vim.diagnostic.severity|) Limit severity of\n+---                                          diagnostics found. For example,\n+---                                          vim.diagnostic.severity.WARN means both errors and\n+---                                          warnings will be valid.\n+---@return table Table with map of line number to list of diagnostics.\n+--               Structured: { [1] = {...}, [5] = {.... } }\n+function M.get_line_diagnostics(bufnr, lnum, opts)\n+  vim.validate {\n+    bufnr = { bufnr, 'n', true },\n+    lnum = { lnum, 'n', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  opts = opts or {}\n+\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  lnum = lnum or vim.api.nvim_win_get_cursor(0)[1] - 1\n+\n+  local ns_get_diags = function(iter_namespace)\n+    return (diagnostic_cache_lines[bufnr][iter_namespace] or {})[lnum] or {}\n+  end\n+\n+  local line_diagnostics\n+  if opts.namespace == nil then\n+    line_diagnostics = {}\n+    for iter_namespace, _ in pairs(diagnostic_cache_lines[bufnr]) do\n+      for _, diagnostic in ipairs(ns_get_diags(iter_namespace)) do\n+        table.insert(line_diagnostics, diagnostic)\n+      end\n+    end\n+  else\n+    line_diagnostics = vim.deepcopy(ns_get_diags(opts.namespace))\n+  end\n+\n+  if opts.severity then\n+    line_diagnostics = filter_to_severity_limit(opts.severity, line_diagnostics)\n+  elseif opts.severity_limit then\n+    line_diagnostics = filter_by_severity_limit(opts.severity_limit, line_diagnostics)\n+  end\n+\n+  table.sort(line_diagnostics, function(a, b) return a.severity < b.severity end)\n+\n+  return line_diagnostics\n+end\n+\n+--- Get the number of diagnostics with the given severity.\n+---\n+--- Useful for showing diagnostic counts in statusline. eg:\n+--- <pre>\n+--- function! DiagnosticStatus() abort\n+---   let sl = ''\n+---   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)\")} '\n+---   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)\")}'\n+---   return sl\n+--- endfunction\n+--- </pre>\n+---\n+--- Then simply add `%{DiagnosticStatus()}` to your statusline.\n+---\n+---@param namespace number|nil Limit diagnostics to the given namespace. If `nil`, retrieve\n+---                            diagnostics from all namespaces.\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param severity|nil Return diagnostics for the given severity |vim.diagnostic.severity|. If\n+---                    omitted, all diagnositcs are returned.\n+function M.get_count(namespace, bufnr, severity)\n+  vim.validate {\n+    namespace = { namespace, 'n', true },\n+    bufnr = { bufnr, 'n', true },\n+    severity = { severity, valid_severity() },\n+  }\n+\n+  if namespace == nil then\n+    local total = 0\n+    for ns in pairs(diagnostic_cache_counts[bufnr]) do\n+      total = total + M.get_count(ns, bufnr, severity)\n+    end\n+    return total\n+  end\n+\n+  return (diagnostic_cache_counts[bufnr][namespace] or {})[to_severity(severity)] or 0\n+end\n+\n+-- Diagnostic Movements {{{\n+\n+local next_diagnostic = function(position, search_forward, bufnr, opts, namespace)\n+  position[1] = position[1] - 1\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  local wrap = vim.F.if_nil(opts.wrap, true)\n+  local line_count = vim.api.nvim_buf_line_count(bufnr)\n+  opts.namespace = namespace\n+  for i = 0, line_count do\n+    local offset = i * (search_forward and 1 or -1)\n+    local lnum = position[1] + offset\n+    if lnum < 0 or lnum >= line_count then\n+      if not wrap then\n+        return\n+      end\n+      lnum = (lnum + line_count) % line_count\n+    end\n+    local line_diagnostics = M.get_line_diagnostics(bufnr, lnum, opts)\n+    if line_diagnostics and not vim.tbl_isempty(line_diagnostics) then\n+      local sort_diagnostics, is_next\n+      if search_forward then\n+        sort_diagnostics = function(a, b) return a.col < b.col end\n+        is_next = function(diagnostic) return diagnostic.col > position[2] end\n+      else\n+        sort_diagnostics = function(a, b) return a.col > b.col end\n+        is_next = function(diagnostic) return diagnostic.col < position[2] end\n+      end\n+      table.sort(line_diagnostics, sort_diagnostics)\n+      if i == 0 then\n+        for _, v in pairs(line_diagnostics) do\n+          if is_next(v) then\n+            return v\n+          end\n+        end\n+      else\n+        return line_diagnostics[1]\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function diagnostic_pos(opts, diagnostic)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+\n+  if not diagnostic then\n+    return false\n+  end\n+\n+  local lnum, col = diagnostic.lnum, diagnostic.col\n+  if col > 0 then\n+    if not vim.api.nvim_buf_is_loaded(bufnr) then\n+      vim.fn.bufload(bufnr)\n+    end\n+\n+    local line = vim.api.nvim_buf_get_lines(bufnr, lnum, lnum + 1, true)[1]\n+    if line then\n+      local ok, result = pcall(vim.str_byteindex, line, col)\n+\n+      if ok then\n+        col = result\n+      end\n+    end\n+  end\n+\n+  return {lnum, col}\n+end\n+\n+---@private\n+local function diagnostic_move_pos(name, opts, pos)\n+  opts = opts or {}\n+\n+  local enable_popup = vim.F.if_nil(opts.enable_popup, true)\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+\n+  if not pos then\n+    print(string.format(\"%s: No more valid diagnostics to move to.\", name))\n+    return\n+  end\n+\n+  vim.api.nvim_win_set_cursor(win_id, {pos[1] + 1, pos[2]})\n+\n+  if enable_popup then\n+    -- This is a bit weird... I'm surprised that we need to wait til the next tick to do this.\n+    vim.schedule(function()\n+      M.show_position_diagnostics(opts.popup_opts, vim.api.nvim_win_get_buf(win_id))\n+    end)\n+  end\n+end\n+\n+--- Get the previous diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic\n+function M.get_prev(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, false, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the previous diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic position as a (row, col) tuple.\n+function M.get_prev_pos(opts)\n+  return diagnostic_pos(\n+    opts,\n+    M.get_prev(opts)\n+  )\n+end\n+\n+--- Move to the previous diagnostic in the current buffer.\n+---@param opts table See |vim.diagnostic.goto_next()|\n+function M.goto_prev(opts)\n+  return diagnostic_move_pos(\n+    \"DiagnosticPrevious\",\n+    opts,\n+    M.get_prev_pos(opts)\n+  )\n+end\n+\n+--- Get the next diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic\n+function M.get_next(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, true, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the next diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic position as a (row, col) tuple.\n+function M.get_next_pos(opts)\n+  return diagnostic_pos(\n+    opts,\n+    M.get_next(opts)\n+  )\n+end\n+\n+--- Move to the next diagnostic.\n+---\n+---@param opts table|nil Configuration table with the following keys:\n+---         - namespace: (number) Only consider diagnostics from the given namespace.\n+---         - cursor_position: (cursor position) Cursor position as a (row, col) tuple. See\n+---                          |nvim_win_get_cursor()|. Defaults to the current cursor position.\n+---         - wrap: (boolean, default true) Whether to loop around file or not. Similar to 'wrapscan'.\n+---         - severity: (|vim.diagnostic.severity|) Exclusive severity to consider.\n+---                   Overrides {severity_limit}\n+---         - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                         example, vim.diagnostic.severity.WARN means both errors and warnings\n+---                         will be valid.\n+---         - enable_popup: (boolean, default true) Call |vim.diagnostic.show_line_diagnostics()|\n+---                       on jump.\n+---         - popup_opts: (table) Table to pass as {opts} parameter to\n+---                     |vim.diagnostic.show_line_diagnostics()|\n+---         - win_id: (number, default 0) Window ID\n+function M.goto_next(opts)\n+  return diagnostic_move_pos(\n+    \"DiagnosticNext\",\n+    opts,\n+    M.get_next_pos(opts)\n+  )\n+end\n+\n+-- Diagnostic Setters {{{\n+\n+--- Set signs for given diagnostics.\n+---\n+--- Sign characters can be customized with the following commands:\n+---\n+--- <pre>\n+--- sign define DiagnosticSignError text=E texthl=DiagnosticSignError linehl= numhl=\n+--- sign define DiagnosticSignWarning text=W texthl=DiagnosticSignWarning linehl= numhl=\n+--- sign define DiagnosticSignInformation text=I texthl=DiagnosticSignInformation linehl= numhl=\n+--- sign define DiagnosticSignHint text=H texthl=DiagnosticSignHint linehl= numhl=\n+--- </pre>\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics|nil table A list of diagnostic items |diagnostic-structure|. If omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param bufnr number The buffer number\n+---@param opts table Configuration table with the following keys:\n+---            - priority: Set the priority of the signs |sign-priority|.\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                           example, `vim.diagnostic.severity.WARN` means errors and warnings are\n+---                           valid.\n+function M.set_signs(namespace, diagnostics, bufnr, opts)\n+  opts = get_resolved_options({ signs = opts }, namespace, bufnr).signs\n+\n+  if not diagnostics then\n+    diagnostics = diagnostic_cache[bufnr][namespace]\n+  end\n+\n+  if not diagnostics then\n+    return\n+  end\n+\n+  bufnr = get_bufnr(bufnr)\n+  diagnostics = filter_by_severity_limit(opts.severity_limit, diagnostics)\n+\n+  local ns = get_namespace(namespace)\n+\n+  local ok = true\n+  for _, diagnostic in ipairs(diagnostics) do\n+    ok = ok and pcall(vim.fn.sign_place,\n+      0,\n+      ns.sign_group,\n+      sign_highlight_map[diagnostic.severity],\n+      bufnr,\n+      {\n+        priority = opts.priority,\n+        lnum = diagnostic.lnum + 1\n+      }\n+    )\n+  end\n+end\n+\n+--- Set underline for given diagnostics.\n+---\n+--- Underline highlights can be customized by changing the following |:highlight| groups.\n+---\n+--- <pre>\n+--- DiagnosticUnderlineError\n+--- DiagnosticUnderlineWarning\n+--- DiagnosticUnderlineInformation\n+--- DiagnosticUnderlineHint\n+--- </pre>\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics|nil table A list of diagnostic items |diagnostic-structure|. If omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param bufnr number The buffer number\n+---@param opts table Configuration table with the following keys:\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                           example, `vim.diagnostic.severity.WARN` means errors and warnings are\n+---                           valid.\n+function M.set_underline(namespace, diagnostics, bufnr, opts)\n+  opts = get_resolved_options({ underline = opts }, namespace, bufnr).underline\n+\n+  diagnostics = filter_by_severity_limit(opts.severity_limit, diagnostics)\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local higroup = underline_highlight_map[diagnostic.severity]\n+\n+    if higroup == nil then\n+      -- Default to error if we don't have a highlight associated\n+      higroup = underline_highlight_map.Error\n+    end\n+\n+    vim.highlight.range(\n+      bufnr,\n+      namespace,\n+      higroup,\n+      { diagnostic.lnum, diagnostic.col },\n+      { diagnostic.end_lnum, diagnostic.end_col }\n+    )\n+  end\n+end\n+\n+--- Set virtual text for given diagnostics.\n+---\n+--- Virtual text highlights can be customized by changing the following |:highlight| groups.\n+---\n+--- <pre>\n+--- DiagnosticVirtualTextError\n+--- DiagnosticVirtualTextWarning\n+--- DiagnosticVirtualTextInformation\n+--- DiagnosticVirtualTextHint\n+--- </pre>\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics|nil table A list of diagnostic items |diagnostic-structure|. If omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param bufnr number The buffer number\n+---@param opts table Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line\n+---            - spacing: (number) Number of spaces to insert before virtual text\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics found. For\n+---                           example, `vim.diagnostic.severity.WARN` means errors and warnings are\n+---                           valid.\n+function M.set_virtual_text(namespace, diagnostics, bufnr, opts)\n+  opts = get_resolved_options({ virtual_text = opts }, namespace, bufnr).virtual_text\n+\n+  local buffer_line_diagnostics\n+  if diagnostics then\n+    buffer_line_diagnostics = diagnostic_lines(diagnostics)\n+  else\n+    buffer_line_diagnostics = diagnostic_cache_lines[bufnr][namespace]\n+  end\n+\n+  if not buffer_line_diagnostics then\n+    return nil\n+  end\n+\n+  for line, line_diagnostics in pairs(buffer_line_diagnostics) do\n+    line_diagnostics = filter_by_severity_limit(opts.severity_limit, line_diagnostics)\n+    local virt_texts = M.get_virt_text_chunks(line_diagnostics, opts)\n+\n+    if virt_texts then\n+      vim.api.nvim_buf_set_extmark(bufnr, namespace, line, 0, {\n+        hl_mode = \"combine\",\n+        virt_text = virt_texts,\n+      })\n+    end\n+  end\n+end\n+\n+--- Get virtual text chunks to display using |nvim_buf_set_extmark()|.\n+---\n+---@param line_diags table The diagnostics associated with the line\n+---                  |vim.diagnostic.get_line_diagnostics()|\n+---@param opts table See {opts} from |vim.diagnostic.set_virtual_text()|\n+---@return an array of [text, hl_group] arrays. This can be passed directly to\n+---        the {virt_text} option of |nvim_buf_set_extmark()|.\n+function M.get_virt_text_chunks(line_diags, opts)\n+  if #line_diags == 0 then\n+    return nil\n+  end\n+\n+  opts = opts or {}\n+  local prefix = opts.prefix or \"■\"\n+  local spacing = opts.spacing or 4\n+\n+  -- Create a little more space between virtual text and contents\n+  local virt_texts = {{string.rep(\" \", spacing)}}\n+\n+  for i = 1, #line_diags - 1 do\n+    table.insert(virt_texts, {prefix, virtual_text_highlight_map[line_diags[i].severity]})\n+  end\n+  local last = line_diags[#line_diags]\n+\n+  -- TODO(tjdevries): Allow different servers to be shown first somehow?\n+  -- TODO(tjdevries): Display server name associated with these?\n+  if last.message then\n+    table.insert(\n+      virt_texts,\n+      {\n+        string.format(\"%s %s\", prefix, last.message:gsub(\"\\r\", \"\"):gsub(\"\\n\", \"  \")),\n+        virtual_text_highlight_map[last.severity]\n+      }\n+    )\n+\n+    return virt_texts\n+  end\n+end\n+\n+--- Clear the currently displayed diagnostics.\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number|nil Clear diagnostics in the given buffer. If omitted, diagnostics for\n+---             the given namespace are cleared in all buffers.\n+function M.clear(namespace, bufnr)\n+  vim.validate {\n+    namespace = { namespace, 'n' },\n+    bufnr = { bufnr, 'n', true },\n+  }\n+\n+  if bufnr == nil then\n+    for k, v in pairs(diagnostic_cache_extmarks) do\n+      if v[namespace] then\n+        M.clear(namespace, k)\n+      end\n+    end\n+  else\n+    bufnr = get_bufnr(bufnr)\n+    diagnostic_cache_extmarks[bufnr][namespace] = {}\n+\n+    local ns = get_namespace(namespace)\n+\n+    -- clear sign group\n+    vim.fn.sign_unplace(ns.sign_group, {buffer=bufnr})\n+\n+    -- clear virtual text namespace\n+    vim.api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+  end\n+end\n+\n+--- Callback scheduled when leaving Insert mode.\n+---\n+--- This function must be exported publicly so that it is available to be called from the Vimscript\n+--- autocommand.\n+---\n+--- See @ref schedule_display()\n+---\n+---@private\n+function M._execute_scheduled_display(namespace, bufnr)\n+  local args = bufs_waiting_to_update[bufnr][namespace]\n+  if not args then\n+    return\n+  end\n+\n+  -- Clear the args so we don't display unnecessarily.\n+  bufs_waiting_to_update[bufnr][namespace] = nil\n+\n+  display(namespace, nil, bufnr, args)\n+end\n+\n+--- Redraw diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number Redraw diagnostics for the given\n+---                 namespace\n+---@param bufnr number|nil Buffer handle. If omitted, redraw diagnostics for the given namespace in\n+---             all buffers.\n+function M.redraw(namespace, bufnr)\n+  if bufnr == nil then\n+    for k, v in pairs(diagnostic_cache) do\n+      if v[namespace] then\n+        M.redraw(namespace, k)\n+      end\n+    end\n+  else\n+    local diagnostics = M.get(namespace, bufnr)\n+    display(namespace, diagnostics, bufnr)\n+  end\n+end\n+\n+--- Open a floating window with the diagnostics at the given position.\n+---\n+---@param opts table|nil Configuration table with the same keys as\n+---            |vim.lsp.util.open_floatin_preview()| in addition to the following:\n+---            - namespace: (number) Limit diagnostics to the given namespace\n+---            - severity: (|vim.diagnostic.severity|) Only return diagnostics with this\n+---                        severity. Overrides severity_limit\n+---            - severity_limit: (|vim.diagnostic.severity|) Limit severity of diagnostics\n+---                            found. For example, `vim.diagnostic.severity.WARN` means\n+---                            errors and warnings are valid.\n+---            - show_header: (boolean, default true) Show \"Diagnostics:\" header\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param position table|nil The (0,0)-indexed position. Defaults to the current cursor position.\n+---@return table {popup_bufnr, win_id}\n+function M.show_position_diagnostics(opts, bufnr, position)\n+  vim.validate {\n+    opts = { opts, 't', true },\n+    bufnr = { bufnr, 'n', true },\n+    position = { position, 't', true },\n+  }\n+\n+  opts = opts or {}\n+  opts.focus_id = \"position_diagnostics\"\n+  bufnr = get_bufnr(bufnr)\n+  if not position then\n+    local curr_position = vim.api.nvim_win_get_cursor(0)\n+    curr_position[1] = curr_position[1] - 1\n+    position = curr_position\n+  end\n+  local match_position_predicate = function(diag)\n+    return position[1] == diag.lnum and\n+    position[2] >= diag.col and\n+    (position[2] <= diag.end_col or position[1] < diag.end_lnum)\n+  end\n+  local position_diagnostics = vim.tbl_filter(match_position_predicate, M.get(opts.namespace, bufnr))\n+  if opts.severity then\n+    position_diagnostics = filter_to_severity_limit(opts.severity, position_diagnostics)\n+  elseif opts.severity_limit then\n+    position_diagnostics = filter_by_severity_limit(opts.severity_limit, position_diagnostics)\n+  end\n+  table.sort(position_diagnostics, function(a, b) return a.severity < b.severity end)\n+  return show_diagnostics(opts, position_diagnostics)\n+end\n+\n+--- Open a floating window with the diagnostics from the given line.\n+\n+---@param opts table Configuration table. See |vim.diagnostic.show_position_diagnostics()|.\n+---@param bufnr number|nil The buffer number. Defaults to the current buffer.\n+---@param lnum number|nil The line number. Defaults to line number of cursor.\n+---@return table {popup_bufnr, win_id}\n+function M.show_line_diagnostics(opts, bufnr, lnum)\n+  vim.validate {\n+    opts = { opts, 't', true },\n+    bufnr = { bufnr, 'n', true },\n+    lnum = { lnum, 'n', true },\n+  }\n+\n+  opts = opts or {}\n+  opts.focus_id = \"line_diagnostics\"\n+  lnum = lnum or (vim.api.nvim_win_get_cursor(0)[1] - 1)\n+  local line_diagnostics = M.get_line_diagnostics(bufnr, lnum, opts)\n+  return show_diagnostics(opts, line_diagnostics)\n+end\n+\n+--- Clear diagnotics and diagnostic cache.\n+---\n+---@param namespace number\n+---@param bufnr number|nil Reset diagnostics for the given buffer. If omitted,\n+---             diagnostics are reset for all buffers.\n+function M.reset(namespace, bufnr)",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706864134",
            "id": 706864134,
            "in_reply_to_id": 706607287,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjg2NDEzNA==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 1095,
            "original_position": 1283,
            "original_start_line": 1278,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 752178066,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706864134/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-12T16:51:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706864134",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r706868673"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/706868673"
                }
            },
            "author_association": "MEMBER",
            "body": "> We could add an optional parameter to set to disable automatically displaying diagnostics for the other cases though.\r\n\r\nI just added this, but on further thought I'm not sure it's necessary. We already have a way for diagnostic producers to temporarily disable display of their diagnostics:\r\n\r\n```lua\r\nvim.diagnostic.disable(my_namespace)\r\n\r\n-- Set diagnostics. They won't be displayed becuase of the 'disable()' call\r\nvim.diagnostic.set(...)\r\n\r\n-- Re-enable to display diagnostics\r\nvim.diagnostic.enable(my_namespace)\r\n```\r\n\r\nThis is pretty much exactly equivalent to using\r\n\r\n```lua\r\nvim.diagnostic.set(..., false)\r\nvim.diagnostic.display(my_namespace)\r\n```\r\n\r\nI don't like having two ways to do the same thing, so I think I'll revert that last change.\r\n\r\nIn addition I'm not sure we need to expose `redraw()` *or* `display()`. Display of diagnostics should be handled completely internally by `vim.diagnostic` and we should only expose `enable()` and `disable()` to API consumers.\r\n\r\nAny thoughts?",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-12T17:30:33Z",
            "diff_hunk": "@@ -0,0 +1,1377 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_to_severity_limit(severity, diagnostics)\n+  local filter_level = to_severity(severity)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity == filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function filter_by_severity_limit(severity_limit, diagnostics)\n+  local filter_level = to_severity(severity_limit)\n+  if not filter_level then\n+    return diagnostics\n+  end\n+\n+  return vim.tbl_filter(function(t) return t.severity <= filter_level end, diagnostics)\n+end\n+\n+---@private\n+local function valid_severity()\n+  return function(severity)\n+    if type(severity) == 'string' then\n+      return to_severity(severity) ~= nil\n+    elseif type(severity) == 'number' then\n+      return M.severity[severity] ~= nil\n+    end\n+  end, \"Invalid value for 'severity' parameter\"\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local default_highlight_map = make_highlight_map(\"Default\")\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_lines = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_counts = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function diagnostic_counts(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local counts = {}\n+  for _, diagnostic in pairs(diagnostics) do\n+    if diagnostic.severity then\n+      local val = counts[diagnostic.severity]\n+      if val == nil then\n+        val = 0\n+      end\n+\n+      counts[diagnostic.severity] = val + 1\n+    end\n+  end\n+\n+  return counts\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+  diagnostic_cache_lines[bufnr][namespace] = diagnostic_lines(diagnostics)\n+  diagnostic_cache_counts[bufnr][namespace] = diagnostic_counts(diagnostics)\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+  diagnostic_cache_lines[bufnr][namespace] = nil\n+  diagnostic_cache_counts[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+\n+--- Display diagnostics for the buffer with the given options.\n+---@private\n+local function display(namespace, diagnostics, bufnr, opts)\n+  if diagnostic_disabled[bufnr][namespace] then\n+    return\n+  end\n+\n+  M.clear(namespace, bufnr)\n+\n+  diagnostics = diagnostics or M.get(namespace, bufnr)\n+\n+  if not diagnostics or vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+\n+  opts = get_resolved_options(opts, namespace, bufnr)\n+\n+  if opts.update_in_insert then\n+    clear_scheduled_display(namespace, bufnr)\n+  else\n+    local mode = vim.api.nvim_get_mode()\n+    if string.sub(mode.mode, 1, 1) == 'i' then\n+      schedule_display(namespace, bufnr, opts)\n+      return\n+    end\n+  end\n+\n+  if opts.underline then\n+    M.set_underline(namespace, diagnostics, bufnr, opts.underline)\n+  end\n+\n+  if opts.virtual_text then\n+    M.set_virtual_text(namespace, diagnostics, bufnr, opts.virtual_text)\n+  end\n+\n+  if opts.signs then\n+    M.set_signs(namespace, diagnostics, bufnr, opts.signs)\n+  end\n+\n+  save_extmarks(namespace, bufnr)\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---\n+--- The floating window can be customized with the following highlight groups:\n+--- <pre>\n+--- DiagnosticsFloatingError\n+--- DiagnosticsFloatingWarning\n+--- DiagnosticsFloatingInformation\n+--- DiagnosticsFloatingHint\n+--- </pre>\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local diagnostics = M.get(opts.namespace, opts.bufnr)\n+  local items = vim.tbl_filter(function(d)\n+    local severity = to_severity(opts.severity)\n+    if severity then\n+      return d.severity == severity\n+    end\n+    local severity_limit = to_severity(opts.severity_limit)\n+    if severity_limit then\n+      return d.severity <= severity_limit\n+    end\n+    return true\n+  end, diagnostics_to_list_items(diagnostics))\n+  if loclist then\n+    vim.fn.setloclist(0, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+--- Create links to Lsp* groups for backward compatibility (this should\n+--- eventually be removed)\n+---@private\n+local function make_compat_highlight_link(name)\n+  local from = name:gsub(\"^Diagnostic\", \"LspDiagnostics\"):gsub(\"Info\", \"Information\"):gsub(\"Warn\", \"Warning\")\n+  vim.highlight.link(from, name, false)\n+end\n+\n+---@private\n+local function define_default_signs_and_highlights()\n+  ---@private\n+  local function define_default_sign(name, properties)\n+    if vim.tbl_isempty(vim.fn.sign_getdefined(name)) then\n+      vim.fn.sign_define(name, properties)\n+    end\n+  end\n+\n+  -- Initialize default diagnostic highlights\n+  for severity, hi_info in pairs(diagnostic_severities) do\n+    local default_highlight_name = default_highlight_map[severity]\n+    vim.highlight.create(default_highlight_name, hi_info, true)\n+\n+    -- Default link all corresponding highlights to the default highlight\n+    vim.highlight.link(virtual_text_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(floating_highlight_map[severity], default_highlight_name, false)\n+    vim.highlight.link(sign_highlight_map[severity], default_highlight_name, false)\n+\n+    make_compat_highlight_link(default_highlight_name)\n+    make_compat_highlight_link(virtual_text_highlight_map[severity])\n+    make_compat_highlight_link(floating_highlight_map[severity])\n+    make_compat_highlight_link(sign_highlight_map[severity])\n+  end\n+\n+  -- Create all signs\n+  for severity, sign_hl_name in pairs(sign_highlight_map) do\n+    local severity_name = M.severity[severity]\n+\n+    define_default_sign(sign_hl_name, {\n+      text = (severity_name or 'U'):sub(1, 1),\n+      texthl = sign_hl_name,\n+      linehl = '',\n+      numhl = '',\n+    })\n+  end\n+\n+  -- Initialize Underline highlights\n+  for severity, underline_highlight_name in pairs(underline_highlight_map) do\n+    vim.highlight.create(underline_highlight_name, {\n+      cterm = 'underline',\n+      gui   = 'underline',\n+      guisp = diagnostic_severities[severity].guifg\n+    }, true)\n+    make_compat_highlight_link(underline_highlight_name)\n+  end\n+end\n+\n+define_default_signs_and_highlights()\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics |vim.diagnostic.set_underline()|\n+---       - virtual_text: (default true) Use virtual text for diagnostics |vim.diagnostic.set_virtual_text()|\n+---       - signs: (default true) Use signs for diagnostics |vim.diagnostic.set_signs()|\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    M.redraw(namespace)\n+  else\n+    for k in pairs(all_namespaces) do\n+      M.redraw(k)\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param bufnr number|nil The buffer to set diagnostics for. Defaults to the current buffer.\n+function M.set(namespace, diagnostics, bufnr)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    bufnr = {bufnr, 'n', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  bufnr = get_bufnr(bufnr)\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    display(namespace, diagnostics, bufnr)\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r706868673",
            "id": 706868673,
            "in_reply_to_id": 706607910,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjg2ODY3Mw==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 519,
            "original_position": 640,
            "original_start_line": 638,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 752181063,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706868673/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-12T17:30:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/706868673",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r707532806"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/707532806"
                }
            },
            "author_association": "MEMBER",
            "body": "Is `min_severity` clearer than `severity_limit`? I will also make `severity` and `min_severity` mutually exclusive; providing both is an error.\r\n\r\n```\r\n- severity: (|vim.diagnostic.severity|) Only return diagnostics with this severity. Conflicts with {min_severity}.\r\n- min_severity: (|vim.diagnostic.severity|) Return diagnostics with this severity or worse. Conflicts with {severity}.\r\n```\r\n\r\nMy only hangup is that `min` implies ordered numbering. In my mind \"lower\" = \"better\" so that e.g. \"Warning\" is \"lower\" than \"Error\". So `min_severity = WARN` would imply both warnings and errors.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-13T17:16:45Z",
            "diff_hunk": "@@ -0,0 +1,616 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+\t\t\t\t\t\t\t*diagnostic-highlights*\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultWarn*\n+DiagnosticDefaultWarn\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultInfo*\n+DiagnosticDefaultInfo\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultHint*\n+DiagnosticDefaultHint\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+  See |vim.diagnostic.set_virtual_text()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+  See |vim.diagnostic.set_underline()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+  See |vim.diagnostic.set_signs()|\n+\n+==============================================================================\n+Events\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed in a loaded buffer.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+clear({namespace}, {bufnr})                           *vim.diagnostic.clear()*\n+                Clear the currently displayed diagnostics.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Clear diagnostics in the given\n+                                 buffer. If omitted, diagnostics for the given\n+                                 namespace are cleared in all buffers.\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:- `false`: Disable this feature - `true`: Enable this\n+                    feature, use default settings. - `table`: Enable this\n+                    feature with overrides. - `function`: Function with\n+                    signature (namespace, bufnr) that returns any of the\n+                    above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                   |vim.diagnostic.set_underline()|\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                   |vim.diagnostic.set_virtual_text()|\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics |vim.diagnostic.set_signs()|\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({namespace}, {bufnr})                       *vim.diagnostic.disable()*\n+                Disable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, disable\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+enable({namespace}, {bufnr})                         *vim.diagnostic.enable()*\n+                Enable diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Buffer handle. If omitted, eanble\n+                                 diagnostics for all buffers in the given\n+                                 namespace\n+\n+get({namespace}, {bufnr})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the given namespace or buffer.\n+\n+                With no arguments, return a list of all diagnostics.\n+\n+                If {namespace} is `nil` , retrieve all diagnostics associated\n+                with buffer {bufnr}. If {bufnr} is `nil` , retrieve all\n+                diagnostics associated with namespace {namespace}. Otherwise,\n+                retrieve diagnostics from namespace {namespace} associated\n+                with buffer {bufnr}.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil The namespace to get diagnostics\n+                                 from. If omitted, get diagnostics from all\n+                                 namespaces. be `nil` only when {bufnr} is not\n+                                 `nil` .\n+                    {bufnr}      number|nil The buffer number to get\n+                                 diagnistics from. If omitted, get diagnostics\n+                                 from all buffers.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({namespace}, {bufnr}, {severity})\n+                Get the number of diagnostics with the given severity.\n+\n+                Useful for showing diagnostic counts in statusline. eg: >\n+\n+                 function! DiagnosticStatus() abort\n+                   let sl = ''\n+                   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.ERROR)\")} '\n+                   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(nil, 0, vim.diagnostic.severity.WARN)\")}'\n+                   return sl\n+                 endfunction\n+<\n+\n+                Then simply add `%{DiagnosticStatus()}` to your statusline.\n+\n+                Parameters: ~\n+                    {namespace}     number|nil Limit diagnostics to the given\n+                                    namespace. If `nil` , retrieve diagnostics\n+                                    from all namespaces.\n+                    {bufnr}         number|nil The buffer number. Defaults to\n+                                    the current buffer.\n+                    {severity|nil}  Return diagnostics for the given severity\n+                                    |vim.diagnostic.severity|. If omitted, all\n+                                    diagnositcs are returned.\n+\n+                                       *vim.diagnostic.get_line_diagnostics()*\n+get_line_diagnostics({bufnr}, {lnum}, {opts})\n+                Get diagnostics by line.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace. If `nil` , retrieve diagnostics\n+                                 from all namespaces.\n+                    {bufnr}      number|nil The buffer number. Defaults to the\n+                                 current buffer.\n+                    {lnum}       number|nil The line number. Defaults to the\n+                                 current line.\n+                    {opts}       table|nil A table with the following keys:\n+                                 • namespace: (number) Limit diagnostics to\n+                                   the given namespace.\n+                                 • severity: (|vim.diagnostic.severity|) Only\n+                                   return diagnostics with this severity.",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r707532806",
            "id": 707532806,
            "in_reply_to_id": 706590743,
            "line": null,
            "node_id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNzUzMjgwNg==",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 284,
            "original_position": 304,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 753017921,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/707532806/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-13T17:16:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/707532806",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r707839811"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/707839811"
                }
            },
            "author_association": "MEMBER",
            "body": "Why does this need to read the filesystem? Don't we just need `vim.str_byteindex()`?",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-14T01:36:43Z",
            "diff_hunk": "@@ -57,338 +13,241 @@ end\n \n local M = {}\n \n--- Diagnostic Highlights {{{\n-\n--- TODO(tjdevries): Determine how to generate documentation for these\n---                  and how to configure them to be easy for users.\n---\n---                  For now, just use the following script. It should work pretty good.\n---[[\n-local levels = {\"Error\", \"Warning\", \"Information\", \"Hint\" }\n-\n-local all_info = {\n-  { \"Default\", \"Used as the base highlight group, other highlight groups link to\", },\n-  { \"VirtualText\", 'Used for \"%s\" diagnostic virtual text.\\n  See |vim.lsp.diagnostic.set_virtual_text()|', },\n-  { \"Underline\", 'Used to underline \"%s\" diagnostics.\\n  See |vim.lsp.diagnostic.set_underline()|', },\n-  { \"Floating\", 'Used to color \"%s\" diagnostic messages in diagnostics float.\\n  See |vim.lsp.diagnostic.show_line_diagnostics()|', },\n-  { \"Sign\", 'Used for \"%s\" signs in sing column.\\n  See |vim.lsp.diagnostic.set_signs()|', },\n-}\n-\n-local results = {}\n-for _, info in ipairs(all_info) do\n-  for _, level in ipairs(levels) do\n-    local name = info[1]\n-    local description = info[2]\n-    local fullname = string.format(\"Lsp%s%s\", name, level)\n-    table.insert(results, string.format(\n-      \"%78s\", string.format(\"*hl-%s*\", fullname))\n-    )\n-\n-    table.insert(results, fullname)\n-    table.insert(results, string.format(\"  %s\", description))\n-    table.insert(results, \"\")\n-  end\n-end\n-\n--- print(table.concat(results, '\\n'))\n-vim.fn.setreg(\"*\", table.concat(results, '\\n'))\n---]]\n-\n-local diagnostic_severities = {\n-  [DiagnosticSeverity.Error]       = { guifg = \"Red\" };\n-  [DiagnosticSeverity.Warning]     = { guifg = \"Orange\" };\n-  [DiagnosticSeverity.Information] = { guifg = \"LightBlue\" };\n-  [DiagnosticSeverity.Hint]        = { guifg = \"LightGrey\" };\n-}\n-\n--- Make a map from DiagnosticSeverity -> Highlight Name\n-local make_highlight_map = function(base_name)\n-  local result = {}\n-  for k, _ in pairs(diagnostic_severities) do\n-    result[k] = \"LspDiagnostics\" .. base_name .. DiagnosticSeverity[k]\n-  end\n-\n-  return result\n-end\n-\n-local default_highlight_map = make_highlight_map(\"Default\")\n-local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n-local underline_highlight_map = make_highlight_map(\"Underline\")\n-local floating_highlight_map = make_highlight_map(\"Floating\")\n-local sign_highlight_map = make_highlight_map(\"Sign\")\n-\n--- }}}\n--- Diagnostic Namespaces {{{\n local DEFAULT_CLIENT_ID = -1\n-local get_client_id = function(client_id)\n+---@private\n+local function get_client_id(client_id)\n   if client_id == nil then\n     client_id = DEFAULT_CLIENT_ID\n   end\n \n   return client_id\n end\n \n-local get_bufnr = function(bufnr)\n+---@private\n+local function get_bufnr(bufnr)\n   if not bufnr then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   elseif bufnr == 0 then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   end\n \n   return bufnr\n end\n \n-\n---- Create a namespace table, used to track a client's buffer local items\n-local _make_namespace_table = function(namespace, api_namespace)\n-  vim.validate { namespace = { namespace, 's' } }\n-\n-  return setmetatable({\n-    [DEFAULT_CLIENT_ID] = api.nvim_create_namespace(namespace)\n-  }, {\n-    __index = function(t, client_id)\n-      client_id = get_client_id(client_id)\n-\n-      if rawget(t, client_id) == nil then\n-        local value = string.format(\"%s:%s\", namespace, client_id)\n-\n-        if api_namespace then\n-          value = api.nvim_create_namespace(value)\n-        end\n-\n-        rawset(t, client_id, value)\n-      end\n-\n-      return rawget(t, client_id)\n-    end\n-  })\n+---@private\n+local function severity_lsp_to_vim(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.lsp.protocol.DiagnosticSeverity[severity]\n+  end\n+  return severity\n end\n \n-local _diagnostic_namespaces = _make_namespace_table(\"vim_lsp_diagnostics\", true)\n-local _sign_namespaces = _make_namespace_table(\"vim_lsp_signs\", false)\n-\n ---@private\n-function M._get_diagnostic_namespace(client_id)\n-  return _diagnostic_namespaces[client_id]\n+local function severity_vim_to_lsp(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.diagnostic.severity[severity]\n+  end\n+  return severity\n end\n \n ---@private\n-function M._get_sign_namespace(client_id)\n-  return _sign_namespaces[client_id]\n+local function diagnostic_lsp_to_vim(diagnostics)\n+  return vim.tbl_map(function(diagnostic)\n+    local start = diagnostic.range.start\n+    local _end = diagnostic.range[\"end\"]\n+    return {\n+      lnum = start.line,\n+      col = start.character,\n+      end_lnum = _end.line,\n+      end_col = _end.character,",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r707839811",
            "id": 707839811,
            "in_reply_to_id": 706609565,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qMMdD",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 62,
            "original_position": 196,
            "original_start_line": 59,
            "path": "runtime/lua/vim/lsp/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 753390614,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/707839811/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-14T01:41:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/707839811",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r707840385"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/707840385"
                }
            },
            "author_association": "MEMBER",
            "body": "Also, do you happen to have a simple test case for this that we can add to `lsp/diagnostic_spec.lua`? Right now there is no test for this behavior. If not, I'll try and whip something up.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-14T01:38:15Z",
            "diff_hunk": "@@ -57,338 +13,241 @@ end\n \n local M = {}\n \n--- Diagnostic Highlights {{{\n-\n--- TODO(tjdevries): Determine how to generate documentation for these\n---                  and how to configure them to be easy for users.\n---\n---                  For now, just use the following script. It should work pretty good.\n---[[\n-local levels = {\"Error\", \"Warning\", \"Information\", \"Hint\" }\n-\n-local all_info = {\n-  { \"Default\", \"Used as the base highlight group, other highlight groups link to\", },\n-  { \"VirtualText\", 'Used for \"%s\" diagnostic virtual text.\\n  See |vim.lsp.diagnostic.set_virtual_text()|', },\n-  { \"Underline\", 'Used to underline \"%s\" diagnostics.\\n  See |vim.lsp.diagnostic.set_underline()|', },\n-  { \"Floating\", 'Used to color \"%s\" diagnostic messages in diagnostics float.\\n  See |vim.lsp.diagnostic.show_line_diagnostics()|', },\n-  { \"Sign\", 'Used for \"%s\" signs in sing column.\\n  See |vim.lsp.diagnostic.set_signs()|', },\n-}\n-\n-local results = {}\n-for _, info in ipairs(all_info) do\n-  for _, level in ipairs(levels) do\n-    local name = info[1]\n-    local description = info[2]\n-    local fullname = string.format(\"Lsp%s%s\", name, level)\n-    table.insert(results, string.format(\n-      \"%78s\", string.format(\"*hl-%s*\", fullname))\n-    )\n-\n-    table.insert(results, fullname)\n-    table.insert(results, string.format(\"  %s\", description))\n-    table.insert(results, \"\")\n-  end\n-end\n-\n--- print(table.concat(results, '\\n'))\n-vim.fn.setreg(\"*\", table.concat(results, '\\n'))\n---]]\n-\n-local diagnostic_severities = {\n-  [DiagnosticSeverity.Error]       = { guifg = \"Red\" };\n-  [DiagnosticSeverity.Warning]     = { guifg = \"Orange\" };\n-  [DiagnosticSeverity.Information] = { guifg = \"LightBlue\" };\n-  [DiagnosticSeverity.Hint]        = { guifg = \"LightGrey\" };\n-}\n-\n--- Make a map from DiagnosticSeverity -> Highlight Name\n-local make_highlight_map = function(base_name)\n-  local result = {}\n-  for k, _ in pairs(diagnostic_severities) do\n-    result[k] = \"LspDiagnostics\" .. base_name .. DiagnosticSeverity[k]\n-  end\n-\n-  return result\n-end\n-\n-local default_highlight_map = make_highlight_map(\"Default\")\n-local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n-local underline_highlight_map = make_highlight_map(\"Underline\")\n-local floating_highlight_map = make_highlight_map(\"Floating\")\n-local sign_highlight_map = make_highlight_map(\"Sign\")\n-\n--- }}}\n--- Diagnostic Namespaces {{{\n local DEFAULT_CLIENT_ID = -1\n-local get_client_id = function(client_id)\n+---@private\n+local function get_client_id(client_id)\n   if client_id == nil then\n     client_id = DEFAULT_CLIENT_ID\n   end\n \n   return client_id\n end\n \n-local get_bufnr = function(bufnr)\n+---@private\n+local function get_bufnr(bufnr)\n   if not bufnr then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   elseif bufnr == 0 then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   end\n \n   return bufnr\n end\n \n-\n---- Create a namespace table, used to track a client's buffer local items\n-local _make_namespace_table = function(namespace, api_namespace)\n-  vim.validate { namespace = { namespace, 's' } }\n-\n-  return setmetatable({\n-    [DEFAULT_CLIENT_ID] = api.nvim_create_namespace(namespace)\n-  }, {\n-    __index = function(t, client_id)\n-      client_id = get_client_id(client_id)\n-\n-      if rawget(t, client_id) == nil then\n-        local value = string.format(\"%s:%s\", namespace, client_id)\n-\n-        if api_namespace then\n-          value = api.nvim_create_namespace(value)\n-        end\n-\n-        rawset(t, client_id, value)\n-      end\n-\n-      return rawget(t, client_id)\n-    end\n-  })\n+---@private\n+local function severity_lsp_to_vim(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.lsp.protocol.DiagnosticSeverity[severity]\n+  end\n+  return severity\n end\n \n-local _diagnostic_namespaces = _make_namespace_table(\"vim_lsp_diagnostics\", true)\n-local _sign_namespaces = _make_namespace_table(\"vim_lsp_signs\", false)\n-\n ---@private\n-function M._get_diagnostic_namespace(client_id)\n-  return _diagnostic_namespaces[client_id]\n+local function severity_vim_to_lsp(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.diagnostic.severity[severity]\n+  end\n+  return severity\n end\n \n ---@private\n-function M._get_sign_namespace(client_id)\n-  return _sign_namespaces[client_id]\n+local function diagnostic_lsp_to_vim(diagnostics)\n+  return vim.tbl_map(function(diagnostic)\n+    local start = diagnostic.range.start\n+    local _end = diagnostic.range[\"end\"]\n+    return {\n+      lnum = start.line,\n+      col = start.character,\n+      end_lnum = _end.line,\n+      end_col = _end.character,",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r707840385",
            "id": 707840385,
            "in_reply_to_id": 706609565,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qMMmB",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 62,
            "original_position": 196,
            "original_start_line": 59,
            "path": "runtime/lua/vim/lsp/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 753391252,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/707840385/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-14T01:38:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/707840385",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r708005084"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/708005084"
                }
            },
            "author_association": "MEMBER",
            "body": "> Why does this need to read the filesystem? Don't we just need `vim.str_byteindex()`?\r\n\r\n`str_byteindex` requires the line. For already loaded buffers it is possible to use `nvim_buf_get_lines`. For unloaded it would either be necessary to load them (reading vs + processing autocmds), or read the files directly, bypassing the autocmd processing. See https://github.com/neovim/neovim/pull/14615 \r\n\r\nI don't have a test-case at hand, but something where an error is in the same line as an emoji or so should trip it up.\r\n",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-14T07:48:54Z",
            "diff_hunk": "@@ -57,338 +13,241 @@ end\n \n local M = {}\n \n--- Diagnostic Highlights {{{\n-\n--- TODO(tjdevries): Determine how to generate documentation for these\n---                  and how to configure them to be easy for users.\n---\n---                  For now, just use the following script. It should work pretty good.\n---[[\n-local levels = {\"Error\", \"Warning\", \"Information\", \"Hint\" }\n-\n-local all_info = {\n-  { \"Default\", \"Used as the base highlight group, other highlight groups link to\", },\n-  { \"VirtualText\", 'Used for \"%s\" diagnostic virtual text.\\n  See |vim.lsp.diagnostic.set_virtual_text()|', },\n-  { \"Underline\", 'Used to underline \"%s\" diagnostics.\\n  See |vim.lsp.diagnostic.set_underline()|', },\n-  { \"Floating\", 'Used to color \"%s\" diagnostic messages in diagnostics float.\\n  See |vim.lsp.diagnostic.show_line_diagnostics()|', },\n-  { \"Sign\", 'Used for \"%s\" signs in sing column.\\n  See |vim.lsp.diagnostic.set_signs()|', },\n-}\n-\n-local results = {}\n-for _, info in ipairs(all_info) do\n-  for _, level in ipairs(levels) do\n-    local name = info[1]\n-    local description = info[2]\n-    local fullname = string.format(\"Lsp%s%s\", name, level)\n-    table.insert(results, string.format(\n-      \"%78s\", string.format(\"*hl-%s*\", fullname))\n-    )\n-\n-    table.insert(results, fullname)\n-    table.insert(results, string.format(\"  %s\", description))\n-    table.insert(results, \"\")\n-  end\n-end\n-\n--- print(table.concat(results, '\\n'))\n-vim.fn.setreg(\"*\", table.concat(results, '\\n'))\n---]]\n-\n-local diagnostic_severities = {\n-  [DiagnosticSeverity.Error]       = { guifg = \"Red\" };\n-  [DiagnosticSeverity.Warning]     = { guifg = \"Orange\" };\n-  [DiagnosticSeverity.Information] = { guifg = \"LightBlue\" };\n-  [DiagnosticSeverity.Hint]        = { guifg = \"LightGrey\" };\n-}\n-\n--- Make a map from DiagnosticSeverity -> Highlight Name\n-local make_highlight_map = function(base_name)\n-  local result = {}\n-  for k, _ in pairs(diagnostic_severities) do\n-    result[k] = \"LspDiagnostics\" .. base_name .. DiagnosticSeverity[k]\n-  end\n-\n-  return result\n-end\n-\n-local default_highlight_map = make_highlight_map(\"Default\")\n-local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n-local underline_highlight_map = make_highlight_map(\"Underline\")\n-local floating_highlight_map = make_highlight_map(\"Floating\")\n-local sign_highlight_map = make_highlight_map(\"Sign\")\n-\n--- }}}\n--- Diagnostic Namespaces {{{\n local DEFAULT_CLIENT_ID = -1\n-local get_client_id = function(client_id)\n+---@private\n+local function get_client_id(client_id)\n   if client_id == nil then\n     client_id = DEFAULT_CLIENT_ID\n   end\n \n   return client_id\n end\n \n-local get_bufnr = function(bufnr)\n+---@private\n+local function get_bufnr(bufnr)\n   if not bufnr then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   elseif bufnr == 0 then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   end\n \n   return bufnr\n end\n \n-\n---- Create a namespace table, used to track a client's buffer local items\n-local _make_namespace_table = function(namespace, api_namespace)\n-  vim.validate { namespace = { namespace, 's' } }\n-\n-  return setmetatable({\n-    [DEFAULT_CLIENT_ID] = api.nvim_create_namespace(namespace)\n-  }, {\n-    __index = function(t, client_id)\n-      client_id = get_client_id(client_id)\n-\n-      if rawget(t, client_id) == nil then\n-        local value = string.format(\"%s:%s\", namespace, client_id)\n-\n-        if api_namespace then\n-          value = api.nvim_create_namespace(value)\n-        end\n-\n-        rawset(t, client_id, value)\n-      end\n-\n-      return rawget(t, client_id)\n-    end\n-  })\n+---@private\n+local function severity_lsp_to_vim(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.lsp.protocol.DiagnosticSeverity[severity]\n+  end\n+  return severity\n end\n \n-local _diagnostic_namespaces = _make_namespace_table(\"vim_lsp_diagnostics\", true)\n-local _sign_namespaces = _make_namespace_table(\"vim_lsp_signs\", false)\n-\n ---@private\n-function M._get_diagnostic_namespace(client_id)\n-  return _diagnostic_namespaces[client_id]\n+local function severity_vim_to_lsp(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.diagnostic.severity[severity]\n+  end\n+  return severity\n end\n \n ---@private\n-function M._get_sign_namespace(client_id)\n-  return _sign_namespaces[client_id]\n+local function diagnostic_lsp_to_vim(diagnostics)\n+  return vim.tbl_map(function(diagnostic)\n+    local start = diagnostic.range.start\n+    local _end = diagnostic.range[\"end\"]\n+    return {\n+      lnum = start.line,\n+      col = start.character,\n+      end_lnum = _end.line,\n+      end_col = _end.character,",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r708005084",
            "id": 708005084,
            "in_reply_to_id": 706609565,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qM0zc",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 62,
            "original_position": 196,
            "original_start_line": 59,
            "path": "runtime/lua/vim/lsp/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 753592458,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708005084/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-14T07:52:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708005084",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r708270979"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/708270979"
                }
            },
            "author_association": "MEMBER",
            "body": "That makes sense. So if I'm understanding your suggestion here:\r\n\r\n>An alternative would be to store the col format as part of the diagnostics and make the conversion to byte column lazy?\r\n\r\nWe don't need to really convert the byte columns until the point where diagnostics are actually displayed somehow (either through decorations or via the quickfix list). So we could indicate in some fashion to defer that conversion until the point of display.\r\n\r\nI suppose we could support letting the `col` field of the diagnostic structure be a function, in which case it gets called in order to resolve the value.\r\n\r\nThis seems like a lot of additional complexity though and I'd want to be sure that the performance improvements are really worth it. So I'm leaning toward copying what folke did in #14615 first and then if we find that it's too slow we can try to be more clever.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-14T13:30:13Z",
            "diff_hunk": "@@ -57,338 +13,241 @@ end\n \n local M = {}\n \n--- Diagnostic Highlights {{{\n-\n--- TODO(tjdevries): Determine how to generate documentation for these\n---                  and how to configure them to be easy for users.\n---\n---                  For now, just use the following script. It should work pretty good.\n---[[\n-local levels = {\"Error\", \"Warning\", \"Information\", \"Hint\" }\n-\n-local all_info = {\n-  { \"Default\", \"Used as the base highlight group, other highlight groups link to\", },\n-  { \"VirtualText\", 'Used for \"%s\" diagnostic virtual text.\\n  See |vim.lsp.diagnostic.set_virtual_text()|', },\n-  { \"Underline\", 'Used to underline \"%s\" diagnostics.\\n  See |vim.lsp.diagnostic.set_underline()|', },\n-  { \"Floating\", 'Used to color \"%s\" diagnostic messages in diagnostics float.\\n  See |vim.lsp.diagnostic.show_line_diagnostics()|', },\n-  { \"Sign\", 'Used for \"%s\" signs in sing column.\\n  See |vim.lsp.diagnostic.set_signs()|', },\n-}\n-\n-local results = {}\n-for _, info in ipairs(all_info) do\n-  for _, level in ipairs(levels) do\n-    local name = info[1]\n-    local description = info[2]\n-    local fullname = string.format(\"Lsp%s%s\", name, level)\n-    table.insert(results, string.format(\n-      \"%78s\", string.format(\"*hl-%s*\", fullname))\n-    )\n-\n-    table.insert(results, fullname)\n-    table.insert(results, string.format(\"  %s\", description))\n-    table.insert(results, \"\")\n-  end\n-end\n-\n--- print(table.concat(results, '\\n'))\n-vim.fn.setreg(\"*\", table.concat(results, '\\n'))\n---]]\n-\n-local diagnostic_severities = {\n-  [DiagnosticSeverity.Error]       = { guifg = \"Red\" };\n-  [DiagnosticSeverity.Warning]     = { guifg = \"Orange\" };\n-  [DiagnosticSeverity.Information] = { guifg = \"LightBlue\" };\n-  [DiagnosticSeverity.Hint]        = { guifg = \"LightGrey\" };\n-}\n-\n--- Make a map from DiagnosticSeverity -> Highlight Name\n-local make_highlight_map = function(base_name)\n-  local result = {}\n-  for k, _ in pairs(diagnostic_severities) do\n-    result[k] = \"LspDiagnostics\" .. base_name .. DiagnosticSeverity[k]\n-  end\n-\n-  return result\n-end\n-\n-local default_highlight_map = make_highlight_map(\"Default\")\n-local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n-local underline_highlight_map = make_highlight_map(\"Underline\")\n-local floating_highlight_map = make_highlight_map(\"Floating\")\n-local sign_highlight_map = make_highlight_map(\"Sign\")\n-\n--- }}}\n--- Diagnostic Namespaces {{{\n local DEFAULT_CLIENT_ID = -1\n-local get_client_id = function(client_id)\n+---@private\n+local function get_client_id(client_id)\n   if client_id == nil then\n     client_id = DEFAULT_CLIENT_ID\n   end\n \n   return client_id\n end\n \n-local get_bufnr = function(bufnr)\n+---@private\n+local function get_bufnr(bufnr)\n   if not bufnr then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   elseif bufnr == 0 then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   end\n \n   return bufnr\n end\n \n-\n---- Create a namespace table, used to track a client's buffer local items\n-local _make_namespace_table = function(namespace, api_namespace)\n-  vim.validate { namespace = { namespace, 's' } }\n-\n-  return setmetatable({\n-    [DEFAULT_CLIENT_ID] = api.nvim_create_namespace(namespace)\n-  }, {\n-    __index = function(t, client_id)\n-      client_id = get_client_id(client_id)\n-\n-      if rawget(t, client_id) == nil then\n-        local value = string.format(\"%s:%s\", namespace, client_id)\n-\n-        if api_namespace then\n-          value = api.nvim_create_namespace(value)\n-        end\n-\n-        rawset(t, client_id, value)\n-      end\n-\n-      return rawget(t, client_id)\n-    end\n-  })\n+---@private\n+local function severity_lsp_to_vim(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.lsp.protocol.DiagnosticSeverity[severity]\n+  end\n+  return severity\n end\n \n-local _diagnostic_namespaces = _make_namespace_table(\"vim_lsp_diagnostics\", true)\n-local _sign_namespaces = _make_namespace_table(\"vim_lsp_signs\", false)\n-\n ---@private\n-function M._get_diagnostic_namespace(client_id)\n-  return _diagnostic_namespaces[client_id]\n+local function severity_vim_to_lsp(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.diagnostic.severity[severity]\n+  end\n+  return severity\n end\n \n ---@private\n-function M._get_sign_namespace(client_id)\n-  return _sign_namespaces[client_id]\n+local function diagnostic_lsp_to_vim(diagnostics)\n+  return vim.tbl_map(function(diagnostic)\n+    local start = diagnostic.range.start\n+    local _end = diagnostic.range[\"end\"]\n+    return {\n+      lnum = start.line,\n+      col = start.character,\n+      end_lnum = _end.line,\n+      end_col = _end.character,",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r708270979",
            "id": 708270979,
            "in_reply_to_id": 706609565,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qN1uD",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 62,
            "original_position": 196,
            "original_start_line": 59,
            "path": "runtime/lua/vim/lsp/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 753947914,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708270979/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-14T13:30:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708270979",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r708331046"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/708331046"
                }
            },
            "author_association": "MEMBER",
            "body": "@mfussenegger Can you review 4e18d1ed5 and dce4259a8?",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-14T14:29:54Z",
            "diff_hunk": "@@ -57,338 +13,241 @@ end\n \n local M = {}\n \n--- Diagnostic Highlights {{{\n-\n--- TODO(tjdevries): Determine how to generate documentation for these\n---                  and how to configure them to be easy for users.\n---\n---                  For now, just use the following script. It should work pretty good.\n---[[\n-local levels = {\"Error\", \"Warning\", \"Information\", \"Hint\" }\n-\n-local all_info = {\n-  { \"Default\", \"Used as the base highlight group, other highlight groups link to\", },\n-  { \"VirtualText\", 'Used for \"%s\" diagnostic virtual text.\\n  See |vim.lsp.diagnostic.set_virtual_text()|', },\n-  { \"Underline\", 'Used to underline \"%s\" diagnostics.\\n  See |vim.lsp.diagnostic.set_underline()|', },\n-  { \"Floating\", 'Used to color \"%s\" diagnostic messages in diagnostics float.\\n  See |vim.lsp.diagnostic.show_line_diagnostics()|', },\n-  { \"Sign\", 'Used for \"%s\" signs in sing column.\\n  See |vim.lsp.diagnostic.set_signs()|', },\n-}\n-\n-local results = {}\n-for _, info in ipairs(all_info) do\n-  for _, level in ipairs(levels) do\n-    local name = info[1]\n-    local description = info[2]\n-    local fullname = string.format(\"Lsp%s%s\", name, level)\n-    table.insert(results, string.format(\n-      \"%78s\", string.format(\"*hl-%s*\", fullname))\n-    )\n-\n-    table.insert(results, fullname)\n-    table.insert(results, string.format(\"  %s\", description))\n-    table.insert(results, \"\")\n-  end\n-end\n-\n--- print(table.concat(results, '\\n'))\n-vim.fn.setreg(\"*\", table.concat(results, '\\n'))\n---]]\n-\n-local diagnostic_severities = {\n-  [DiagnosticSeverity.Error]       = { guifg = \"Red\" };\n-  [DiagnosticSeverity.Warning]     = { guifg = \"Orange\" };\n-  [DiagnosticSeverity.Information] = { guifg = \"LightBlue\" };\n-  [DiagnosticSeverity.Hint]        = { guifg = \"LightGrey\" };\n-}\n-\n--- Make a map from DiagnosticSeverity -> Highlight Name\n-local make_highlight_map = function(base_name)\n-  local result = {}\n-  for k, _ in pairs(diagnostic_severities) do\n-    result[k] = \"LspDiagnostics\" .. base_name .. DiagnosticSeverity[k]\n-  end\n-\n-  return result\n-end\n-\n-local default_highlight_map = make_highlight_map(\"Default\")\n-local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n-local underline_highlight_map = make_highlight_map(\"Underline\")\n-local floating_highlight_map = make_highlight_map(\"Floating\")\n-local sign_highlight_map = make_highlight_map(\"Sign\")\n-\n--- }}}\n--- Diagnostic Namespaces {{{\n local DEFAULT_CLIENT_ID = -1\n-local get_client_id = function(client_id)\n+---@private\n+local function get_client_id(client_id)\n   if client_id == nil then\n     client_id = DEFAULT_CLIENT_ID\n   end\n \n   return client_id\n end\n \n-local get_bufnr = function(bufnr)\n+---@private\n+local function get_bufnr(bufnr)\n   if not bufnr then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   elseif bufnr == 0 then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   end\n \n   return bufnr\n end\n \n-\n---- Create a namespace table, used to track a client's buffer local items\n-local _make_namespace_table = function(namespace, api_namespace)\n-  vim.validate { namespace = { namespace, 's' } }\n-\n-  return setmetatable({\n-    [DEFAULT_CLIENT_ID] = api.nvim_create_namespace(namespace)\n-  }, {\n-    __index = function(t, client_id)\n-      client_id = get_client_id(client_id)\n-\n-      if rawget(t, client_id) == nil then\n-        local value = string.format(\"%s:%s\", namespace, client_id)\n-\n-        if api_namespace then\n-          value = api.nvim_create_namespace(value)\n-        end\n-\n-        rawset(t, client_id, value)\n-      end\n-\n-      return rawget(t, client_id)\n-    end\n-  })\n+---@private\n+local function severity_lsp_to_vim(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.lsp.protocol.DiagnosticSeverity[severity]\n+  end\n+  return severity\n end\n \n-local _diagnostic_namespaces = _make_namespace_table(\"vim_lsp_diagnostics\", true)\n-local _sign_namespaces = _make_namespace_table(\"vim_lsp_signs\", false)\n-\n ---@private\n-function M._get_diagnostic_namespace(client_id)\n-  return _diagnostic_namespaces[client_id]\n+local function severity_vim_to_lsp(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.diagnostic.severity[severity]\n+  end\n+  return severity\n end\n \n ---@private\n-function M._get_sign_namespace(client_id)\n-  return _sign_namespaces[client_id]\n+local function diagnostic_lsp_to_vim(diagnostics)\n+  return vim.tbl_map(function(diagnostic)\n+    local start = diagnostic.range.start\n+    local _end = diagnostic.range[\"end\"]\n+    return {\n+      lnum = start.line,\n+      col = start.character,\n+      end_lnum = _end.line,\n+      end_col = _end.character,",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r708331046",
            "id": 708331046,
            "in_reply_to_id": 706609565,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qOEYm",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 62,
            "original_position": 196,
            "original_start_line": 59,
            "path": "runtime/lua/vim/lsp/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 754030343,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708331046/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-14T14:29:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708331046",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r708391263"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/708391263"
                }
            },
            "author_association": "MEMBER",
            "body": "The specification uses UTF-16 and I think UTF-8 is the exception that is not even part of the specification. (afaik only clangd supports it).  So I'd tend to change the default value here",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-14T15:30:53Z",
            "diff_hunk": "@@ -57,250 +13,122 @@ end\n \n local M = {}\n \n--- Diagnostic Highlights {{{\n-\n--- TODO(tjdevries): Determine how to generate documentation for these\n---                  and how to configure them to be easy for users.\n---\n---                  For now, just use the following script. It should work pretty good.\n---[[\n-local levels = {\"Error\", \"Warning\", \"Information\", \"Hint\" }\n-\n-local all_info = {\n-  { \"Default\", \"Used as the base highlight group, other highlight groups link to\", },\n-  { \"VirtualText\", 'Used for \"%s\" diagnostic virtual text.\\n  See |vim.lsp.diagnostic.set_virtual_text()|', },\n-  { \"Underline\", 'Used to underline \"%s\" diagnostics.\\n  See |vim.lsp.diagnostic.set_underline()|', },\n-  { \"Floating\", 'Used to color \"%s\" diagnostic messages in diagnostics float.\\n  See |vim.lsp.diagnostic.show_line_diagnostics()|', },\n-  { \"Sign\", 'Used for \"%s\" signs in sing column.\\n  See |vim.lsp.diagnostic.set_signs()|', },\n-}\n-\n-local results = {}\n-for _, info in ipairs(all_info) do\n-  for _, level in ipairs(levels) do\n-    local name = info[1]\n-    local description = info[2]\n-    local fullname = string.format(\"Lsp%s%s\", name, level)\n-    table.insert(results, string.format(\n-      \"%78s\", string.format(\"*hl-%s*\", fullname))\n-    )\n-\n-    table.insert(results, fullname)\n-    table.insert(results, string.format(\"  %s\", description))\n-    table.insert(results, \"\")\n-  end\n-end\n-\n--- print(table.concat(results, '\\n'))\n-vim.fn.setreg(\"*\", table.concat(results, '\\n'))\n---]]\n-\n-local diagnostic_severities = {\n-  [DiagnosticSeverity.Error]       = { guifg = \"Red\" };\n-  [DiagnosticSeverity.Warning]     = { guifg = \"Orange\" };\n-  [DiagnosticSeverity.Information] = { guifg = \"LightBlue\" };\n-  [DiagnosticSeverity.Hint]        = { guifg = \"LightGrey\" };\n-}\n-\n--- Make a map from DiagnosticSeverity -> Highlight Name\n-local make_highlight_map = function(base_name)\n-  local result = {}\n-  for k, _ in pairs(diagnostic_severities) do\n-    result[k] = \"LspDiagnostics\" .. base_name .. DiagnosticSeverity[k]\n-  end\n-\n-  return result\n-end\n-\n-local default_highlight_map = make_highlight_map(\"Default\")\n-local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n-local underline_highlight_map = make_highlight_map(\"Underline\")\n-local floating_highlight_map = make_highlight_map(\"Floating\")\n-local sign_highlight_map = make_highlight_map(\"Sign\")\n-\n--- }}}\n--- Diagnostic Namespaces {{{\n local DEFAULT_CLIENT_ID = -1\n-local get_client_id = function(client_id)\n+---@private\n+local function get_client_id(client_id)\n   if client_id == nil then\n     client_id = DEFAULT_CLIENT_ID\n   end\n \n   return client_id\n end\n \n-local get_bufnr = function(bufnr)\n+---@private\n+local function get_bufnr(bufnr)\n   if not bufnr then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   elseif bufnr == 0 then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   end\n \n   return bufnr\n end\n \n-\n---- Create a namespace table, used to track a client's buffer local items\n-local _make_namespace_table = function(namespace, api_namespace)\n-  vim.validate { namespace = { namespace, 's' } }\n-\n-  return setmetatable({\n-    [DEFAULT_CLIENT_ID] = api.nvim_create_namespace(namespace)\n-  }, {\n-    __index = function(t, client_id)\n-      client_id = get_client_id(client_id)\n-\n-      if rawget(t, client_id) == nil then\n-        local value = string.format(\"%s:%s\", namespace, client_id)\n-\n-        if api_namespace then\n-          value = api.nvim_create_namespace(value)\n-        end\n-\n-        rawset(t, client_id, value)\n-      end\n-\n-      return rawget(t, client_id)\n-    end\n-  })\n-end\n-\n-local _diagnostic_namespaces = _make_namespace_table(\"vim_lsp_diagnostics\", true)\n-local _sign_namespaces = _make_namespace_table(\"vim_lsp_signs\", false)\n-\n ---@private\n-function M._get_diagnostic_namespace(client_id)\n-  return _diagnostic_namespaces[client_id]\n+local function severity_lsp_to_vim(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.lsp.protocol.DiagnosticSeverity[severity]\n+  end\n+  return severity\n end\n \n ---@private\n-function M._get_sign_namespace(client_id)\n-  return _sign_namespaces[client_id]\n-end\n--- }}}\n--- Diagnostic Buffer & Client metatables {{{\n-local bufnr_and_client_cacher_mt = {\n-  __index = function(t, bufnr)\n-    if bufnr == 0 or bufnr == nil then\n-      bufnr = vim.api.nvim_get_current_buf()\n-    end\n-\n-    if rawget(t, bufnr) == nil then\n-      rawset(t, bufnr, {})\n-    end\n-\n-    return rawget(t, bufnr)\n-  end,\n-\n-  __newindex = function(t, bufnr, v)\n-    if bufnr == 0 or bufnr == nil then\n-      bufnr = vim.api.nvim_get_current_buf()\n-    end\n-\n-    rawset(t, bufnr, v)\n-  end,\n-}\n--- }}}\n--- Diagnostic Saving & Caching {{{\n-local _diagnostic_cleanup = setmetatable({}, bufnr_and_client_cacher_mt)\n-local diagnostic_cache = setmetatable({}, bufnr_and_client_cacher_mt)\n-local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_client_cacher_mt)\n-local diagnostic_cache_lines = setmetatable({}, bufnr_and_client_cacher_mt)\n-local diagnostic_cache_counts = setmetatable({}, bufnr_and_client_cacher_mt)\n-local diagnostic_attached_buffers = {}\n-\n--- Disabled buffers and clients\n-local diagnostic_disabled = setmetatable({}, bufnr_and_client_cacher_mt)\n-\n-local _bufs_waiting_to_update = setmetatable({}, bufnr_and_client_cacher_mt)\n-\n---- Store Diagnostic[] by line\n----\n----@param diagnostics Diagnostic[]\n----@return table<number, Diagnostic[]>\n-local _diagnostic_lines = function(diagnostics)\n-  if not diagnostics then return end\n-\n-  local diagnostics_by_line = {}\n-  for _, diagnostic in ipairs(diagnostics) do\n-    local start = diagnostic.range.start\n-    local line_diagnostics = diagnostics_by_line[start.line]\n-    if not line_diagnostics then\n-      line_diagnostics = {}\n-      diagnostics_by_line[start.line] = line_diagnostics\n-    end\n-    table.insert(line_diagnostics, diagnostic)\n+local function severity_vim_to_lsp(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.diagnostic.severity[severity]\n   end\n-  return diagnostics_by_line\n+  return severity\n end\n \n---- Get the count of M by Severity\n----\n----@param diagnostics Diagnostic[]\n----@return table<DiagnosticSeverity, number>\n-local _diagnostic_counts = function(diagnostics)\n-  if not diagnostics then return end\n-\n-  local counts = {}\n-  for _, diagnostic in pairs(diagnostics) do\n-    if diagnostic.severity then\n-      local val = counts[diagnostic.severity]\n-      if val == nil then\n-        val = 0\n-      end\n+---@private\n+local function line_byte_from_position(lines, lnum, col, offset_encoding)\n+  if offset_encoding == \"utf-8\" then\n+    return col\n+  end\n \n-      counts[diagnostic.severity] = val + 1\n-    end\n+  local line = lines[lnum + 1]\n+  local ok, result = pcall(vim.str_byteindex, line, col, offset_encoding == \"utf-16\")\n+  if ok then\n+    return result\n   end\n \n-  return counts\n+  return col\n end\n \n ---@private\n---- Set the different diagnostic cache after `textDocument/publishDiagnostics`\n----@param diagnostics Diagnostic[]\n----@param bufnr number\n----@param client_id number\n----@return nil\n-local function set_diagnostic_cache(diagnostics, bufnr, client_id)\n-  client_id = get_client_id(client_id)\n-\n-  -- https://microsoft.github.io/language-server-protocol/specifications/specification-current/#diagnostic\n-  --\n-  -- The diagnostic's severity. Can be omitted. If omitted it is up to the\n-  -- client to interpret diagnostics as error, warning, info or hint.\n-  -- TODO: Replace this with server-specific heuristics to infer severity.\n-  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n-  for _, diagnostic in ipairs(diagnostics) do\n-    if diagnostic.severity == nil then\n-      diagnostic.severity = DiagnosticSeverity.Error\n-    end\n-    -- Account for servers that place diagnostics on terminating newline\n-    if buf_line_count > 0 then\n-      diagnostic.range.start.line = math.max(math.min(\n-        diagnostic.range.start.line, buf_line_count - 1\n-      ), 0)\n-      diagnostic.range[\"end\"].line = math.max(math.min(\n-        diagnostic.range[\"end\"].line, buf_line_count - 1\n-      ), 0)\n-    end\n+local function get_buf_lines(bufnr)\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    return vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)\n   end\n \n-  diagnostic_cache[bufnr][client_id] = diagnostics\n-  diagnostic_cache_lines[bufnr][client_id] = _diagnostic_lines(diagnostics)\n-  diagnostic_cache_counts[bufnr][client_id] = _diagnostic_counts(diagnostics)\n+  local filename = vim.api.nvim_buf_get_name(bufnr)\n+  local f = io.open(filename)\n+  local lines = vim.split(f:read(\"*a\"), \"\\n\")\n+  f:close()\n+  return lines\n end\n \n+---@private\n+local function diagnostic_lsp_to_vim(diagnostics, bufnr, client_id)\n+  local buf_lines = get_buf_lines(bufnr)\n+  local client = vim.lsp.get_client_by_id(client_id)\n+  local offset_encoding = client and client.offset_encoding or \"utf-8\"",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r708391263",
            "id": 708391263,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qOTFf",
            "original_commit_id": "4a8cc05b1b2bb0d68e492d0006e738d3d1545d5d",
            "original_line": 85,
            "original_position": 323,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 754110642,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708391263/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-14T15:31:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708391263",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r708393192"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/708393192"
                }
            },
            "author_association": "MEMBER",
            "body": "Looks good :+1: \r\n\r\n> This seems like a lot of additional complexity though and I'd want to be sure that the performance improvements are really worth it. So I'm leaning toward copying what folke did in #14615 first and then if we find that it's too slow we can try to be more clever.\r\n\r\n:100: ",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-14T15:32:56Z",
            "diff_hunk": "@@ -57,338 +13,241 @@ end\n \n local M = {}\n \n--- Diagnostic Highlights {{{\n-\n--- TODO(tjdevries): Determine how to generate documentation for these\n---                  and how to configure them to be easy for users.\n---\n---                  For now, just use the following script. It should work pretty good.\n---[[\n-local levels = {\"Error\", \"Warning\", \"Information\", \"Hint\" }\n-\n-local all_info = {\n-  { \"Default\", \"Used as the base highlight group, other highlight groups link to\", },\n-  { \"VirtualText\", 'Used for \"%s\" diagnostic virtual text.\\n  See |vim.lsp.diagnostic.set_virtual_text()|', },\n-  { \"Underline\", 'Used to underline \"%s\" diagnostics.\\n  See |vim.lsp.diagnostic.set_underline()|', },\n-  { \"Floating\", 'Used to color \"%s\" diagnostic messages in diagnostics float.\\n  See |vim.lsp.diagnostic.show_line_diagnostics()|', },\n-  { \"Sign\", 'Used for \"%s\" signs in sing column.\\n  See |vim.lsp.diagnostic.set_signs()|', },\n-}\n-\n-local results = {}\n-for _, info in ipairs(all_info) do\n-  for _, level in ipairs(levels) do\n-    local name = info[1]\n-    local description = info[2]\n-    local fullname = string.format(\"Lsp%s%s\", name, level)\n-    table.insert(results, string.format(\n-      \"%78s\", string.format(\"*hl-%s*\", fullname))\n-    )\n-\n-    table.insert(results, fullname)\n-    table.insert(results, string.format(\"  %s\", description))\n-    table.insert(results, \"\")\n-  end\n-end\n-\n--- print(table.concat(results, '\\n'))\n-vim.fn.setreg(\"*\", table.concat(results, '\\n'))\n---]]\n-\n-local diagnostic_severities = {\n-  [DiagnosticSeverity.Error]       = { guifg = \"Red\" };\n-  [DiagnosticSeverity.Warning]     = { guifg = \"Orange\" };\n-  [DiagnosticSeverity.Information] = { guifg = \"LightBlue\" };\n-  [DiagnosticSeverity.Hint]        = { guifg = \"LightGrey\" };\n-}\n-\n--- Make a map from DiagnosticSeverity -> Highlight Name\n-local make_highlight_map = function(base_name)\n-  local result = {}\n-  for k, _ in pairs(diagnostic_severities) do\n-    result[k] = \"LspDiagnostics\" .. base_name .. DiagnosticSeverity[k]\n-  end\n-\n-  return result\n-end\n-\n-local default_highlight_map = make_highlight_map(\"Default\")\n-local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n-local underline_highlight_map = make_highlight_map(\"Underline\")\n-local floating_highlight_map = make_highlight_map(\"Floating\")\n-local sign_highlight_map = make_highlight_map(\"Sign\")\n-\n--- }}}\n--- Diagnostic Namespaces {{{\n local DEFAULT_CLIENT_ID = -1\n-local get_client_id = function(client_id)\n+---@private\n+local function get_client_id(client_id)\n   if client_id == nil then\n     client_id = DEFAULT_CLIENT_ID\n   end\n \n   return client_id\n end\n \n-local get_bufnr = function(bufnr)\n+---@private\n+local function get_bufnr(bufnr)\n   if not bufnr then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   elseif bufnr == 0 then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   end\n \n   return bufnr\n end\n \n-\n---- Create a namespace table, used to track a client's buffer local items\n-local _make_namespace_table = function(namespace, api_namespace)\n-  vim.validate { namespace = { namespace, 's' } }\n-\n-  return setmetatable({\n-    [DEFAULT_CLIENT_ID] = api.nvim_create_namespace(namespace)\n-  }, {\n-    __index = function(t, client_id)\n-      client_id = get_client_id(client_id)\n-\n-      if rawget(t, client_id) == nil then\n-        local value = string.format(\"%s:%s\", namespace, client_id)\n-\n-        if api_namespace then\n-          value = api.nvim_create_namespace(value)\n-        end\n-\n-        rawset(t, client_id, value)\n-      end\n-\n-      return rawget(t, client_id)\n-    end\n-  })\n+---@private\n+local function severity_lsp_to_vim(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.lsp.protocol.DiagnosticSeverity[severity]\n+  end\n+  return severity\n end\n \n-local _diagnostic_namespaces = _make_namespace_table(\"vim_lsp_diagnostics\", true)\n-local _sign_namespaces = _make_namespace_table(\"vim_lsp_signs\", false)\n-\n ---@private\n-function M._get_diagnostic_namespace(client_id)\n-  return _diagnostic_namespaces[client_id]\n+local function severity_vim_to_lsp(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.diagnostic.severity[severity]\n+  end\n+  return severity\n end\n \n ---@private\n-function M._get_sign_namespace(client_id)\n-  return _sign_namespaces[client_id]\n+local function diagnostic_lsp_to_vim(diagnostics)\n+  return vim.tbl_map(function(diagnostic)\n+    local start = diagnostic.range.start\n+    local _end = diagnostic.range[\"end\"]\n+    return {\n+      lnum = start.line,\n+      col = start.character,\n+      end_lnum = _end.line,\n+      end_col = _end.character,",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r708393192",
            "id": 708393192,
            "in_reply_to_id": 706609565,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qOTjo",
            "original_commit_id": "d9d077df004dfe046a74beba652b8f89c3d11b34",
            "original_line": 62,
            "original_position": 196,
            "original_start_line": 59,
            "path": "runtime/lua/vim/lsp/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 754113158,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708393192/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-14T15:32:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708393192",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r708408187"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/708408187"
                }
            },
            "author_association": "MEMBER",
            "body": "instead of `buffer` shouldn't this function take an (optional) window? IIUC if the buffer is displayed in multiple windows, each window still has a separate loclist.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-14T15:49:19Z",
            "diff_hunk": "@@ -0,0 +1,520 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based\n+rows and columns). |api-indexing|\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+\t\t\t\t\t\t\t*diagnostic-highlights*\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultWarn*\n+DiagnosticDefaultWarn\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultInfo*\n+DiagnosticDefaultInfo\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultHint*\n+DiagnosticDefaultHint\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+\n+==============================================================================\n+Events\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed in a loaded buffer.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:- `false`: Disable this feature - `true`: Enable this\n+                    feature, use default settings. - `table`: Enable this\n+                    feature with overrides. - `function`: Function with\n+                    signature (namespace, bufnr) that returns any of the\n+                    above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                   |vim.diagnostic.set_underline()|\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                   |vim.diagnostic.set_virtual_text()|\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics |vim.diagnostic.set_signs()|\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({bufnr}, {namespace})                       *vim.diagnostic.disable()*\n+                Disable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer handle. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only disable diagnostics for the\n+                                 given namespace.\n+\n+enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*\n+                Enable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer handle. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only enable diagnostics for the\n+                                 given namespace.\n+\n+get({bufnr}, {namespace})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil The buffer number to get\n+                                 diagnistics from. Use 0 for current buffer.\n+                                 If `nil` , retrieve diagnostics from all\n+                                 buffers.\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({bufnr}, {severity}, {namespace})\n+                Get the number of diagnostics with the given severity.\n+\n+                Useful for showing diagnostic counts in statusline. eg: >\n+\n+                 function! DiagnosticStatus() abort\n+                   let sl = ''\n+                   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(0, vim.diagnostic.severity.ERROR)\")} '\n+                   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(0, vim.diagnostic.severity.WARN)\")}'\n+                   return sl\n+                 endfunction\n+<\n+\n+                Then simply add `%{DiagnosticStatus()}` to your statusline.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil The buffer number. Use 0 for\n+                                 current buffer. If `nil` , count diagnostics\n+                                 from all buffers.\n+                    {severity}   |vim.diagnostic.severity| Count only\n+                                 diagnostics for the given severity. If\n+                                 omitted, count all diagnostics.\n+                    {namespace}  number|nil Count only diagnostics from the\n+                                 given namespace.\n+\n+                                       *vim.diagnostic.get_line_diagnostics()*\n+get_line_diagnostics({bufnr}, {lnum}, {opts})\n+                Get diagnostics by line.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace. If `nil` , retrieve diagnostics\n+                                 from all namespaces.\n+                    {bufnr}      number|nil The buffer number. Defaults to the\n+                                 current buffer.\n+                    {lnum}       number|nil The line number. Defaults to the\n+                                 current line.\n+                    {opts}       table|nil A table with the following keys:\n+                                 • namespace: (number) Limit diagnostics to\n+                                   the given namespace.\n+                                 • severity: (|vim.diagnostic.severity|) Only\n+                                   return diagnostics with this severity.\n+                                   Conflicts with {min_severity}.\n+                                 • min_severity: (|vim.diagnostic.severity|)\n+                                   Return diagnostics with this severity or\n+                                   worse. Conflicts with {severity}.\n+\n+                Return: ~\n+                    table Table with map of line number to list of\n+                    diagnostics.\n+\n+get_next({opts})                                   *vim.diagnostic.get_next()*\n+                Get the next diagnostic closest to the cursor position.\n+\n+                Parameters: ~\n+                    {opts}  table See |vim.diagnostic.goto_next()|\n+\n+                Return: ~\n+                    table Next diagnostic\n+\n+get_next_pos({opts})                           *vim.diagnostic.get_next_pos()*\n+                Return the position of the next diagnostic in the current\n+                buffer.\n+\n+                Parameters: ~\n+                    {opts}  table See |vim.diagnostic.goto_next()|\n+\n+                Return: ~\n+                    table Next diagnostic position as a (row, col) tuple.\n+\n+get_prev({opts})                                   *vim.diagnostic.get_prev()*\n+                Get the previous diagnostic closest to the cursor position.\n+\n+                Parameters: ~\n+                    {opts}  table See |vim.diagnostic.goto_next()|\n+\n+                Return: ~\n+                    table Previous diagnostic\n+\n+get_prev_pos({opts})                           *vim.diagnostic.get_prev_pos()*\n+                Return the position of the previous diagnostic in the current\n+                buffer.\n+\n+                Parameters: ~\n+                    {opts}  table See |vim.diagnostic.goto_next()|\n+\n+                Return: ~\n+                    table Previous diagnostic position as a (row, col) tuple.\n+\n+                                       *vim.diagnostic.get_virt_text_chunks()*\n+get_virt_text_chunks({line_diags}, {opts})\n+                Get virtual text chunks to display using\n+                |nvim_buf_set_extmark()|.\n+\n+                Parameters: ~\n+                    {line_diags}  table The diagnostics associated with the\n+                                  line |vim.diagnostic.get_line_diagnostics()|\n+                    {opts}        table|nil Configuration table with the\n+                                  following keys:\n+                                  • prefix: (string) Prefix to display before\n+                                    virtual text on line\n+                                  • spacing: (number) Number of spaces to\n+                                    insert before virtual text\n+\n+                Return: ~\n+                    an array of [text, hl_group] arrays. This can be passed\n+                    directly to the {virt_text} option of\n+                    |nvim_buf_set_extmark()|.\n+\n+goto_next({opts})                                 *vim.diagnostic.goto_next()*\n+                Move to the next diagnostic.\n+\n+                Parameters: ~\n+                    {opts}  table|nil Configuration table with the following\n+                            keys:\n+                            • namespace: (number) Only consider diagnostics\n+                              from the given namespace.\n+                            • cursor_position: (cursor position) Cursor\n+                              position as a (row, col) tuple. See\n+                              |nvim_win_get_cursor()|. Defaults to the current\n+                              cursor position.\n+                            • wrap: (boolean, default true) Whether to loop\n+                              around file or not. Similar to 'wrapscan'.\n+                            • severity: (|vim.diagnostic.severity|) Only\n+                              return diagnostics with this severity. Conflicts\n+                              with {min_severity}.\n+                            • min_severity: (|vim.diagnostic.severity|) Return\n+                              diagnostics with this severity or worse.\n+                              Conflicts with {severity}.\n+                            • enable_popup: (boolean, default true) Call\n+                              |vim.diagnostic.show_line_diagnostics()| on\n+                              jump.\n+                            • popup_opts: (table) Table to pass as {opts}\n+                              parameter to\n+                              |vim.diagnostic.show_line_diagnostics()|\n+                            • win_id: (number, default 0) Window ID\n+\n+goto_prev({opts})                                 *vim.diagnostic.goto_prev()*\n+                Move to the previous diagnostic in the current buffer.\n+\n+                Parameters: ~\n+                    {opts}  table See |vim.diagnostic.goto_next()|\n+\n+hide({namespace}, {bufnr})                             *vim.diagnostic.hide()*\n+                Hide currently displayed diagnostics.\n+\n+                This only clears the decorations displayed in the buffer.\n+                Diagnostics can be redisplayed with |vim.diagnostic.show()|.\n+                To completely remove diagnostics, use\n+                |vim.diagnostic.reset()|.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Only clear diagnostics in the\n+                                 given buffer. Defaults to the current buffer.\n+\n+reset({namespace}, {bufnr})                           *vim.diagnostic.reset()*\n+                Remove all diagnostics from the given namespace.\n+\n+                Unlike |vim.diagnostic.hide()|, this function removes all\n+                saved diagnostics. They cannot be redisplayed using\n+                |vim.diagnostic.show()|. To simply remove diagnostic\n+                decorations in a way that they can be re-displayed, use\n+                |vim.diagnostic.hide()|.\n+\n+                Parameters: ~\n+                    {namespace}  number\n+                    {bufnr}      number|nil Remove diagnostics for the given\n+                                 buffer. If omitted, diagnostics are removed\n+                                 for all buffers.\n+\n+set({namespace}, {diagnostics}, {bufnr}, {opts})        *vim.diagnostic.set()*\n+                Set diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}    number The diagnostic namespace\n+                    {diagnostics}  table A list of diagnostic items\n+                                   |diagnostic-structure|\n+                    {bufnr}        number|nil The buffer to set diagnostics\n+                                   for. Defaults to the current buffer.\n+                    {opts}         table|nil Display options to pass to\n+                                   |vim.diagnostic.show()|\n+\n+setloclist({opts})                               *vim.diagnostic.setloclist()*\n+                Add diagnostics to the location list.\n+\n+                By default, adds diagnostics for the current buffer in all\n+                namespaces.\n+\n+                Parameters: ~\n+                    {opts}  table|nil Configuration table with the following\n+                            keys:\n+                            • namespace: (number) Only add diagnostics from\n+                              the given namespace.\n+                            • bufnr: (number, default 0) Only add diagnostics",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r708408187",
            "id": 708408187,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qOXN7",
            "original_commit_id": "4a8cc05b1b2bb0d68e492d0006e738d3d1545d5d",
            "original_line": 427,
            "original_position": 427,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 754133035,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708408187/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-14T15:49:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708408187",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1363104?v=4",
                "events_url": "https://api.github.com/users/bfredl/events{/privacy}",
                "followers_url": "https://api.github.com/users/bfredl/followers",
                "following_url": "https://api.github.com/users/bfredl/following{/other_user}",
                "gists_url": "https://api.github.com/users/bfredl/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/bfredl",
                "id": 1363104,
                "login": "bfredl",
                "node_id": "MDQ6VXNlcjEzNjMxMDQ=",
                "organizations_url": "https://api.github.com/users/bfredl/orgs",
                "received_events_url": "https://api.github.com/users/bfredl/received_events",
                "repos_url": "https://api.github.com/users/bfredl/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/bfredl/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/bfredl/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/bfredl"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r708429913"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/708429913"
                }
            },
            "author_association": "MEMBER",
            "body": "Yep, good catch, thanks.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-14T16:14:03Z",
            "diff_hunk": "@@ -0,0 +1,520 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based\n+rows and columns). |api-indexing|\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+\t\t\t\t\t\t\t*diagnostic-highlights*\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultWarn*\n+DiagnosticDefaultWarn\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultInfo*\n+DiagnosticDefaultInfo\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t*hl-DiagnosticDefaultHint*\n+DiagnosticDefaultHint\n+  Used as the base highlight group.\n+  Other LspDiagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+\n+==============================================================================\n+Events\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed in a loaded buffer.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:- `false`: Disable this feature - `true`: Enable this\n+                    feature, use default settings. - `table`: Enable this\n+                    feature with overrides. - `function`: Function with\n+                    signature (namespace, bufnr) that returns any of the\n+                    above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                   |vim.diagnostic.set_underline()|\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                   |vim.diagnostic.set_virtual_text()|\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics |vim.diagnostic.set_signs()|\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({bufnr}, {namespace})                       *vim.diagnostic.disable()*\n+                Disable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer handle. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only disable diagnostics for the\n+                                 given namespace.\n+\n+enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*\n+                Enable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer handle. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only enable diagnostics for the\n+                                 given namespace.\n+\n+get({bufnr}, {namespace})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil The buffer number to get\n+                                 diagnistics from. Use 0 for current buffer.\n+                                 If `nil` , retrieve diagnostics from all\n+                                 buffers.\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({bufnr}, {severity}, {namespace})\n+                Get the number of diagnostics with the given severity.\n+\n+                Useful for showing diagnostic counts in statusline. eg: >\n+\n+                 function! DiagnosticStatus() abort\n+                   let sl = ''\n+                   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(0, vim.diagnostic.severity.ERROR)\")} '\n+                   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(0, vim.diagnostic.severity.WARN)\")}'\n+                   return sl\n+                 endfunction\n+<\n+\n+                Then simply add `%{DiagnosticStatus()}` to your statusline.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil The buffer number. Use 0 for\n+                                 current buffer. If `nil` , count diagnostics\n+                                 from all buffers.\n+                    {severity}   |vim.diagnostic.severity| Count only\n+                                 diagnostics for the given severity. If\n+                                 omitted, count all diagnostics.\n+                    {namespace}  number|nil Count only diagnostics from the\n+                                 given namespace.\n+\n+                                       *vim.diagnostic.get_line_diagnostics()*\n+get_line_diagnostics({bufnr}, {lnum}, {opts})\n+                Get diagnostics by line.\n+\n+                Parameters: ~\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace. If `nil` , retrieve diagnostics\n+                                 from all namespaces.\n+                    {bufnr}      number|nil The buffer number. Defaults to the\n+                                 current buffer.\n+                    {lnum}       number|nil The line number. Defaults to the\n+                                 current line.\n+                    {opts}       table|nil A table with the following keys:\n+                                 • namespace: (number) Limit diagnostics to\n+                                   the given namespace.\n+                                 • severity: (|vim.diagnostic.severity|) Only\n+                                   return diagnostics with this severity.\n+                                   Conflicts with {min_severity}.\n+                                 • min_severity: (|vim.diagnostic.severity|)\n+                                   Return diagnostics with this severity or\n+                                   worse. Conflicts with {severity}.\n+\n+                Return: ~\n+                    table Table with map of line number to list of\n+                    diagnostics.\n+\n+get_next({opts})                                   *vim.diagnostic.get_next()*\n+                Get the next diagnostic closest to the cursor position.\n+\n+                Parameters: ~\n+                    {opts}  table See |vim.diagnostic.goto_next()|\n+\n+                Return: ~\n+                    table Next diagnostic\n+\n+get_next_pos({opts})                           *vim.diagnostic.get_next_pos()*\n+                Return the position of the next diagnostic in the current\n+                buffer.\n+\n+                Parameters: ~\n+                    {opts}  table See |vim.diagnostic.goto_next()|\n+\n+                Return: ~\n+                    table Next diagnostic position as a (row, col) tuple.\n+\n+get_prev({opts})                                   *vim.diagnostic.get_prev()*\n+                Get the previous diagnostic closest to the cursor position.\n+\n+                Parameters: ~\n+                    {opts}  table See |vim.diagnostic.goto_next()|\n+\n+                Return: ~\n+                    table Previous diagnostic\n+\n+get_prev_pos({opts})                           *vim.diagnostic.get_prev_pos()*\n+                Return the position of the previous diagnostic in the current\n+                buffer.\n+\n+                Parameters: ~\n+                    {opts}  table See |vim.diagnostic.goto_next()|\n+\n+                Return: ~\n+                    table Previous diagnostic position as a (row, col) tuple.\n+\n+                                       *vim.diagnostic.get_virt_text_chunks()*\n+get_virt_text_chunks({line_diags}, {opts})\n+                Get virtual text chunks to display using\n+                |nvim_buf_set_extmark()|.\n+\n+                Parameters: ~\n+                    {line_diags}  table The diagnostics associated with the\n+                                  line |vim.diagnostic.get_line_diagnostics()|\n+                    {opts}        table|nil Configuration table with the\n+                                  following keys:\n+                                  • prefix: (string) Prefix to display before\n+                                    virtual text on line\n+                                  • spacing: (number) Number of spaces to\n+                                    insert before virtual text\n+\n+                Return: ~\n+                    an array of [text, hl_group] arrays. This can be passed\n+                    directly to the {virt_text} option of\n+                    |nvim_buf_set_extmark()|.\n+\n+goto_next({opts})                                 *vim.diagnostic.goto_next()*\n+                Move to the next diagnostic.\n+\n+                Parameters: ~\n+                    {opts}  table|nil Configuration table with the following\n+                            keys:\n+                            • namespace: (number) Only consider diagnostics\n+                              from the given namespace.\n+                            • cursor_position: (cursor position) Cursor\n+                              position as a (row, col) tuple. See\n+                              |nvim_win_get_cursor()|. Defaults to the current\n+                              cursor position.\n+                            • wrap: (boolean, default true) Whether to loop\n+                              around file or not. Similar to 'wrapscan'.\n+                            • severity: (|vim.diagnostic.severity|) Only\n+                              return diagnostics with this severity. Conflicts\n+                              with {min_severity}.\n+                            • min_severity: (|vim.diagnostic.severity|) Return\n+                              diagnostics with this severity or worse.\n+                              Conflicts with {severity}.\n+                            • enable_popup: (boolean, default true) Call\n+                              |vim.diagnostic.show_line_diagnostics()| on\n+                              jump.\n+                            • popup_opts: (table) Table to pass as {opts}\n+                              parameter to\n+                              |vim.diagnostic.show_line_diagnostics()|\n+                            • win_id: (number, default 0) Window ID\n+\n+goto_prev({opts})                                 *vim.diagnostic.goto_prev()*\n+                Move to the previous diagnostic in the current buffer.\n+\n+                Parameters: ~\n+                    {opts}  table See |vim.diagnostic.goto_next()|\n+\n+hide({namespace}, {bufnr})                             *vim.diagnostic.hide()*\n+                Hide currently displayed diagnostics.\n+\n+                This only clears the decorations displayed in the buffer.\n+                Diagnostics can be redisplayed with |vim.diagnostic.show()|.\n+                To completely remove diagnostics, use\n+                |vim.diagnostic.reset()|.\n+\n+                Parameters: ~\n+                    {namespace}  number The diagnostic namespace\n+                    {bufnr}      number|nil Only clear diagnostics in the\n+                                 given buffer. Defaults to the current buffer.\n+\n+reset({namespace}, {bufnr})                           *vim.diagnostic.reset()*\n+                Remove all diagnostics from the given namespace.\n+\n+                Unlike |vim.diagnostic.hide()|, this function removes all\n+                saved diagnostics. They cannot be redisplayed using\n+                |vim.diagnostic.show()|. To simply remove diagnostic\n+                decorations in a way that they can be re-displayed, use\n+                |vim.diagnostic.hide()|.\n+\n+                Parameters: ~\n+                    {namespace}  number\n+                    {bufnr}      number|nil Remove diagnostics for the given\n+                                 buffer. If omitted, diagnostics are removed\n+                                 for all buffers.\n+\n+set({namespace}, {diagnostics}, {bufnr}, {opts})        *vim.diagnostic.set()*\n+                Set diagnostics for the given namespace and buffer.\n+\n+                Parameters: ~\n+                    {namespace}    number The diagnostic namespace\n+                    {diagnostics}  table A list of diagnostic items\n+                                   |diagnostic-structure|\n+                    {bufnr}        number|nil The buffer to set diagnostics\n+                                   for. Defaults to the current buffer.\n+                    {opts}         table|nil Display options to pass to\n+                                   |vim.diagnostic.show()|\n+\n+setloclist({opts})                               *vim.diagnostic.setloclist()*\n+                Add diagnostics to the location list.\n+\n+                By default, adds diagnostics for the current buffer in all\n+                namespaces.\n+\n+                Parameters: ~\n+                    {opts}  table|nil Configuration table with the following\n+                            keys:\n+                            • namespace: (number) Only add diagnostics from\n+                              the given namespace.\n+                            • bufnr: (number, default 0) Only add diagnostics",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r708429913",
            "id": 708429913,
            "in_reply_to_id": 708408187,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qOchZ",
            "original_commit_id": "4a8cc05b1b2bb0d68e492d0006e738d3d1545d5d",
            "original_line": 427,
            "original_position": 427,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 754162025,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708429913/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-14T16:14:04Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708429913",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r708430015"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/708430015"
                }
            },
            "author_association": "MEMBER",
            "body": "Thanks, updated.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-14T16:14:13Z",
            "diff_hunk": "@@ -57,250 +13,122 @@ end\n \n local M = {}\n \n--- Diagnostic Highlights {{{\n-\n--- TODO(tjdevries): Determine how to generate documentation for these\n---                  and how to configure them to be easy for users.\n---\n---                  For now, just use the following script. It should work pretty good.\n---[[\n-local levels = {\"Error\", \"Warning\", \"Information\", \"Hint\" }\n-\n-local all_info = {\n-  { \"Default\", \"Used as the base highlight group, other highlight groups link to\", },\n-  { \"VirtualText\", 'Used for \"%s\" diagnostic virtual text.\\n  See |vim.lsp.diagnostic.set_virtual_text()|', },\n-  { \"Underline\", 'Used to underline \"%s\" diagnostics.\\n  See |vim.lsp.diagnostic.set_underline()|', },\n-  { \"Floating\", 'Used to color \"%s\" diagnostic messages in diagnostics float.\\n  See |vim.lsp.diagnostic.show_line_diagnostics()|', },\n-  { \"Sign\", 'Used for \"%s\" signs in sing column.\\n  See |vim.lsp.diagnostic.set_signs()|', },\n-}\n-\n-local results = {}\n-for _, info in ipairs(all_info) do\n-  for _, level in ipairs(levels) do\n-    local name = info[1]\n-    local description = info[2]\n-    local fullname = string.format(\"Lsp%s%s\", name, level)\n-    table.insert(results, string.format(\n-      \"%78s\", string.format(\"*hl-%s*\", fullname))\n-    )\n-\n-    table.insert(results, fullname)\n-    table.insert(results, string.format(\"  %s\", description))\n-    table.insert(results, \"\")\n-  end\n-end\n-\n--- print(table.concat(results, '\\n'))\n-vim.fn.setreg(\"*\", table.concat(results, '\\n'))\n---]]\n-\n-local diagnostic_severities = {\n-  [DiagnosticSeverity.Error]       = { guifg = \"Red\" };\n-  [DiagnosticSeverity.Warning]     = { guifg = \"Orange\" };\n-  [DiagnosticSeverity.Information] = { guifg = \"LightBlue\" };\n-  [DiagnosticSeverity.Hint]        = { guifg = \"LightGrey\" };\n-}\n-\n--- Make a map from DiagnosticSeverity -> Highlight Name\n-local make_highlight_map = function(base_name)\n-  local result = {}\n-  for k, _ in pairs(diagnostic_severities) do\n-    result[k] = \"LspDiagnostics\" .. base_name .. DiagnosticSeverity[k]\n-  end\n-\n-  return result\n-end\n-\n-local default_highlight_map = make_highlight_map(\"Default\")\n-local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n-local underline_highlight_map = make_highlight_map(\"Underline\")\n-local floating_highlight_map = make_highlight_map(\"Floating\")\n-local sign_highlight_map = make_highlight_map(\"Sign\")\n-\n--- }}}\n--- Diagnostic Namespaces {{{\n local DEFAULT_CLIENT_ID = -1\n-local get_client_id = function(client_id)\n+---@private\n+local function get_client_id(client_id)\n   if client_id == nil then\n     client_id = DEFAULT_CLIENT_ID\n   end\n \n   return client_id\n end\n \n-local get_bufnr = function(bufnr)\n+---@private\n+local function get_bufnr(bufnr)\n   if not bufnr then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   elseif bufnr == 0 then\n-    return api.nvim_get_current_buf()\n+    return vim.api.nvim_get_current_buf()\n   end\n \n   return bufnr\n end\n \n-\n---- Create a namespace table, used to track a client's buffer local items\n-local _make_namespace_table = function(namespace, api_namespace)\n-  vim.validate { namespace = { namespace, 's' } }\n-\n-  return setmetatable({\n-    [DEFAULT_CLIENT_ID] = api.nvim_create_namespace(namespace)\n-  }, {\n-    __index = function(t, client_id)\n-      client_id = get_client_id(client_id)\n-\n-      if rawget(t, client_id) == nil then\n-        local value = string.format(\"%s:%s\", namespace, client_id)\n-\n-        if api_namespace then\n-          value = api.nvim_create_namespace(value)\n-        end\n-\n-        rawset(t, client_id, value)\n-      end\n-\n-      return rawget(t, client_id)\n-    end\n-  })\n-end\n-\n-local _diagnostic_namespaces = _make_namespace_table(\"vim_lsp_diagnostics\", true)\n-local _sign_namespaces = _make_namespace_table(\"vim_lsp_signs\", false)\n-\n ---@private\n-function M._get_diagnostic_namespace(client_id)\n-  return _diagnostic_namespaces[client_id]\n+local function severity_lsp_to_vim(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.lsp.protocol.DiagnosticSeverity[severity]\n+  end\n+  return severity\n end\n \n ---@private\n-function M._get_sign_namespace(client_id)\n-  return _sign_namespaces[client_id]\n-end\n--- }}}\n--- Diagnostic Buffer & Client metatables {{{\n-local bufnr_and_client_cacher_mt = {\n-  __index = function(t, bufnr)\n-    if bufnr == 0 or bufnr == nil then\n-      bufnr = vim.api.nvim_get_current_buf()\n-    end\n-\n-    if rawget(t, bufnr) == nil then\n-      rawset(t, bufnr, {})\n-    end\n-\n-    return rawget(t, bufnr)\n-  end,\n-\n-  __newindex = function(t, bufnr, v)\n-    if bufnr == 0 or bufnr == nil then\n-      bufnr = vim.api.nvim_get_current_buf()\n-    end\n-\n-    rawset(t, bufnr, v)\n-  end,\n-}\n--- }}}\n--- Diagnostic Saving & Caching {{{\n-local _diagnostic_cleanup = setmetatable({}, bufnr_and_client_cacher_mt)\n-local diagnostic_cache = setmetatable({}, bufnr_and_client_cacher_mt)\n-local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_client_cacher_mt)\n-local diagnostic_cache_lines = setmetatable({}, bufnr_and_client_cacher_mt)\n-local diagnostic_cache_counts = setmetatable({}, bufnr_and_client_cacher_mt)\n-local diagnostic_attached_buffers = {}\n-\n--- Disabled buffers and clients\n-local diagnostic_disabled = setmetatable({}, bufnr_and_client_cacher_mt)\n-\n-local _bufs_waiting_to_update = setmetatable({}, bufnr_and_client_cacher_mt)\n-\n---- Store Diagnostic[] by line\n----\n----@param diagnostics Diagnostic[]\n----@return table<number, Diagnostic[]>\n-local _diagnostic_lines = function(diagnostics)\n-  if not diagnostics then return end\n-\n-  local diagnostics_by_line = {}\n-  for _, diagnostic in ipairs(diagnostics) do\n-    local start = diagnostic.range.start\n-    local line_diagnostics = diagnostics_by_line[start.line]\n-    if not line_diagnostics then\n-      line_diagnostics = {}\n-      diagnostics_by_line[start.line] = line_diagnostics\n-    end\n-    table.insert(line_diagnostics, diagnostic)\n+local function severity_vim_to_lsp(severity)\n+  if type(severity) == 'string' then\n+    severity = vim.diagnostic.severity[severity]\n   end\n-  return diagnostics_by_line\n+  return severity\n end\n \n---- Get the count of M by Severity\n----\n----@param diagnostics Diagnostic[]\n----@return table<DiagnosticSeverity, number>\n-local _diagnostic_counts = function(diagnostics)\n-  if not diagnostics then return end\n-\n-  local counts = {}\n-  for _, diagnostic in pairs(diagnostics) do\n-    if diagnostic.severity then\n-      local val = counts[diagnostic.severity]\n-      if val == nil then\n-        val = 0\n-      end\n+---@private\n+local function line_byte_from_position(lines, lnum, col, offset_encoding)\n+  if offset_encoding == \"utf-8\" then\n+    return col\n+  end\n \n-      counts[diagnostic.severity] = val + 1\n-    end\n+  local line = lines[lnum + 1]\n+  local ok, result = pcall(vim.str_byteindex, line, col, offset_encoding == \"utf-16\")\n+  if ok then\n+    return result\n   end\n \n-  return counts\n+  return col\n end\n \n ---@private\n---- Set the different diagnostic cache after `textDocument/publishDiagnostics`\n----@param diagnostics Diagnostic[]\n----@param bufnr number\n----@param client_id number\n----@return nil\n-local function set_diagnostic_cache(diagnostics, bufnr, client_id)\n-  client_id = get_client_id(client_id)\n-\n-  -- https://microsoft.github.io/language-server-protocol/specifications/specification-current/#diagnostic\n-  --\n-  -- The diagnostic's severity. Can be omitted. If omitted it is up to the\n-  -- client to interpret diagnostics as error, warning, info or hint.\n-  -- TODO: Replace this with server-specific heuristics to infer severity.\n-  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n-  for _, diagnostic in ipairs(diagnostics) do\n-    if diagnostic.severity == nil then\n-      diagnostic.severity = DiagnosticSeverity.Error\n-    end\n-    -- Account for servers that place diagnostics on terminating newline\n-    if buf_line_count > 0 then\n-      diagnostic.range.start.line = math.max(math.min(\n-        diagnostic.range.start.line, buf_line_count - 1\n-      ), 0)\n-      diagnostic.range[\"end\"].line = math.max(math.min(\n-        diagnostic.range[\"end\"].line, buf_line_count - 1\n-      ), 0)\n-    end\n+local function get_buf_lines(bufnr)\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    return vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)\n   end\n \n-  diagnostic_cache[bufnr][client_id] = diagnostics\n-  diagnostic_cache_lines[bufnr][client_id] = _diagnostic_lines(diagnostics)\n-  diagnostic_cache_counts[bufnr][client_id] = _diagnostic_counts(diagnostics)\n+  local filename = vim.api.nvim_buf_get_name(bufnr)\n+  local f = io.open(filename)\n+  local lines = vim.split(f:read(\"*a\"), \"\\n\")\n+  f:close()\n+  return lines\n end\n \n+---@private\n+local function diagnostic_lsp_to_vim(diagnostics, bufnr, client_id)\n+  local buf_lines = get_buf_lines(bufnr)\n+  local client = vim.lsp.get_client_by_id(client_id)\n+  local offset_encoding = client and client.offset_encoding or \"utf-8\"",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r708430015",
            "id": 708430015,
            "in_reply_to_id": 708391263,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qOci_",
            "original_commit_id": "4a8cc05b1b2bb0d68e492d0006e738d3d1545d5d",
            "original_line": 85,
            "original_position": 323,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 754162176,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708430015/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-14T16:14:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/708430015",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709050772"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709050772"
                }
            },
            "author_association": "MEMBER",
            "body": "might be out of scope for this PR, but I am surprised to see that we have a module where require() does global side-effects. That is an anti-pattern. require() should always be safe.\r\n\r\n Callers should explicitly do something like `require('vim.disagnostic').init()`.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T10:23:48Z",
            "diff_hunk": "@@ -1039,7 +1039,7 @@ describe('LSP', function()\n       'LspDiagnosticsVirtualTextHint',\n       'LspDiagnosticsVirtualTextInformation',\n       'LspDiagnosticsVirtualTextWarning',\n-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))\n+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709050772",
            "id": 709050772,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qQ0GU",
            "original_commit_id": "80d474e1bcfc5a197cc201bbcfd8023e83209536",
            "original_line": 1042,
            "original_position": 5,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp_spec.lua",
            "position": null,
            "pull_request_review_id": 754937994,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709050772/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T10:23:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709050772",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709070160"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709070160"
                }
            },
            "author_association": "MEMBER",
            "body": "the sections here are alphanumerically ordered, can you move this just before the \"Lua\" section",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T10:52:41Z",
            "diff_hunk": "@@ -18,6 +18,44 @@ API ~\n *nvim_command_output()*\t\tUse |nvim_exec()| instead.\n *nvim_execute_lua()*\t\tUse |nvim_exec_lua()| instead.\n \n+LSP Diagnostics ~",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709070160",
            "id": 709070160,
            "line": 58,
            "node_id": "PRRC_kwDOAPphoM4qQ41Q",
            "original_commit_id": "80d474e1bcfc5a197cc201bbcfd8023e83209536",
            "original_line": 58,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/doc/deprecated.txt",
            "position": 4,
            "pull_request_review_id": 754963495,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709070160/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T10:52:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709070160",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709080664"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709080664"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    it('correctly handles UTF-16 offsets', function()\r\n```",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T11:09:24Z",
            "diff_hunk": "@@ -798,6 +766,45 @@ describe('vim.lsp.diagnostic', function()\n       eq(1, get_extmark_count_with_severity(\"Warning\"))\n       eq(1, get_extmark_count_with_severity(\"Hint\"))\n     end)\n+\n+    it('correctly handles UTF-16 offsets #thetest', function()",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709080664",
            "id": 709080664,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qQ7ZY",
            "original_commit_id": "80d474e1bcfc5a197cc201bbcfd8023e83209536",
            "original_line": 770,
            "original_position": 111,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp/diagnostic_spec.lua",
            "position": null,
            "pull_request_review_id": 754977913,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709080664/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T11:09:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709080664",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709081908"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709081908"
                }
            },
            "author_association": "MEMBER",
            "body": "just mentioning this to avoid proliferation: \"should be able to\" is noise in test descriptions.\r\n\r\nsame for the other cases in this PR.\r\n```suggestion\r\n    it('retrieves diagnostics from all buffers and namespaces', function()\r\n```",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T11:11:27Z",
            "diff_hunk": "@@ -0,0 +1,795 @@\n+local helpers = require('test.functional.helpers')(after_each)\n+\n+local clear = helpers.clear\n+local exec_lua = helpers.exec_lua\n+local eq = helpers.eq\n+local nvim = helpers.nvim\n+\n+describe('vim.diagnostic', function()\n+  before_each(function()\n+    clear()\n+\n+    exec_lua [[\n+      require('vim.diagnostic')\n+\n+      make_error = function(msg, x1, y1, x2, y2)\n+        return {\n+          lnum = x1,\n+          col = y1,\n+          end_lnum = x2,\n+          end_col = y2,\n+          message = msg,\n+          severity = vim.diagnostic.severity.ERROR,\n+        }\n+      end\n+\n+      make_warning = function(msg, x1, y1, x2, y2)\n+        return {\n+          lnum = x1,\n+          col = y1,\n+          end_lnum = x2,\n+          end_col = y2,\n+          message = msg,\n+          severity = vim.diagnostic.severity.WARN,\n+        }\n+      end\n+\n+      make_information = function(msg, x1, y1, x2, y2)\n+        return {\n+          lnum = x1,\n+          col = y1,\n+          end_lnum = x2,\n+          end_col = y2,\n+          message = msg,\n+          severity = vim.diagnostic.severity.INFO,\n+        }\n+      end\n+\n+      count_extmarks = function(namespace, bufnr)\n+        return #vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {})\n+      end\n+    ]]\n+\n+    exec_lua([[\n+      diagnostic_ns = vim.api.nvim_create_namespace(\"diagnostic_spec\")\n+      other_ns = vim.api.nvim_create_namespace(\"other_namespace\")\n+      diagnostic_bufnr = vim.api.nvim_create_buf(true, false)\n+      local lines = {\"1st line of text\", \"2nd line of text\", \"wow\", \"cool\", \"more\", \"lines\"}\n+      vim.fn.bufload(diagnostic_bufnr)\n+      vim.api.nvim_buf_set_lines(diagnostic_bufnr, 0, 1, false, lines)\n+      return diagnostic_bufnr\n+    ]])\n+  end)\n+\n+  after_each(function()\n+    clear()\n+  end)\n+\n+  it('creates highlight groups', function()\n+    eq({\n+      'DiagnosticDefaultError',\n+      'DiagnosticDefaultHint',\n+      'DiagnosticDefaultInfo',\n+      'DiagnosticDefaultWarn',\n+      'DiagnosticFloatingError',\n+      'DiagnosticFloatingHint',\n+      'DiagnosticFloatingInfo',\n+      'DiagnosticFloatingWarn',\n+      'DiagnosticSignError',\n+      'DiagnosticSignHint',\n+      'DiagnosticSignInfo',\n+      'DiagnosticSignWarn',\n+      'DiagnosticUnderlineError',\n+      'DiagnosticUnderlineHint',\n+      'DiagnosticUnderlineInfo',\n+      'DiagnosticUnderlineWarn',\n+      'DiagnosticVirtualTextError',\n+      'DiagnosticVirtualTextHint',\n+      'DiagnosticVirtualTextInfo',\n+      'DiagnosticVirtualTextWarn',\n+    }, exec_lua([[return vim.fn.getcompletion('Diagnostic', 'highlight')]]))\n+  end)\n+\n+  describe('vim.diagnostic', function()\n+    it('should be able to retrieve diagnostics from all buffers and namespaces', function()",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709081908",
            "id": 709081908,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qQ7s0",
            "original_commit_id": "80d474e1bcfc5a197cc201bbcfd8023e83209536",
            "original_line": 94,
            "original_position": 94,
            "original_start_line": null,
            "path": "test/functional/lua/diagnostic_spec.lua",
            "position": null,
            "pull_request_review_id": 754979597,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709081908/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T11:11:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709081908",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709086674"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709086674"
                }
            },
            "author_association": "MEMBER",
            "body": "💯  nice addition to the docs. These concise practical overviews are important.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T11:18:34Z",
            "diff_hunk": "@@ -0,0 +1,524 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709086674",
            "id": 709086674,
            "line": 29,
            "node_id": "PRRC_kwDOAPphoM4qQ83S",
            "original_commit_id": "80d474e1bcfc5a197cc201bbcfd8023e83209536",
            "original_line": 29,
            "original_position": 29,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": 29,
            "pull_request_review_id": 754985757,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709086674/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T11:18:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709086674",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709088417"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709088417"
                }
            },
            "author_association": "MEMBER",
            "body": "since we are renaming these anyway let's remove \"Default\" from the highlight names. Don't want this pattern to proliferate. It is redundant and unnecessary. All highlights may (or may not) have \"default\" forms.\r\n```suggestion\r\nDiagnosticError\r\n```",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T11:21:14Z",
            "diff_hunk": "@@ -0,0 +1,524 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+Generally speaking, the API is split between functions meant to be used by\n+diagnostic producers and those meant for diagnostic consumers (i.e. end users\n+who want to read and view the diagnostics for a buffer).  The APIs for\n+producers require a {namespace} as their first argument, while those for\n+consumers generally do not require a namespace (though often one may be\n+optionally supplied).  A good rule of thumb is that if a method is meant to\n+modify the diagnostics for a buffer (e.g. |vim.diagnostic.set()|) then it\n+requires a namespace.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based\n+rows and columns). |api-indexing|\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+==============================================================================\n+HIGHLIGHTS\t\t\t\t\t\t*diagnostic-highlights*\n+\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding DiagnosticDefault highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is\n+linked to |hl-DiagnosticDefaultError|. To change the default (and\n+therefore the linked highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticDefaultError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t*hl-DiagnosticDefaultError*\n+DiagnosticDefaultError",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709088417",
            "id": 709088417,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qQ9Sh",
            "original_commit_id": "80d474e1bcfc5a197cc201bbcfd8023e83209536",
            "original_line": 80,
            "original_position": 80,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 754988170,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709088417/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T11:21:26Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709088417",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709167409"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709167409"
                }
            },
            "author_association": "MEMBER",
            "body": "The `require()` is needed just to setup highlight groups. It is a global side effect, but it's idempotent. Normally this is never needed since simply using `vim.diagnostic` sets up these highlight groups, but since this is a contrived test that doesn't actually use `vim.diagnostic` but only checks for the highlight groups, we have to do things a little differently.\r\n\r\nWe could expose some method like `_setup_highlight_groups()` but that would *only* be used in this one test. Not sure that is worth it IMO.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T13:07:09Z",
            "diff_hunk": "@@ -1039,7 +1039,7 @@ describe('LSP', function()\n       'LspDiagnosticsVirtualTextHint',\n       'LspDiagnosticsVirtualTextInformation',\n       'LspDiagnosticsVirtualTextWarning',\n-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))\n+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709167409",
            "id": 709167409,
            "in_reply_to_id": 709050772,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qRQkx",
            "original_commit_id": "80d474e1bcfc5a197cc201bbcfd8023e83209536",
            "original_line": 1042,
            "original_position": 5,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp_spec.lua",
            "position": null,
            "pull_request_review_id": 755093671,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709167409/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T13:07:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709167409",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709173269"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709173269"
                }
            },
            "author_association": "MEMBER",
            "body": "Alternatively we could just define the highlight groups in `syntax.c` in the `highlight_init_both` table. That might make sense now that this is a top level module.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T13:13:50Z",
            "diff_hunk": "@@ -1039,7 +1039,7 @@ describe('LSP', function()\n       'LspDiagnosticsVirtualTextHint',\n       'LspDiagnosticsVirtualTextInformation',\n       'LspDiagnosticsVirtualTextWarning',\n-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))\n+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709173269",
            "id": 709173269,
            "in_reply_to_id": 709050772,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qRSAV",
            "original_commit_id": "80d474e1bcfc5a197cc201bbcfd8023e83209536",
            "original_line": 1042,
            "original_position": 5,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp_spec.lua",
            "position": null,
            "pull_request_review_id": 755101707,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709173269/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T13:13:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709173269",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709175034"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709175034"
                }
            },
            "author_association": "MEMBER",
            "body": "> We could expose some method like `_setup_highlight_groups()` but that would _only_ be used in this one test. Not sure that is worth it IMO.\r\n\r\nJust an `init()` is all that's needed. We're already implicitly doing it.\r\n\r\n\r\n\r\n> but it's idempotent.\r\n\r\nYeah but people copy the pattern and then start doing other things. Also,\r\n- even idempotent effects are surprising. Imagine if require() is called by some other component somewhere earlier in Nvim startup; now state that previously wasn't available is available. This could affect scripts or whatever, and it's harder to track down because nothing is explicitly calling `require(..).init()`.\r\n- For documentation/communication, it is clearer to have a simple guideline: \"require() should not have side-effects\".\r\n\r\n",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T13:15:44Z",
            "diff_hunk": "@@ -1039,7 +1039,7 @@ describe('LSP', function()\n       'LspDiagnosticsVirtualTextHint',\n       'LspDiagnosticsVirtualTextInformation',\n       'LspDiagnosticsVirtualTextWarning',\n-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))\n+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709175034",
            "id": 709175034,
            "in_reply_to_id": 709050772,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qRSb6",
            "original_commit_id": "80d474e1bcfc5a197cc201bbcfd8023e83209536",
            "original_line": 1042,
            "original_position": 5,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp_spec.lua",
            "position": null,
            "pull_request_review_id": 755104080,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709175034/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T13:20:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709175034",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709180950"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709180950"
                }
            },
            "author_association": "MEMBER",
            "body": "What do you think of the suggestion of defining the groups directly in `syntax.c`? That would remove the need for any kind of init() altogether.\r\n\r\nHaving to call init() bothers me as that's not a pattern used anywhere else in the Lua API. There is no `vim.api.init()` or `vim.lsp.init()`: users just use the API without thinking about having to initialize it. Having users manually initialize the system just doesn't feel right to me. But I also understand that 'require' shouldn't have side effects, and since we're just defining highlight groups it seems we can solve both problems at once by defining these highlights in the same place that we define all the other groups.\r\n\r\nOr we can just remove the test that checks for the highlight groups 🤷 ",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T13:22:08Z",
            "diff_hunk": "@@ -1039,7 +1039,7 @@ describe('LSP', function()\n       'LspDiagnosticsVirtualTextHint',\n       'LspDiagnosticsVirtualTextInformation',\n       'LspDiagnosticsVirtualTextWarning',\n-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))\n+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709180950",
            "id": 709180950,
            "in_reply_to_id": 709050772,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qRT4W",
            "original_commit_id": "80d474e1bcfc5a197cc201bbcfd8023e83209536",
            "original_line": 1042,
            "original_position": 5,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp_spec.lua",
            "position": null,
            "pull_request_review_id": 755112019,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709180950/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T13:26:04Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709180950",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709190943"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709190943"
                }
            },
            "author_association": "MEMBER",
            "body": "Either is fine, I think -- for LSP, we also did not predefine highlight groups and explicitly mentioned in the documentation that these need to be defined by the user.\r\n\r\nHowever, that _did_ lead to repeated questions since not everybody reads the documentation...\r\n\r\nSo I would prefer if these were just defined in `syntax.c` (as they are now no longer LSP-specific) so that colorschemes can redefine them easily.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T13:32:49Z",
            "diff_hunk": "@@ -1039,7 +1039,7 @@ describe('LSP', function()\n       'LspDiagnosticsVirtualTextHint',\n       'LspDiagnosticsVirtualTextInformation',\n       'LspDiagnosticsVirtualTextWarning',\n-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))\n+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709190943",
            "id": 709190943,
            "in_reply_to_id": 709050772,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qRWUf",
            "original_commit_id": "80d474e1bcfc5a197cc201bbcfd8023e83209536",
            "original_line": 1042,
            "original_position": 5,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp_spec.lua",
            "position": null,
            "pull_request_review_id": 755125598,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709190943/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T13:55:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709190943",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709202045"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709202045"
                }
            },
            "author_association": "MEMBER",
            "body": "> Either is fine, I think -- for LSP, we also did not predefine highlight groups and explicitly mentioned in the documentation that these need to be defined by the user.\r\n\r\nThis is not correct. I copied this pattern from the existing code:\r\n\r\nhttps://github.com/neovim/neovim/blob/afdc9e61502a9f02c8cf5156652a1bde027e4345/runtime/lua/vim/lsp.lua#L1538\r\n\r\nSo already, accessing `vim.lsp` has the same side effects that `vim.diagnostic` would have (i.e. defining highlight groups).\r\n\r\nJust wanted to clarify that I'm not introducing anything new here, just sticking with the status quo. \r\n\r\n> So I would prefer if these were just defined in syntax.c (as they are now no longer LSP-specific) so that colorschemes can redefine them easily.\r\n\r\n+1",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T13:44:22Z",
            "diff_hunk": "@@ -1039,7 +1039,7 @@ describe('LSP', function()\n       'LspDiagnosticsVirtualTextHint',\n       'LspDiagnosticsVirtualTextInformation',\n       'LspDiagnosticsVirtualTextWarning',\n-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))\n+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709202045",
            "id": 709202045,
            "in_reply_to_id": 709050772,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qRZB9",
            "original_commit_id": "80d474e1bcfc5a197cc201bbcfd8023e83209536",
            "original_line": 1042,
            "original_position": 5,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp_spec.lua",
            "position": null,
            "pull_request_review_id": 755140837,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709202045/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T13:55:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709202045",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709203336"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709203336"
                }
            },
            "author_association": "MEMBER",
            "body": "can we eliminate `get_count()` by adding a `severity` param to `get()` ?",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T13:45:47Z",
            "diff_hunk": "@@ -0,0 +1,524 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+Generally speaking, the API is split between functions meant to be used by\n+diagnostic producers and those meant for diagnostic consumers (i.e. end users\n+who want to read and view the diagnostics for a buffer).  The APIs for\n+producers require a {namespace} as their first argument, while those for\n+consumers generally do not require a namespace (though often one may be\n+optionally supplied).  A good rule of thumb is that if a method is meant to\n+modify the diagnostics for a buffer (e.g. |vim.diagnostic.set()|) then it\n+requires a namespace.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based\n+rows and columns). |api-indexing|\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+==============================================================================\n+HIGHLIGHTS\t\t\t\t\t\t*diagnostic-highlights*\n+\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding default highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is linked\n+to |hl-DiagnosticError|. To change the default (and therefore the linked\n+highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t\t*hl-DiagnosticError*\n+DiagnosticError\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticWarn*\n+DiagnosticWarn\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticInfo*\n+DiagnosticInfo\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticHint*\n+DiagnosticHint\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+\n+==============================================================================\n+EVENTS\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:\n+                    • `false` : Disable this feature\n+                    • `true` : Enable this feature, use default settings.\n+                    • `table` : Enable this feature with overrides.\n+                    • `function` : Function with signature (namespace, bufnr)\n+                      that returns any of the above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({bufnr}, {namespace})                       *vim.diagnostic.disable()*\n+                Disable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only disable diagnostics for the\n+                                 given namespace.\n+\n+enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*\n+                Enable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only enable diagnostics for the\n+                                 given namespace.\n+\n+get({bufnr}, {namespace})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number to get diagnistics\n+                                 from. Use 0 for current buffer. When omitted,\n+                                 retrieve diagnostics from all buffers.\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({bufnr}, {severity}, {namespace})",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709203336",
            "id": 709203336,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qRZWI",
            "original_commit_id": "c8fbd4e5fcfd6b5bed782b3ad266ebaf445deb9d",
            "original_line": 242,
            "original_position": 242,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 755142642,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709203336/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T13:45:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709203336",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709205053"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709205053"
                }
            },
            "author_association": "MEMBER",
            "body": "- for parallel form with `get()` we can name this `get_by_linenr`. (Don't need to repeat \"diagnostics\" in the name)\r\n- alternatively I would consider adding an optional `opt.linenr` param to `get()`, then we don't need this extra function.\r\n- OTOH, I see this has a counterpart in `show_line_diagnostics` , so maybe just leave it. Else that would need to be renamed to something like `show_at_line`\r\n\r\n```suggestion\r\nget_by_linenr({bufnr}, {lnum}, {opts})\r\n```\r\n\r\n",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T13:47:25Z",
            "diff_hunk": "@@ -0,0 +1,524 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+Generally speaking, the API is split between functions meant to be used by\n+diagnostic producers and those meant for diagnostic consumers (i.e. end users\n+who want to read and view the diagnostics for a buffer).  The APIs for\n+producers require a {namespace} as their first argument, while those for\n+consumers generally do not require a namespace (though often one may be\n+optionally supplied).  A good rule of thumb is that if a method is meant to\n+modify the diagnostics for a buffer (e.g. |vim.diagnostic.set()|) then it\n+requires a namespace.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based\n+rows and columns). |api-indexing|\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+==============================================================================\n+HIGHLIGHTS\t\t\t\t\t\t*diagnostic-highlights*\n+\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding default highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is linked\n+to |hl-DiagnosticError|. To change the default (and therefore the linked\n+highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t\t*hl-DiagnosticError*\n+DiagnosticError\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticWarn*\n+DiagnosticWarn\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticInfo*\n+DiagnosticInfo\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticHint*\n+DiagnosticHint\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+\n+==============================================================================\n+EVENTS\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:\n+                    • `false` : Disable this feature\n+                    • `true` : Enable this feature, use default settings.\n+                    • `table` : Enable this feature with overrides.\n+                    • `function` : Function with signature (namespace, bufnr)\n+                      that returns any of the above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({bufnr}, {namespace})                       *vim.diagnostic.disable()*\n+                Disable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only disable diagnostics for the\n+                                 given namespace.\n+\n+enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*\n+                Enable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only enable diagnostics for the\n+                                 given namespace.\n+\n+get({bufnr}, {namespace})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number to get diagnistics\n+                                 from. Use 0 for current buffer. When omitted,\n+                                 retrieve diagnostics from all buffers.\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({bufnr}, {severity}, {namespace})\n+                Get the number of diagnostics with the given severity.\n+\n+                Useful for showing diagnostic counts in the |status-line|.\n+                Example: >\n+\n+                 function! DiagnosticStatus() abort\n+                   let sl = ''\n+                   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(0, vim.diagnostic.severity.ERROR)\")} '\n+                   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(0, vim.diagnostic.severity.WARN)\")}'\n+                   return sl\n+                 endfunction\n+<\n+\n+                Then simply add `%{DiagnosticStatus()}` to 'statusline'.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Use 0 for current\n+                                 buffer. When omitted, count diagnostics from\n+                                 all buffers.\n+                    {severity}   |vim.diagnostic.severity| Count only\n+                                 diagnostics for the given severity. When\n+                                 omitted, count all diagnostics.\n+                    {namespace}  number|nil Count only diagnostics from the\n+                                 given namespace.\n+\n+                                       *vim.diagnostic.get_line_diagnostics()*\n+get_line_diagnostics({bufnr}, {lnum}, {opts})",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709205053",
            "id": 709205053,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qRZw9",
            "original_commit_id": "c8fbd4e5fcfd6b5bed782b3ad266ebaf445deb9d",
            "original_line": 249,
            "original_position": 269,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 755144773,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709205053/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T13:50:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709205053",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709206638"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709206638"
                }
            },
            "author_association": "MEMBER",
            "body": "```lua\r\nvim.diagnostic.get_count(0, vim.diagnostic.severity.ERROR)\r\n```\r\n\r\nbecomes\r\n\r\n```lua\r\n#vim.diagnostic.get(0, nil, { severity = vim.diagnostic.severity.ERROR })\r\n```\r\n\r\nIt's a little more verbose but not prohibitively so. Sounds good to me.\r\n\r\n**EDIT:** Actually we can probably move `{namespace}` into the opts table as we do in other places, so there's no need for the `nil` second argument.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T13:49:02Z",
            "diff_hunk": "@@ -0,0 +1,524 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+Generally speaking, the API is split between functions meant to be used by\n+diagnostic producers and those meant for diagnostic consumers (i.e. end users\n+who want to read and view the diagnostics for a buffer).  The APIs for\n+producers require a {namespace} as their first argument, while those for\n+consumers generally do not require a namespace (though often one may be\n+optionally supplied).  A good rule of thumb is that if a method is meant to\n+modify the diagnostics for a buffer (e.g. |vim.diagnostic.set()|) then it\n+requires a namespace.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based\n+rows and columns). |api-indexing|\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+==============================================================================\n+HIGHLIGHTS\t\t\t\t\t\t*diagnostic-highlights*\n+\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding default highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is linked\n+to |hl-DiagnosticError|. To change the default (and therefore the linked\n+highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t\t*hl-DiagnosticError*\n+DiagnosticError\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticWarn*\n+DiagnosticWarn\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticInfo*\n+DiagnosticInfo\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticHint*\n+DiagnosticHint\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+\n+==============================================================================\n+EVENTS\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:\n+                    • `false` : Disable this feature\n+                    • `true` : Enable this feature, use default settings.\n+                    • `table` : Enable this feature with overrides.\n+                    • `function` : Function with signature (namespace, bufnr)\n+                      that returns any of the above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({bufnr}, {namespace})                       *vim.diagnostic.disable()*\n+                Disable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only disable diagnostics for the\n+                                 given namespace.\n+\n+enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*\n+                Enable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only enable diagnostics for the\n+                                 given namespace.\n+\n+get({bufnr}, {namespace})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number to get diagnistics\n+                                 from. Use 0 for current buffer. When omitted,\n+                                 retrieve diagnostics from all buffers.\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({bufnr}, {severity}, {namespace})",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709206638",
            "id": 709206638,
            "in_reply_to_id": 709203336,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qRaJu",
            "original_commit_id": "c8fbd4e5fcfd6b5bed782b3ad266ebaf445deb9d",
            "original_line": 242,
            "original_position": 242,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 755146902,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709206638/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T13:50:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709206638",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709208419"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709208419"
                }
            },
            "author_association": "MEMBER",
            "body": "> This is not correct. I copied this pattern from the existing code:\r\n\r\nAh, that's relatively new. The documentation still claims that you need to define them (which really did use to be the case, at least for some, before that was changed).\r\n\r\nIn any case, defining them in `syntax.c` is much cleaner IMHO. (I suspect the only reason they are currently defined the way they are is that TJ would only touch the C code if held at gunpoint ;))",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T13:50:45Z",
            "diff_hunk": "@@ -1039,7 +1039,7 @@ describe('LSP', function()\n       'LspDiagnosticsVirtualTextHint',\n       'LspDiagnosticsVirtualTextInformation',\n       'LspDiagnosticsVirtualTextWarning',\n-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))\n+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709208419",
            "id": 709208419,
            "in_reply_to_id": 709050772,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qRalj",
            "original_commit_id": "80d474e1bcfc5a197cc201bbcfd8023e83209536",
            "original_line": 1042,
            "original_position": 5,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp_spec.lua",
            "position": null,
            "pull_request_review_id": 755149296,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709208419/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T13:52:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709208419",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709212424"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709212424"
                }
            },
            "author_association": "MEMBER",
            "body": "> What do you think of the suggestion of defining the groups directly in `syntax.c`? That would remove the need for any kind of init() altogether.\r\n\r\nNo, I don't think we should start mixing parts of the LSP framework into the C core. That makes it hard to reason about and hard to explain.\r\n\r\n> Having to call init() bothers me as that's not a pattern used anywhere else in the Lua API. There is no `vim.api.init()` or `vim.lsp.init()`: users just use the API without thinking about having to initialize it. Having users manually initialize the system just doesn't feel right to me.\r\n\r\non second thought, we already have a pattern for this: `plugin/foo.vim` and `lua/foo/init.vim`. Don't need `init()`.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T13:54:41Z",
            "diff_hunk": "@@ -1039,7 +1039,7 @@ describe('LSP', function()\n       'LspDiagnosticsVirtualTextHint',\n       'LspDiagnosticsVirtualTextInformation',\n       'LspDiagnosticsVirtualTextWarning',\n-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))\n+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709212424",
            "id": 709212424,
            "in_reply_to_id": 709050772,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qRbkI",
            "original_commit_id": "80d474e1bcfc5a197cc201bbcfd8023e83209536",
            "original_line": 1042,
            "original_position": 5,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp_spec.lua",
            "position": null,
            "pull_request_review_id": 755154472,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709212424/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T13:57:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709212424",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709215093"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709215093"
                }
            },
            "author_association": "MEMBER",
            "body": "But this is no longer LSP-specific but a more general diagnostic framework? (The argument still applies, of course, albeit more weakly.)",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T13:57:22Z",
            "diff_hunk": "@@ -1039,7 +1039,7 @@ describe('LSP', function()\n       'LspDiagnosticsVirtualTextHint',\n       'LspDiagnosticsVirtualTextInformation',\n       'LspDiagnosticsVirtualTextWarning',\n-    }, exec_lua([[require'vim.lsp'; return vim.fn.getcompletion('Lsp', 'highlight')]]))\n+    }, exec_lua([[require'vim.diagnostic'; return vim.fn.getcompletion('Lsp', 'highlight')]]))",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709215093",
            "id": 709215093,
            "in_reply_to_id": 709050772,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qRcN1",
            "original_commit_id": "80d474e1bcfc5a197cc201bbcfd8023e83209536",
            "original_line": 1042,
            "original_position": 5,
            "original_start_line": null,
            "path": "test/functional/plugin/lsp_spec.lua",
            "position": null,
            "pull_request_review_id": 755158192,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709215093/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T13:57:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709215093",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709249358"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709249358"
                }
            },
            "author_association": "MEMBER",
            "body": "I actually like just adding a line number to `get()`. I don't think the symmetry with `show_line_diagnostics` is important.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T14:32:20Z",
            "diff_hunk": "@@ -0,0 +1,524 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+Generally speaking, the API is split between functions meant to be used by\n+diagnostic producers and those meant for diagnostic consumers (i.e. end users\n+who want to read and view the diagnostics for a buffer).  The APIs for\n+producers require a {namespace} as their first argument, while those for\n+consumers generally do not require a namespace (though often one may be\n+optionally supplied).  A good rule of thumb is that if a method is meant to\n+modify the diagnostics for a buffer (e.g. |vim.diagnostic.set()|) then it\n+requires a namespace.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based\n+rows and columns). |api-indexing|\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+==============================================================================\n+HIGHLIGHTS\t\t\t\t\t\t*diagnostic-highlights*\n+\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding default highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is linked\n+to |hl-DiagnosticError|. To change the default (and therefore the linked\n+highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t\t*hl-DiagnosticError*\n+DiagnosticError\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticWarn*\n+DiagnosticWarn\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticInfo*\n+DiagnosticInfo\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticHint*\n+DiagnosticHint\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+\n+==============================================================================\n+EVENTS\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:\n+                    • `false` : Disable this feature\n+                    • `true` : Enable this feature, use default settings.\n+                    • `table` : Enable this feature with overrides.\n+                    • `function` : Function with signature (namespace, bufnr)\n+                      that returns any of the above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({bufnr}, {namespace})                       *vim.diagnostic.disable()*\n+                Disable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only disable diagnostics for the\n+                                 given namespace.\n+\n+enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*\n+                Enable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only enable diagnostics for the\n+                                 given namespace.\n+\n+get({bufnr}, {namespace})                               *vim.diagnostic.get()*\n+                Get all diagnostics for the buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number to get diagnistics\n+                                 from. Use 0 for current buffer. When omitted,\n+                                 retrieve diagnostics from all buffers.\n+                    {namespace}  number|nil Limit diagnostics to the given\n+                                 namespace.\n+\n+                Return: ~\n+                    table A list of diagnostic items |diagnostic-structure|.\n+\n+                                                  *vim.diagnostic.get_count()*\n+get_count({bufnr}, {severity}, {namespace})\n+                Get the number of diagnostics with the given severity.\n+\n+                Useful for showing diagnostic counts in the |status-line|.\n+                Example: >\n+\n+                 function! DiagnosticStatus() abort\n+                   let sl = ''\n+                   let sl .= 'E: %{luaeval(\"vim.diagnostic.get_count(0, vim.diagnostic.severity.ERROR)\")} '\n+                   let sl .= 'W: %{luaeval(\"vim.diagnostic.get_count(0, vim.diagnostic.severity.WARN)\")}'\n+                   return sl\n+                 endfunction\n+<\n+\n+                Then simply add `%{DiagnosticStatus()}` to 'statusline'.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Use 0 for current\n+                                 buffer. When omitted, count diagnostics from\n+                                 all buffers.\n+                    {severity}   |vim.diagnostic.severity| Count only\n+                                 diagnostics for the given severity. When\n+                                 omitted, count all diagnostics.\n+                    {namespace}  number|nil Count only diagnostics from the\n+                                 given namespace.\n+\n+                                       *vim.diagnostic.get_line_diagnostics()*\n+get_line_diagnostics({bufnr}, {lnum}, {opts})",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709249358",
            "id": 709249358,
            "in_reply_to_id": 709205053,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qRklO",
            "original_commit_id": "c8fbd4e5fcfd6b5bed782b3ad266ebaf445deb9d",
            "original_line": 249,
            "original_position": 269,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 755205706,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709249358/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T14:32:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709249358",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709255321"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709255321"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n\" :help vim.diagnostic\r\n\r\nhi DiagnosticError ctermfg=1 guifg=Red\r\n```",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T14:38:26Z",
            "diff_hunk": "@@ -0,0 +1,46 @@\n+hi DiagnosticError ctermfg=1 guifg=Red",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709255321",
            "id": 709255321,
            "line": 3,
            "node_id": "PRRC_kwDOAPphoM4qRmCZ",
            "original_commit_id": "dc14f88a7fd1deed4cf5e11f53d1a382278d0dd1",
            "original_line": 3,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/plugin/diagnostic.vim",
            "position": 3,
            "pull_request_review_id": 755213869,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709255321/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T14:38:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709255321",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709342840"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709342840"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n                             Use 0 for current buffer, or nil for all buffers.\r\n```",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T16:15:15Z",
            "diff_hunk": "@@ -0,0 +1,484 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+Generally speaking, the API is split between functions meant to be used by\n+diagnostic producers and those meant for diagnostic consumers (i.e. end users\n+who want to read and view the diagnostics for a buffer).  The APIs for\n+producers require a {namespace} as their first argument, while those for\n+consumers generally do not require a namespace (though often one may be\n+optionally supplied).  A good rule of thumb is that if a method is meant to\n+modify the diagnostics for a buffer (e.g. |vim.diagnostic.set()|) then it\n+requires a namespace.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based\n+rows and columns). |api-indexing|\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+==============================================================================\n+HIGHLIGHTS\t\t\t\t\t\t*diagnostic-highlights*\n+\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding default highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is linked\n+to |hl-DiagnosticError|. To change the default (and therefore the linked\n+highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t\t*hl-DiagnosticError*\n+DiagnosticError\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticWarn*\n+DiagnosticWarn\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticInfo*\n+DiagnosticInfo\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticHint*\n+DiagnosticHint\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+\n+==============================================================================\n+EVENTS\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:\n+                    • `false` : Disable this feature\n+                    • `true` : Enable this feature, use default settings.\n+                    • `table` : Enable this feature with overrides.\n+                    • `function` : Function with signature (namespace, bufnr)\n+                      that returns any of the above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({bufnr}, {namespace})                       *vim.diagnostic.disable()*\n+                Disable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only disable diagnostics for the\n+                                 given namespace.\n+\n+enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*\n+                Enable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only enable diagnostics for the\n+                                 given namespace.\n+\n+get({bufnr}, {opts})                                    *vim.diagnostic.get()*\n+                Get all diagnostics for the buffer.\n+\n+                Parameters: ~\n+                    {bufnr}  number|nil Buffer number to get diagnistics from.\n+                             Use 0 for current buffer. When omitted, retrieve",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709342840",
            "id": 709342840,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qR7Z4",
            "original_commit_id": "6f96d5ddaa3fe3942839d250b3ef3902a61c6496",
            "original_line": 233,
            "original_position": 233,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 755333128,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709342840/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T16:15:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709342840",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709343689"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709343689"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n                Gets current diagnostics.\r\n```",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T16:16:16Z",
            "diff_hunk": "@@ -0,0 +1,484 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+Generally speaking, the API is split between functions meant to be used by\n+diagnostic producers and those meant for diagnostic consumers (i.e. end users\n+who want to read and view the diagnostics for a buffer).  The APIs for\n+producers require a {namespace} as their first argument, while those for\n+consumers generally do not require a namespace (though often one may be\n+optionally supplied).  A good rule of thumb is that if a method is meant to\n+modify the diagnostics for a buffer (e.g. |vim.diagnostic.set()|) then it\n+requires a namespace.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based\n+rows and columns). |api-indexing|\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+==============================================================================\n+HIGHLIGHTS\t\t\t\t\t\t*diagnostic-highlights*\n+\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding default highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is linked\n+to |hl-DiagnosticError|. To change the default (and therefore the linked\n+highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t\t*hl-DiagnosticError*\n+DiagnosticError\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticWarn*\n+DiagnosticWarn\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticInfo*\n+DiagnosticInfo\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticHint*\n+DiagnosticHint\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+\n+==============================================================================\n+EVENTS\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:\n+                    • `false` : Disable this feature\n+                    • `true` : Enable this feature, use default settings.\n+                    • `table` : Enable this feature with overrides.\n+                    • `function` : Function with signature (namespace, bufnr)\n+                      that returns any of the above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({bufnr}, {namespace})                       *vim.diagnostic.disable()*\n+                Disable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only disable diagnostics for the\n+                                 given namespace.\n+\n+enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*\n+                Enable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only enable diagnostics for the\n+                                 given namespace.\n+\n+get({bufnr}, {opts})                                    *vim.diagnostic.get()*\n+                Get all diagnostics for the buffer.",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709343689",
            "id": 709343689,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qR7nJ",
            "original_commit_id": "6f96d5ddaa3fe3942839d250b3ef3902a61c6496",
            "original_line": 229,
            "original_position": 229,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 755334238,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709343689/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T16:16:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709343689",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709348301"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709348301"
                }
            },
            "author_association": "MEMBER",
            "body": "instead of these conflicts maybe `severity` could be a tuple.\r\n\r\n> severity: (|vim.diagnostic.severity| or a 2-tuple thereof) Filter diagnostics matching this severity level or within the bounds of the `{min, max}` 2-tuple. `{min, nil}` is a lower bound.\r\n\r\nsame for `show_position_diagnostics()`",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T16:22:12Z",
            "diff_hunk": "@@ -0,0 +1,484 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+Generally speaking, the API is split between functions meant to be used by\n+diagnostic producers and those meant for diagnostic consumers (i.e. end users\n+who want to read and view the diagnostics for a buffer).  The APIs for\n+producers require a {namespace} as their first argument, while those for\n+consumers generally do not require a namespace (though often one may be\n+optionally supplied).  A good rule of thumb is that if a method is meant to\n+modify the diagnostics for a buffer (e.g. |vim.diagnostic.set()|) then it\n+requires a namespace.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based\n+rows and columns). |api-indexing|\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+==============================================================================\n+HIGHLIGHTS\t\t\t\t\t\t*diagnostic-highlights*\n+\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding default highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is linked\n+to |hl-DiagnosticError|. To change the default (and therefore the linked\n+highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t\t*hl-DiagnosticError*\n+DiagnosticError\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticWarn*\n+DiagnosticWarn\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticInfo*\n+DiagnosticInfo\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticHint*\n+DiagnosticHint\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+\n+==============================================================================\n+EVENTS\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:\n+                    • `false` : Disable this feature\n+                    • `true` : Enable this feature, use default settings.\n+                    • `table` : Enable this feature with overrides.\n+                    • `function` : Function with signature (namespace, bufnr)\n+                      that returns any of the above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({bufnr}, {namespace})                       *vim.diagnostic.disable()*\n+                Disable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only disable diagnostics for the\n+                                 given namespace.\n+\n+enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*\n+                Enable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only enable diagnostics for the\n+                                 given namespace.\n+\n+get({bufnr}, {opts})                                    *vim.diagnostic.get()*\n+                Get all diagnostics for the buffer.\n+\n+                Parameters: ~\n+                    {bufnr}  number|nil Buffer number to get diagnistics from.\n+                             Use 0 for current buffer. When omitted, retrieve\n+                             diagnostics from all buffers.\n+                    {opts}   table|nil A table with the following keys:\n+                             • namespace: (number) Limit diagnostics to the\n+                               given namespace.\n+                             • lnum: (number) Limit diagnostics to the given\n+                               line number.\n+                             • severity: (|vim.diagnostic.severity|) Only\n+                               return diagnostics with this severity.\n+                               Conflicts with {min_severity}.\n+                             • min_severity: (|vim.diagnostic.severity|)\n+                               Return diagnostics with this severity or worse.\n+                               Conflicts with {severity}.",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709348301",
            "id": 709348301,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qR8vN",
            "original_commit_id": "6f96d5ddaa3fe3942839d250b3ef3902a61c6496",
            "original_line": 245,
            "original_position": 245,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 755340515,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709348301/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T16:24:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709348301",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709496086"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709496086"
                }
            },
            "author_association": "MEMBER",
            "body": "One possible concern is that in Lua `{min, nil}` is indistinguishable from `{min}`. I suspect this could be confusing. What would a typical user expect from e.g.\r\n\r\n```lua\r\nvim.diagnostic.get(0, { severity = {vim.diagnostic.severity.WARN} })\r\n```\r\n\r\nThey passed a table with only one element, so we would treat this as a lower bound. But it's not at all obvious that this is correct. `severity` and `min_severity` is more verbose but has fewer surprises.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T19:05:20Z",
            "diff_hunk": "@@ -0,0 +1,484 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+Generally speaking, the API is split between functions meant to be used by\n+diagnostic producers and those meant for diagnostic consumers (i.e. end users\n+who want to read and view the diagnostics for a buffer).  The APIs for\n+producers require a {namespace} as their first argument, while those for\n+consumers generally do not require a namespace (though often one may be\n+optionally supplied).  A good rule of thumb is that if a method is meant to\n+modify the diagnostics for a buffer (e.g. |vim.diagnostic.set()|) then it\n+requires a namespace.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based\n+rows and columns). |api-indexing|\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+==============================================================================\n+HIGHLIGHTS\t\t\t\t\t\t*diagnostic-highlights*\n+\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding default highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is linked\n+to |hl-DiagnosticError|. To change the default (and therefore the linked\n+highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t\t*hl-DiagnosticError*\n+DiagnosticError\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticWarn*\n+DiagnosticWarn\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticInfo*\n+DiagnosticInfo\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticHint*\n+DiagnosticHint\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+\n+==============================================================================\n+EVENTS\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:\n+                    • `false` : Disable this feature\n+                    • `true` : Enable this feature, use default settings.\n+                    • `table` : Enable this feature with overrides.\n+                    • `function` : Function with signature (namespace, bufnr)\n+                      that returns any of the above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({bufnr}, {namespace})                       *vim.diagnostic.disable()*\n+                Disable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only disable diagnostics for the\n+                                 given namespace.\n+\n+enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*\n+                Enable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only enable diagnostics for the\n+                                 given namespace.\n+\n+get({bufnr}, {opts})                                    *vim.diagnostic.get()*\n+                Get all diagnostics for the buffer.\n+\n+                Parameters: ~\n+                    {bufnr}  number|nil Buffer number to get diagnistics from.\n+                             Use 0 for current buffer. When omitted, retrieve\n+                             diagnostics from all buffers.\n+                    {opts}   table|nil A table with the following keys:\n+                             • namespace: (number) Limit diagnostics to the\n+                               given namespace.\n+                             • lnum: (number) Limit diagnostics to the given\n+                               line number.\n+                             • severity: (|vim.diagnostic.severity|) Only\n+                               return diagnostics with this severity.\n+                               Conflicts with {min_severity}.\n+                             • min_severity: (|vim.diagnostic.severity|)\n+                               Return diagnostics with this severity or worse.\n+                               Conflicts with {severity}.",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709496086",
            "id": 709496086,
            "in_reply_to_id": 709348301,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qSg0W",
            "original_commit_id": "6f96d5ddaa3fe3942839d250b3ef3902a61c6496",
            "original_line": 245,
            "original_position": 245,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 755520942,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709496086/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T19:05:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709496086",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709522623"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709522623"
                }
            },
            "author_association": "MEMBER",
            "body": "a dict could avoid that. The main point is to avoid awkward mix-and-match parameters that conflict. Although the validation/processing logic might be a chore, this \"single value or dict\" pattern is common and we could formalize it in `vim.validate()`.\r\n\r\n> ```lua\r\n> vim.diagnostic.get(0, { severity = {min=vim.diagnostic.severity.WARN} })\r\n> ```",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T19:47:01Z",
            "diff_hunk": "@@ -0,0 +1,484 @@\n+*diagnostic.txt*   Diagnostics\n+\n+\n+                            NVIM REFERENCE MANUAL\n+\n+\n+Diagnostic framework                                     *vim.diagnostic*\n+\n+Nvim provides a framework for displaying errors or warnings from external\n+tools, otherwise known as \"diagnostics\". These diagnostics can come from a\n+variety of sources, such as linters or LSP servers. The diagnostic framework\n+is an extension to existing error handling functionality such as the\n+|quickfix| list.\n+\n+                                      Type |gO| to see the table of contents.\n+\n+==============================================================================\n+QUICKSTART                                              *diagnostic-quickstart*\n+\n+Anything that reports diagnostics is referred to below as a \"diagnostic\n+producer\". Diagnostic producers need only follow a few simple steps to\n+report diagnostics:\n+\n+1. Create a namespace |nvim_create_namespace()|. Note that the namespace must\n+   have a name. Anonymous namespaces WILL NOT WORK.\n+2. (Optional) Configure options for the diagnostic namespace\n+   |vim.diagnostic.config()|.\n+3. Generate diagnostics.\n+4. Set the diagnostics for the buffer |vim.diagnostic.set()|.\n+5. Repeat from step 3.\n+\n+Generally speaking, the API is split between functions meant to be used by\n+diagnostic producers and those meant for diagnostic consumers (i.e. end users\n+who want to read and view the diagnostics for a buffer).  The APIs for\n+producers require a {namespace} as their first argument, while those for\n+consumers generally do not require a namespace (though often one may be\n+optionally supplied).  A good rule of thumb is that if a method is meant to\n+modify the diagnostics for a buffer (e.g. |vim.diagnostic.set()|) then it\n+requires a namespace.\n+\n+\t\t\t\t\t\t\t*diagnostic-structure*\n+A diagnostic is a Lua table with the following keys:\n+\n+\tlnum: The starting line of the diagnostic\n+\tend_lnum: The final line of the diagnostic\n+\tcol: The starting column of the diagnostic\n+\tend_col: The final column of the diagnostic\n+\tseverity: The severity of the diagnostic |vim.diagnostic.severity|\n+\tmessage: The diagnostic text\n+\n+Diagnostics use the same indexing as the rest of the Nvim API (i.e. 0-based\n+rows and columns). |api-indexing|\n+\n+\t\t\t\t*vim.diagnostic.severity* *diagnostic-severity*\n+The \"severity\" key in a diagnostic is one of the values defined in\n+`vim.diagnostic.severity`:\n+\n+\tvim.diagnostic.severity.ERROR\n+\tvim.diagnostic.severity.WARN\n+\tvim.diagnostic.severity.INFO\n+\tvim.diagnostic.severity.HINT\n+\n+==============================================================================\n+HIGHLIGHTS\t\t\t\t\t\t*diagnostic-highlights*\n+\n+All highlights defined for diagnostics begin with `Diagnostic` followed by\n+the type of highlight (e.g., `Sign`, `Underline`, etc.) and the severity (e.g.\n+`Error`, `Warn`, etc.)\n+\n+Sign, underline and virtual text highlights (by default) are linked to their\n+corresponding default highlight.\n+\n+For example, the default highlighting for |hl-DiagnosticSignError| is linked\n+to |hl-DiagnosticError|. To change the default (and therefore the linked\n+highlights), use the |:highlight| command: >\n+\n+    highlight DiagnosticError guifg=\"BrightRed\"\n+<\n+\t\t\t\t\t\t\t*hl-DiagnosticError*\n+DiagnosticError\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticWarn*\n+DiagnosticWarn\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticInfo*\n+DiagnosticInfo\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t\t\t*hl-DiagnosticHint*\n+DiagnosticHint\n+  Used as the base highlight group.\n+  Other Diagnostic highlights link to this by default (except Underline)\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextError*\n+DiagnosticVirtualTextError\n+  Used for \"Error\" diagnostic virtual text.\n+\n+\t\t\t\t\t*hl-DiagnosticVirtualTextWarn*\n+DiagnosticVirtualTextWarn\n+  Used for \"Warn\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextInfo*\n+DiagnosticVirtualTextInfo\n+  Used for \"Info\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticVirtualTextHint*\n+DiagnosticVirtualTextHint\n+  Used for \"Hint\" diagnostic virtual text.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineError*\n+DiagnosticUnderlineError\n+  Used to underline \"Error\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineWarn*\n+DiagnosticUnderlineWarn\n+  Used to underline \"Warn\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineInfo*\n+DiagnosticUnderlineInfo\n+  Used to underline \"Info\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticUnderlineHint*\n+DiagnosticUnderlineHint\n+  Used to underline \"Hint\" diagnostics.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingError*\n+DiagnosticFloatingError\n+  Used to color \"Error\" diagnostic messages in diagnostics float.\n+  See |vim.diagnostic.show_line_diagnostics()|\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingWarn*\n+DiagnosticFloatingWarn\n+  Used to color \"Warn\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingInfo*\n+DiagnosticFloatingInfo\n+  Used to color \"Info\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticFloatingHint*\n+DiagnosticFloatingHint\n+  Used to color \"Hint\" diagnostic messages in diagnostics float.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignError*\n+DiagnosticSignError\n+  Used for \"Error\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignWarn*\n+DiagnosticSignWarn\n+  Used for \"Warn\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignInfo*\n+DiagnosticSignInfo\n+  Used for \"Info\" signs in sign column.\n+\n+\t\t\t\t\t\t*hl-DiagnosticSignHint*\n+DiagnosticSignHint\n+  Used for \"Hint\" signs in sign column.\n+\n+==============================================================================\n+EVENTS\t\t\t\t\t\t\t*diagnostic-events*\n+\n+\t\t\t\t\t\t\t*DiagnosticsChanged*\n+DiagnosticsChanged\tAfter diagnostics have changed.\n+\n+Example: >\n+\tautocmd User DiagnosticsChanged lua vim.diagnostic.setqflist({open = false })\n+<\n+\n+==============================================================================\n+Lua module: vim.diagnostic                                    *diagnostic-api*\n+\n+config({opts}, {namespace})                          *vim.diagnostic.config()*\n+                Configure diagnostic options globally or for a specific\n+                diagnostic namespace.\n+\n+                Note:\n+                    Each of the configuration options below accepts one of the\n+                    following:\n+                    • `false` : Disable this feature\n+                    • `true` : Enable this feature, use default settings.\n+                    • `table` : Enable this feature with overrides.\n+                    • `function` : Function with signature (namespace, bufnr)\n+                      that returns any of the above.\n+\n+                Parameters: ~\n+                    {opts}       table Configuration table with the following\n+                                 keys:\n+                                 • underline: (default true) Use underline for\n+                                   diagnostics\n+                                 • virtual_text: (default true) Use virtual\n+                                   text for diagnostics\n+                                 • signs: (default true) Use signs for\n+                                   diagnostics\n+                                 • update_in_insert: (default false) Update\n+                                   diagnostics in Insert mode (if false,\n+                                   diagnostics are updated on InsertLeave)\n+                                 • severity_sort: (default false) Sort\n+                                   diagnostics by severity. This affects the\n+                                   order in which signs and virtual text are\n+                                   displayed\n+                    {namespace}  number|nil Update the options for the given\n+                                 namespace. When omitted, update the global\n+                                 diagnostic options.\n+\n+disable({bufnr}, {namespace})                       *vim.diagnostic.disable()*\n+                Disable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only disable diagnostics for the\n+                                 given namespace.\n+\n+enable({bufnr}, {namespace})                         *vim.diagnostic.enable()*\n+                Enable diagnostics in the given buffer.\n+\n+                Parameters: ~\n+                    {bufnr}      number|nil Buffer number. Defaults to the\n+                                 current buffer.\n+                    {namespace}  number|nil Only enable diagnostics for the\n+                                 given namespace.\n+\n+get({bufnr}, {opts})                                    *vim.diagnostic.get()*\n+                Get all diagnostics for the buffer.\n+\n+                Parameters: ~\n+                    {bufnr}  number|nil Buffer number to get diagnistics from.\n+                             Use 0 for current buffer. When omitted, retrieve\n+                             diagnostics from all buffers.\n+                    {opts}   table|nil A table with the following keys:\n+                             • namespace: (number) Limit diagnostics to the\n+                               given namespace.\n+                             • lnum: (number) Limit diagnostics to the given\n+                               line number.\n+                             • severity: (|vim.diagnostic.severity|) Only\n+                               return diagnostics with this severity.\n+                               Conflicts with {min_severity}.\n+                             • min_severity: (|vim.diagnostic.severity|)\n+                               Return diagnostics with this severity or worse.\n+                               Conflicts with {severity}.",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709522623",
            "id": 709522623,
            "in_reply_to_id": 709348301,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qSnS_",
            "original_commit_id": "6f96d5ddaa3fe3942839d250b3ef3902a61c6496",
            "original_line": 245,
            "original_position": 245,
            "original_start_line": null,
            "path": "runtime/doc/diagnostic.txt",
            "position": null,
            "pull_request_review_id": 755555515,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709522623/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T19:47:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709522623",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r709612188"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/709612188"
                }
            },
            "author_association": "MEMBER",
            "body": "can also test \"max\" or range with just 1 extra test line.\r\n\r\n    eq(3, exec_lua [[return #vim.diagnostic.get(diagnostic_bufnr, { severity = {min=vim.diagnostic.severity.ERROR, max=vim.diagnostic.severity.INFO} })]])",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-15T22:15:04Z",
            "diff_hunk": "@@ -0,0 +1,810 @@\n+local helpers = require('test.functional.helpers')(after_each)\n+\n+local command = helpers.command\n+local clear = helpers.clear\n+local exec_lua = helpers.exec_lua\n+local eq = helpers.eq\n+local nvim = helpers.nvim\n+\n+describe('vim.diagnostic', function()\n+  before_each(function()\n+    clear()\n+\n+    exec_lua [[\n+      require('vim.diagnostic')\n+\n+      function make_error(msg, x1, y1, x2, y2)\n+        return {\n+          lnum = x1,\n+          col = y1,\n+          end_lnum = x2,\n+          end_col = y2,\n+          message = msg,\n+          severity = vim.diagnostic.severity.ERROR,\n+        }\n+      end\n+\n+      function make_warning(msg, x1, y1, x2, y2)\n+        return {\n+          lnum = x1,\n+          col = y1,\n+          end_lnum = x2,\n+          end_col = y2,\n+          message = msg,\n+          severity = vim.diagnostic.severity.WARN,\n+        }\n+      end\n+\n+      function make_information(msg, x1, y1, x2, y2)\n+        return {\n+          lnum = x1,\n+          col = y1,\n+          end_lnum = x2,\n+          end_col = y2,\n+          message = msg,\n+          severity = vim.diagnostic.severity.INFO,\n+        }\n+      end\n+\n+      function count_diagnostics(bufnr, severity, namespace)\n+        return #vim.diagnostic.get(bufnr, {severity = severity, namespace = namespace})\n+      end\n+\n+      function count_extmarks(bufnr, namespace)\n+        return #vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {})\n+      end\n+    ]]\n+\n+    exec_lua([[\n+      diagnostic_ns = vim.api.nvim_create_namespace(\"diagnostic_spec\")\n+      other_ns = vim.api.nvim_create_namespace(\"other_namespace\")\n+      diagnostic_bufnr = vim.api.nvim_create_buf(true, false)\n+      local lines = {\"1st line of text\", \"2nd line of text\", \"wow\", \"cool\", \"more\", \"lines\"}\n+      vim.fn.bufload(diagnostic_bufnr)\n+      vim.api.nvim_buf_set_lines(diagnostic_bufnr, 0, 1, false, lines)\n+      return diagnostic_bufnr\n+    ]])\n+  end)\n+\n+  after_each(function()\n+    clear()\n+  end)\n+\n+  it('creates highlight groups', function()\n+    command('runtime plugin/diagnostic.vim')\n+    eq({\n+      'DiagnosticError',\n+      'DiagnosticFloatingError',\n+      'DiagnosticFloatingHint',\n+      'DiagnosticFloatingInfo',\n+      'DiagnosticFloatingWarn',\n+      'DiagnosticHint',\n+      'DiagnosticInfo',\n+      'DiagnosticSignError',\n+      'DiagnosticSignHint',\n+      'DiagnosticSignInfo',\n+      'DiagnosticSignWarn',\n+      'DiagnosticUnderlineError',\n+      'DiagnosticUnderlineHint',\n+      'DiagnosticUnderlineInfo',\n+      'DiagnosticUnderlineWarn',\n+      'DiagnosticVirtualTextError',\n+      'DiagnosticVirtualTextHint',\n+      'DiagnosticVirtualTextInfo',\n+      'DiagnosticVirtualTextWarn',\n+      'DiagnosticWarn',\n+    }, exec_lua([[return vim.fn.getcompletion('Diagnostic', 'highlight')]]))\n+  end)\n+\n+  it('retrieves diagnostics from all buffers and namespaces', function()\n+    local result = exec_lua [[\n+      vim.diagnostic.set(diagnostic_ns, 1, {\n+        make_error('Diagnostic #1', 1, 1, 1, 1),\n+        make_error('Diagnostic #2', 2, 1, 2, 1),\n+      })\n+      vim.diagnostic.set(other_ns, 2, {\n+        make_error('Diagnostic #3', 3, 1, 3, 1),\n+      })\n+      return vim.diagnostic.get()\n+    ]]\n+    eq(3, #result)\n+    eq(2, exec_lua([[return #vim.tbl_filter(function(d) return d.bufnr == 1 end, ...)]], result))\n+    eq('Diagnostic #1', result[1].message)\n+  end)\n+\n+  it('saves and count a single error', function()\n+    eq(1, exec_lua [[\n+      vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, {\n+        make_error('Diagnostic #1', 1, 1, 1, 1),\n+      })\n+      return count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.ERROR, diagnostic_ns)\n+    ]])\n+  end)\n+\n+  it('saves and count multiple errors', function()\n+    eq(2, exec_lua [[\n+      vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, {\n+        make_error('Diagnostic #1', 1, 1, 1, 1),\n+        make_error('Diagnostic #2', 2, 1, 2, 1),\n+      })\n+      return count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.ERROR, diagnostic_ns)\n+    ]])\n+  end)\n+\n+  it('saves and count from multiple namespaces', function()\n+    eq({1, 1, 2}, exec_lua [[\n+      vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, {\n+        make_error('Diagnostic From Server 1', 1, 1, 1, 1),\n+      })\n+      vim.diagnostic.set(other_ns, diagnostic_bufnr, {\n+        make_error('Diagnostic From Server 2', 1, 1, 1, 1),\n+      })\n+      return {\n+        -- First namespace\n+        count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.ERROR, diagnostic_ns),\n+        -- Second namespace\n+        count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.ERROR, other_ns),\n+        -- All namespaces\n+        count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.ERROR),\n+      }\n+    ]])\n+  end)\n+\n+  it('saves and count from multiple namespaces with respect to severity', function()\n+    eq({3, 0, 3}, exec_lua [[\n+      vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, {\n+        make_error('Diagnostic From Server 1:1', 1, 1, 1, 1),\n+        make_error('Diagnostic From Server 1:2', 2, 2, 2, 2),\n+        make_error('Diagnostic From Server 1:3', 2, 3, 3, 2),\n+      })\n+      vim.diagnostic.set(other_ns, diagnostic_bufnr, {\n+        make_warning('Warning From Server 2', 3, 3, 3, 3),\n+      })\n+      return {\n+        -- Namespace 1\n+        count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.ERROR, diagnostic_ns),\n+        -- Namespace 2\n+        count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.ERROR, other_ns),\n+        -- All namespaces\n+        count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.ERROR),\n+      }\n+    ]])\n+  end)\n+\n+  it('handles one namespace clearing highlights while the other still has highlights', function()\n+    -- 1 Error (1)\n+    -- 1 Warning (2)\n+    -- 1 Warning (2) + 1 Warning (1)\n+    -- 2 highlights and 2 underlines (since error)\n+    -- 1 highlight + 1 underline\n+    local all_highlights = {1, 1, 2, 4, 2}\n+    eq(all_highlights, exec_lua [[\n+      local ns_1_diags = {\n+        make_error(\"Error 1\", 1, 1, 1, 5),\n+        make_warning(\"Warning on Server 1\", 2, 1, 2, 5),\n+      }\n+      local ns_2_diags = {\n+        make_warning(\"Warning 1\", 2, 1, 2, 5),\n+      }\n+\n+      vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, ns_1_diags)\n+      vim.diagnostic.set(other_ns, diagnostic_bufnr, ns_2_diags)\n+\n+      return {\n+        count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.ERROR, diagnostic_ns),\n+        count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.WARN, other_ns),\n+        count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.WARN),\n+        count_extmarks(diagnostic_bufnr, diagnostic_ns),\n+        count_extmarks(diagnostic_bufnr, other_ns),\n+      }\n+    ]])\n+\n+    -- Clear diagnostics from namespace 1, and make sure we have the right amount of stuff for namespace 2\n+    eq({1, 1, 2, 0, 2}, exec_lua [[\n+      vim.diagnostic.disable(diagnostic_bufnr, diagnostic_ns)\n+      return {\n+        count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.ERROR, diagnostic_ns),\n+        count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.WARN, other_ns),\n+        count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.WARN),\n+        count_extmarks(diagnostic_bufnr, diagnostic_ns),\n+        count_extmarks(diagnostic_bufnr, other_ns),\n+      }\n+    ]])\n+\n+    -- Show diagnostics from namespace 1 again\n+    eq(all_highlights, exec_lua([[\n+      vim.diagnostic.enable(diagnostic_bufnr, diagnostic_ns)\n+      return {\n+        count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.ERROR, diagnostic_ns),\n+        count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.WARN, other_ns),\n+        count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.WARN),\n+        count_extmarks(diagnostic_bufnr, diagnostic_ns),\n+        count_extmarks(diagnostic_bufnr, other_ns),\n+      }\n+    ]]))\n+  end)\n+\n+  it('does not display diagnostics when disabled', function()\n+    eq({0, 2}, exec_lua [[\n+      local ns_1_diags = {\n+        make_error(\"Error 1\", 1, 1, 1, 5),\n+        make_warning(\"Warning on Server 1\", 2, 1, 2, 5),\n+      }\n+      local ns_2_diags = {\n+        make_warning(\"Warning 1\", 2, 1, 2, 5),\n+      }\n+\n+      vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, ns_1_diags)\n+      vim.diagnostic.set(other_ns, diagnostic_bufnr, ns_2_diags)\n+\n+      vim.diagnostic.disable(diagnostic_bufnr, diagnostic_ns)\n+\n+      return {\n+        count_extmarks(diagnostic_bufnr, diagnostic_ns),\n+        count_extmarks(diagnostic_bufnr, other_ns),\n+      }\n+    ]])\n+\n+    eq({4, 0}, exec_lua [[\n+      vim.diagnostic.enable(diagnostic_bufnr, diagnostic_ns)\n+      vim.diagnostic.disable(diagnostic_bufnr, other_ns)\n+\n+      return {\n+        count_extmarks(diagnostic_bufnr, diagnostic_ns),\n+        count_extmarks(diagnostic_bufnr, other_ns),\n+      }\n+    ]])\n+  end)\n+\n+  describe('reset()', function()\n+    it('diagnostic count is 0 and displayed diagnostics are 0 after call', function()\n+      -- 1 Error (1)\n+      -- 1 Warning (2)\n+      -- 1 Warning (2) + 1 Warning (1)\n+      -- 2 highlights and 2 underlines (since error)\n+      -- 1 highlight + 1 underline\n+      local all_highlights = {1, 1, 2, 4, 2}\n+      eq(all_highlights, exec_lua [[\n+        local ns_1_diags = {\n+          make_error(\"Error 1\", 1, 1, 1, 5),\n+          make_warning(\"Warning on Server 1\", 2, 1, 2, 5),\n+        }\n+        local ns_2_diags = {\n+          make_warning(\"Warning 1\", 2, 1, 2, 5),\n+        }\n+\n+        vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, ns_1_diags)\n+        vim.diagnostic.set(other_ns, diagnostic_bufnr, ns_2_diags)\n+\n+        return {\n+          count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.ERROR, diagnostic_ns),\n+          count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.WARN, other_ns),\n+          count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.WARN),\n+          count_extmarks(diagnostic_bufnr, diagnostic_ns),\n+          count_extmarks(diagnostic_bufnr, other_ns),\n+        }\n+      ]])\n+\n+      -- Reset diagnostics from namespace 1\n+      exec_lua([[ vim.diagnostic.reset(diagnostic_ns) ]])\n+\n+      -- Make sure we have the right diagnostic count\n+      eq({0, 1, 1, 0, 2} , exec_lua [[\n+        local diagnostic_count = {}\n+        vim.wait(100, function () diagnostic_count = {\n+          count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.ERROR, diagnostic_ns),\n+          count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.WARN, other_ns),\n+          count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.WARN),\n+          count_extmarks(diagnostic_bufnr, diagnostic_ns),\n+          count_extmarks(diagnostic_bufnr, other_ns),\n+        } end )\n+        return diagnostic_count\n+      ]])\n+\n+      -- Reset diagnostics from namespace 2\n+      exec_lua([[ vim.diagnostic.reset(other_ns) ]])\n+\n+      -- Make sure we have the right diagnostic count\n+      eq({0, 0, 0, 0, 0}, exec_lua [[\n+        local diagnostic_count = {}\n+        vim.wait(100, function () diagnostic_count = {\n+          count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.ERROR, diagnostic_ns),\n+          count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.WARN, other_ns),\n+          count_diagnostics(diagnostic_bufnr, vim.diagnostic.severity.WARN),\n+          count_extmarks(diagnostic_bufnr, diagnostic_ns),\n+          count_extmarks(diagnostic_bufnr, other_ns),\n+        } end )\n+        return diagnostic_count\n+      ]])\n+\n+    end)\n+  end)\n+\n+  describe('get_next_pos()', function()\n+    it('can find the next pos with only one namespace', function()\n+      eq({1, 1}, exec_lua [[\n+        vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, {\n+          make_error('Diagnostic #1', 1, 1, 1, 1),\n+        })\n+        vim.api.nvim_win_set_buf(0, diagnostic_bufnr)\n+        return vim.diagnostic.get_next_pos()\n+      ]])\n+    end)\n+\n+    it('can find next pos with two errors', function()\n+      eq({4, 4}, exec_lua [[\n+        vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, {\n+          make_error('Diagnostic #1', 1, 1, 1, 1),\n+          make_error('Diagnostic #2', 4, 4, 4, 4),\n+        })\n+        vim.api.nvim_win_set_buf(0, diagnostic_bufnr)\n+        vim.api.nvim_win_set_cursor(0, {3, 1})\n+        return vim.diagnostic.get_next_pos { namespace = diagnostic_ns }\n+      ]])\n+    end)\n+\n+    it('can cycle when position is past error', function()\n+      eq({1, 1}, exec_lua [[\n+        vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, {\n+          make_error('Diagnostic #1', 1, 1, 1, 1),\n+        })\n+        vim.api.nvim_win_set_buf(0, diagnostic_bufnr)\n+        vim.api.nvim_win_set_cursor(0, {3, 1})\n+        return vim.diagnostic.get_next_pos { namespace = diagnostic_ns }\n+      ]])\n+    end)\n+\n+    it('will not cycle when wrap is off', function()\n+      eq(false, exec_lua [[\n+        vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, {\n+          make_error('Diagnostic #1', 1, 1, 1, 1),\n+        })\n+        vim.api.nvim_win_set_buf(0, diagnostic_bufnr)\n+        vim.api.nvim_win_set_cursor(0, {3, 1})\n+        return vim.diagnostic.get_next_pos { namespace = diagnostic_ns, wrap = false }\n+      ]])\n+    end)\n+\n+    it('can cycle even from the last line', function()\n+      eq({4, 4}, exec_lua [[\n+        vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, {\n+          make_error('Diagnostic #2', 4, 4, 4, 4),\n+        })\n+        vim.api.nvim_win_set_buf(0, diagnostic_bufnr)\n+        vim.api.nvim_win_set_cursor(0, {vim.api.nvim_buf_line_count(0), 1})\n+        return vim.diagnostic.get_prev_pos { namespace = diagnostic_ns }\n+      ]])\n+    end)\n+  end)\n+\n+  describe('get_prev_pos()', function()\n+    it('can find the prev pos with only one namespace', function()\n+      eq({1, 1}, exec_lua [[\n+        vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, {\n+          make_error('Diagnostic #1', 1, 1, 1, 1),\n+        })\n+        vim.api.nvim_win_set_buf(0, diagnostic_bufnr)\n+        vim.api.nvim_win_set_cursor(0, {3, 1})\n+        return vim.diagnostic.get_prev_pos()\n+      ]])\n+    end)\n+\n+    it('can find prev pos with two errors', function()\n+      eq({1, 1}, exec_lua [[\n+        vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, {\n+          make_error('Diagnostic #1', 1, 1, 1, 1),\n+          make_error('Diagnostic #2', 4, 4, 4, 4),\n+        })\n+        vim.api.nvim_win_set_buf(0, diagnostic_bufnr)\n+        vim.api.nvim_win_set_cursor(0, {3, 1})\n+        return vim.diagnostic.get_prev_pos { namespace = diagnostic_ns }\n+      ]])\n+    end)\n+\n+    it('can cycle when position is past error', function()\n+      eq({4, 4}, exec_lua [[\n+        vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, {\n+          make_error('Diagnostic #2', 4, 4, 4, 4),\n+        })\n+        vim.api.nvim_win_set_buf(0, diagnostic_bufnr)\n+        vim.api.nvim_win_set_cursor(0, {3, 1})\n+        return vim.diagnostic.get_prev_pos { namespace = diagnostic_ns }\n+      ]])\n+    end)\n+\n+    it('respects wrap parameter', function()\n+      eq(false, exec_lua [[\n+        vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, {\n+          make_error('Diagnostic #2', 4, 4, 4, 4),\n+        })\n+        vim.api.nvim_win_set_buf(0, diagnostic_bufnr)\n+        vim.api.nvim_win_set_cursor(0, {3, 1})\n+        return vim.diagnostic.get_prev_pos { namespace = diagnostic_ns, wrap = false}\n+      ]])\n+    end)\n+  end)\n+\n+  describe('get()', function()\n+    it('returns an empty table when no diagnostics are present', function()\n+      eq({}, exec_lua [[return vim.diagnostic.get(diagnostic_bufnr, {namespace=diagnostic_ns})]])\n+    end)\n+\n+    it('returns all diagnostics when no severity is supplied', function()\n+      eq(2, exec_lua [[\n+        vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, {\n+          make_error(\"Error 1\", 1, 1, 1, 5),\n+          make_warning(\"Warning on Server 1\", 1, 1, 2, 5),\n+        })\n+\n+        return #vim.diagnostic.get(diagnostic_bufnr)\n+      ]])\n+    end)\n+\n+    it('returns only requested diagnostics when severity is supplied', function()\n+      eq(2, exec_lua [[\n+        vim.diagnostic.set(diagnostic_ns, diagnostic_bufnr, {\n+          make_error(\"Error 1\", 1, 1, 1, 5),\n+          make_warning(\"Warning on Server 1\", 1, 1, 2, 5),\n+          make_information(\"Ignored information\", 1, 1, 2, 5),\n+        })\n+\n+        return #vim.diagnostic.get(diagnostic_bufnr, { severity = {min=vim.diagnostic.severity.WARN} })\n+      ]])",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r709612188",
            "id": 709612188,
            "line": 473,
            "node_id": "PRRC_kwDOAPphoM4qS9Kc",
            "original_commit_id": "a5bbb932f9094098bd656d3f6be3c58344576709",
            "original_line": 452,
            "original_position": 452,
            "original_start_line": null,
            "path": "test/functional/lua/diagnostic_spec.lua",
            "position": 473,
            "pull_request_review_id": 755668575,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709612188/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-15T22:15:04Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/709612188",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r710148617"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/710148617"
                }
            },
            "author_association": "MEMBER",
            "body": "can all of this be removed? dealing with non-standard unicode indices is an LSP-ism that should be confined to `vim/lsp/diagnostic.lua` and not leak out into this _nvim-defined_ interface.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-16T14:00:54Z",
            "diff_hunk": "@@ -0,0 +1,1178 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_by_severity(severity, diagnostics)\n+  if not severity then\n+    return diagnostics\n+  end\n+\n+  if type(severity) ~= \"table\" then\n+    severity = to_severity(severity)\n+    return vim.tbl_filter(function(t) return t.severity == severity end, diagnostics)\n+  end\n+\n+  local min_severity = to_severity(severity.min) or M.severity.HINT\n+  local max_severity = to_severity(severity.max) or M.severity.ERROR\n+\n+  return vim.tbl_filter(function(t) return t.severity <= min_severity and t.severity >= max_severity end, diagnostics)\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local define_default_signs = (function()\n+  local signs_defined = false\n+  return function()\n+    if signs_defined then\n+      return\n+    end\n+\n+    for severity, sign_hl_name in pairs(sign_highlight_map) do\n+      local severity_name = M.severity[severity]\n+      vim.fn.sign_define(sign_hl_name, {\n+        text = (severity_name or 'U'):sub(1, 1),\n+        texthl = sign_hl_name,\n+        linehl = '',\n+        numhl = '',\n+      })\n+    end\n+\n+    signs_defined = true\n+  end\n+end)()\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = {}\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function is_disabled(namespace, bufnr)\n+  if type(diagnostic_disabled[bufnr]) == \"table\" then\n+    return diagnostic_disabled[bufnr][namespace]\n+  end\n+  return diagnostic_disabled[bufnr]\n+end\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.namespace = namespace\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local winnr = opts.winnr or 0\n+  local diagnostics = M.get(loclist and vim.api.nvim_win_get_buf(winnr), opts)\n+  local items = diagnostics_to_list_items(diagnostics)\n+  if loclist then\n+    vim.fn.setloclist(winnr, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics\n+---       - virtual_text: (default true) Use virtual text for diagnostics\n+---       - signs: (default true) Use signs for diagnostics\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      if v[namespace] then\n+        M.show(namespace, bufnr)\n+      end\n+    end\n+  else\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      for ns in pairs(v) do\n+        M.show(ns, bufnr)\n+      end\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param opts table|nil Display options to pass to |vim.diagnostic.show()|\n+function M.set(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return M.reset(namespace, bufnr)\n+  end\n+\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if opts then\n+    M.config(opts, namespace)\n+  end\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    M.show(namespace, bufnr)\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+end\n+\n+--- Get current diagnostics.\n+---\n+---@param bufnr number|nil Buffer number to get diagnistics from. Use 0 for\n+---                        current buffer or nil for all buffers.\n+---@param opts table|nil A table with the following keys:\n+---                        - namespace: (number) Limit diagnostics to the given namespace.\n+---                        - lnum: (number) Limit diagnostics to the given line number.\n+---                        - severity: See |diagnostic-severity|.\n+---@return table A list of diagnostic items |diagnostic-structure|.\n+function M.get(bufnr, opts)\n+  vim.validate {\n+    bufnr = { bufnr, 'n', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  opts = opts or {}\n+\n+  local namespace = opts.namespace\n+  local diagnostics = {}\n+\n+  ---@private\n+  local function add(d)\n+    if not opts.lnum or d.lnum == opts.lnum then\n+      table.insert(diagnostics, d)\n+    end\n+  end\n+\n+  if namespace == nil and bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, v in pairs(t) do\n+        for _, diagnostic in pairs(v) do\n+          add(diagnostic)\n+        end\n+      end\n+    end\n+  elseif namespace == nil then\n+    for iter_namespace in pairs(diagnostic_cache[bufnr]) do\n+      for _, diagnostic in pairs(diagnostic_cache[bufnr][iter_namespace]) do\n+        add(diagnostic)\n+      end\n+    end\n+  elseif bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, diagnostic in pairs(t[namespace] or {}) do\n+        add(diagnostic)\n+      end\n+    end\n+  else\n+    for _, diagnostic in pairs(diagnostic_cache[bufnr][namespace] or {}) do\n+      add(diagnostic)\n+    end\n+  end\n+\n+  if opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  return diagnostics\n+end\n+\n+-- Diagnostic Movements {{{\n+\n+local next_diagnostic = function(position, search_forward, bufnr, opts, namespace)\n+  position[1] = position[1] - 1\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  local wrap = vim.F.if_nil(opts.wrap, true)\n+  local line_count = vim.api.nvim_buf_line_count(bufnr)\n+  opts.namespace = namespace\n+  for i = 0, line_count do\n+    local offset = i * (search_forward and 1 or -1)\n+    local lnum = position[1] + offset\n+    if lnum < 0 or lnum >= line_count then\n+      if not wrap then\n+        return\n+      end\n+      lnum = (lnum + line_count) % line_count\n+    end\n+    opts.lnum = lnum\n+    local line_diagnostics = M.get(bufnr, opts)\n+    if line_diagnostics and not vim.tbl_isempty(line_diagnostics) then\n+      local sort_diagnostics, is_next\n+      if search_forward then\n+        sort_diagnostics = function(a, b) return a.col < b.col end\n+        is_next = function(diagnostic) return diagnostic.col > position[2] end\n+      else\n+        sort_diagnostics = function(a, b) return a.col > b.col end\n+        is_next = function(diagnostic) return diagnostic.col < position[2] end\n+      end\n+      table.sort(line_diagnostics, sort_diagnostics)\n+      if i == 0 then\n+        for _, v in pairs(line_diagnostics) do\n+          if is_next(v) then\n+            return v\n+          end\n+        end\n+      else\n+        return line_diagnostics[1]\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function diagnostic_pos(opts, diagnostic)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+\n+  if not diagnostic then\n+    return false\n+  end\n+\n+  local lnum, col = diagnostic.lnum, diagnostic.col\n+  if col > 0 then\n+    if not vim.api.nvim_buf_is_loaded(bufnr) then\n+      vim.fn.bufload(bufnr)\n+    end\n+\n+    local line = vim.api.nvim_buf_get_lines(bufnr, lnum, lnum + 1, true)[1]\n+    if line then\n+      local ok, result = pcall(vim.str_byteindex, line, col)\n+\n+      if ok then\n+        col = result\n+      end\n+    end\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r710148617",
            "id": 710148617,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qVAIJ",
            "original_commit_id": "4fa386558802aa74571f0a2ae983125a722cc370",
            "original_line": 651,
            "original_position": 651,
            "original_start_line": 638,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 756342976,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710148617/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-16T14:00:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710148617",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1363104?v=4",
                "events_url": "https://api.github.com/users/bfredl/events{/privacy}",
                "followers_url": "https://api.github.com/users/bfredl/followers",
                "following_url": "https://api.github.com/users/bfredl/following{/other_user}",
                "gists_url": "https://api.github.com/users/bfredl/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/bfredl",
                "id": 1363104,
                "login": "bfredl",
                "node_id": "MDQ6VXNlcjEzNjMxMDQ=",
                "organizations_url": "https://api.github.com/users/bfredl/orgs",
                "received_events_url": "https://api.github.com/users/bfredl/received_events",
                "repos_url": "https://api.github.com/users/bfredl/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/bfredl/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/bfredl/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/bfredl"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r710326020"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/710326020"
                }
            },
            "author_association": "MEMBER",
            "body": "Yep, good catch, I did move this over to LSP already but forgot to remove it from this one.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-16T17:22:06Z",
            "diff_hunk": "@@ -0,0 +1,1178 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_by_severity(severity, diagnostics)\n+  if not severity then\n+    return diagnostics\n+  end\n+\n+  if type(severity) ~= \"table\" then\n+    severity = to_severity(severity)\n+    return vim.tbl_filter(function(t) return t.severity == severity end, diagnostics)\n+  end\n+\n+  local min_severity = to_severity(severity.min) or M.severity.HINT\n+  local max_severity = to_severity(severity.max) or M.severity.ERROR\n+\n+  return vim.tbl_filter(function(t) return t.severity <= min_severity and t.severity >= max_severity end, diagnostics)\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local define_default_signs = (function()\n+  local signs_defined = false\n+  return function()\n+    if signs_defined then\n+      return\n+    end\n+\n+    for severity, sign_hl_name in pairs(sign_highlight_map) do\n+      local severity_name = M.severity[severity]\n+      vim.fn.sign_define(sign_hl_name, {\n+        text = (severity_name or 'U'):sub(1, 1),\n+        texthl = sign_hl_name,\n+        linehl = '',\n+        numhl = '',\n+      })\n+    end\n+\n+    signs_defined = true\n+  end\n+end)()\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = {}\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function is_disabled(namespace, bufnr)\n+  if type(diagnostic_disabled[bufnr]) == \"table\" then\n+    return diagnostic_disabled[bufnr][namespace]\n+  end\n+  return diagnostic_disabled[bufnr]\n+end\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.namespace = namespace\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local winnr = opts.winnr or 0\n+  local diagnostics = M.get(loclist and vim.api.nvim_win_get_buf(winnr), opts)\n+  local items = diagnostics_to_list_items(diagnostics)\n+  if loclist then\n+    vim.fn.setloclist(winnr, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics\n+---       - virtual_text: (default true) Use virtual text for diagnostics\n+---       - signs: (default true) Use signs for diagnostics\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      if v[namespace] then\n+        M.show(namespace, bufnr)\n+      end\n+    end\n+  else\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      for ns in pairs(v) do\n+        M.show(ns, bufnr)\n+      end\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param opts table|nil Display options to pass to |vim.diagnostic.show()|\n+function M.set(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return M.reset(namespace, bufnr)\n+  end\n+\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if opts then\n+    M.config(opts, namespace)\n+  end\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    M.show(namespace, bufnr)\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+end\n+\n+--- Get current diagnostics.\n+---\n+---@param bufnr number|nil Buffer number to get diagnistics from. Use 0 for\n+---                        current buffer or nil for all buffers.\n+---@param opts table|nil A table with the following keys:\n+---                        - namespace: (number) Limit diagnostics to the given namespace.\n+---                        - lnum: (number) Limit diagnostics to the given line number.\n+---                        - severity: See |diagnostic-severity|.\n+---@return table A list of diagnostic items |diagnostic-structure|.\n+function M.get(bufnr, opts)\n+  vim.validate {\n+    bufnr = { bufnr, 'n', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  opts = opts or {}\n+\n+  local namespace = opts.namespace\n+  local diagnostics = {}\n+\n+  ---@private\n+  local function add(d)\n+    if not opts.lnum or d.lnum == opts.lnum then\n+      table.insert(diagnostics, d)\n+    end\n+  end\n+\n+  if namespace == nil and bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, v in pairs(t) do\n+        for _, diagnostic in pairs(v) do\n+          add(diagnostic)\n+        end\n+      end\n+    end\n+  elseif namespace == nil then\n+    for iter_namespace in pairs(diagnostic_cache[bufnr]) do\n+      for _, diagnostic in pairs(diagnostic_cache[bufnr][iter_namespace]) do\n+        add(diagnostic)\n+      end\n+    end\n+  elseif bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, diagnostic in pairs(t[namespace] or {}) do\n+        add(diagnostic)\n+      end\n+    end\n+  else\n+    for _, diagnostic in pairs(diagnostic_cache[bufnr][namespace] or {}) do\n+      add(diagnostic)\n+    end\n+  end\n+\n+  if opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  return diagnostics\n+end\n+\n+-- Diagnostic Movements {{{\n+\n+local next_diagnostic = function(position, search_forward, bufnr, opts, namespace)\n+  position[1] = position[1] - 1\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  local wrap = vim.F.if_nil(opts.wrap, true)\n+  local line_count = vim.api.nvim_buf_line_count(bufnr)\n+  opts.namespace = namespace\n+  for i = 0, line_count do\n+    local offset = i * (search_forward and 1 or -1)\n+    local lnum = position[1] + offset\n+    if lnum < 0 or lnum >= line_count then\n+      if not wrap then\n+        return\n+      end\n+      lnum = (lnum + line_count) % line_count\n+    end\n+    opts.lnum = lnum\n+    local line_diagnostics = M.get(bufnr, opts)\n+    if line_diagnostics and not vim.tbl_isempty(line_diagnostics) then\n+      local sort_diagnostics, is_next\n+      if search_forward then\n+        sort_diagnostics = function(a, b) return a.col < b.col end\n+        is_next = function(diagnostic) return diagnostic.col > position[2] end\n+      else\n+        sort_diagnostics = function(a, b) return a.col > b.col end\n+        is_next = function(diagnostic) return diagnostic.col < position[2] end\n+      end\n+      table.sort(line_diagnostics, sort_diagnostics)\n+      if i == 0 then\n+        for _, v in pairs(line_diagnostics) do\n+          if is_next(v) then\n+            return v\n+          end\n+        end\n+      else\n+        return line_diagnostics[1]\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function diagnostic_pos(opts, diagnostic)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+\n+  if not diagnostic then\n+    return false\n+  end\n+\n+  local lnum, col = diagnostic.lnum, diagnostic.col\n+  if col > 0 then\n+    if not vim.api.nvim_buf_is_loaded(bufnr) then\n+      vim.fn.bufload(bufnr)\n+    end\n+\n+    local line = vim.api.nvim_buf_get_lines(bufnr, lnum, lnum + 1, true)[1]\n+    if line then\n+      local ok, result = pcall(vim.str_byteindex, line, col)\n+\n+      if ok then\n+        col = result\n+      end\n+    end\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r710326020",
            "id": 710326020,
            "in_reply_to_id": 710148617,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM4qVrcE",
            "original_commit_id": "4fa386558802aa74571f0a2ae983125a722cc370",
            "original_line": 651,
            "original_position": 651,
            "original_start_line": 638,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": null,
            "pull_request_review_id": 756578962,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710326020/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2021-09-16T17:22:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710326020",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r710878303"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/710878303"
                }
            },
            "author_association": "MEMBER",
            "body": "should be `tuple (...)` to make sumneko happy",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-17T08:55:04Z",
            "diff_hunk": "@@ -0,0 +1,1150 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_by_severity(severity, diagnostics)\n+  if not severity then\n+    return diagnostics\n+  end\n+\n+  if type(severity) ~= \"table\" then\n+    severity = to_severity(severity)\n+    return vim.tbl_filter(function(t) return t.severity == severity end, diagnostics)\n+  end\n+\n+  local min_severity = to_severity(severity.min) or M.severity.HINT\n+  local max_severity = to_severity(severity.max) or M.severity.ERROR\n+\n+  return vim.tbl_filter(function(t) return t.severity <= min_severity and t.severity >= max_severity end, diagnostics)\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local define_default_signs = (function()\n+  local signs_defined = false\n+  return function()\n+    if signs_defined then\n+      return\n+    end\n+\n+    for severity, sign_hl_name in pairs(sign_highlight_map) do\n+      local severity_name = M.severity[severity]\n+      vim.fn.sign_define(sign_hl_name, {\n+        text = (severity_name or 'U'):sub(1, 1),\n+        texthl = sign_hl_name,\n+        linehl = '',\n+        numhl = '',\n+      })\n+    end\n+\n+    signs_defined = true\n+  end\n+end)()\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = {}\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function is_disabled(namespace, bufnr)\n+  if type(diagnostic_disabled[bufnr]) == \"table\" then\n+    return diagnostic_disabled[bufnr][namespace]\n+  end\n+  return diagnostic_disabled[bufnr]\n+end\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.namespace = namespace\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local winnr = opts.winnr or 0\n+  local diagnostics = M.get(loclist and vim.api.nvim_win_get_buf(winnr), opts)\n+  local items = diagnostics_to_list_items(diagnostics)\n+  if loclist then\n+    vim.fn.setloclist(winnr, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics\n+---       - virtual_text: (default true) Use virtual text for diagnostics\n+---       - signs: (default true) Use signs for diagnostics\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      if v[namespace] then\n+        M.show(namespace, bufnr)\n+      end\n+    end\n+  else\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      for ns in pairs(v) do\n+        M.show(ns, bufnr)\n+      end\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param opts table|nil Display options to pass to |vim.diagnostic.show()|\n+function M.set(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return M.reset(namespace, bufnr)\n+  end\n+\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if opts then\n+    M.config(opts, namespace)\n+  end\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    M.show(namespace, bufnr)\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+end\n+\n+--- Get current diagnostics.\n+---\n+---@param bufnr number|nil Buffer number to get diagnistics from. Use 0 for\n+---                        current buffer or nil for all buffers.\n+---@param opts table|nil A table with the following keys:\n+---                        - namespace: (number) Limit diagnostics to the given namespace.\n+---                        - lnum: (number) Limit diagnostics to the given line number.\n+---                        - severity: See |diagnostic-severity|.\n+---@return table A list of diagnostic items |diagnostic-structure|.\n+function M.get(bufnr, opts)\n+  vim.validate {\n+    bufnr = { bufnr, 'n', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  opts = opts or {}\n+\n+  local namespace = opts.namespace\n+  local diagnostics = {}\n+\n+  ---@private\n+  local function add(d)\n+    if not opts.lnum or d.lnum == opts.lnum then\n+      table.insert(diagnostics, d)\n+    end\n+  end\n+\n+  if namespace == nil and bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, v in pairs(t) do\n+        for _, diagnostic in pairs(v) do\n+          add(diagnostic)\n+        end\n+      end\n+    end\n+  elseif namespace == nil then\n+    for iter_namespace in pairs(diagnostic_cache[bufnr]) do\n+      for _, diagnostic in pairs(diagnostic_cache[bufnr][iter_namespace]) do\n+        add(diagnostic)\n+      end\n+    end\n+  elseif bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, diagnostic in pairs(t[namespace] or {}) do\n+        add(diagnostic)\n+      end\n+    end\n+  else\n+    for _, diagnostic in pairs(diagnostic_cache[bufnr][namespace] or {}) do\n+      add(diagnostic)\n+    end\n+  end\n+\n+  if opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  return diagnostics\n+end\n+\n+-- Diagnostic Movements {{{\n+\n+local next_diagnostic = function(position, search_forward, bufnr, opts, namespace)\n+  position[1] = position[1] - 1\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  local wrap = vim.F.if_nil(opts.wrap, true)\n+  local line_count = vim.api.nvim_buf_line_count(bufnr)\n+  opts.namespace = namespace\n+  for i = 0, line_count do\n+    local offset = i * (search_forward and 1 or -1)\n+    local lnum = position[1] + offset\n+    if lnum < 0 or lnum >= line_count then\n+      if not wrap then\n+        return\n+      end\n+      lnum = (lnum + line_count) % line_count\n+    end\n+    opts.lnum = lnum\n+    local line_diagnostics = M.get(bufnr, opts)\n+    if line_diagnostics and not vim.tbl_isempty(line_diagnostics) then\n+      local sort_diagnostics, is_next\n+      if search_forward then\n+        sort_diagnostics = function(a, b) return a.col < b.col end\n+        is_next = function(diagnostic) return diagnostic.col > position[2] end\n+      else\n+        sort_diagnostics = function(a, b) return a.col > b.col end\n+        is_next = function(diagnostic) return diagnostic.col < position[2] end\n+      end\n+      table.sort(line_diagnostics, sort_diagnostics)\n+      if i == 0 then\n+        for _, v in pairs(line_diagnostics) do\n+          if is_next(v) then\n+            return v\n+          end\n+        end\n+      else\n+        return line_diagnostics[1]\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function diagnostic_move_pos(opts, pos)\n+  opts = opts or {}\n+\n+  local enable_popup = vim.F.if_nil(opts.enable_popup, true)\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+\n+  if not pos then\n+    vim.api.nvim_echo({\"No more valid diagnostics to move to\", \"WarningMsg\"})\n+    return\n+  end\n+\n+  vim.api.nvim_win_set_cursor(win_id, {pos[1] + 1, pos[2]})\n+\n+  if enable_popup then\n+    -- This is a bit weird... I'm surprised that we need to wait til the next tick to do this.\n+    vim.schedule(function()\n+      M.show_position_diagnostics(opts.popup_opts, vim.api.nvim_win_get_buf(win_id))\n+    end)\n+  end\n+end\n+\n+--- Get the previous diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic\n+function M.get_prev(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, false, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the previous diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic position as a (row, col) tuple.\n+function M.get_prev_pos(opts)\n+  local prev = M.get_prev(opts)\n+  if not prev then\n+    return false\n+  end\n+\n+  return {prev.lnum, prev.col}\n+end\n+\n+--- Move to the previous diagnostic in the current buffer.\n+---@param opts table See |vim.diagnostic.goto_next()|\n+function M.goto_prev(opts)\n+  return diagnostic_move_pos(\n+    opts,\n+    M.get_prev_pos(opts)\n+  )\n+end\n+\n+--- Get the next diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic\n+function M.get_next(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, true, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the next diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic position as a (row, col) tuple.\n+function M.get_next_pos(opts)\n+  local next = M.get_next(opts)\n+  if not next then\n+    return false\n+  end\n+\n+  return {next.lnum, next.col}\n+end\n+\n+--- Move to the next diagnostic.\n+---\n+---@param opts table|nil Configuration table with the following keys:\n+---         - namespace: (number) Only consider diagnostics from the given namespace.\n+---         - cursor_position: (cursor position) Cursor position as a (row, col) tuple. See\n+---                          |nvim_win_get_cursor()|. Defaults to the current cursor position.\n+---         - wrap: (boolean, default true) Whether to loop around file or not. Similar to 'wrapscan'.\n+---         - severity: See |diagnostic-severity|.\n+---         - enable_popup: (boolean, default true) Call |vim.diagnostic.show_line_diagnostics()|\n+---                       on jump.\n+---         - popup_opts: (table) Table to pass as {opts} parameter to\n+---                     |vim.diagnostic.show_line_diagnostics()|\n+---         - win_id: (number, default 0) Window ID\n+function M.goto_next(opts)\n+  return diagnostic_move_pos(\n+    opts,\n+    M.get_next_pos(opts)\n+  )\n+end\n+\n+-- Diagnostic Setters {{{\n+\n+--- Set signs for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table Configuration table with the following keys:\n+---            - priority: Set the priority of the signs |sign-priority|.\n+---@private\n+function M._set_signs(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ signs = opts }, namespace, bufnr).signs\n+\n+  if opts and opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  local ns = get_namespace(namespace)\n+\n+  define_default_signs()\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    vim.fn.sign_place(\n+      0,\n+      ns.sign_group,\n+      sign_highlight_map[diagnostic.severity],\n+      bufnr,\n+      {\n+        priority = opts and opts.priority,\n+        lnum = diagnostic.lnum + 1\n+      }\n+    )\n+  end\n+end\n+\n+--- Set underline for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table Configuration table. Currently unused.\n+---@private\n+function M._set_underline(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ underline = opts }, namespace, bufnr).underline\n+\n+  if opts and opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local higroup = underline_highlight_map[diagnostic.severity]\n+\n+    if higroup == nil then\n+      -- Default to error if we don't have a highlight associated\n+      higroup = underline_highlight_map.Error\n+    end\n+\n+    vim.highlight.range(\n+      bufnr,\n+      namespace,\n+      higroup,\n+      { diagnostic.lnum, diagnostic.col },\n+      { diagnostic.end_lnum, diagnostic.end_col }\n+    )\n+  end\n+end\n+\n+--- Set virtual text for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table|nil Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line.\n+---            - spacing: (number) Number of spaces to insert before virtual text.\n+---@private\n+function M._set_virtual_text(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ virtual_text = opts }, namespace, bufnr).virtual_text\n+\n+  local buffer_line_diagnostics = diagnostic_lines(diagnostics)\n+  for line, line_diagnostics in pairs(buffer_line_diagnostics) do\n+    if opts and opts.severity then\n+      line_diagnostics = filter_by_severity(opts.severity, line_diagnostics)\n+    end\n+    local virt_texts = M.get_virt_text_chunks(line_diagnostics, opts)\n+\n+    if virt_texts then\n+      vim.api.nvim_buf_set_extmark(bufnr, namespace, line, 0, {\n+        hl_mode = \"combine\",\n+        virt_text = virt_texts,\n+      })\n+    end\n+  end\n+end\n+\n+--- Get virtual text chunks to display using |nvim_buf_set_extmark()|.\n+---\n+---@param line_diags table The diagnostics associated with the line.\n+---@param opts table|nil Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line.\n+---            - spacing: (number) Number of spaces to insert before virtual text.\n+---@return an array of [text, hl_group] arrays. This can be passed directly to\n+---        the {virt_text} option of |nvim_buf_set_extmark()|.\n+function M.get_virt_text_chunks(line_diags, opts)\n+  if #line_diags == 0 then\n+    return nil\n+  end\n+\n+  opts = opts or {}\n+  local prefix = opts.prefix or \"■\"\n+  local spacing = opts.spacing or 4\n+\n+  -- Create a little more space between virtual text and contents\n+  local virt_texts = {{string.rep(\" \", spacing)}}\n+\n+  for i = 1, #line_diags - 1 do\n+    table.insert(virt_texts, {prefix, virtual_text_highlight_map[line_diags[i].severity]})\n+  end\n+  local last = line_diags[#line_diags]\n+\n+  -- TODO(tjdevries): Allow different servers to be shown first somehow?\n+  -- TODO(tjdevries): Display server name associated with these?\n+  if last.message then\n+    table.insert(\n+      virt_texts,\n+      {\n+        string.format(\"%s %s\", prefix, last.message:gsub(\"\\r\", \"\"):gsub(\"\\n\", \"  \")),\n+        virtual_text_highlight_map[last.severity]\n+      }\n+    )\n+\n+    return virt_texts\n+  end\n+end\n+\n+--- Callback scheduled when leaving Insert mode.\n+---\n+--- This function must be exported publicly so that it is available to be\n+--- called from the Vimscript autocommand.\n+---\n+--- See @ref schedule_display()\n+---\n+---@private\n+function M._execute_scheduled_display(namespace, bufnr)\n+  local args = bufs_waiting_to_update[bufnr][namespace]\n+  if not args then\n+    return\n+  end\n+\n+  -- Clear the args so we don't display unnecessarily.\n+  bufs_waiting_to_update[bufnr][namespace] = nil\n+\n+  M.show(namespace, bufnr, nil, args)\n+end\n+\n+--- Hide currently displayed diagnostics.\n+---\n+--- This only clears the decorations displayed in the buffer. Diagnostics can\n+--- be redisplayed with |vim.diagnostic.show()|. To completely remove\n+--- diagnostics, use |vim.diagnostic.reset()|.\n+---\n+--- To hide diagnostics and prevent them from re-displaying, use\n+--- |vim.diagnostic.disable()|.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number|nil Buffer number. Defaults to the current buffer.\n+function M.hide(namespace, bufnr)\n+  vim.validate {\n+    namespace = { namespace, 'n' },\n+    bufnr = { bufnr, 'n', true },\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  diagnostic_cache_extmarks[bufnr][namespace] = {}\n+\n+  local ns = get_namespace(namespace)\n+\n+  -- clear sign group\n+  vim.fn.sign_unplace(ns.sign_group, {buffer=bufnr})\n+\n+  -- clear virtual text namespace\n+  vim.api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+end\n+\n+\n+--- Display diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number Diagnostic namespace\n+---@param bufnr number|nil Buffer number. Defaults to the current buffer.\n+---@param diagnostics table|nil The diagnostics to display. When omitted, use the\n+---                             saved diagnostics for the given namespace and\n+---                             buffer. This can be used to display a list of diagnostics\n+---                             without saving them or to display only a subset of\n+---                             diagnostics.\n+---@param opts table|nil Display options. See |vim.diagnostic.config()|.\n+function M.show(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = { namespace, 'n' },\n+    bufnr = { bufnr, 'n', true },\n+    diagnostics = { diagnostics, 't', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  if is_disabled(namespace, bufnr) then\n+    return\n+  end\n+\n+  M.hide(namespace, bufnr)\n+\n+  diagnostics = diagnostics or M.get(bufnr, {namespace=namespace})\n+\n+  if not diagnostics or vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  opts = get_resolved_options(opts, namespace, bufnr)\n+\n+  if opts.update_in_insert then\n+    clear_scheduled_display(namespace, bufnr)\n+  else\n+    local mode = vim.api.nvim_get_mode()\n+    if string.sub(mode.mode, 1, 1) == 'i' then\n+      schedule_display(namespace, bufnr, opts)\n+      return\n+    end\n+  end\n+\n+  if opts.underline then\n+    M._set_underline(namespace, bufnr, diagnostics, opts.underline)\n+  end\n+\n+  if opts.virtual_text then\n+    M._set_virtual_text(namespace, bufnr, diagnostics, opts.virtual_text)\n+  end\n+\n+  if opts.signs then\n+    M._set_signs(namespace, bufnr, diagnostics, opts.signs)\n+  end\n+\n+  save_extmarks(namespace, bufnr)\n+end\n+\n+--- Open a floating window with the diagnostics at the given position.\n+---\n+---@param opts table|nil Configuration table with the same keys as\n+---            |vim.lsp.util.open_floatin_preview()| in addition to the following:\n+---            - namespace: (number) Limit diagnostics to the given namespace\n+---            - severity: See |diagnostic-severity|.\n+---            - show_header: (boolean, default true) Show \"Diagnostics:\" header\n+---@param bufnr number|nil Buffer number. Defaults to the current buffer.\n+---@param position table|nil The (0,0)-indexed position. Defaults to the current cursor position.\n+---@return A ({popup_bufnr}, {win_id}) tuple",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r710878303",
            "id": 710878303,
            "line": 1010,
            "node_id": "PRRC_kwDOAPphoM4qXyRf",
            "original_commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "original_line": 1010,
            "original_position": 1010,
            "original_start_line": null,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": 1010,
            "pull_request_review_id": 757226245,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710878303/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-17T08:58:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710878303",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r710878457"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/710878457"
                }
            },
            "author_association": "MEMBER",
            "body": "`open_floating_preview`",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-17T08:55:17Z",
            "diff_hunk": "@@ -0,0 +1,1150 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_by_severity(severity, diagnostics)\n+  if not severity then\n+    return diagnostics\n+  end\n+\n+  if type(severity) ~= \"table\" then\n+    severity = to_severity(severity)\n+    return vim.tbl_filter(function(t) return t.severity == severity end, diagnostics)\n+  end\n+\n+  local min_severity = to_severity(severity.min) or M.severity.HINT\n+  local max_severity = to_severity(severity.max) or M.severity.ERROR\n+\n+  return vim.tbl_filter(function(t) return t.severity <= min_severity and t.severity >= max_severity end, diagnostics)\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local define_default_signs = (function()\n+  local signs_defined = false\n+  return function()\n+    if signs_defined then\n+      return\n+    end\n+\n+    for severity, sign_hl_name in pairs(sign_highlight_map) do\n+      local severity_name = M.severity[severity]\n+      vim.fn.sign_define(sign_hl_name, {\n+        text = (severity_name or 'U'):sub(1, 1),\n+        texthl = sign_hl_name,\n+        linehl = '',\n+        numhl = '',\n+      })\n+    end\n+\n+    signs_defined = true\n+  end\n+end)()\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = {}\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function is_disabled(namespace, bufnr)\n+  if type(diagnostic_disabled[bufnr]) == \"table\" then\n+    return diagnostic_disabled[bufnr][namespace]\n+  end\n+  return diagnostic_disabled[bufnr]\n+end\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.namespace = namespace\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local winnr = opts.winnr or 0\n+  local diagnostics = M.get(loclist and vim.api.nvim_win_get_buf(winnr), opts)\n+  local items = diagnostics_to_list_items(diagnostics)\n+  if loclist then\n+    vim.fn.setloclist(winnr, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics\n+---       - virtual_text: (default true) Use virtual text for diagnostics\n+---       - signs: (default true) Use signs for diagnostics\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      if v[namespace] then\n+        M.show(namespace, bufnr)\n+      end\n+    end\n+  else\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      for ns in pairs(v) do\n+        M.show(ns, bufnr)\n+      end\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param opts table|nil Display options to pass to |vim.diagnostic.show()|\n+function M.set(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return M.reset(namespace, bufnr)\n+  end\n+\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if opts then\n+    M.config(opts, namespace)\n+  end\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    M.show(namespace, bufnr)\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+end\n+\n+--- Get current diagnostics.\n+---\n+---@param bufnr number|nil Buffer number to get diagnistics from. Use 0 for\n+---                        current buffer or nil for all buffers.\n+---@param opts table|nil A table with the following keys:\n+---                        - namespace: (number) Limit diagnostics to the given namespace.\n+---                        - lnum: (number) Limit diagnostics to the given line number.\n+---                        - severity: See |diagnostic-severity|.\n+---@return table A list of diagnostic items |diagnostic-structure|.\n+function M.get(bufnr, opts)\n+  vim.validate {\n+    bufnr = { bufnr, 'n', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  opts = opts or {}\n+\n+  local namespace = opts.namespace\n+  local diagnostics = {}\n+\n+  ---@private\n+  local function add(d)\n+    if not opts.lnum or d.lnum == opts.lnum then\n+      table.insert(diagnostics, d)\n+    end\n+  end\n+\n+  if namespace == nil and bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, v in pairs(t) do\n+        for _, diagnostic in pairs(v) do\n+          add(diagnostic)\n+        end\n+      end\n+    end\n+  elseif namespace == nil then\n+    for iter_namespace in pairs(diagnostic_cache[bufnr]) do\n+      for _, diagnostic in pairs(diagnostic_cache[bufnr][iter_namespace]) do\n+        add(diagnostic)\n+      end\n+    end\n+  elseif bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, diagnostic in pairs(t[namespace] or {}) do\n+        add(diagnostic)\n+      end\n+    end\n+  else\n+    for _, diagnostic in pairs(diagnostic_cache[bufnr][namespace] or {}) do\n+      add(diagnostic)\n+    end\n+  end\n+\n+  if opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  return diagnostics\n+end\n+\n+-- Diagnostic Movements {{{\n+\n+local next_diagnostic = function(position, search_forward, bufnr, opts, namespace)\n+  position[1] = position[1] - 1\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  local wrap = vim.F.if_nil(opts.wrap, true)\n+  local line_count = vim.api.nvim_buf_line_count(bufnr)\n+  opts.namespace = namespace\n+  for i = 0, line_count do\n+    local offset = i * (search_forward and 1 or -1)\n+    local lnum = position[1] + offset\n+    if lnum < 0 or lnum >= line_count then\n+      if not wrap then\n+        return\n+      end\n+      lnum = (lnum + line_count) % line_count\n+    end\n+    opts.lnum = lnum\n+    local line_diagnostics = M.get(bufnr, opts)\n+    if line_diagnostics and not vim.tbl_isempty(line_diagnostics) then\n+      local sort_diagnostics, is_next\n+      if search_forward then\n+        sort_diagnostics = function(a, b) return a.col < b.col end\n+        is_next = function(diagnostic) return diagnostic.col > position[2] end\n+      else\n+        sort_diagnostics = function(a, b) return a.col > b.col end\n+        is_next = function(diagnostic) return diagnostic.col < position[2] end\n+      end\n+      table.sort(line_diagnostics, sort_diagnostics)\n+      if i == 0 then\n+        for _, v in pairs(line_diagnostics) do\n+          if is_next(v) then\n+            return v\n+          end\n+        end\n+      else\n+        return line_diagnostics[1]\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function diagnostic_move_pos(opts, pos)\n+  opts = opts or {}\n+\n+  local enable_popup = vim.F.if_nil(opts.enable_popup, true)\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+\n+  if not pos then\n+    vim.api.nvim_echo({\"No more valid diagnostics to move to\", \"WarningMsg\"})\n+    return\n+  end\n+\n+  vim.api.nvim_win_set_cursor(win_id, {pos[1] + 1, pos[2]})\n+\n+  if enable_popup then\n+    -- This is a bit weird... I'm surprised that we need to wait til the next tick to do this.\n+    vim.schedule(function()\n+      M.show_position_diagnostics(opts.popup_opts, vim.api.nvim_win_get_buf(win_id))\n+    end)\n+  end\n+end\n+\n+--- Get the previous diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic\n+function M.get_prev(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, false, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the previous diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic position as a (row, col) tuple.\n+function M.get_prev_pos(opts)\n+  local prev = M.get_prev(opts)\n+  if not prev then\n+    return false\n+  end\n+\n+  return {prev.lnum, prev.col}\n+end\n+\n+--- Move to the previous diagnostic in the current buffer.\n+---@param opts table See |vim.diagnostic.goto_next()|\n+function M.goto_prev(opts)\n+  return diagnostic_move_pos(\n+    opts,\n+    M.get_prev_pos(opts)\n+  )\n+end\n+\n+--- Get the next diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic\n+function M.get_next(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, true, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the next diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic position as a (row, col) tuple.\n+function M.get_next_pos(opts)\n+  local next = M.get_next(opts)\n+  if not next then\n+    return false\n+  end\n+\n+  return {next.lnum, next.col}\n+end\n+\n+--- Move to the next diagnostic.\n+---\n+---@param opts table|nil Configuration table with the following keys:\n+---         - namespace: (number) Only consider diagnostics from the given namespace.\n+---         - cursor_position: (cursor position) Cursor position as a (row, col) tuple. See\n+---                          |nvim_win_get_cursor()|. Defaults to the current cursor position.\n+---         - wrap: (boolean, default true) Whether to loop around file or not. Similar to 'wrapscan'.\n+---         - severity: See |diagnostic-severity|.\n+---         - enable_popup: (boolean, default true) Call |vim.diagnostic.show_line_diagnostics()|\n+---                       on jump.\n+---         - popup_opts: (table) Table to pass as {opts} parameter to\n+---                     |vim.diagnostic.show_line_diagnostics()|\n+---         - win_id: (number, default 0) Window ID\n+function M.goto_next(opts)\n+  return diagnostic_move_pos(\n+    opts,\n+    M.get_next_pos(opts)\n+  )\n+end\n+\n+-- Diagnostic Setters {{{\n+\n+--- Set signs for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table Configuration table with the following keys:\n+---            - priority: Set the priority of the signs |sign-priority|.\n+---@private\n+function M._set_signs(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ signs = opts }, namespace, bufnr).signs\n+\n+  if opts and opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  local ns = get_namespace(namespace)\n+\n+  define_default_signs()\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    vim.fn.sign_place(\n+      0,\n+      ns.sign_group,\n+      sign_highlight_map[diagnostic.severity],\n+      bufnr,\n+      {\n+        priority = opts and opts.priority,\n+        lnum = diagnostic.lnum + 1\n+      }\n+    )\n+  end\n+end\n+\n+--- Set underline for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table Configuration table. Currently unused.\n+---@private\n+function M._set_underline(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ underline = opts }, namespace, bufnr).underline\n+\n+  if opts and opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local higroup = underline_highlight_map[diagnostic.severity]\n+\n+    if higroup == nil then\n+      -- Default to error if we don't have a highlight associated\n+      higroup = underline_highlight_map.Error\n+    end\n+\n+    vim.highlight.range(\n+      bufnr,\n+      namespace,\n+      higroup,\n+      { diagnostic.lnum, diagnostic.col },\n+      { diagnostic.end_lnum, diagnostic.end_col }\n+    )\n+  end\n+end\n+\n+--- Set virtual text for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table|nil Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line.\n+---            - spacing: (number) Number of spaces to insert before virtual text.\n+---@private\n+function M._set_virtual_text(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ virtual_text = opts }, namespace, bufnr).virtual_text\n+\n+  local buffer_line_diagnostics = diagnostic_lines(diagnostics)\n+  for line, line_diagnostics in pairs(buffer_line_diagnostics) do\n+    if opts and opts.severity then\n+      line_diagnostics = filter_by_severity(opts.severity, line_diagnostics)\n+    end\n+    local virt_texts = M.get_virt_text_chunks(line_diagnostics, opts)\n+\n+    if virt_texts then\n+      vim.api.nvim_buf_set_extmark(bufnr, namespace, line, 0, {\n+        hl_mode = \"combine\",\n+        virt_text = virt_texts,\n+      })\n+    end\n+  end\n+end\n+\n+--- Get virtual text chunks to display using |nvim_buf_set_extmark()|.\n+---\n+---@param line_diags table The diagnostics associated with the line.\n+---@param opts table|nil Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line.\n+---            - spacing: (number) Number of spaces to insert before virtual text.\n+---@return an array of [text, hl_group] arrays. This can be passed directly to\n+---        the {virt_text} option of |nvim_buf_set_extmark()|.\n+function M.get_virt_text_chunks(line_diags, opts)\n+  if #line_diags == 0 then\n+    return nil\n+  end\n+\n+  opts = opts or {}\n+  local prefix = opts.prefix or \"■\"\n+  local spacing = opts.spacing or 4\n+\n+  -- Create a little more space between virtual text and contents\n+  local virt_texts = {{string.rep(\" \", spacing)}}\n+\n+  for i = 1, #line_diags - 1 do\n+    table.insert(virt_texts, {prefix, virtual_text_highlight_map[line_diags[i].severity]})\n+  end\n+  local last = line_diags[#line_diags]\n+\n+  -- TODO(tjdevries): Allow different servers to be shown first somehow?\n+  -- TODO(tjdevries): Display server name associated with these?\n+  if last.message then\n+    table.insert(\n+      virt_texts,\n+      {\n+        string.format(\"%s %s\", prefix, last.message:gsub(\"\\r\", \"\"):gsub(\"\\n\", \"  \")),\n+        virtual_text_highlight_map[last.severity]\n+      }\n+    )\n+\n+    return virt_texts\n+  end\n+end\n+\n+--- Callback scheduled when leaving Insert mode.\n+---\n+--- This function must be exported publicly so that it is available to be\n+--- called from the Vimscript autocommand.\n+---\n+--- See @ref schedule_display()\n+---\n+---@private\n+function M._execute_scheduled_display(namespace, bufnr)\n+  local args = bufs_waiting_to_update[bufnr][namespace]\n+  if not args then\n+    return\n+  end\n+\n+  -- Clear the args so we don't display unnecessarily.\n+  bufs_waiting_to_update[bufnr][namespace] = nil\n+\n+  M.show(namespace, bufnr, nil, args)\n+end\n+\n+--- Hide currently displayed diagnostics.\n+---\n+--- This only clears the decorations displayed in the buffer. Diagnostics can\n+--- be redisplayed with |vim.diagnostic.show()|. To completely remove\n+--- diagnostics, use |vim.diagnostic.reset()|.\n+---\n+--- To hide diagnostics and prevent them from re-displaying, use\n+--- |vim.diagnostic.disable()|.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number|nil Buffer number. Defaults to the current buffer.\n+function M.hide(namespace, bufnr)\n+  vim.validate {\n+    namespace = { namespace, 'n' },\n+    bufnr = { bufnr, 'n', true },\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  diagnostic_cache_extmarks[bufnr][namespace] = {}\n+\n+  local ns = get_namespace(namespace)\n+\n+  -- clear sign group\n+  vim.fn.sign_unplace(ns.sign_group, {buffer=bufnr})\n+\n+  -- clear virtual text namespace\n+  vim.api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+end\n+\n+\n+--- Display diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number Diagnostic namespace\n+---@param bufnr number|nil Buffer number. Defaults to the current buffer.\n+---@param diagnostics table|nil The diagnostics to display. When omitted, use the\n+---                             saved diagnostics for the given namespace and\n+---                             buffer. This can be used to display a list of diagnostics\n+---                             without saving them or to display only a subset of\n+---                             diagnostics.\n+---@param opts table|nil Display options. See |vim.diagnostic.config()|.\n+function M.show(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = { namespace, 'n' },\n+    bufnr = { bufnr, 'n', true },\n+    diagnostics = { diagnostics, 't', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  if is_disabled(namespace, bufnr) then\n+    return\n+  end\n+\n+  M.hide(namespace, bufnr)\n+\n+  diagnostics = diagnostics or M.get(bufnr, {namespace=namespace})\n+\n+  if not diagnostics or vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  opts = get_resolved_options(opts, namespace, bufnr)\n+\n+  if opts.update_in_insert then\n+    clear_scheduled_display(namespace, bufnr)\n+  else\n+    local mode = vim.api.nvim_get_mode()\n+    if string.sub(mode.mode, 1, 1) == 'i' then\n+      schedule_display(namespace, bufnr, opts)\n+      return\n+    end\n+  end\n+\n+  if opts.underline then\n+    M._set_underline(namespace, bufnr, diagnostics, opts.underline)\n+  end\n+\n+  if opts.virtual_text then\n+    M._set_virtual_text(namespace, bufnr, diagnostics, opts.virtual_text)\n+  end\n+\n+  if opts.signs then\n+    M._set_signs(namespace, bufnr, diagnostics, opts.signs)\n+  end\n+\n+  save_extmarks(namespace, bufnr)\n+end\n+\n+--- Open a floating window with the diagnostics at the given position.\n+---\n+---@param opts table|nil Configuration table with the same keys as\n+---            |vim.lsp.util.open_floatin_preview()| in addition to the following:",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r710878457",
            "id": 710878457,
            "line": 1004,
            "node_id": "PRRC_kwDOAPphoM4qXyT5",
            "original_commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "original_line": 1004,
            "original_position": 1004,
            "original_start_line": null,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": 1004,
            "pull_request_review_id": 757226245,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710878457/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-17T08:58:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710878457",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r710879229"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/710879229"
                }
            },
            "author_association": "MEMBER",
            "body": "`diagnostics`",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-17T08:56:25Z",
            "diff_hunk": "@@ -0,0 +1,1150 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_by_severity(severity, diagnostics)\n+  if not severity then\n+    return diagnostics\n+  end\n+\n+  if type(severity) ~= \"table\" then\n+    severity = to_severity(severity)\n+    return vim.tbl_filter(function(t) return t.severity == severity end, diagnostics)\n+  end\n+\n+  local min_severity = to_severity(severity.min) or M.severity.HINT\n+  local max_severity = to_severity(severity.max) or M.severity.ERROR\n+\n+  return vim.tbl_filter(function(t) return t.severity <= min_severity and t.severity >= max_severity end, diagnostics)\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local define_default_signs = (function()\n+  local signs_defined = false\n+  return function()\n+    if signs_defined then\n+      return\n+    end\n+\n+    for severity, sign_hl_name in pairs(sign_highlight_map) do\n+      local severity_name = M.severity[severity]\n+      vim.fn.sign_define(sign_hl_name, {\n+        text = (severity_name or 'U'):sub(1, 1),\n+        texthl = sign_hl_name,\n+        linehl = '',\n+        numhl = '',\n+      })\n+    end\n+\n+    signs_defined = true\n+  end\n+end)()\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = {}\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function is_disabled(namespace, bufnr)\n+  if type(diagnostic_disabled[bufnr]) == \"table\" then\n+    return diagnostic_disabled[bufnr][namespace]\n+  end\n+  return diagnostic_disabled[bufnr]\n+end\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.namespace = namespace\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local winnr = opts.winnr or 0\n+  local diagnostics = M.get(loclist and vim.api.nvim_win_get_buf(winnr), opts)\n+  local items = diagnostics_to_list_items(diagnostics)\n+  if loclist then\n+    vim.fn.setloclist(winnr, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics\n+---       - virtual_text: (default true) Use virtual text for diagnostics\n+---       - signs: (default true) Use signs for diagnostics\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      if v[namespace] then\n+        M.show(namespace, bufnr)\n+      end\n+    end\n+  else\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      for ns in pairs(v) do\n+        M.show(ns, bufnr)\n+      end\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param opts table|nil Display options to pass to |vim.diagnostic.show()|\n+function M.set(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return M.reset(namespace, bufnr)\n+  end\n+\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if opts then\n+    M.config(opts, namespace)\n+  end\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    M.show(namespace, bufnr)\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+end\n+\n+--- Get current diagnostics.\n+---\n+---@param bufnr number|nil Buffer number to get diagnistics from. Use 0 for",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r710879229",
            "id": 710879229,
            "line": 526,
            "node_id": "PRRC_kwDOAPphoM4qXyf9",
            "original_commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "original_line": 526,
            "original_position": 526,
            "original_start_line": null,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": 526,
            "pull_request_review_id": 757226245,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710879229/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-17T08:58:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710879229",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r710879547"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/710879547"
                }
            },
            "author_association": "MEMBER",
            "body": "`array of ...` (for sumneko)",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-17T08:56:52Z",
            "diff_hunk": "@@ -0,0 +1,1150 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_by_severity(severity, diagnostics)\n+  if not severity then\n+    return diagnostics\n+  end\n+\n+  if type(severity) ~= \"table\" then\n+    severity = to_severity(severity)\n+    return vim.tbl_filter(function(t) return t.severity == severity end, diagnostics)\n+  end\n+\n+  local min_severity = to_severity(severity.min) or M.severity.HINT\n+  local max_severity = to_severity(severity.max) or M.severity.ERROR\n+\n+  return vim.tbl_filter(function(t) return t.severity <= min_severity and t.severity >= max_severity end, diagnostics)\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local define_default_signs = (function()\n+  local signs_defined = false\n+  return function()\n+    if signs_defined then\n+      return\n+    end\n+\n+    for severity, sign_hl_name in pairs(sign_highlight_map) do\n+      local severity_name = M.severity[severity]\n+      vim.fn.sign_define(sign_hl_name, {\n+        text = (severity_name or 'U'):sub(1, 1),\n+        texthl = sign_hl_name,\n+        linehl = '',\n+        numhl = '',\n+      })\n+    end\n+\n+    signs_defined = true\n+  end\n+end)()\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = {}\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function is_disabled(namespace, bufnr)\n+  if type(diagnostic_disabled[bufnr]) == \"table\" then\n+    return diagnostic_disabled[bufnr][namespace]\n+  end\n+  return diagnostic_disabled[bufnr]\n+end\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.namespace = namespace\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local winnr = opts.winnr or 0\n+  local diagnostics = M.get(loclist and vim.api.nvim_win_get_buf(winnr), opts)\n+  local items = diagnostics_to_list_items(diagnostics)\n+  if loclist then\n+    vim.fn.setloclist(winnr, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics\n+---       - virtual_text: (default true) Use virtual text for diagnostics\n+---       - signs: (default true) Use signs for diagnostics\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      if v[namespace] then\n+        M.show(namespace, bufnr)\n+      end\n+    end\n+  else\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      for ns in pairs(v) do\n+        M.show(ns, bufnr)\n+      end\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param opts table|nil Display options to pass to |vim.diagnostic.show()|\n+function M.set(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return M.reset(namespace, bufnr)\n+  end\n+\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if opts then\n+    M.config(opts, namespace)\n+  end\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    M.show(namespace, bufnr)\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+end\n+\n+--- Get current diagnostics.\n+---\n+---@param bufnr number|nil Buffer number to get diagnistics from. Use 0 for\n+---                        current buffer or nil for all buffers.\n+---@param opts table|nil A table with the following keys:\n+---                        - namespace: (number) Limit diagnostics to the given namespace.\n+---                        - lnum: (number) Limit diagnostics to the given line number.\n+---                        - severity: See |diagnostic-severity|.\n+---@return table A list of diagnostic items |diagnostic-structure|.\n+function M.get(bufnr, opts)\n+  vim.validate {\n+    bufnr = { bufnr, 'n', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  opts = opts or {}\n+\n+  local namespace = opts.namespace\n+  local diagnostics = {}\n+\n+  ---@private\n+  local function add(d)\n+    if not opts.lnum or d.lnum == opts.lnum then\n+      table.insert(diagnostics, d)\n+    end\n+  end\n+\n+  if namespace == nil and bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, v in pairs(t) do\n+        for _, diagnostic in pairs(v) do\n+          add(diagnostic)\n+        end\n+      end\n+    end\n+  elseif namespace == nil then\n+    for iter_namespace in pairs(diagnostic_cache[bufnr]) do\n+      for _, diagnostic in pairs(diagnostic_cache[bufnr][iter_namespace]) do\n+        add(diagnostic)\n+      end\n+    end\n+  elseif bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, diagnostic in pairs(t[namespace] or {}) do\n+        add(diagnostic)\n+      end\n+    end\n+  else\n+    for _, diagnostic in pairs(diagnostic_cache[bufnr][namespace] or {}) do\n+      add(diagnostic)\n+    end\n+  end\n+\n+  if opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  return diagnostics\n+end\n+\n+-- Diagnostic Movements {{{\n+\n+local next_diagnostic = function(position, search_forward, bufnr, opts, namespace)\n+  position[1] = position[1] - 1\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  local wrap = vim.F.if_nil(opts.wrap, true)\n+  local line_count = vim.api.nvim_buf_line_count(bufnr)\n+  opts.namespace = namespace\n+  for i = 0, line_count do\n+    local offset = i * (search_forward and 1 or -1)\n+    local lnum = position[1] + offset\n+    if lnum < 0 or lnum >= line_count then\n+      if not wrap then\n+        return\n+      end\n+      lnum = (lnum + line_count) % line_count\n+    end\n+    opts.lnum = lnum\n+    local line_diagnostics = M.get(bufnr, opts)\n+    if line_diagnostics and not vim.tbl_isempty(line_diagnostics) then\n+      local sort_diagnostics, is_next\n+      if search_forward then\n+        sort_diagnostics = function(a, b) return a.col < b.col end\n+        is_next = function(diagnostic) return diagnostic.col > position[2] end\n+      else\n+        sort_diagnostics = function(a, b) return a.col > b.col end\n+        is_next = function(diagnostic) return diagnostic.col < position[2] end\n+      end\n+      table.sort(line_diagnostics, sort_diagnostics)\n+      if i == 0 then\n+        for _, v in pairs(line_diagnostics) do\n+          if is_next(v) then\n+            return v\n+          end\n+        end\n+      else\n+        return line_diagnostics[1]\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function diagnostic_move_pos(opts, pos)\n+  opts = opts or {}\n+\n+  local enable_popup = vim.F.if_nil(opts.enable_popup, true)\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+\n+  if not pos then\n+    vim.api.nvim_echo({\"No more valid diagnostics to move to\", \"WarningMsg\"})\n+    return\n+  end\n+\n+  vim.api.nvim_win_set_cursor(win_id, {pos[1] + 1, pos[2]})\n+\n+  if enable_popup then\n+    -- This is a bit weird... I'm surprised that we need to wait til the next tick to do this.\n+    vim.schedule(function()\n+      M.show_position_diagnostics(opts.popup_opts, vim.api.nvim_win_get_buf(win_id))\n+    end)\n+  end\n+end\n+\n+--- Get the previous diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic\n+function M.get_prev(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, false, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the previous diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic position as a (row, col) tuple.\n+function M.get_prev_pos(opts)\n+  local prev = M.get_prev(opts)\n+  if not prev then\n+    return false\n+  end\n+\n+  return {prev.lnum, prev.col}\n+end\n+\n+--- Move to the previous diagnostic in the current buffer.\n+---@param opts table See |vim.diagnostic.goto_next()|\n+function M.goto_prev(opts)\n+  return diagnostic_move_pos(\n+    opts,\n+    M.get_prev_pos(opts)\n+  )\n+end\n+\n+--- Get the next diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic\n+function M.get_next(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, true, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the next diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic position as a (row, col) tuple.\n+function M.get_next_pos(opts)\n+  local next = M.get_next(opts)\n+  if not next then\n+    return false\n+  end\n+\n+  return {next.lnum, next.col}\n+end\n+\n+--- Move to the next diagnostic.\n+---\n+---@param opts table|nil Configuration table with the following keys:\n+---         - namespace: (number) Only consider diagnostics from the given namespace.\n+---         - cursor_position: (cursor position) Cursor position as a (row, col) tuple. See\n+---                          |nvim_win_get_cursor()|. Defaults to the current cursor position.\n+---         - wrap: (boolean, default true) Whether to loop around file or not. Similar to 'wrapscan'.\n+---         - severity: See |diagnostic-severity|.\n+---         - enable_popup: (boolean, default true) Call |vim.diagnostic.show_line_diagnostics()|\n+---                       on jump.\n+---         - popup_opts: (table) Table to pass as {opts} parameter to\n+---                     |vim.diagnostic.show_line_diagnostics()|\n+---         - win_id: (number, default 0) Window ID\n+function M.goto_next(opts)\n+  return diagnostic_move_pos(\n+    opts,\n+    M.get_next_pos(opts)\n+  )\n+end\n+\n+-- Diagnostic Setters {{{\n+\n+--- Set signs for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table Configuration table with the following keys:\n+---            - priority: Set the priority of the signs |sign-priority|.\n+---@private\n+function M._set_signs(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ signs = opts }, namespace, bufnr).signs\n+\n+  if opts and opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  local ns = get_namespace(namespace)\n+\n+  define_default_signs()\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    vim.fn.sign_place(\n+      0,\n+      ns.sign_group,\n+      sign_highlight_map[diagnostic.severity],\n+      bufnr,\n+      {\n+        priority = opts and opts.priority,\n+        lnum = diagnostic.lnum + 1\n+      }\n+    )\n+  end\n+end\n+\n+--- Set underline for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table Configuration table. Currently unused.\n+---@private\n+function M._set_underline(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ underline = opts }, namespace, bufnr).underline\n+\n+  if opts and opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local higroup = underline_highlight_map[diagnostic.severity]\n+\n+    if higroup == nil then\n+      -- Default to error if we don't have a highlight associated\n+      higroup = underline_highlight_map.Error\n+    end\n+\n+    vim.highlight.range(\n+      bufnr,\n+      namespace,\n+      higroup,\n+      { diagnostic.lnum, diagnostic.col },\n+      { diagnostic.end_lnum, diagnostic.end_col }\n+    )\n+  end\n+end\n+\n+--- Set virtual text for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table|nil Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line.\n+---            - spacing: (number) Number of spaces to insert before virtual text.\n+---@private\n+function M._set_virtual_text(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ virtual_text = opts }, namespace, bufnr).virtual_text\n+\n+  local buffer_line_diagnostics = diagnostic_lines(diagnostics)\n+  for line, line_diagnostics in pairs(buffer_line_diagnostics) do\n+    if opts and opts.severity then\n+      line_diagnostics = filter_by_severity(opts.severity, line_diagnostics)\n+    end\n+    local virt_texts = M.get_virt_text_chunks(line_diagnostics, opts)\n+\n+    if virt_texts then\n+      vim.api.nvim_buf_set_extmark(bufnr, namespace, line, 0, {\n+        hl_mode = \"combine\",\n+        virt_text = virt_texts,\n+      })\n+    end\n+  end\n+end\n+\n+--- Get virtual text chunks to display using |nvim_buf_set_extmark()|.\n+---\n+---@param line_diags table The diagnostics associated with the line.\n+---@param opts table|nil Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line.\n+---            - spacing: (number) Number of spaces to insert before virtual text.\n+---@return an array of [text, hl_group] arrays. This can be passed directly to",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r710879547",
            "id": 710879547,
            "line": 859,
            "node_id": "PRRC_kwDOAPphoM4qXyk7",
            "original_commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "original_line": 859,
            "original_position": 859,
            "original_start_line": null,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": 859,
            "pull_request_review_id": 757226245,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710879547/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-17T08:58:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710879547",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r710879937"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/710879937"
                }
            },
            "author_association": "MEMBER",
            "body": "`tuple (...)`",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-17T08:57:23Z",
            "diff_hunk": "@@ -0,0 +1,1150 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_by_severity(severity, diagnostics)\n+  if not severity then\n+    return diagnostics\n+  end\n+\n+  if type(severity) ~= \"table\" then\n+    severity = to_severity(severity)\n+    return vim.tbl_filter(function(t) return t.severity == severity end, diagnostics)\n+  end\n+\n+  local min_severity = to_severity(severity.min) or M.severity.HINT\n+  local max_severity = to_severity(severity.max) or M.severity.ERROR\n+\n+  return vim.tbl_filter(function(t) return t.severity <= min_severity and t.severity >= max_severity end, diagnostics)\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local define_default_signs = (function()\n+  local signs_defined = false\n+  return function()\n+    if signs_defined then\n+      return\n+    end\n+\n+    for severity, sign_hl_name in pairs(sign_highlight_map) do\n+      local severity_name = M.severity[severity]\n+      vim.fn.sign_define(sign_hl_name, {\n+        text = (severity_name or 'U'):sub(1, 1),\n+        texthl = sign_hl_name,\n+        linehl = '',\n+        numhl = '',\n+      })\n+    end\n+\n+    signs_defined = true\n+  end\n+end)()\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = {}\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function is_disabled(namespace, bufnr)\n+  if type(diagnostic_disabled[bufnr]) == \"table\" then\n+    return diagnostic_disabled[bufnr][namespace]\n+  end\n+  return diagnostic_disabled[bufnr]\n+end\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.namespace = namespace\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local winnr = opts.winnr or 0\n+  local diagnostics = M.get(loclist and vim.api.nvim_win_get_buf(winnr), opts)\n+  local items = diagnostics_to_list_items(diagnostics)\n+  if loclist then\n+    vim.fn.setloclist(winnr, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics\n+---       - virtual_text: (default true) Use virtual text for diagnostics\n+---       - signs: (default true) Use signs for diagnostics\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      if v[namespace] then\n+        M.show(namespace, bufnr)\n+      end\n+    end\n+  else\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      for ns in pairs(v) do\n+        M.show(ns, bufnr)\n+      end\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param opts table|nil Display options to pass to |vim.diagnostic.show()|\n+function M.set(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return M.reset(namespace, bufnr)\n+  end\n+\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if opts then\n+    M.config(opts, namespace)\n+  end\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    M.show(namespace, bufnr)\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+end\n+\n+--- Get current diagnostics.\n+---\n+---@param bufnr number|nil Buffer number to get diagnistics from. Use 0 for\n+---                        current buffer or nil for all buffers.\n+---@param opts table|nil A table with the following keys:\n+---                        - namespace: (number) Limit diagnostics to the given namespace.\n+---                        - lnum: (number) Limit diagnostics to the given line number.\n+---                        - severity: See |diagnostic-severity|.\n+---@return table A list of diagnostic items |diagnostic-structure|.\n+function M.get(bufnr, opts)\n+  vim.validate {\n+    bufnr = { bufnr, 'n', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  opts = opts or {}\n+\n+  local namespace = opts.namespace\n+  local diagnostics = {}\n+\n+  ---@private\n+  local function add(d)\n+    if not opts.lnum or d.lnum == opts.lnum then\n+      table.insert(diagnostics, d)\n+    end\n+  end\n+\n+  if namespace == nil and bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, v in pairs(t) do\n+        for _, diagnostic in pairs(v) do\n+          add(diagnostic)\n+        end\n+      end\n+    end\n+  elseif namespace == nil then\n+    for iter_namespace in pairs(diagnostic_cache[bufnr]) do\n+      for _, diagnostic in pairs(diagnostic_cache[bufnr][iter_namespace]) do\n+        add(diagnostic)\n+      end\n+    end\n+  elseif bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, diagnostic in pairs(t[namespace] or {}) do\n+        add(diagnostic)\n+      end\n+    end\n+  else\n+    for _, diagnostic in pairs(diagnostic_cache[bufnr][namespace] or {}) do\n+      add(diagnostic)\n+    end\n+  end\n+\n+  if opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  return diagnostics\n+end\n+\n+-- Diagnostic Movements {{{\n+\n+local next_diagnostic = function(position, search_forward, bufnr, opts, namespace)\n+  position[1] = position[1] - 1\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  local wrap = vim.F.if_nil(opts.wrap, true)\n+  local line_count = vim.api.nvim_buf_line_count(bufnr)\n+  opts.namespace = namespace\n+  for i = 0, line_count do\n+    local offset = i * (search_forward and 1 or -1)\n+    local lnum = position[1] + offset\n+    if lnum < 0 or lnum >= line_count then\n+      if not wrap then\n+        return\n+      end\n+      lnum = (lnum + line_count) % line_count\n+    end\n+    opts.lnum = lnum\n+    local line_diagnostics = M.get(bufnr, opts)\n+    if line_diagnostics and not vim.tbl_isempty(line_diagnostics) then\n+      local sort_diagnostics, is_next\n+      if search_forward then\n+        sort_diagnostics = function(a, b) return a.col < b.col end\n+        is_next = function(diagnostic) return diagnostic.col > position[2] end\n+      else\n+        sort_diagnostics = function(a, b) return a.col > b.col end\n+        is_next = function(diagnostic) return diagnostic.col < position[2] end\n+      end\n+      table.sort(line_diagnostics, sort_diagnostics)\n+      if i == 0 then\n+        for _, v in pairs(line_diagnostics) do\n+          if is_next(v) then\n+            return v\n+          end\n+        end\n+      else\n+        return line_diagnostics[1]\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function diagnostic_move_pos(opts, pos)\n+  opts = opts or {}\n+\n+  local enable_popup = vim.F.if_nil(opts.enable_popup, true)\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+\n+  if not pos then\n+    vim.api.nvim_echo({\"No more valid diagnostics to move to\", \"WarningMsg\"})\n+    return\n+  end\n+\n+  vim.api.nvim_win_set_cursor(win_id, {pos[1] + 1, pos[2]})\n+\n+  if enable_popup then\n+    -- This is a bit weird... I'm surprised that we need to wait til the next tick to do this.\n+    vim.schedule(function()\n+      M.show_position_diagnostics(opts.popup_opts, vim.api.nvim_win_get_buf(win_id))\n+    end)\n+  end\n+end\n+\n+--- Get the previous diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic\n+function M.get_prev(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, false, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the previous diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic position as a (row, col) tuple.\n+function M.get_prev_pos(opts)\n+  local prev = M.get_prev(opts)\n+  if not prev then\n+    return false\n+  end\n+\n+  return {prev.lnum, prev.col}\n+end\n+\n+--- Move to the previous diagnostic in the current buffer.\n+---@param opts table See |vim.diagnostic.goto_next()|\n+function M.goto_prev(opts)\n+  return diagnostic_move_pos(\n+    opts,\n+    M.get_prev_pos(opts)\n+  )\n+end\n+\n+--- Get the next diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic\n+function M.get_next(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, true, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the next diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic position as a (row, col) tuple.\n+function M.get_next_pos(opts)\n+  local next = M.get_next(opts)\n+  if not next then\n+    return false\n+  end\n+\n+  return {next.lnum, next.col}\n+end\n+\n+--- Move to the next diagnostic.\n+---\n+---@param opts table|nil Configuration table with the following keys:\n+---         - namespace: (number) Only consider diagnostics from the given namespace.\n+---         - cursor_position: (cursor position) Cursor position as a (row, col) tuple. See\n+---                          |nvim_win_get_cursor()|. Defaults to the current cursor position.\n+---         - wrap: (boolean, default true) Whether to loop around file or not. Similar to 'wrapscan'.\n+---         - severity: See |diagnostic-severity|.\n+---         - enable_popup: (boolean, default true) Call |vim.diagnostic.show_line_diagnostics()|\n+---                       on jump.\n+---         - popup_opts: (table) Table to pass as {opts} parameter to\n+---                     |vim.diagnostic.show_line_diagnostics()|\n+---         - win_id: (number, default 0) Window ID\n+function M.goto_next(opts)\n+  return diagnostic_move_pos(\n+    opts,\n+    M.get_next_pos(opts)\n+  )\n+end\n+\n+-- Diagnostic Setters {{{\n+\n+--- Set signs for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table Configuration table with the following keys:\n+---            - priority: Set the priority of the signs |sign-priority|.\n+---@private\n+function M._set_signs(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ signs = opts }, namespace, bufnr).signs\n+\n+  if opts and opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  local ns = get_namespace(namespace)\n+\n+  define_default_signs()\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    vim.fn.sign_place(\n+      0,\n+      ns.sign_group,\n+      sign_highlight_map[diagnostic.severity],\n+      bufnr,\n+      {\n+        priority = opts and opts.priority,\n+        lnum = diagnostic.lnum + 1\n+      }\n+    )\n+  end\n+end\n+\n+--- Set underline for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table Configuration table. Currently unused.\n+---@private\n+function M._set_underline(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ underline = opts }, namespace, bufnr).underline\n+\n+  if opts and opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local higroup = underline_highlight_map[diagnostic.severity]\n+\n+    if higroup == nil then\n+      -- Default to error if we don't have a highlight associated\n+      higroup = underline_highlight_map.Error\n+    end\n+\n+    vim.highlight.range(\n+      bufnr,\n+      namespace,\n+      higroup,\n+      { diagnostic.lnum, diagnostic.col },\n+      { diagnostic.end_lnum, diagnostic.end_col }\n+    )\n+  end\n+end\n+\n+--- Set virtual text for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table|nil Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line.\n+---            - spacing: (number) Number of spaces to insert before virtual text.\n+---@private\n+function M._set_virtual_text(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ virtual_text = opts }, namespace, bufnr).virtual_text\n+\n+  local buffer_line_diagnostics = diagnostic_lines(diagnostics)\n+  for line, line_diagnostics in pairs(buffer_line_diagnostics) do\n+    if opts and opts.severity then\n+      line_diagnostics = filter_by_severity(opts.severity, line_diagnostics)\n+    end\n+    local virt_texts = M.get_virt_text_chunks(line_diagnostics, opts)\n+\n+    if virt_texts then\n+      vim.api.nvim_buf_set_extmark(bufnr, namespace, line, 0, {\n+        hl_mode = \"combine\",\n+        virt_text = virt_texts,\n+      })\n+    end\n+  end\n+end\n+\n+--- Get virtual text chunks to display using |nvim_buf_set_extmark()|.\n+---\n+---@param line_diags table The diagnostics associated with the line.\n+---@param opts table|nil Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line.\n+---            - spacing: (number) Number of spaces to insert before virtual text.\n+---@return an array of [text, hl_group] arrays. This can be passed directly to\n+---        the {virt_text} option of |nvim_buf_set_extmark()|.\n+function M.get_virt_text_chunks(line_diags, opts)\n+  if #line_diags == 0 then\n+    return nil\n+  end\n+\n+  opts = opts or {}\n+  local prefix = opts.prefix or \"■\"\n+  local spacing = opts.spacing or 4\n+\n+  -- Create a little more space between virtual text and contents\n+  local virt_texts = {{string.rep(\" \", spacing)}}\n+\n+  for i = 1, #line_diags - 1 do\n+    table.insert(virt_texts, {prefix, virtual_text_highlight_map[line_diags[i].severity]})\n+  end\n+  local last = line_diags[#line_diags]\n+\n+  -- TODO(tjdevries): Allow different servers to be shown first somehow?\n+  -- TODO(tjdevries): Display server name associated with these?\n+  if last.message then\n+    table.insert(\n+      virt_texts,\n+      {\n+        string.format(\"%s %s\", prefix, last.message:gsub(\"\\r\", \"\"):gsub(\"\\n\", \"  \")),\n+        virtual_text_highlight_map[last.severity]\n+      }\n+    )\n+\n+    return virt_texts\n+  end\n+end\n+\n+--- Callback scheduled when leaving Insert mode.\n+---\n+--- This function must be exported publicly so that it is available to be\n+--- called from the Vimscript autocommand.\n+---\n+--- See @ref schedule_display()\n+---\n+---@private\n+function M._execute_scheduled_display(namespace, bufnr)\n+  local args = bufs_waiting_to_update[bufnr][namespace]\n+  if not args then\n+    return\n+  end\n+\n+  -- Clear the args so we don't display unnecessarily.\n+  bufs_waiting_to_update[bufnr][namespace] = nil\n+\n+  M.show(namespace, bufnr, nil, args)\n+end\n+\n+--- Hide currently displayed diagnostics.\n+---\n+--- This only clears the decorations displayed in the buffer. Diagnostics can\n+--- be redisplayed with |vim.diagnostic.show()|. To completely remove\n+--- diagnostics, use |vim.diagnostic.reset()|.\n+---\n+--- To hide diagnostics and prevent them from re-displaying, use\n+--- |vim.diagnostic.disable()|.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number|nil Buffer number. Defaults to the current buffer.\n+function M.hide(namespace, bufnr)\n+  vim.validate {\n+    namespace = { namespace, 'n' },\n+    bufnr = { bufnr, 'n', true },\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  diagnostic_cache_extmarks[bufnr][namespace] = {}\n+\n+  local ns = get_namespace(namespace)\n+\n+  -- clear sign group\n+  vim.fn.sign_unplace(ns.sign_group, {buffer=bufnr})\n+\n+  -- clear virtual text namespace\n+  vim.api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+end\n+\n+\n+--- Display diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number Diagnostic namespace\n+---@param bufnr number|nil Buffer number. Defaults to the current buffer.\n+---@param diagnostics table|nil The diagnostics to display. When omitted, use the\n+---                             saved diagnostics for the given namespace and\n+---                             buffer. This can be used to display a list of diagnostics\n+---                             without saving them or to display only a subset of\n+---                             diagnostics.\n+---@param opts table|nil Display options. See |vim.diagnostic.config()|.\n+function M.show(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = { namespace, 'n' },\n+    bufnr = { bufnr, 'n', true },\n+    diagnostics = { diagnostics, 't', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  if is_disabled(namespace, bufnr) then\n+    return\n+  end\n+\n+  M.hide(namespace, bufnr)\n+\n+  diagnostics = diagnostics or M.get(bufnr, {namespace=namespace})\n+\n+  if not diagnostics or vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  opts = get_resolved_options(opts, namespace, bufnr)\n+\n+  if opts.update_in_insert then\n+    clear_scheduled_display(namespace, bufnr)\n+  else\n+    local mode = vim.api.nvim_get_mode()\n+    if string.sub(mode.mode, 1, 1) == 'i' then\n+      schedule_display(namespace, bufnr, opts)\n+      return\n+    end\n+  end\n+\n+  if opts.underline then\n+    M._set_underline(namespace, bufnr, diagnostics, opts.underline)\n+  end\n+\n+  if opts.virtual_text then\n+    M._set_virtual_text(namespace, bufnr, diagnostics, opts.virtual_text)\n+  end\n+\n+  if opts.signs then\n+    M._set_signs(namespace, bufnr, diagnostics, opts.signs)\n+  end\n+\n+  save_extmarks(namespace, bufnr)\n+end\n+\n+--- Open a floating window with the diagnostics at the given position.\n+---\n+---@param opts table|nil Configuration table with the same keys as\n+---            |vim.lsp.util.open_floatin_preview()| in addition to the following:\n+---            - namespace: (number) Limit diagnostics to the given namespace\n+---            - severity: See |diagnostic-severity|.\n+---            - show_header: (boolean, default true) Show \"Diagnostics:\" header\n+---@param bufnr number|nil Buffer number. Defaults to the current buffer.\n+---@param position table|nil The (0,0)-indexed position. Defaults to the current cursor position.\n+---@return A ({popup_bufnr}, {win_id}) tuple\n+function M.show_position_diagnostics(opts, bufnr, position)\n+  vim.validate {\n+    opts = { opts, 't', true },\n+    bufnr = { bufnr, 'n', true },\n+    position = { position, 't', true },\n+  }\n+\n+  opts = opts or {}\n+\n+  opts.focus_id = \"position_diagnostics\"\n+  bufnr = get_bufnr(bufnr)\n+  if not position then\n+    local curr_position = vim.api.nvim_win_get_cursor(0)\n+    curr_position[1] = curr_position[1] - 1\n+    position = curr_position\n+  end\n+  local match_position_predicate = function(diag)\n+    return position[1] == diag.lnum and\n+    position[2] >= diag.col and\n+    (position[2] <= diag.end_col or position[1] < diag.end_lnum)\n+  end\n+  local position_diagnostics = vim.tbl_filter(match_position_predicate, M.get(bufnr, opts))\n+  table.sort(position_diagnostics, function(a, b) return a.severity < b.severity end)\n+  return show_diagnostics(opts, position_diagnostics)\n+end\n+\n+--- Open a floating window with the diagnostics from the given line.\n+---\n+---@param opts table Configuration table. See |vim.diagnostic.show_position_diagnostics()|.\n+---@param bufnr number|nil Buffer number. Defaults to the current buffer.\n+---@param lnum number|nil Line number. Defaults to line number of cursor.\n+---@return A ({popup_bufnr}, {win_id}) tuple",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r710879937",
            "id": 710879937,
            "line": 1042,
            "node_id": "PRRC_kwDOAPphoM4qXyrB",
            "original_commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "original_line": 1042,
            "original_position": 1042,
            "original_start_line": null,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": 1042,
            "pull_request_review_id": 757226245,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710879937/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-17T08:58:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710879937",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r710910682"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/710910682"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Using `lua vim.diagnostic.setqflist()` results in an error.\r\n```\r\nE5108: Error executing lua /home/oni-link/git/neovim/runtime/lua/vim/diagnostic.lua:534: bufnr: expected n\r\number, got boolean\r\nstack traceback:\r\n        /home/oni-link/git/neovim/runtime/lua/vim/diagnostic.lua:534: in function 'get'\r\n        /home/oni-link/git/neovim/runtime/lua/vim/diagnostic.lua:411: in function 'set_list'\r\n        /home/oni-link/git/neovim/runtime/lua/vim/diagnostic.lua:1090: in function 'setqflist'\r\n        [string \":lua\"]:1: in main chunk\r\n```\r\nIf `loclist == false` then the first argument to `M.get()` is a bool and not a number.",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-17T09:40:58Z",
            "diff_hunk": "@@ -0,0 +1,1150 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_by_severity(severity, diagnostics)\n+  if not severity then\n+    return diagnostics\n+  end\n+\n+  if type(severity) ~= \"table\" then\n+    severity = to_severity(severity)\n+    return vim.tbl_filter(function(t) return t.severity == severity end, diagnostics)\n+  end\n+\n+  local min_severity = to_severity(severity.min) or M.severity.HINT\n+  local max_severity = to_severity(severity.max) or M.severity.ERROR\n+\n+  return vim.tbl_filter(function(t) return t.severity <= min_severity and t.severity >= max_severity end, diagnostics)\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local define_default_signs = (function()\n+  local signs_defined = false\n+  return function()\n+    if signs_defined then\n+      return\n+    end\n+\n+    for severity, sign_hl_name in pairs(sign_highlight_map) do\n+      local severity_name = M.severity[severity]\n+      vim.fn.sign_define(sign_hl_name, {\n+        text = (severity_name or 'U'):sub(1, 1),\n+        texthl = sign_hl_name,\n+        linehl = '',\n+        numhl = '',\n+      })\n+    end\n+\n+    signs_defined = true\n+  end\n+end)()\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = {}\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function is_disabled(namespace, bufnr)\n+  if type(diagnostic_disabled[bufnr]) == \"table\" then\n+    return diagnostic_disabled[bufnr][namespace]\n+  end\n+  return diagnostic_disabled[bufnr]\n+end\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.namespace = namespace\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local winnr = opts.winnr or 0\n+  local diagnostics = M.get(loclist and vim.api.nvim_win_get_buf(winnr), opts)",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r710910682",
            "id": 710910682,
            "line": 411,
            "node_id": "PRRC_kwDOAPphoM4qX6La",
            "original_commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "original_line": 411,
            "original_position": 411,
            "original_start_line": null,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": 411,
            "pull_request_review_id": 757268778,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710910682/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-17T09:40:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710910682",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2077655?v=4",
                "events_url": "https://api.github.com/users/oni-link/events{/privacy}",
                "followers_url": "https://api.github.com/users/oni-link/followers",
                "following_url": "https://api.github.com/users/oni-link/following{/other_user}",
                "gists_url": "https://api.github.com/users/oni-link/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/oni-link",
                "id": 2077655,
                "login": "oni-link",
                "node_id": "MDQ6VXNlcjIwNzc2NTU=",
                "organizations_url": "https://api.github.com/users/oni-link/orgs",
                "received_events_url": "https://api.github.com/users/oni-link/received_events",
                "repos_url": "https://api.github.com/users/oni-link/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/oni-link/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/oni-link/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/oni-link"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r710978169"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/710978169"
                }
            },
            "author_association": "MEMBER",
            "body": "not sure _how_ to make EmmyLua happy there, though...",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-17T11:32:25Z",
            "diff_hunk": "@@ -0,0 +1,1150 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_by_severity(severity, diagnostics)\n+  if not severity then\n+    return diagnostics\n+  end\n+\n+  if type(severity) ~= \"table\" then\n+    severity = to_severity(severity)\n+    return vim.tbl_filter(function(t) return t.severity == severity end, diagnostics)\n+  end\n+\n+  local min_severity = to_severity(severity.min) or M.severity.HINT\n+  local max_severity = to_severity(severity.max) or M.severity.ERROR\n+\n+  return vim.tbl_filter(function(t) return t.severity <= min_severity and t.severity >= max_severity end, diagnostics)\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local define_default_signs = (function()\n+  local signs_defined = false\n+  return function()\n+    if signs_defined then\n+      return\n+    end\n+\n+    for severity, sign_hl_name in pairs(sign_highlight_map) do\n+      local severity_name = M.severity[severity]\n+      vim.fn.sign_define(sign_hl_name, {\n+        text = (severity_name or 'U'):sub(1, 1),\n+        texthl = sign_hl_name,\n+        linehl = '',\n+        numhl = '',\n+      })\n+    end\n+\n+    signs_defined = true\n+  end\n+end)()\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = {}\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function is_disabled(namespace, bufnr)\n+  if type(diagnostic_disabled[bufnr]) == \"table\" then\n+    return diagnostic_disabled[bufnr][namespace]\n+  end\n+  return diagnostic_disabled[bufnr]\n+end\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.namespace = namespace\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local winnr = opts.winnr or 0\n+  local diagnostics = M.get(loclist and vim.api.nvim_win_get_buf(winnr), opts)\n+  local items = diagnostics_to_list_items(diagnostics)\n+  if loclist then\n+    vim.fn.setloclist(winnr, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics\n+---       - virtual_text: (default true) Use virtual text for diagnostics\n+---       - signs: (default true) Use signs for diagnostics\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      if v[namespace] then\n+        M.show(namespace, bufnr)\n+      end\n+    end\n+  else\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      for ns in pairs(v) do\n+        M.show(ns, bufnr)\n+      end\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param opts table|nil Display options to pass to |vim.diagnostic.show()|\n+function M.set(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return M.reset(namespace, bufnr)\n+  end\n+\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if opts then\n+    M.config(opts, namespace)\n+  end\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    M.show(namespace, bufnr)\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+end\n+\n+--- Get current diagnostics.\n+---\n+---@param bufnr number|nil Buffer number to get diagnistics from. Use 0 for\n+---                        current buffer or nil for all buffers.\n+---@param opts table|nil A table with the following keys:\n+---                        - namespace: (number) Limit diagnostics to the given namespace.\n+---                        - lnum: (number) Limit diagnostics to the given line number.\n+---                        - severity: See |diagnostic-severity|.\n+---@return table A list of diagnostic items |diagnostic-structure|.\n+function M.get(bufnr, opts)\n+  vim.validate {\n+    bufnr = { bufnr, 'n', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  opts = opts or {}\n+\n+  local namespace = opts.namespace\n+  local diagnostics = {}\n+\n+  ---@private\n+  local function add(d)\n+    if not opts.lnum or d.lnum == opts.lnum then\n+      table.insert(diagnostics, d)\n+    end\n+  end\n+\n+  if namespace == nil and bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, v in pairs(t) do\n+        for _, diagnostic in pairs(v) do\n+          add(diagnostic)\n+        end\n+      end\n+    end\n+  elseif namespace == nil then\n+    for iter_namespace in pairs(diagnostic_cache[bufnr]) do\n+      for _, diagnostic in pairs(diagnostic_cache[bufnr][iter_namespace]) do\n+        add(diagnostic)\n+      end\n+    end\n+  elseif bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, diagnostic in pairs(t[namespace] or {}) do\n+        add(diagnostic)\n+      end\n+    end\n+  else\n+    for _, diagnostic in pairs(diagnostic_cache[bufnr][namespace] or {}) do\n+      add(diagnostic)\n+    end\n+  end\n+\n+  if opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  return diagnostics\n+end\n+\n+-- Diagnostic Movements {{{\n+\n+local next_diagnostic = function(position, search_forward, bufnr, opts, namespace)\n+  position[1] = position[1] - 1\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  local wrap = vim.F.if_nil(opts.wrap, true)\n+  local line_count = vim.api.nvim_buf_line_count(bufnr)\n+  opts.namespace = namespace\n+  for i = 0, line_count do\n+    local offset = i * (search_forward and 1 or -1)\n+    local lnum = position[1] + offset\n+    if lnum < 0 or lnum >= line_count then\n+      if not wrap then\n+        return\n+      end\n+      lnum = (lnum + line_count) % line_count\n+    end\n+    opts.lnum = lnum\n+    local line_diagnostics = M.get(bufnr, opts)\n+    if line_diagnostics and not vim.tbl_isempty(line_diagnostics) then\n+      local sort_diagnostics, is_next\n+      if search_forward then\n+        sort_diagnostics = function(a, b) return a.col < b.col end\n+        is_next = function(diagnostic) return diagnostic.col > position[2] end\n+      else\n+        sort_diagnostics = function(a, b) return a.col > b.col end\n+        is_next = function(diagnostic) return diagnostic.col < position[2] end\n+      end\n+      table.sort(line_diagnostics, sort_diagnostics)\n+      if i == 0 then\n+        for _, v in pairs(line_diagnostics) do\n+          if is_next(v) then\n+            return v\n+          end\n+        end\n+      else\n+        return line_diagnostics[1]\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function diagnostic_move_pos(opts, pos)\n+  opts = opts or {}\n+\n+  local enable_popup = vim.F.if_nil(opts.enable_popup, true)\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+\n+  if not pos then\n+    vim.api.nvim_echo({\"No more valid diagnostics to move to\", \"WarningMsg\"})\n+    return\n+  end\n+\n+  vim.api.nvim_win_set_cursor(win_id, {pos[1] + 1, pos[2]})\n+\n+  if enable_popup then\n+    -- This is a bit weird... I'm surprised that we need to wait til the next tick to do this.\n+    vim.schedule(function()\n+      M.show_position_diagnostics(opts.popup_opts, vim.api.nvim_win_get_buf(win_id))\n+    end)\n+  end\n+end\n+\n+--- Get the previous diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic\n+function M.get_prev(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, false, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the previous diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic position as a (row, col) tuple.\n+function M.get_prev_pos(opts)\n+  local prev = M.get_prev(opts)\n+  if not prev then\n+    return false\n+  end\n+\n+  return {prev.lnum, prev.col}\n+end\n+\n+--- Move to the previous diagnostic in the current buffer.\n+---@param opts table See |vim.diagnostic.goto_next()|\n+function M.goto_prev(opts)\n+  return diagnostic_move_pos(\n+    opts,\n+    M.get_prev_pos(opts)\n+  )\n+end\n+\n+--- Get the next diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic\n+function M.get_next(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, true, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the next diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic position as a (row, col) tuple.\n+function M.get_next_pos(opts)\n+  local next = M.get_next(opts)\n+  if not next then\n+    return false\n+  end\n+\n+  return {next.lnum, next.col}\n+end\n+\n+--- Move to the next diagnostic.\n+---\n+---@param opts table|nil Configuration table with the following keys:\n+---         - namespace: (number) Only consider diagnostics from the given namespace.\n+---         - cursor_position: (cursor position) Cursor position as a (row, col) tuple. See\n+---                          |nvim_win_get_cursor()|. Defaults to the current cursor position.\n+---         - wrap: (boolean, default true) Whether to loop around file or not. Similar to 'wrapscan'.\n+---         - severity: See |diagnostic-severity|.\n+---         - enable_popup: (boolean, default true) Call |vim.diagnostic.show_line_diagnostics()|\n+---                       on jump.\n+---         - popup_opts: (table) Table to pass as {opts} parameter to\n+---                     |vim.diagnostic.show_line_diagnostics()|\n+---         - win_id: (number, default 0) Window ID\n+function M.goto_next(opts)\n+  return diagnostic_move_pos(\n+    opts,\n+    M.get_next_pos(opts)\n+  )\n+end\n+\n+-- Diagnostic Setters {{{\n+\n+--- Set signs for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table Configuration table with the following keys:\n+---            - priority: Set the priority of the signs |sign-priority|.\n+---@private\n+function M._set_signs(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ signs = opts }, namespace, bufnr).signs\n+\n+  if opts and opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  local ns = get_namespace(namespace)\n+\n+  define_default_signs()\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    vim.fn.sign_place(\n+      0,\n+      ns.sign_group,\n+      sign_highlight_map[diagnostic.severity],\n+      bufnr,\n+      {\n+        priority = opts and opts.priority,\n+        lnum = diagnostic.lnum + 1\n+      }\n+    )\n+  end\n+end\n+\n+--- Set underline for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table Configuration table. Currently unused.\n+---@private\n+function M._set_underline(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ underline = opts }, namespace, bufnr).underline\n+\n+  if opts and opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local higroup = underline_highlight_map[diagnostic.severity]\n+\n+    if higroup == nil then\n+      -- Default to error if we don't have a highlight associated\n+      higroup = underline_highlight_map.Error\n+    end\n+\n+    vim.highlight.range(\n+      bufnr,\n+      namespace,\n+      higroup,\n+      { diagnostic.lnum, diagnostic.col },\n+      { diagnostic.end_lnum, diagnostic.end_col }\n+    )\n+  end\n+end\n+\n+--- Set virtual text for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table|nil Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line.\n+---            - spacing: (number) Number of spaces to insert before virtual text.\n+---@private\n+function M._set_virtual_text(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ virtual_text = opts }, namespace, bufnr).virtual_text\n+\n+  local buffer_line_diagnostics = diagnostic_lines(diagnostics)\n+  for line, line_diagnostics in pairs(buffer_line_diagnostics) do\n+    if opts and opts.severity then\n+      line_diagnostics = filter_by_severity(opts.severity, line_diagnostics)\n+    end\n+    local virt_texts = M.get_virt_text_chunks(line_diagnostics, opts)\n+\n+    if virt_texts then\n+      vim.api.nvim_buf_set_extmark(bufnr, namespace, line, 0, {\n+        hl_mode = \"combine\",\n+        virt_text = virt_texts,\n+      })\n+    end\n+  end\n+end\n+\n+--- Get virtual text chunks to display using |nvim_buf_set_extmark()|.\n+---\n+---@param line_diags table The diagnostics associated with the line.\n+---@param opts table|nil Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line.\n+---            - spacing: (number) Number of spaces to insert before virtual text.\n+---@return an array of [text, hl_group] arrays. This can be passed directly to\n+---        the {virt_text} option of |nvim_buf_set_extmark()|.\n+function M.get_virt_text_chunks(line_diags, opts)\n+  if #line_diags == 0 then\n+    return nil\n+  end\n+\n+  opts = opts or {}\n+  local prefix = opts.prefix or \"■\"\n+  local spacing = opts.spacing or 4\n+\n+  -- Create a little more space between virtual text and contents\n+  local virt_texts = {{string.rep(\" \", spacing)}}\n+\n+  for i = 1, #line_diags - 1 do\n+    table.insert(virt_texts, {prefix, virtual_text_highlight_map[line_diags[i].severity]})\n+  end\n+  local last = line_diags[#line_diags]\n+\n+  -- TODO(tjdevries): Allow different servers to be shown first somehow?\n+  -- TODO(tjdevries): Display server name associated with these?\n+  if last.message then\n+    table.insert(\n+      virt_texts,\n+      {\n+        string.format(\"%s %s\", prefix, last.message:gsub(\"\\r\", \"\"):gsub(\"\\n\", \"  \")),\n+        virtual_text_highlight_map[last.severity]\n+      }\n+    )\n+\n+    return virt_texts\n+  end\n+end\n+\n+--- Callback scheduled when leaving Insert mode.\n+---\n+--- This function must be exported publicly so that it is available to be\n+--- called from the Vimscript autocommand.\n+---\n+--- See @ref schedule_display()\n+---\n+---@private\n+function M._execute_scheduled_display(namespace, bufnr)\n+  local args = bufs_waiting_to_update[bufnr][namespace]\n+  if not args then\n+    return\n+  end\n+\n+  -- Clear the args so we don't display unnecessarily.\n+  bufs_waiting_to_update[bufnr][namespace] = nil\n+\n+  M.show(namespace, bufnr, nil, args)\n+end\n+\n+--- Hide currently displayed diagnostics.\n+---\n+--- This only clears the decorations displayed in the buffer. Diagnostics can\n+--- be redisplayed with |vim.diagnostic.show()|. To completely remove\n+--- diagnostics, use |vim.diagnostic.reset()|.\n+---\n+--- To hide diagnostics and prevent them from re-displaying, use\n+--- |vim.diagnostic.disable()|.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number|nil Buffer number. Defaults to the current buffer.\n+function M.hide(namespace, bufnr)\n+  vim.validate {\n+    namespace = { namespace, 'n' },\n+    bufnr = { bufnr, 'n', true },\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  diagnostic_cache_extmarks[bufnr][namespace] = {}\n+\n+  local ns = get_namespace(namespace)\n+\n+  -- clear sign group\n+  vim.fn.sign_unplace(ns.sign_group, {buffer=bufnr})\n+\n+  -- clear virtual text namespace\n+  vim.api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+end\n+\n+\n+--- Display diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number Diagnostic namespace\n+---@param bufnr number|nil Buffer number. Defaults to the current buffer.\n+---@param diagnostics table|nil The diagnostics to display. When omitted, use the\n+---                             saved diagnostics for the given namespace and\n+---                             buffer. This can be used to display a list of diagnostics\n+---                             without saving them or to display only a subset of\n+---                             diagnostics.\n+---@param opts table|nil Display options. See |vim.diagnostic.config()|.\n+function M.show(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = { namespace, 'n' },\n+    bufnr = { bufnr, 'n', true },\n+    diagnostics = { diagnostics, 't', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  if is_disabled(namespace, bufnr) then\n+    return\n+  end\n+\n+  M.hide(namespace, bufnr)\n+\n+  diagnostics = diagnostics or M.get(bufnr, {namespace=namespace})\n+\n+  if not diagnostics or vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  opts = get_resolved_options(opts, namespace, bufnr)\n+\n+  if opts.update_in_insert then\n+    clear_scheduled_display(namespace, bufnr)\n+  else\n+    local mode = vim.api.nvim_get_mode()\n+    if string.sub(mode.mode, 1, 1) == 'i' then\n+      schedule_display(namespace, bufnr, opts)\n+      return\n+    end\n+  end\n+\n+  if opts.underline then\n+    M._set_underline(namespace, bufnr, diagnostics, opts.underline)\n+  end\n+\n+  if opts.virtual_text then\n+    M._set_virtual_text(namespace, bufnr, diagnostics, opts.virtual_text)\n+  end\n+\n+  if opts.signs then\n+    M._set_signs(namespace, bufnr, diagnostics, opts.signs)\n+  end\n+\n+  save_extmarks(namespace, bufnr)\n+end\n+\n+--- Open a floating window with the diagnostics at the given position.\n+---\n+---@param opts table|nil Configuration table with the same keys as\n+---            |vim.lsp.util.open_floatin_preview()| in addition to the following:\n+---            - namespace: (number) Limit diagnostics to the given namespace\n+---            - severity: See |diagnostic-severity|.\n+---            - show_header: (boolean, default true) Show \"Diagnostics:\" header\n+---@param bufnr number|nil Buffer number. Defaults to the current buffer.\n+---@param position table|nil The (0,0)-indexed position. Defaults to the current cursor position.\n+---@return A ({popup_bufnr}, {win_id}) tuple",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r710978169",
            "id": 710978169,
            "in_reply_to_id": 710878303,
            "line": 1010,
            "node_id": "PRRC_kwDOAPphoM4qYKp5",
            "original_commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "original_line": 1010,
            "original_position": 1010,
            "original_start_line": null,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": 1010,
            "pull_request_review_id": 757358141,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710978169/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-17T11:32:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/710978169",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r711129986"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/711129986"
                }
            },
            "author_association": "MEMBER",
            "body": "#15696 ",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-17T14:56:59Z",
            "diff_hunk": "@@ -0,0 +1,1150 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_by_severity(severity, diagnostics)\n+  if not severity then\n+    return diagnostics\n+  end\n+\n+  if type(severity) ~= \"table\" then\n+    severity = to_severity(severity)\n+    return vim.tbl_filter(function(t) return t.severity == severity end, diagnostics)\n+  end\n+\n+  local min_severity = to_severity(severity.min) or M.severity.HINT\n+  local max_severity = to_severity(severity.max) or M.severity.ERROR\n+\n+  return vim.tbl_filter(function(t) return t.severity <= min_severity and t.severity >= max_severity end, diagnostics)\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local define_default_signs = (function()\n+  local signs_defined = false\n+  return function()\n+    if signs_defined then\n+      return\n+    end\n+\n+    for severity, sign_hl_name in pairs(sign_highlight_map) do\n+      local severity_name = M.severity[severity]\n+      vim.fn.sign_define(sign_hl_name, {\n+        text = (severity_name or 'U'):sub(1, 1),\n+        texthl = sign_hl_name,\n+        linehl = '',\n+        numhl = '',\n+      })\n+    end\n+\n+    signs_defined = true\n+  end\n+end)()\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = {}\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function is_disabled(namespace, bufnr)\n+  if type(diagnostic_disabled[bufnr]) == \"table\" then\n+    return diagnostic_disabled[bufnr][namespace]\n+  end\n+  return diagnostic_disabled[bufnr]\n+end\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.namespace = namespace\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local winnr = opts.winnr or 0\n+  local diagnostics = M.get(loclist and vim.api.nvim_win_get_buf(winnr), opts)",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r711129986",
            "id": 711129986,
            "in_reply_to_id": 710910682,
            "line": 411,
            "node_id": "PRRC_kwDOAPphoM4qYvuC",
            "original_commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "original_line": 411,
            "original_position": 411,
            "original_start_line": null,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": 411,
            "pull_request_review_id": 757563287,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/711129986/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-17T14:56:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/711129986",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/15585#discussion_r711139469"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/15585"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/711139469"
                }
            },
            "author_association": "MEMBER",
            "body": "All of these are addressed in #15696 ",
            "commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "created_at": "2021-09-17T15:08:55Z",
            "diff_hunk": "@@ -0,0 +1,1150 @@\n+local M = {}\n+\n+M.severity = {\n+  ERROR = 1,\n+  WARN = 2,\n+  INFO = 3,\n+  HINT = 4,\n+}\n+\n+vim.tbl_add_reverse_lookup(M.severity)\n+\n+local global_diagnostic_options = {\n+  signs = true,\n+  underline = true,\n+  virtual_text = true,\n+  update_in_insert = false,\n+  severity_sort = false,\n+}\n+\n+-- Local functions {{{\n+\n+---@private\n+local function to_severity(severity)\n+  return type(severity) == 'string' and M.severity[string.upper(severity)] or severity\n+end\n+\n+---@private\n+local function filter_by_severity(severity, diagnostics)\n+  if not severity then\n+    return diagnostics\n+  end\n+\n+  if type(severity) ~= \"table\" then\n+    severity = to_severity(severity)\n+    return vim.tbl_filter(function(t) return t.severity == severity end, diagnostics)\n+  end\n+\n+  local min_severity = to_severity(severity.min) or M.severity.HINT\n+  local max_severity = to_severity(severity.max) or M.severity.ERROR\n+\n+  return vim.tbl_filter(function(t) return t.severity <= min_severity and t.severity >= max_severity end, diagnostics)\n+end\n+\n+---@private\n+local function resolve_optional_value(option, namespace, bufnr)\n+  local enabled_val = {}\n+\n+  if not option then\n+    return false\n+  elseif option == true then\n+    return enabled_val\n+  elseif type(option) == 'function' then\n+    local val = option(namespace, bufnr)\n+    if val == true then\n+      return enabled_val\n+    else\n+      return val\n+    end\n+  elseif type(option) == 'table' then\n+    return option\n+  else\n+    error(\"Unexpected option type: \" .. vim.inspect(option))\n+  end\n+end\n+\n+local all_namespaces = {}\n+\n+---@private\n+local function get_namespace(ns)\n+  if not all_namespaces[ns] then\n+    local name\n+    for k, v in pairs(vim.api.nvim_get_namespaces()) do\n+      if ns == v then\n+        name = k\n+        break\n+      end\n+    end\n+\n+    if not name then\n+      return vim.notify(\"namespace does not exist or is anonymous\", vim.log.levels.ERROR)\n+    end\n+\n+    all_namespaces[ns] = {\n+      name = name,\n+      sign_group = string.format(\"vim.diagnostic.%s\", name),\n+      opts = {}\n+    }\n+  end\n+  return all_namespaces[ns]\n+end\n+\n+---@private\n+local function get_resolved_options(opts, namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  local resolved = vim.tbl_extend('keep', opts or {}, ns.opts, global_diagnostic_options)\n+  for k in pairs(global_diagnostic_options) do\n+    if resolved[k] ~= nil then\n+      resolved[k] = resolve_optional_value(resolved[k], namespace, bufnr)\n+    end\n+  end\n+  return resolved\n+end\n+\n+-- Default diagnostic highlights\n+local diagnostic_severities = {\n+  [M.severity.ERROR] = { ctermfg = 1, guifg = \"Red\" };\n+  [M.severity.WARN] = { ctermfg = 3, guifg = \"Orange\" };\n+  [M.severity.INFO] = { ctermfg = 4, guifg = \"LightBlue\" };\n+  [M.severity.HINT] = { ctermfg = 7, guifg = \"LightGrey\" };\n+}\n+\n+-- Make a map from DiagnosticSeverity -> Highlight Name\n+---@private\n+local function make_highlight_map(base_name)\n+  local result = {}\n+  for k in pairs(diagnostic_severities) do\n+    local name = M.severity[k]\n+    name = name:sub(1, 1) .. name:sub(2):lower()\n+    result[k] = \"Diagnostic\" .. base_name .. name\n+  end\n+\n+  return result\n+end\n+\n+local virtual_text_highlight_map = make_highlight_map(\"VirtualText\")\n+local underline_highlight_map = make_highlight_map(\"Underline\")\n+local floating_highlight_map = make_highlight_map(\"Floating\")\n+local sign_highlight_map = make_highlight_map(\"Sign\")\n+\n+---@private\n+local define_default_signs = (function()\n+  local signs_defined = false\n+  return function()\n+    if signs_defined then\n+      return\n+    end\n+\n+    for severity, sign_hl_name in pairs(sign_highlight_map) do\n+      local severity_name = M.severity[severity]\n+      vim.fn.sign_define(sign_hl_name, {\n+        text = (severity_name or 'U'):sub(1, 1),\n+        texthl = sign_hl_name,\n+        linehl = '',\n+        numhl = '',\n+      })\n+    end\n+\n+    signs_defined = true\n+  end\n+end)()\n+\n+---@private\n+local function get_bufnr(bufnr)\n+  if not bufnr or bufnr == 0 then\n+    return vim.api.nvim_get_current_buf()\n+  end\n+  return bufnr\n+end\n+\n+-- Metatable that automatically creates an empty table when assigning to a missing key\n+local bufnr_and_namespace_cacher_mt = {\n+  __index = function(t, bufnr)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    if rawget(t, bufnr) == nil then\n+      rawset(t, bufnr, {})\n+    end\n+\n+    return rawget(t, bufnr)\n+  end,\n+\n+  __newindex = function(t, bufnr, v)\n+    if not bufnr or bufnr == 0 then\n+      bufnr = vim.api.nvim_get_current_buf()\n+    end\n+\n+    rawset(t, bufnr, v)\n+  end,\n+}\n+\n+local diagnostic_cleanup = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_cache_extmarks = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+local diagnostic_attached_buffers = {}\n+local diagnostic_disabled = {}\n+local bufs_waiting_to_update = setmetatable({}, bufnr_and_namespace_cacher_mt)\n+\n+---@private\n+local function is_disabled(namespace, bufnr)\n+  if type(diagnostic_disabled[bufnr]) == \"table\" then\n+    return diagnostic_disabled[bufnr][namespace]\n+  end\n+  return diagnostic_disabled[bufnr]\n+end\n+\n+---@private\n+local function diagnostic_lines(diagnostics)\n+  if not diagnostics then\n+    return\n+  end\n+\n+  local diagnostics_by_line = {}\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local line_diagnostics = diagnostics_by_line[diagnostic.lnum]\n+    if not line_diagnostics then\n+      line_diagnostics = {}\n+      diagnostics_by_line[diagnostic.lnum] = line_diagnostics\n+    end\n+    table.insert(line_diagnostics, diagnostic)\n+  end\n+  return diagnostics_by_line\n+end\n+\n+---@private\n+local function set_diagnostic_cache(namespace, diagnostics, bufnr)\n+  local buf_line_count = vim.api.nvim_buf_line_count(bufnr)\n+  for _, diagnostic in ipairs(diagnostics) do\n+    if diagnostic.severity == nil then\n+      diagnostic.severity = M.severity.ERROR\n+    end\n+\n+    diagnostic.namespace = namespace\n+    diagnostic.bufnr = bufnr\n+\n+    if buf_line_count > 0 then\n+      diagnostic.lnum = math.max(math.min(\n+        diagnostic.lnum, buf_line_count - 1\n+      ), 0)\n+      diagnostic.end_lnum = math.max(math.min(\n+        diagnostic.end_lnum, buf_line_count - 1\n+      ), 0)\n+    end\n+  end\n+\n+  diagnostic_cache[bufnr][namespace] = diagnostics\n+end\n+\n+---@private\n+local function clear_diagnostic_cache(namespace, bufnr)\n+  diagnostic_cache[bufnr][namespace] = nil\n+end\n+\n+---@private\n+local function restore_extmarks(bufnr, last)\n+  for ns, extmarks in pairs(diagnostic_cache_extmarks[bufnr]) do\n+    local extmarks_current = vim.api.nvim_buf_get_extmarks(bufnr, ns, 0, -1, {details = true})\n+    local found = {}\n+    for _, extmark in ipairs(extmarks_current) do\n+      -- nvim_buf_set_lines will move any extmark to the line after the last\n+      -- nvim_buf_set_text will move any extmark to the last line\n+      if extmark[2] ~= last + 1 then\n+        found[extmark[1]] = true\n+      end\n+    end\n+    for _, extmark in ipairs(extmarks) do\n+      if not found[extmark[1]] then\n+        local opts = extmark[4]\n+        opts.id = extmark[1]\n+        -- HACK: end_row should be end_line\n+        if opts.end_row then\n+          opts.end_line = opts.end_row\n+          opts.end_row = nil\n+        end\n+        pcall(vim.api.nvim_buf_set_extmark, bufnr, ns, extmark[2], extmark[3], opts)\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function save_extmarks(namespace, bufnr)\n+  bufnr = bufnr == 0 and vim.api.nvim_get_current_buf() or bufnr\n+  if not diagnostic_attached_buffers[bufnr] then\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_lines = function(_, _, _, _, _, last)\n+        restore_extmarks(bufnr, last - 1)\n+      end,\n+      on_detach = function()\n+        diagnostic_cache_extmarks[bufnr] = nil\n+      end})\n+    diagnostic_attached_buffers[bufnr] = true\n+  end\n+  diagnostic_cache_extmarks[bufnr][namespace] = vim.api.nvim_buf_get_extmarks(bufnr, namespace, 0, -1, {details = true})\n+end\n+\n+local registered_autocmds = {}\n+\n+---@private\n+local function make_augroup_key(namespace, bufnr)\n+  local ns = get_namespace(namespace)\n+  return string.format(\"DiagnosticInsertLeave:%s:%s\", bufnr, ns.name)\n+end\n+\n+--- Table of autocmd events to fire the update for displaying new diagnostic information\n+local insert_leave_auto_cmds = { \"InsertLeave\", \"CursorHoldI\" }\n+\n+---@private\n+local function schedule_display(namespace, bufnr, args)\n+  bufs_waiting_to_update[bufnr][namespace] = args\n+\n+  local key = make_augroup_key(namespace, bufnr)\n+  if not registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\n+      string.format(\n+        [[autocmd %s <buffer=%s> lua vim.diagnostic._execute_scheduled_display(%s, %s)]],\n+        table.concat(insert_leave_auto_cmds, \",\"),\n+        bufnr,\n+        namespace,\n+        bufnr\n+      )\n+    )\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = true\n+  end\n+end\n+\n+---@private\n+local function clear_scheduled_display(namespace, bufnr)\n+  local key = make_augroup_key(namespace, bufnr)\n+\n+  if registered_autocmds[key] then\n+    vim.cmd(string.format(\"augroup %s\", key))\n+    vim.cmd(\"  au!\")\n+    vim.cmd(\"augroup END\")\n+\n+    registered_autocmds[key] = nil\n+  end\n+end\n+\n+---@private\n+--- Open a floating window with the provided diagnostics\n+---@param opts table Configuration table\n+---     - show_header (boolean, default true): Show \"Diagnostics:\" header\n+---     - all opts for |vim.util.open_floating_preview()| can be used here\n+---@param diagnostics table: The diagnostics to display\n+---@return table {popup_bufnr, win_id}\n+local function show_diagnostics(opts, diagnostics)\n+  if vim.tbl_isempty(diagnostics) then return end\n+  local lines = {}\n+  local highlights = {}\n+  local show_header = vim.F.if_nil(opts.show_header, true)\n+  if show_header then\n+    table.insert(lines, \"Diagnostics:\")\n+    table.insert(highlights, {0, \"Bold\"})\n+  end\n+\n+  for i, diagnostic in ipairs(diagnostics) do\n+    local prefix = string.format(\"%d. \", i)\n+    local hiname = floating_highlight_map[diagnostic.severity]\n+    assert(hiname, 'unknown severity: ' .. tostring(diagnostic.severity))\n+\n+    local message_lines = vim.split(diagnostic.message, '\\n', true)\n+    table.insert(lines, prefix..message_lines[1])\n+    table.insert(highlights, {#prefix, hiname})\n+    for j = 2, #message_lines do\n+      table.insert(lines, string.rep(' ', #prefix) .. message_lines[j])\n+      table.insert(highlights, {0, hiname})\n+    end\n+  end\n+\n+  local popup_bufnr, winnr = require('vim.lsp.util').open_floating_preview(lines, 'plaintext', opts)\n+  for i, hi in ipairs(highlights) do\n+    local prefixlen, hiname = unpack(hi)\n+    -- Start highlight after the prefix\n+    vim.api.nvim_buf_add_highlight(popup_bufnr, -1, hiname, i-1, prefixlen, -1)\n+  end\n+\n+  return popup_bufnr, winnr\n+end\n+\n+local errlist_type_map = {\n+  [M.severity.ERROR] = 'E',\n+  [M.severity.WARN] = 'W',\n+  [M.severity.INFO] = 'I',\n+  [M.severity.HINT] = 'I',\n+}\n+\n+---@private\n+local function diagnostics_to_list_items(diagnostics)\n+  local items = {}\n+  for _, d in pairs(diagnostics) do\n+    table.insert(items, {\n+      bufnr = d.bufnr,\n+      lnum = d.lnum + 1,\n+      col = d.col + 1,\n+      text = d.message,\n+      type = errlist_type_map[d.severity or M.severity.ERROR] or 'E'\n+    })\n+  end\n+  table.sort(items, function(a, b)\n+    if a.bufnr == b.bufnr then\n+      return a.lnum < b.lnum\n+    else\n+      return a.bufnr < b.bufnr\n+    end\n+  end)\n+  return items\n+end\n+\n+---@private\n+local function set_list(loclist, opts)\n+  opts = opts or {}\n+  local open = vim.F.if_nil(opts.open, true)\n+  local title = opts.title or \"Diagnostics\"\n+  local winnr = opts.winnr or 0\n+  local diagnostics = M.get(loclist and vim.api.nvim_win_get_buf(winnr), opts)\n+  local items = diagnostics_to_list_items(diagnostics)\n+  if loclist then\n+    vim.fn.setloclist(winnr, {}, ' ', { title = title, items = items })\n+  else\n+    vim.fn.setqflist({}, ' ', { title = title, items = items })\n+  end\n+  if open then\n+    vim.api.nvim_command(loclist and \"lopen\" or \"copen\")\n+  end\n+end\n+\n+-- }}}\n+\n+-- Public API {{{\n+\n+--- Configure diagnostic options globally or for a specific diagnostic\n+--- namespace.\n+---\n+---@note Each of the configuration options below accepts one of the following:\n+---         - `false`: Disable this feature\n+---         - `true`: Enable this feature, use default settings.\n+---         - `table`: Enable this feature with overrides.\n+---         - `function`: Function with signature (namespace, bufnr) that returns any of the above.\n+---\n+---@param opts table Configuration table with the following keys:\n+---       - underline: (default true) Use underline for diagnostics\n+---       - virtual_text: (default true) Use virtual text for diagnostics\n+---       - signs: (default true) Use signs for diagnostics\n+---       - update_in_insert: (default false) Update diagnostics in Insert mode (if false,\n+---                           diagnostics are updated on InsertLeave)\n+---       - severity_sort: (default false) Sort diagnostics by severity. This affects the order in\n+---                         which signs and virtual text are displayed\n+---@param namespace number|nil Update the options for the given namespace. When omitted, update the\n+---                            global diagnostic options.\n+function M.config(opts, namespace)\n+  vim.validate {\n+    opts = { opts, 't' },\n+    namespace = { namespace, 'n', true },\n+  }\n+\n+  local t\n+  if namespace then\n+    local ns = get_namespace(namespace)\n+    t = ns.opts\n+  else\n+    t = global_diagnostic_options\n+  end\n+\n+  for opt in pairs(global_diagnostic_options) do\n+    if opts[opt] ~= nil then\n+      t[opt] = opts[opt]\n+    end\n+  end\n+\n+  if namespace then\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      if v[namespace] then\n+        M.show(namespace, bufnr)\n+      end\n+    end\n+  else\n+    for bufnr, v in pairs(diagnostic_cache) do\n+      for ns in pairs(v) do\n+        M.show(ns, bufnr)\n+      end\n+    end\n+  end\n+end\n+\n+--- Set diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|\n+---@param opts table|nil Display options to pass to |vim.diagnostic.show()|\n+function M.set(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  if vim.tbl_isempty(diagnostics) then\n+    return M.reset(namespace, bufnr)\n+  end\n+\n+  if not diagnostic_cleanup[bufnr][namespace] then\n+    diagnostic_cleanup[bufnr][namespace] = true\n+\n+    -- Clean up our data when the buffer unloads.\n+    vim.api.nvim_buf_attach(bufnr, false, {\n+      on_detach = function(_, b)\n+        clear_diagnostic_cache(b, namespace)\n+        diagnostic_cleanup[b][namespace] = nil\n+      end\n+    })\n+  end\n+\n+  set_diagnostic_cache(namespace, diagnostics, bufnr)\n+\n+  if opts then\n+    M.config(opts, namespace)\n+  end\n+\n+  if vim.api.nvim_buf_is_loaded(bufnr) then\n+    M.show(namespace, bufnr)\n+  end\n+\n+  vim.api.nvim_command(\"doautocmd <nomodeline> User DiagnosticsChanged\")\n+end\n+\n+--- Get current diagnostics.\n+---\n+---@param bufnr number|nil Buffer number to get diagnistics from. Use 0 for\n+---                        current buffer or nil for all buffers.\n+---@param opts table|nil A table with the following keys:\n+---                        - namespace: (number) Limit diagnostics to the given namespace.\n+---                        - lnum: (number) Limit diagnostics to the given line number.\n+---                        - severity: See |diagnostic-severity|.\n+---@return table A list of diagnostic items |diagnostic-structure|.\n+function M.get(bufnr, opts)\n+  vim.validate {\n+    bufnr = { bufnr, 'n', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  opts = opts or {}\n+\n+  local namespace = opts.namespace\n+  local diagnostics = {}\n+\n+  ---@private\n+  local function add(d)\n+    if not opts.lnum or d.lnum == opts.lnum then\n+      table.insert(diagnostics, d)\n+    end\n+  end\n+\n+  if namespace == nil and bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, v in pairs(t) do\n+        for _, diagnostic in pairs(v) do\n+          add(diagnostic)\n+        end\n+      end\n+    end\n+  elseif namespace == nil then\n+    for iter_namespace in pairs(diagnostic_cache[bufnr]) do\n+      for _, diagnostic in pairs(diagnostic_cache[bufnr][iter_namespace]) do\n+        add(diagnostic)\n+      end\n+    end\n+  elseif bufnr == nil then\n+    for _, t in pairs(diagnostic_cache) do\n+      for _, diagnostic in pairs(t[namespace] or {}) do\n+        add(diagnostic)\n+      end\n+    end\n+  else\n+    for _, diagnostic in pairs(diagnostic_cache[bufnr][namespace] or {}) do\n+      add(diagnostic)\n+    end\n+  end\n+\n+  if opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  return diagnostics\n+end\n+\n+-- Diagnostic Movements {{{\n+\n+local next_diagnostic = function(position, search_forward, bufnr, opts, namespace)\n+  position[1] = position[1] - 1\n+  bufnr = bufnr or vim.api.nvim_get_current_buf()\n+  local wrap = vim.F.if_nil(opts.wrap, true)\n+  local line_count = vim.api.nvim_buf_line_count(bufnr)\n+  opts.namespace = namespace\n+  for i = 0, line_count do\n+    local offset = i * (search_forward and 1 or -1)\n+    local lnum = position[1] + offset\n+    if lnum < 0 or lnum >= line_count then\n+      if not wrap then\n+        return\n+      end\n+      lnum = (lnum + line_count) % line_count\n+    end\n+    opts.lnum = lnum\n+    local line_diagnostics = M.get(bufnr, opts)\n+    if line_diagnostics and not vim.tbl_isempty(line_diagnostics) then\n+      local sort_diagnostics, is_next\n+      if search_forward then\n+        sort_diagnostics = function(a, b) return a.col < b.col end\n+        is_next = function(diagnostic) return diagnostic.col > position[2] end\n+      else\n+        sort_diagnostics = function(a, b) return a.col > b.col end\n+        is_next = function(diagnostic) return diagnostic.col < position[2] end\n+      end\n+      table.sort(line_diagnostics, sort_diagnostics)\n+      if i == 0 then\n+        for _, v in pairs(line_diagnostics) do\n+          if is_next(v) then\n+            return v\n+          end\n+        end\n+      else\n+        return line_diagnostics[1]\n+      end\n+    end\n+  end\n+end\n+\n+---@private\n+local function diagnostic_move_pos(opts, pos)\n+  opts = opts or {}\n+\n+  local enable_popup = vim.F.if_nil(opts.enable_popup, true)\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+\n+  if not pos then\n+    vim.api.nvim_echo({\"No more valid diagnostics to move to\", \"WarningMsg\"})\n+    return\n+  end\n+\n+  vim.api.nvim_win_set_cursor(win_id, {pos[1] + 1, pos[2]})\n+\n+  if enable_popup then\n+    -- This is a bit weird... I'm surprised that we need to wait til the next tick to do this.\n+    vim.schedule(function()\n+      M.show_position_diagnostics(opts.popup_opts, vim.api.nvim_win_get_buf(win_id))\n+    end)\n+  end\n+end\n+\n+--- Get the previous diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic\n+function M.get_prev(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, false, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the previous diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Previous diagnostic position as a (row, col) tuple.\n+function M.get_prev_pos(opts)\n+  local prev = M.get_prev(opts)\n+  if not prev then\n+    return false\n+  end\n+\n+  return {prev.lnum, prev.col}\n+end\n+\n+--- Move to the previous diagnostic in the current buffer.\n+---@param opts table See |vim.diagnostic.goto_next()|\n+function M.goto_prev(opts)\n+  return diagnostic_move_pos(\n+    opts,\n+    M.get_prev_pos(opts)\n+  )\n+end\n+\n+--- Get the next diagnostic closest to the cursor position.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic\n+function M.get_next(opts)\n+  opts = opts or {}\n+\n+  local win_id = opts.win_id or vim.api.nvim_get_current_win()\n+  local bufnr = vim.api.nvim_win_get_buf(win_id)\n+  local cursor_position = opts.cursor_position or vim.api.nvim_win_get_cursor(win_id)\n+\n+  return next_diagnostic(cursor_position, true, bufnr, opts, opts.namespace)\n+end\n+\n+--- Return the position of the next diagnostic in the current buffer.\n+---\n+---@param opts table See |vim.diagnostic.goto_next()|\n+---@return table Next diagnostic position as a (row, col) tuple.\n+function M.get_next_pos(opts)\n+  local next = M.get_next(opts)\n+  if not next then\n+    return false\n+  end\n+\n+  return {next.lnum, next.col}\n+end\n+\n+--- Move to the next diagnostic.\n+---\n+---@param opts table|nil Configuration table with the following keys:\n+---         - namespace: (number) Only consider diagnostics from the given namespace.\n+---         - cursor_position: (cursor position) Cursor position as a (row, col) tuple. See\n+---                          |nvim_win_get_cursor()|. Defaults to the current cursor position.\n+---         - wrap: (boolean, default true) Whether to loop around file or not. Similar to 'wrapscan'.\n+---         - severity: See |diagnostic-severity|.\n+---         - enable_popup: (boolean, default true) Call |vim.diagnostic.show_line_diagnostics()|\n+---                       on jump.\n+---         - popup_opts: (table) Table to pass as {opts} parameter to\n+---                     |vim.diagnostic.show_line_diagnostics()|\n+---         - win_id: (number, default 0) Window ID\n+function M.goto_next(opts)\n+  return diagnostic_move_pos(\n+    opts,\n+    M.get_next_pos(opts)\n+  )\n+end\n+\n+-- Diagnostic Setters {{{\n+\n+--- Set signs for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table Configuration table with the following keys:\n+---            - priority: Set the priority of the signs |sign-priority|.\n+---@private\n+function M._set_signs(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ signs = opts }, namespace, bufnr).signs\n+\n+  if opts and opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  local ns = get_namespace(namespace)\n+\n+  define_default_signs()\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    vim.fn.sign_place(\n+      0,\n+      ns.sign_group,\n+      sign_highlight_map[diagnostic.severity],\n+      bufnr,\n+      {\n+        priority = opts and opts.priority,\n+        lnum = diagnostic.lnum + 1\n+      }\n+    )\n+  end\n+end\n+\n+--- Set underline for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table Configuration table. Currently unused.\n+---@private\n+function M._set_underline(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ underline = opts }, namespace, bufnr).underline\n+\n+  if opts and opts.severity then\n+    diagnostics = filter_by_severity(opts.severity, diagnostics)\n+  end\n+\n+  for _, diagnostic in ipairs(diagnostics) do\n+    local higroup = underline_highlight_map[diagnostic.severity]\n+\n+    if higroup == nil then\n+      -- Default to error if we don't have a highlight associated\n+      higroup = underline_highlight_map.Error\n+    end\n+\n+    vim.highlight.range(\n+      bufnr,\n+      namespace,\n+      higroup,\n+      { diagnostic.lnum, diagnostic.col },\n+      { diagnostic.end_lnum, diagnostic.end_col }\n+    )\n+  end\n+end\n+\n+--- Set virtual text for given diagnostics.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number Buffer number\n+---@param diagnostics table A list of diagnostic items |diagnostic-structure|. When omitted the\n+---                       current diagnostics in the given buffer are used.\n+---@param opts table|nil Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line.\n+---            - spacing: (number) Number of spaces to insert before virtual text.\n+---@private\n+function M._set_virtual_text(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = {namespace, 'n'},\n+    bufnr = {bufnr, 'n'},\n+    diagnostics = {diagnostics, 't'},\n+    opts = {opts, 't', true},\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  opts = get_resolved_options({ virtual_text = opts }, namespace, bufnr).virtual_text\n+\n+  local buffer_line_diagnostics = diagnostic_lines(diagnostics)\n+  for line, line_diagnostics in pairs(buffer_line_diagnostics) do\n+    if opts and opts.severity then\n+      line_diagnostics = filter_by_severity(opts.severity, line_diagnostics)\n+    end\n+    local virt_texts = M.get_virt_text_chunks(line_diagnostics, opts)\n+\n+    if virt_texts then\n+      vim.api.nvim_buf_set_extmark(bufnr, namespace, line, 0, {\n+        hl_mode = \"combine\",\n+        virt_text = virt_texts,\n+      })\n+    end\n+  end\n+end\n+\n+--- Get virtual text chunks to display using |nvim_buf_set_extmark()|.\n+---\n+---@param line_diags table The diagnostics associated with the line.\n+---@param opts table|nil Configuration table with the following keys:\n+---            - prefix: (string) Prefix to display before virtual text on line.\n+---            - spacing: (number) Number of spaces to insert before virtual text.\n+---@return an array of [text, hl_group] arrays. This can be passed directly to\n+---        the {virt_text} option of |nvim_buf_set_extmark()|.\n+function M.get_virt_text_chunks(line_diags, opts)\n+  if #line_diags == 0 then\n+    return nil\n+  end\n+\n+  opts = opts or {}\n+  local prefix = opts.prefix or \"■\"\n+  local spacing = opts.spacing or 4\n+\n+  -- Create a little more space between virtual text and contents\n+  local virt_texts = {{string.rep(\" \", spacing)}}\n+\n+  for i = 1, #line_diags - 1 do\n+    table.insert(virt_texts, {prefix, virtual_text_highlight_map[line_diags[i].severity]})\n+  end\n+  local last = line_diags[#line_diags]\n+\n+  -- TODO(tjdevries): Allow different servers to be shown first somehow?\n+  -- TODO(tjdevries): Display server name associated with these?\n+  if last.message then\n+    table.insert(\n+      virt_texts,\n+      {\n+        string.format(\"%s %s\", prefix, last.message:gsub(\"\\r\", \"\"):gsub(\"\\n\", \"  \")),\n+        virtual_text_highlight_map[last.severity]\n+      }\n+    )\n+\n+    return virt_texts\n+  end\n+end\n+\n+--- Callback scheduled when leaving Insert mode.\n+---\n+--- This function must be exported publicly so that it is available to be\n+--- called from the Vimscript autocommand.\n+---\n+--- See @ref schedule_display()\n+---\n+---@private\n+function M._execute_scheduled_display(namespace, bufnr)\n+  local args = bufs_waiting_to_update[bufnr][namespace]\n+  if not args then\n+    return\n+  end\n+\n+  -- Clear the args so we don't display unnecessarily.\n+  bufs_waiting_to_update[bufnr][namespace] = nil\n+\n+  M.show(namespace, bufnr, nil, args)\n+end\n+\n+--- Hide currently displayed diagnostics.\n+---\n+--- This only clears the decorations displayed in the buffer. Diagnostics can\n+--- be redisplayed with |vim.diagnostic.show()|. To completely remove\n+--- diagnostics, use |vim.diagnostic.reset()|.\n+---\n+--- To hide diagnostics and prevent them from re-displaying, use\n+--- |vim.diagnostic.disable()|.\n+---\n+---@param namespace number The diagnostic namespace\n+---@param bufnr number|nil Buffer number. Defaults to the current buffer.\n+function M.hide(namespace, bufnr)\n+  vim.validate {\n+    namespace = { namespace, 'n' },\n+    bufnr = { bufnr, 'n', true },\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  diagnostic_cache_extmarks[bufnr][namespace] = {}\n+\n+  local ns = get_namespace(namespace)\n+\n+  -- clear sign group\n+  vim.fn.sign_unplace(ns.sign_group, {buffer=bufnr})\n+\n+  -- clear virtual text namespace\n+  vim.api.nvim_buf_clear_namespace(bufnr, namespace, 0, -1)\n+end\n+\n+\n+--- Display diagnostics for the given namespace and buffer.\n+---\n+---@param namespace number Diagnostic namespace\n+---@param bufnr number|nil Buffer number. Defaults to the current buffer.\n+---@param diagnostics table|nil The diagnostics to display. When omitted, use the\n+---                             saved diagnostics for the given namespace and\n+---                             buffer. This can be used to display a list of diagnostics\n+---                             without saving them or to display only a subset of\n+---                             diagnostics.\n+---@param opts table|nil Display options. See |vim.diagnostic.config()|.\n+function M.show(namespace, bufnr, diagnostics, opts)\n+  vim.validate {\n+    namespace = { namespace, 'n' },\n+    bufnr = { bufnr, 'n', true },\n+    diagnostics = { diagnostics, 't', true },\n+    opts = { opts, 't', true },\n+  }\n+\n+  bufnr = get_bufnr(bufnr)\n+  if is_disabled(namespace, bufnr) then\n+    return\n+  end\n+\n+  M.hide(namespace, bufnr)\n+\n+  diagnostics = diagnostics or M.get(bufnr, {namespace=namespace})\n+\n+  if not diagnostics or vim.tbl_isempty(diagnostics) then\n+    return\n+  end\n+\n+  opts = get_resolved_options(opts, namespace, bufnr)\n+\n+  if opts.update_in_insert then\n+    clear_scheduled_display(namespace, bufnr)\n+  else\n+    local mode = vim.api.nvim_get_mode()\n+    if string.sub(mode.mode, 1, 1) == 'i' then\n+      schedule_display(namespace, bufnr, opts)\n+      return\n+    end\n+  end\n+\n+  if opts.underline then\n+    M._set_underline(namespace, bufnr, diagnostics, opts.underline)\n+  end\n+\n+  if opts.virtual_text then\n+    M._set_virtual_text(namespace, bufnr, diagnostics, opts.virtual_text)\n+  end\n+\n+  if opts.signs then\n+    M._set_signs(namespace, bufnr, diagnostics, opts.signs)\n+  end\n+\n+  save_extmarks(namespace, bufnr)\n+end\n+\n+--- Open a floating window with the diagnostics at the given position.\n+---\n+---@param opts table|nil Configuration table with the same keys as\n+---            |vim.lsp.util.open_floatin_preview()| in addition to the following:\n+---            - namespace: (number) Limit diagnostics to the given namespace\n+---            - severity: See |diagnostic-severity|.\n+---            - show_header: (boolean, default true) Show \"Diagnostics:\" header\n+---@param bufnr number|nil Buffer number. Defaults to the current buffer.\n+---@param position table|nil The (0,0)-indexed position. Defaults to the current cursor position.\n+---@return A ({popup_bufnr}, {win_id}) tuple",
            "html_url": "https://github.com/neovim/neovim/pull/15585#discussion_r711139469",
            "id": 711139469,
            "in_reply_to_id": 710878303,
            "line": 1010,
            "node_id": "PRRC_kwDOAPphoM4qYyCN",
            "original_commit_id": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
            "original_line": 1010,
            "original_position": 1010,
            "original_start_line": null,
            "path": "runtime/lua/vim/diagnostic.lua",
            "position": 1010,
            "pull_request_review_id": 757576236,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/711139469/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2021-09-17T15:08:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/711139469",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "CONTRIBUTOR",
            "body": "I think we can refer to the VS Code extension API.",
            "created_at": "2021-09-07T03:30:19Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-913963831",
            "id": 913963831,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42efs3",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/913963831/reactions"
            },
            "updated_at": "2021-09-07T03:30:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/913963831",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/629908?v=4",
                "events_url": "https://api.github.com/users/hrsh7th/events{/privacy}",
                "followers_url": "https://api.github.com/users/hrsh7th/followers",
                "following_url": "https://api.github.com/users/hrsh7th/following{/other_user}",
                "gists_url": "https://api.github.com/users/hrsh7th/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/hrsh7th",
                "id": 629908,
                "login": "hrsh7th",
                "node_id": "MDQ6VXNlcjYyOTkwOA==",
                "organizations_url": "https://api.github.com/users/hrsh7th/orgs",
                "received_events_url": "https://api.github.com/users/hrsh7th/received_events",
                "repos_url": "https://api.github.com/users/hrsh7th/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/hrsh7th/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/hrsh7th/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/hrsh7th"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Why `local ns = vim.diagnostic.create_namespace(\"foo\")` instead of `local ns = vim.api.nvim_create_namespace(\"foo\")`?\r\n\r\nI think it is better to re-use the same concept of namespaces everywhere.",
            "created_at": "2021-09-07T12:49:23Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-914278569",
            "id": 914278569,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42fsip",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914278569/reactions"
            },
            "updated_at": "2021-09-07T12:49:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914278569",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4466899?v=4",
                "events_url": "https://api.github.com/users/tjdevries/events{/privacy}",
                "followers_url": "https://api.github.com/users/tjdevries/followers",
                "following_url": "https://api.github.com/users/tjdevries/following{/other_user}",
                "gists_url": "https://api.github.com/users/tjdevries/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/tjdevries",
                "id": 4466899,
                "login": "tjdevries",
                "node_id": "MDQ6VXNlcjQ0NjY4OTk=",
                "organizations_url": "https://api.github.com/users/tjdevries/orgs",
                "received_events_url": "https://api.github.com/users/tjdevries/received_events",
                "repos_url": "https://api.github.com/users/tjdevries/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/tjdevries/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/tjdevries/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/tjdevries"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Why `local ns = vim.diagnostic.create_namespace(\"foo\")` instead of `local ns = vim.api.nvim_create_namespace(\"foo\")`?\r\n> \r\n> I think it is better to re-use the same concept of namespaces everywhere.\r\n\r\nThe diagnostic namespace also encapsulates some other data, such as the “sign group” used for placing signs and namespace specific options.",
            "created_at": "2021-09-07T13:05:23Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-914289908",
            "id": 914289908,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42fvT0",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914289908/reactions"
            },
            "updated_at": "2021-09-07T13:05:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914289908",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> The diagnostic namespace also encapsulates some other data, such as the “sign group” used for placing signs and namespace specific options.\r\n\r\nIsn't that desirable for every namespace ? \r\n\r\nVery cool initiative",
            "created_at": "2021-09-07T13:17:52Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-914298944",
            "id": 914298944,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42fxhA",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914298944/reactions"
            },
            "updated_at": "2021-09-07T13:17:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914298944",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/886074?v=4",
                "events_url": "https://api.github.com/users/teto/events{/privacy}",
                "followers_url": "https://api.github.com/users/teto/followers",
                "following_url": "https://api.github.com/users/teto/following{/other_user}",
                "gists_url": "https://api.github.com/users/teto/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/teto",
                "id": 886074,
                "login": "teto",
                "node_id": "MDQ6VXNlcjg4NjA3NA==",
                "organizations_url": "https://api.github.com/users/teto/orgs",
                "received_events_url": "https://api.github.com/users/teto/received_events",
                "repos_url": "https://api.github.com/users/teto/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/teto/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/teto/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/teto"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> The diagnostic namespace also encapsulates some other data, such as the “sign group” used for placing signs and namespace specific options.\r\n\r\nI'll suggest initializing the internal state when `vim.diagnostic.set` is first called, and allow a standard `nvim_create_namespace` to be used (the idea is that a plugin can use the same `ns` for various different API:s, c or lua).",
            "created_at": "2021-09-07T13:24:35Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-914304109",
            "id": 914304109,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42fyxt",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914304109/reactions"
            },
            "updated_at": "2021-09-07T13:24:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914304109",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1363104?v=4",
                "events_url": "https://api.github.com/users/bfredl/events{/privacy}",
                "followers_url": "https://api.github.com/users/bfredl/followers",
                "following_url": "https://api.github.com/users/bfredl/following{/other_user}",
                "gists_url": "https://api.github.com/users/bfredl/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/bfredl",
                "id": 1363104,
                "login": "bfredl",
                "node_id": "MDQ6VXNlcjEzNjMxMDQ=",
                "organizations_url": "https://api.github.com/users/bfredl/orgs",
                "received_events_url": "https://api.github.com/users/bfredl/received_events",
                "repos_url": "https://api.github.com/users/bfredl/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/bfredl/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/bfredl/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/bfredl"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> The diagnostic namespace also encapsulates some other data, such as the “sign group” used for placing signs and namespace specific options.\r\n\r\nHmm, can you expand on what you mean? I think having more than one `namespace` creator starts to lead us down a complicated and confusing path. We should try and re-use the same concept IMO (at least on first glance -- I didn't read all the code yet).\r\n\r\n",
            "created_at": "2021-09-07T13:24:40Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-914304180",
            "id": 914304180,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42fyy0",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914304180/reactions"
            },
            "updated_at": "2021-09-07T13:24:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914304180",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/4466899?v=4",
                "events_url": "https://api.github.com/users/tjdevries/events{/privacy}",
                "followers_url": "https://api.github.com/users/tjdevries/followers",
                "following_url": "https://api.github.com/users/tjdevries/following{/other_user}",
                "gists_url": "https://api.github.com/users/tjdevries/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/tjdevries",
                "id": 4466899,
                "login": "tjdevries",
                "node_id": "MDQ6VXNlcjQ0NjY4OTk=",
                "organizations_url": "https://api.github.com/users/tjdevries/orgs",
                "received_events_url": "https://api.github.com/users/tjdevries/received_events",
                "repos_url": "https://api.github.com/users/tjdevries/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/tjdevries/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/tjdevries/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/tjdevries"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> > The diagnostic namespace also encapsulates some other data, such as the “sign group” used for placing signs and namespace specific options.\r\n> \r\n> Hmm, can you expand on what you mean? I think having more than one `namespace` creator starts to lead us down a complicated and confusing path. We should try and re-use the same concept IMO (at least on first glance -- I didn't read all the code yet).\r\n\r\nSure! The structure of a \"namespace diagnostic\" object is just:\r\n\r\n```lua\r\n{\r\n    sign_group = <str>,\r\n    opts = <table>,\r\n}\r\n```\r\n\r\nThis is managed in a reference table keyed by an integer which itself is just the result of `nvim_create_namespace`. The `sign_group` string is `string.format(\"vim.diagnostic.%s\", name)` where `name` is the input parameter to `vim.diagnostic.create_namespace()`.\r\n\r\nThe integer returned to callers of `create_namespace()` is the return value of `nvim_create_namespace`, but we are essentially attaching extra data to the namespace (the sign group and options) by using our own data type.\r\n\r\n>I'll suggest initializing the internal state when vim.diagnostic.set is first called, and allow a standard nvim_create_namespace to be used (the idea is that a plugin can use the same ns for various different API:s, c or lua).\r\n\r\nYea this makes sense and I agree using a standardized API is  best.\r\n\r\nWe need to get the name out of the namespace created with `nvim_create_namespace` so that we can use it with the sign group (which is a string). I think we can do this by changing the `get_namespace` function as follows:\r\n\r\n```lua\r\nlocal function get_namespace(namespace)\r\n    if not all_namespaces[namespace] then\r\n         local name = assert(vim.api.nvim_get_namespaces()[namespace], \"namespace does not exist\")\r\n         all_namespaces[namespace] = { sign_group = string.format(\"vim.diagnostic.%s\", name), opts = {} }\r\n    end\r\n    return all_namespaces[nam\r\nend\r\n```\r\n\r\n**EDIT:** These changes are pushed and I updated the overview in the original comment.",
            "created_at": "2021-09-07T13:44:16Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-914318748",
            "id": 914318748,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42f2Wc",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914318748/reactions"
            },
            "updated_at": "2021-09-07T14:04:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914318748",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "author_association": "NONE",
            "body": "Looks great so far! For null-ls, calling the LSP handler directly isn't a big deal, since we have an actual client ID, but migrating to this should be simple, and I can see it making a big difference in the overall plugin ecosystem.\r\n\r\nOne question so far: Would it be considered valid for a single plugin to create and use multiple namespaces? For null-ls, I played around with adding sources that run on `textDocument/didSave`, but due to the timing of notifications, those diagnostics kept getting wiped out by the ones from `textDocument/didChange`. Using separate namespaces seems like it would solve this nicely. ",
            "created_at": "2021-09-07T14:19:08Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-914346708",
            "id": 914346708,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42f9LU",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914346708/reactions"
            },
            "updated_at": "2021-09-07T14:19:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914346708",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/54108223?v=4",
                "events_url": "https://api.github.com/users/jose-elias-alvarez/events{/privacy}",
                "followers_url": "https://api.github.com/users/jose-elias-alvarez/followers",
                "following_url": "https://api.github.com/users/jose-elias-alvarez/following{/other_user}",
                "gists_url": "https://api.github.com/users/jose-elias-alvarez/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/jose-elias-alvarez",
                "id": 54108223,
                "login": "jose-elias-alvarez",
                "node_id": "MDQ6VXNlcjU0MTA4MjIz",
                "organizations_url": "https://api.github.com/users/jose-elias-alvarez/orgs",
                "received_events_url": "https://api.github.com/users/jose-elias-alvarez/received_events",
                "repos_url": "https://api.github.com/users/jose-elias-alvarez/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/jose-elias-alvarez/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/jose-elias-alvarez/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/jose-elias-alvarez"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> One question so far: Would it be considered valid for a single plugin to create and use multiple namespaces?\r\n\r\nYes, so long as each namespace has a unique name. I have been modifying `nvim-lint` locally to work with these changes and I have been using a separate namespace for each individual linter. It should work either way, but using multiple namespaces gives you more control.\r\n\r\n\r\n",
            "created_at": "2021-09-07T14:22:20Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-914349294",
            "id": 914349294,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42f9zu",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914349294/reactions"
            },
            "updated_at": "2021-09-07T14:23:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914349294",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "author_association": "NONE",
            "body": "> > One question so far: Would it be considered valid for a single plugin to create and use multiple namespaces?\r\n> \r\n> Yes, so long as each namespace has a unique name. I have been modifying `nvim-lint` locally to work with these changes and I have been using a separate namespace for each individual linter. It should work either way, but using multiple namespaces gives you more control.\r\n\r\nWow, that's a great idea. I'll try this out locally when I get a chance and add any feedback here. Thanks for working on this!",
            "created_at": "2021-09-07T14:26:18Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-914352319",
            "id": 914352319,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42f-i_",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914352319/reactions"
            },
            "updated_at": "2021-09-07T14:26:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914352319",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/54108223?v=4",
                "events_url": "https://api.github.com/users/jose-elias-alvarez/events{/privacy}",
                "followers_url": "https://api.github.com/users/jose-elias-alvarez/followers",
                "following_url": "https://api.github.com/users/jose-elias-alvarez/following{/other_user}",
                "gists_url": "https://api.github.com/users/jose-elias-alvarez/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/jose-elias-alvarez",
                "id": 54108223,
                "login": "jose-elias-alvarez",
                "node_id": "MDQ6VXNlcjU0MTA4MjIz",
                "organizations_url": "https://api.github.com/users/jose-elias-alvarez/orgs",
                "received_events_url": "https://api.github.com/users/jose-elias-alvarez/received_events",
                "repos_url": "https://api.github.com/users/jose-elias-alvarez/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/jose-elias-alvarez/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/jose-elias-alvarez/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/jose-elias-alvarez"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Sorry If I missed it, but how do you plan to deal with `textDocument/codeAction` request? \r\n\r\nThe trigger is reliant on `get_line_diagnostics()`\r\nhttps://github.com/neovim/neovim/blob/db695cc4cafa6c26eb71a183cc73a167b842731e/runtime/lua/vim/lsp/buf.lua#L445-L451\r\nIt will then call `code_action_request()` which is currently highly coupled to the LSP client.\r\nhttps://github.com/neovim/neovim/blob/db695cc4cafa6c26eb71a183cc73a167b842731e/runtime/lua/vim/lsp/buf.lua#L425-L431",
            "created_at": "2021-09-07T16:10:23Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-914438429",
            "id": 914438429,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42gTkd",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914438429/reactions"
            },
            "updated_at": "2021-09-07T16:10:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914438429",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/59826753?v=4",
                "events_url": "https://api.github.com/users/kylo252/events{/privacy}",
                "followers_url": "https://api.github.com/users/kylo252/followers",
                "following_url": "https://api.github.com/users/kylo252/following{/other_user}",
                "gists_url": "https://api.github.com/users/kylo252/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/kylo252",
                "id": 59826753,
                "login": "kylo252",
                "node_id": "MDQ6VXNlcjU5ODI2NzUz",
                "organizations_url": "https://api.github.com/users/kylo252/orgs",
                "received_events_url": "https://api.github.com/users/kylo252/received_events",
                "repos_url": "https://api.github.com/users/kylo252/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/kylo252/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/kylo252/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/kylo252"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Sorry If I missed it, but how do you plan to deal with `textDocument/codeAction` request?\r\n\r\nEventually this will be refactored to just use `vim.diagnostic.get_line_diagnostics()`, but in the meantime none of the `vim.lsp.diagnostic` methods are being removed, they are just being modified to use `vim.diagnostic` under the hood, so all LSP behavior will continue to work as expected.\r\n",
            "created_at": "2021-09-07T16:14:03Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-914441094",
            "id": 914441094,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42gUOG",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914441094/reactions"
            },
            "updated_at": "2021-09-07T16:14:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914441094",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Eventually this will be refactored to just use `vim.diagnostic.get_line_diagnostics()`, but in the meantime none of the `vim.lsp.diagnostic` methods are being removed, they are just being modified to use `vim.diagnostic` under the hood, so all LSP behavior will continue to work as expected.\r\n\r\nI was actually wondering about the other way around, where a linter can offer a fix. Maybe there is a need to make CodeAction providers a separate entity with some kind of subscription model.\r\n\r\n",
            "created_at": "2021-09-07T16:59:57Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-914471752",
            "id": 914471752,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42gbtI",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914471752/reactions"
            },
            "updated_at": "2021-09-07T16:59:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914471752",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/59826753?v=4",
                "events_url": "https://api.github.com/users/kylo252/events{/privacy}",
                "followers_url": "https://api.github.com/users/kylo252/followers",
                "following_url": "https://api.github.com/users/kylo252/following{/other_user}",
                "gists_url": "https://api.github.com/users/kylo252/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/kylo252",
                "id": 59826753,
                "login": "kylo252",
                "node_id": "MDQ6VXNlcjU5ODI2NzUz",
                "organizations_url": "https://api.github.com/users/kylo252/orgs",
                "received_events_url": "https://api.github.com/users/kylo252/received_events",
                "repos_url": "https://api.github.com/users/kylo252/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/kylo252/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/kylo252/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/kylo252"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "AFAIK code actions are explicitly an LSP thing and are therefore out of scope for this PR.",
            "created_at": "2021-09-07T17:05:03Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-914475024",
            "id": 914475024,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42gcgQ",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914475024/reactions"
            },
            "updated_at": "2021-09-07T17:05:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/914475024",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Marking as ready to run the CI. Let's see how many tests this breaks",
            "created_at": "2021-09-09T16:27:11Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-916252499",
            "id": 916252499,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42nOdT",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/916252499/reactions"
            },
            "updated_at": "2021-09-09T16:27:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/916252499",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Regarding the current autocommand `LspDiagnosticsChanged` and the highlight groups `LspDiagnostics*`: should we temporarily maintain linkage between the old and new versions for backward compatibility, or should we just rip off the band-aid and add it to the breaking changes list and tell users to update their highlight and autocommand definitions?",
            "created_at": "2021-09-10T16:27:06Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-917038038",
            "id": 917038038,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42qOPW",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/917038038/reactions"
            },
            "updated_at": "2021-09-10T16:27:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/917038038",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "you could maintain linkage while displaing a notification \"you should be using XXX\"",
            "created_at": "2021-09-10T22:54:32Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-917258455",
            "id": 917258455,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42rEDX",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/917258455/reactions"
            },
            "updated_at": "2021-09-10T22:54:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/917258455",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/886074?v=4",
                "events_url": "https://api.github.com/users/teto/events{/privacy}",
                "followers_url": "https://api.github.com/users/teto/followers",
                "following_url": "https://api.github.com/users/teto/following{/other_user}",
                "gists_url": "https://api.github.com/users/teto/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/teto",
                "id": 886074,
                "login": "teto",
                "node_id": "MDQ6VXNlcjg4NjA3NA==",
                "organizations_url": "https://api.github.com/users/teto/orgs",
                "received_events_url": "https://api.github.com/users/teto/received_events",
                "repos_url": "https://api.github.com/users/teto/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/teto/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/teto/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/teto"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Existing tests and new tests for `vim.diagnostic` are all passing. I'll wait to squash all of the commits down to 1 until everyone has had a chance to review.",
            "created_at": "2021-09-11T01:08:20Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-917310507",
            "id": 917310507,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42rQwr",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/917310507/reactions"
            },
            "updated_at": "2021-09-11T01:09:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/917310507",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Regarding the signatures: I think we should make a distinction between \"setter\" APIs and \"getter\" APIs. The former are those used by diagnostic producers and all *require* a diagnostic namespace: for these functions, `namespace` is the first argument.\r\n\r\nHowever, users don't know or care about \"namespaces\": they just want to know \"what are the diagnostics for this buffer?\" So for getter functions, `namespace` is moved into an`opts` table (it's there so that if a plugin *does* want to limit results by their namespace, they can do so). Although maybe we should drop even that and just return all diagnostics anyway and then just filter the result with `tbl_filter`.\r\n\r\n> I'm also questioning a bit whether set_signs / set_underline and set_virtual_text should be exposed standalone, or whether we could change (re)draw to take the opts of the internal display. So a user would for example call vim.diagnostics.draw(..., { virtual_text = true }) to only set the virtual text.\r\n\r\nI agree with you and (bfredl above) that we probably don't need the `set_*` family of functions to be exposed publicly. However, options are not saved alongside the diagnostics themselves but with the namespace (or globally). So using something like `vim.diagnostics.draw(..., { virtual_text = true })` won't work (right now) because if the user calls `disable()` or `clear()`, those options get lost when the diagnostics are redrawn. So right now the way to do this is to configure the *namespace* itself, and then draw the diagnostics:\r\n\r\n```lua\r\nvim.diagnostic.config({ virtual_text = true }, ns)\r\nvim.diagnostic.set(ns, ...)\r\n```\r\n\r\n**EDIT:** The more I think about this diagnostic API the more I'm thinking that specifying a `namespace` argument should really only be necessary for `set()`. Functions like `get()`, `disable()`, `enable()`, etc. are used by diagnostic *consumers* which don't care about the namespace (and don't even know what it is!). Instead, we can add the namespace for each diagnostic to its data structure and consumers can filter on that, if necessary.\r\n\r\nSo I'm going to rework some of these function signatures to make `namespace` an optional parameter (or no parameter at all) for the \"getter\" type functions, e.g. `enable(namespace, bufnr)` becomes `enable(bufnr, namespace)`. This is backwards from what I originally proposed but I think makes much more sense from a consumer's point of view.",
            "created_at": "2021-09-11T15:37:50Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-917426766",
            "id": 917426766,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM42rtJO",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/917426766/reactions"
            },
            "updated_at": "2021-09-11T16:14:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/917426766",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Rebased on master and squashed commits. I think I'm personally happy with how the API looks, so just waiting for final review/critiques/suggestions.",
            "created_at": "2021-09-15T01:16:27Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-919622206",
            "id": 919622206,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM420FI-",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/919622206/reactions"
            },
            "updated_at": "2021-09-15T01:16:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/919622206",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Looks like there is an ASAN failure caused by the [UTF-16 test](https://github.com/neovim/neovim/pull/15585/files?file-filters%5B%5D=.lua#diff-ddcf5ebbb82479c9d8a41bd89fa00be3097eb3b7625ac7b5bf09002c288af794R770-R807). Investigating now.\r\n\r\n<details>\r\n\r\n```\r\n2021-09-15T02:00:11.6743932Z [ RUN      ] vim.lsp.diagnostic vim.lsp.diagnostic.on_publish_diagnostics correctly handles UTF-16 offsets: 13.75 ms OK\r\n2021-09-15T02:00:11.9898991Z ==================== File /home/runner/work/neovim/neovim/build/log/ubsan.20459 ====================\r\n2021-09-15T02:00:11.9900561Z = \r\n2021-09-15T02:00:11.9901125Z = =================================================================\r\n2021-09-15T02:00:11.9901866Z = ==20459==ERROR: LeakSanitizer: detected memory leaks\r\n2021-09-15T02:00:11.9902712Z = \r\n2021-09-15T02:00:11.9903349Z = Direct leak of 6 byte(s) in 2 object(s) allocated from:\r\n2021-09-15T02:00:11.9904038Z =     #0 0x4d9f1d in malloc ??:?\r\n2021-09-15T02:00:11.9904787Z =     #1 0x10de172 in try_malloc /home/runner/work/neovim/neovim/src/nvim/memory.c:73:15\r\n2021-09-15T02:00:11.9905996Z =     #2 0x10de36c in xmalloc /home/runner/work/neovim/neovim/src/nvim/memory.c:107:15\r\n2021-09-15T02:00:11.9906964Z =     #3 0xf414bd in nlua_ref /home/runner/work/neovim/neovim/src/nvim/lua/executor.c:1050:48\r\n2021-09-15T02:00:11.9907984Z =     #4 0xf49a89 in nlua_schedule /home/runner/work/neovim/neovim/src/nvim/lua/executor.c:277:15\r\n2021-09-15T02:00:11.9909732Z =     #5 0x1cf61a7 in luaD_precall /home/runner/nvim-deps/build/src/lua/src/ldo.c:320:10\r\n2021-09-15T02:00:11.9910978Z =     #6 0x1d04a03 in luaV_execute /home/runner/nvim-deps/build/src/lua/src/lvm.c:591:17\r\n2021-09-15T02:00:11.9912225Z =     #7 0x1cf645a in luaD_call /home/runner/nvim-deps/build/src/lua/src/ldo.c:378:5\r\n2021-09-15T02:00:11.9913431Z =     #8 0x1cf28f7 in f_call /home/runner/nvim-deps/build/src/lua/src/lapi.c:800:3\r\n2021-09-15T02:00:11.9914709Z =     #9 0x1cf5464 in luaD_rawrunprotected /home/runner/nvim-deps/build/src/lua/src/ldo.c:116:3\r\n2021-09-15T02:00:11.9915991Z =     #10 0x1cf6864 in luaD_pcall /home/runner/nvim-deps/build/src/lua/src/ldo.c:464:12\r\n2021-09-15T02:00:11.9917191Z =     #11 0x1cf29b9 in lua_pcall /home/runner/nvim-deps/build/src/lua/src/lapi.c:821:12\r\n2021-09-15T02:00:11.9918398Z =     #12 0xf4baa2 in nlua_luv_cfpcall /home/runner/work/neovim/neovim/src/nvim/lua/executor.c:230:16\r\n2021-09-15T02:00:11.9919684Z =     #13 0x1caac29 in uv__chld /home/runner/nvim-deps/build/src/libuv/src/unix/process.c:109:5\r\n2021-09-15T02:00:11.9920481Z = \r\n2021-09-15T02:00:11.9921187Z = SUMMARY: AddressSanitizer: 6 byte(s) leaked in 2 allocation(s).\r\n2021-09-15T02:00:11.9922903Z ====================================================================================================\r\n2021-09-15T02:00:11.9924068Z nan ms test/helpers.lua:249: Found runtime errors in logfile(s): /home/runner/work/neovim/neovim/build/log/ubsan.20459\r\n```\r\n\r\n</details>",
            "created_at": "2021-09-15T03:33:49Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-919671438",
            "id": 919671438,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM420RKO",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/919671438/reactions"
            },
            "updated_at": "2021-09-15T03:49:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/919671438",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Looks like there is an ASAN failure caused by the [UTF-16 test](https://github.com/neovim/neovim/pull/15585/files?file-filters%5B%5D=.lua#diff-ddcf5ebbb82479c9d8a41bd89fa00be3097eb3b7625ac7b5bf09002c288af794R770-R807). Investigating now.\r\n\r\nI'm guessing the tests need this for some reason: https://github.com/neovim/neovim/blob/9edd17509fca597b847656adc8fc20fc1cc44ce5/test/functional/plugin/lsp_spec.lua#L39\r\n\r\ncc @bfredl ",
            "created_at": "2021-09-15T10:33:04Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-919901135",
            "id": 919901135,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM421JPP",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/919901135/reactions"
            },
            "updated_at": "2021-09-15T10:33:04Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/919901135",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "`make lualint` failure",
            "created_at": "2021-09-16T20:28:47Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-921222248",
            "id": 921222248,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM426Lxo",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921222248/reactions"
            },
            "updated_at": "2021-09-16T20:28:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921222248",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> `make lualint` failure\r\n\r\nFixed the unused 'retry' in diagnostic_spec. The rest are unused variables in the LSP diagnostic wrappers. No harm in keeping these to preserve backward compatibility with the function signatures. Turning them into `_` fills the docs with a bunch of `{_}` function parameters which is ugly and useless (imo), so I suggest we just ignore these.\r\n\r\nIs there a way to indicate to lualint (with a comment or something) to ignore certain errors?",
            "created_at": "2021-09-16T20:42:02Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-921230336",
            "id": 921230336,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM426NwA",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921230336/reactions"
            },
            "updated_at": "2021-09-16T20:46:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921230336",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> The rest are unused variables in the LSP diagnostic wrappers. No harm in keeping these to preserve backward compatibility with the function signatures. \r\n\r\nAre these deprecated functions? If so we should not generate docs for them (mark `@private` I guess), they should only be mentioned at `:help deprecated`.\r\n\r\n> Is there a way to indicate to lualint (with a comment or something) to ignore certain errors?\r\n\r\nYes, example:  https://github.com/neovim/neovim/blob/8d7a64a09a99cd345d8c3e39ecf2434c77eaa05e/test/functional/legacy/listlbr_utf8_spec.lua#L11\r\n\r\ndocs: https://luacheck.readthedocs.io/en/stable/warnings.html",
            "created_at": "2021-09-16T20:54:53Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-921237958",
            "id": 921237958,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM426PnG",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921237958/reactions"
            },
            "updated_at": "2021-09-16T20:55:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921237958",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> > The rest are unused variables in the LSP diagnostic wrappers. No harm in keeping these to preserve backward compatibility with the function signatures.\r\n> \r\n> Are these deprecated functions?\r\n\r\nDuh, you're right. I was thinking of when I first generated the docs for these a while ago before they were marked `@deprecated`. No harm in changing these to `_` now.",
            "created_at": "2021-09-16T21:01:00Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-921241700",
            "id": 921241700,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM426Qhk",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921241700/reactions"
            },
            "updated_at": "2021-09-16T21:01:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921241700",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "author_association": "NONE",
            "body": "@gpanders  you remove diagnotics_cache_count on a new diagnostics\r\n but get_count function call a lot on the status line and it needs to be cache.",
            "created_at": "2021-09-17T04:45:39Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-921461456",
            "id": 921461456,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM427GLQ",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921461456/reactions"
            },
            "updated_at": "2021-09-17T07:04:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921461456",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7578110?v=4",
                "events_url": "https://api.github.com/users/windwp/events{/privacy}",
                "followers_url": "https://api.github.com/users/windwp/followers",
                "following_url": "https://api.github.com/users/windwp/following{/other_user}",
                "gists_url": "https://api.github.com/users/windwp/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/windwp",
                "id": 7578110,
                "login": "windwp",
                "node_id": "MDQ6VXNlcjc1NzgxMTA=",
                "organizations_url": "https://api.github.com/users/windwp/orgs",
                "received_events_url": "https://api.github.com/users/windwp/received_events",
                "repos_url": "https://api.github.com/users/windwp/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/windwp/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/windwp/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/windwp"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> @gpanders you remove diagnotics_cache_count on a new diagnostics\r\n> but get_count function call a lot on the status line and it needs to be cache.\r\n\r\nCan you show me some benchmarks demonstrating that not caching the counts has a non-trivial performance impact?\r\n\r\nWe will add this back if that is the case, but I’d like to see some data first.",
            "created_at": "2021-09-17T14:38:57Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-921850495",
            "id": 921850495,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM428lJ_",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921850495/reactions"
            },
            "updated_at": "2021-09-17T14:38:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921850495",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "author_association": "NONE",
            "body": "@gpanders vim.lsp.diagnostic.get_count need to call 4 time to display all possible value  but i can switch to call vim.diagnostic.get() then count \r\nif you still need a demo i will post later",
            "created_at": "2021-09-17T16:05:44Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-921912381",
            "id": 921912381,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM4280Q9",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921912381/reactions"
            },
            "updated_at": "2021-09-17T16:05:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921912381",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7578110?v=4",
                "events_url": "https://api.github.com/users/windwp/events{/privacy}",
                "followers_url": "https://api.github.com/users/windwp/followers",
                "following_url": "https://api.github.com/users/windwp/following{/other_user}",
                "gists_url": "https://api.github.com/users/windwp/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/windwp",
                "id": 7578110,
                "login": "windwp",
                "node_id": "MDQ6VXNlcjc1NzgxMTA=",
                "organizations_url": "https://api.github.com/users/windwp/orgs",
                "received_events_url": "https://api.github.com/users/windwp/received_events",
                "repos_url": "https://api.github.com/users/windwp/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/windwp/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/windwp/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/windwp"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Right, you should be able to just call `vim.diagnostic.get()` once and then use `vim.tbl_filter` to get the count of each severity level from that.\r\n\r\nYou can also cache the results of `vim.diagnostic.get()` yourself and only update them on the `DiagnosticsChanged` autocommand.",
            "created_at": "2021-09-17T16:10:02Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-921915592",
            "id": 921915592,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM4281DI",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 2,
                "-1": 0,
                "confused": 0,
                "eyes": 1,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921915592/reactions"
            },
            "updated_at": "2021-09-17T16:10:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/921915592",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> LSP diagnostics will continue to work as usual\r\n\r\n@gpanders I think this is actually breaking code actions for e.g. typescript language server and eslint language server. Right now the diagnostic.code is no longer send back to the server (by transforming the diagnostics to vim and back we are dropping some fields like the code field) and I think those language servers are using the code field to generate their code actions...\r\n\r\nShould we just copy all the \"unknown\" fields to vim and back?",
            "created_at": "2021-09-20T14:32:42Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-922984692",
            "id": 922984692,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM43A6D0",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/922984692/reactions"
            },
            "updated_at": "2021-09-20T14:33:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/922984692",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/896093?v=4",
                "events_url": "https://api.github.com/users/entropitor/events{/privacy}",
                "followers_url": "https://api.github.com/users/entropitor/followers",
                "following_url": "https://api.github.com/users/entropitor/following{/other_user}",
                "gists_url": "https://api.github.com/users/entropitor/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/entropitor",
                "id": 896093,
                "login": "entropitor",
                "node_id": "MDQ6VXNlcjg5NjA5Mw==",
                "organizations_url": "https://api.github.com/users/entropitor/orgs",
                "received_events_url": "https://api.github.com/users/entropitor/received_events",
                "repos_url": "https://api.github.com/users/entropitor/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/entropitor/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/entropitor/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/entropitor"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I've created an issue for this: https://github.com/neovim/neovim/issues/15733",
            "created_at": "2021-09-20T14:36:17Z",
            "html_url": "https://github.com/neovim/neovim/pull/15585#issuecomment-922987573",
            "id": 922987573,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
            "node_id": "IC_kwDOAPphoM43A6w1",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/922987573/reactions"
            },
            "updated_at": "2021-09-20T14:36:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/922987573",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/896093?v=4",
                "events_url": "https://api.github.com/users/entropitor/events{/privacy}",
                "followers_url": "https://api.github.com/users/entropitor/followers",
                "following_url": "https://api.github.com/users/entropitor/following{/other_user}",
                "gists_url": "https://api.github.com/users/entropitor/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/entropitor",
                "id": 896093,
                "login": "entropitor",
                "node_id": "MDQ6VXNlcjg5NjA5Mw==",
                "organizations_url": "https://api.github.com/users/entropitor/orgs",
                "received_events_url": "https://api.github.com/users/entropitor/received_events",
                "repos_url": "https://api.github.com/users/entropitor/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/entropitor/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/entropitor/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/entropitor"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/15585/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/15585/commits",
    "created_at": "2021-09-07T03:04:31Z",
    "diff_url": "https://github.com/neovim/neovim/pull/15585.diff",
    "draft": false,
    "head": {
        "label": "gpanders:vim-diagnostic",
        "ref": "vim-diagnostic",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/gpanders/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/gpanders/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/gpanders/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/gpanders/neovim/branches{/branch}",
            "clone_url": "https://github.com/gpanders/neovim.git",
            "collaborators_url": "https://api.github.com/repos/gpanders/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/gpanders/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/gpanders/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/gpanders/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/gpanders/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/gpanders/neovim/contributors",
            "created_at": "2021-06-11T03:58:44Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/gpanders/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/gpanders/neovim/downloads",
            "events_url": "https://api.github.com/repos/gpanders/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/gpanders/neovim/forks",
            "full_name": "gpanders/neovim",
            "git_commits_url": "https://api.github.com/repos/gpanders/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/gpanders/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/gpanders/neovim/git/tags{/sha}",
            "git_url": "git://github.com/gpanders/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/gpanders/neovim/hooks",
            "html_url": "https://github.com/gpanders/neovim",
            "id": 375899052,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/gpanders/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/gpanders/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/gpanders/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/gpanders/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/gpanders/neovim/labels{/name}",
            "language": "Vim script",
            "languages_url": "https://api.github.com/repos/gpanders/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/gpanders/neovim/merges",
            "milestones_url": "https://api.github.com/repos/gpanders/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkzNzU4OTkwNTI=",
            "notifications_url": "https://api.github.com/repos/gpanders/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/gpanders/neovim/pulls{/number}",
            "pushed_at": "2024-08-19T11:43:09Z",
            "releases_url": "https://api.github.com/repos/gpanders/neovim/releases{/id}",
            "size": 276474,
            "ssh_url": "git@github.com:gpanders/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/gpanders/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/gpanders/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/gpanders/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/gpanders/neovim/subscription",
            "svn_url": "https://github.com/gpanders/neovim",
            "tags_url": "https://api.github.com/repos/gpanders/neovim/tags",
            "teams_url": "https://api.github.com/repos/gpanders/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/gpanders/neovim/git/trees{/sha}",
            "updated_at": "2022-01-07T19:38:08Z",
            "url": "https://api.github.com/repos/gpanders/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
            "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
            "followers_url": "https://api.github.com/users/gpanders/followers",
            "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
            "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/gpanders",
            "id": 8965202,
            "login": "gpanders",
            "node_id": "MDQ6VXNlcjg5NjUyMDI=",
            "organizations_url": "https://api.github.com/users/gpanders/orgs",
            "received_events_url": "https://api.github.com/users/gpanders/received_events",
            "repos_url": "https://api.github.com/users/gpanders/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/gpanders"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/15585",
    "id": 728271603,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/15585",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": "stdlib",
            "id": 573222693,
            "name": "lua",
            "node_id": "MDU6TGFiZWw1NzMyMjI2OTM=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lua"
        },
        {
            "color": "c5def5",
            "default": false,
            "description": null,
            "id": 662566370,
            "name": "lsp",
            "node_id": "MDU6TGFiZWw2NjI1NjYzNzA=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lsp"
        }
    ],
    "locked": true,
    "merge_commit_sha": "2e8103475e18d1e4aa0d6355107f393815a886a6",
    "merged_at": "2021-09-16T21:23:43Z",
    "milestone": null,
    "node_id": "MDExOlB1bGxSZXF1ZXN0NzI4MjcxNjAz",
    "number": 15585,
    "patch_url": "https://github.com/neovim/neovim/pull/15585.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/15585/comments",
    "state": "closed",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/4fca63dbf722f60f9096ef32c0dbecc2055c4a9a",
    "title": "refactor: move vim.lsp.diagnostic to vim.diagnostic",
    "updated_at": "2024-08-18T02:20:07Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/15585",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
        "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
        "followers_url": "https://api.github.com/users/gpanders/followers",
        "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
        "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/gpanders",
        "id": 8965202,
        "login": "gpanders",
        "node_id": "MDQ6VXNlcjg5NjUyMDI=",
        "organizations_url": "https://api.github.com/users/gpanders/orgs",
        "received_events_url": "https://api.github.com/users/gpanders/received_events",
        "repos_url": "https://api.github.com/users/gpanders/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/gpanders"
    }
}