{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/29280/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/29280/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/29280"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/29280"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/29280/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/cd53db2157f0cd27877451a6b00d66e9bed74e73"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 5490,
            "forks_count": 5490,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1763,
            "open_issues_count": 1763,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2024-07-01T23:59:24Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 275993,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 79695,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2024-07-02T01:57:38Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 79695,
            "watchers_count": 79695,
            "web_commit_signoff_required": false
        },
        "sha": "5581a95534e44b8714e715c925c9de2d95ae1c21",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim"
        }
    },
    "body": "This PR evolved into three improvements:\r\n\r\n- *Massively* cover existing functionality with tests. Some (many) tests are marked as pending because the particular context does not work. Those tests are meant as a reference for future fixing.\r\n- Replace `options` context with `o`, `bo`, `wo`, `go` granular contexts. This aligns with existing Lua options terminology and is more flexible than single `options`.\r\n- Add `env` context for environment variables. As this also aligns with `vim.env`.\r\n\r\nMore details in commits' messages.\r\n\r\n------\r\n\r\nResolves #29253\r\n\r\nAlternative to #29269 and #29268",
    "closed_at": "2024-06-26T10:23:35Z",
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1645868635"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1645868635"
                }
            },
            "author_association": "MEMBER",
            "body": "The name might need a bit of explanation, is this correct:\r\n```suggestion\r\n--- Gets option :set context.\r\nlocal save_set_context = function(context)\r\n```\r\n\r\nNit: \"save\" implies side-effects, so \"get\" would normally be preferrable, but `get_set_context` would be strange.",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-19T10:18:21Z",
            "diff_hunk": "@@ -1151,34 +1154,70 @@ end\n --- @field keeppatterns? boolean\n --- @field lockmarks? boolean\n --- @field noautocmd? boolean\n---- @field options? table<string, any>\n+--- @field o? table<string, any>\n --- @field sandbox? boolean\n --- @field silent? boolean\n --- @field unsilent? boolean\n --- @field win? integer\n+--- @field wo? table<string, any>\n+\n+local save_set_context = function(context)",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1645868635",
            "id": 1645868635,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5iGfZb",
            "original_commit_id": "8b208ff644a072042652b63f1e2dd6058071dff4",
            "original_line": 1164,
            "original_position": 24,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2127786169,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1645868635/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-19T10:18:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1645868635",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1645925496"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1645925496"
                }
            },
            "author_association": "MEMBER",
            "body": "Sure. I'd not use `:set` here, because it is specifically not used during setting context.\r\n\r\nHow about `cache_and_set_context()`? I thought about separating this in two functions, but having them in one reduces the number of `for` cycles in half. I still try to microoptimize this in areas which don't compromise features. To allow it to be run in busy loops.",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-19T10:56:11Z",
            "diff_hunk": "@@ -1151,34 +1154,70 @@ end\n --- @field keeppatterns? boolean\n --- @field lockmarks? boolean\n --- @field noautocmd? boolean\n---- @field options? table<string, any>\n+--- @field o? table<string, any>\n --- @field sandbox? boolean\n --- @field silent? boolean\n --- @field unsilent? boolean\n --- @field win? integer\n+--- @field wo? table<string, any>\n+\n+local save_set_context = function(context)",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1645925496",
            "id": 1645925496,
            "in_reply_to_id": 1645868635,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5iGtR4",
            "original_commit_id": "8b208ff644a072042652b63f1e2dd6058071dff4",
            "original_line": 1164,
            "original_position": 24,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2127873880,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1645925496/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-19T10:56:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1645925496",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1646040445"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1646040445"
                }
            },
            "author_association": "MEMBER",
            "body": "> How about `cache_and_set_context()`?\r\n\r\ndoesn't seem better than \"save\".  I see now that this is setting options so it does in fact have side effects, so ignore my previous comment. Just maybe a brief docstring would help.",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-19T12:04:26Z",
            "diff_hunk": "@@ -1151,34 +1154,70 @@ end\n --- @field keeppatterns? boolean\n --- @field lockmarks? boolean\n --- @field noautocmd? boolean\n---- @field options? table<string, any>\n+--- @field o? table<string, any>\n --- @field sandbox? boolean\n --- @field silent? boolean\n --- @field unsilent? boolean\n --- @field win? integer\n+--- @field wo? table<string, any>\n+\n+local save_set_context = function(context)",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1646040445",
            "id": 1646040445,
            "in_reply_to_id": 1645868635,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5iHJV9",
            "original_commit_id": "8b208ff644a072042652b63f1e2dd6058071dff4",
            "original_line": 1164,
            "original_position": 24,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2128046891,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1646040445/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-19T12:04:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1646040445",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1646312709"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1646312709"
                }
            },
            "author_association": "MEMBER",
            "body": "Out of curiosity, is there a reason to change this?\r\n\r\nThe single-line `vim.validate` calls are basically free (performance wise). I don't think changing this is a readability win either way (there's a small argument to be made for eliminating the repeated `vim.validate`, but that's it). My main concern is about establishing patterns. Future contributors will copy-paste what they find elsewhere, and I think we should try to use the fast version of `vim.validate` wherever possible for that reason.",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-19T14:32:27Z",
            "diff_hunk": "@@ -1151,34 +1154,70 @@ end\n --- @field keeppatterns? boolean\n --- @field lockmarks? boolean\n --- @field noautocmd? boolean\n---- @field options? table<string, any>\n+--- @field o? table<string, any>\n --- @field sandbox? boolean\n --- @field silent? boolean\n --- @field unsilent? boolean\n --- @field win? integer\n+--- @field wo? table<string, any>\n+\n+local save_set_context = function(context)\n+  local cache = { bo = {}, env = {}, go = {}, wo = {} } ---@type table<string, any>\n+\n+  if context.o then\n+    local scope_map = { buf = 'bo', global = 'go', win = 'wo' }\n+    for name, context_value in pairs(context.o) do\n+      -- Infer scope to be cached along with global, as `vim.o` sets both\n+      local scope = scope_map[vim.api.nvim_get_option_info2(name, {}).scope]\n+      cache[scope][name] = vim[scope][name]\n+      cache.go[name] = vim.go[name]\n+\n+      vim.o[name] = context_value\n+    end\n+  end\n+\n+  -- Set other scopes (so that they have more precedence over `context.o`)\n+  for scope, scope_cache in pairs(cache) do\n+    for name, context_value in pairs(context[scope] or {}) do\n+      -- Do not override already set (from `context.o`) cache\n+      scope_cache[name] = scope_cache[name] or vim[scope][name]\n+      vim[scope][name] = context_value\n+    end\n+  end\n+\n+  return cache\n+end\n \n --- Executes function `f` with the given context specification.\n ---\n --- @param context vim.context.mods\n function vim._with(context, f)\n-  vim.validate('context', context, 'table')\n-  vim.validate('f', f, 'function')\n-\n-  vim.validate('context.buf', context.buf, 'number', true)\n-  vim.validate('context.emsg_silent', context.emsg_silent, 'boolean', true)\n-  vim.validate('context.hide', context.hide, 'boolean', true)\n-  vim.validate('context.horizontal', context.horizontal, 'boolean', true)\n-  vim.validate('context.keepalt', context.keepalt, 'boolean', true)\n-  vim.validate('context.keepjumps', context.keepjumps, 'boolean', true)\n-  vim.validate('context.keepmarks', context.keepmarks, 'boolean', true)\n-  vim.validate('context.keeppatterns', context.keeppatterns, 'boolean', true)\n-  vim.validate('context.lockmarks', context.lockmarks, 'boolean', true)\n-  vim.validate('context.noautocmd', context.noautocmd, 'boolean', true)\n-  vim.validate('context.options', context.options, 'table', true)\n-  vim.validate('context.sandbox', context.sandbox, 'boolean', true)\n-  vim.validate('context.silent', context.silent, 'boolean', true)\n-  vim.validate('context.unsilent', context.unsilent, 'boolean', true)\n-  vim.validate('context.win', context.win, 'number', true)\n+  vim.validate({\n+    context = { context, 'table' },\n+    f = { f, 'function' },\n+  })\n+\n+  vim.validate({\n+    ['context.bo'] = { context.bo, 'table', true },\n+    ['context.buf'] = { context.buf, 'number', true },\n+    ['context.emsg_silent'] = { context.emsg_silent, 'boolean', true },\n+    ['context.env'] = { context.env, 'boolean', true },\n+    ['context.go'] = { context.go, 'table', true },\n+    ['context.hide'] = { context.hide, 'boolean', true },\n+    ['context.horizontal'] = { context.horizontal, 'boolean', true },\n+    ['context.keepalt'] = { context.keepalt, 'boolean', true },\n+    ['context.keepjumps'] = { context.keepjumps, 'boolean', true },\n+    ['context.keepmarks'] = { context.keepmarks, 'boolean', true },\n+    ['context.keeppatterns'] = { context.keeppatterns, 'boolean', true },\n+    ['context.lockmarks'] = { context.lockmarks, 'boolean', true },\n+    ['context.noautocmd'] = { context.noautocmd, 'boolean', true },\n+    ['context.o'] = { context.o, 'table', true },\n+    ['context.sandbox'] = { context.sandbox, 'boolean', true },\n+    ['context.silent'] = { context.silent, 'boolean', true },\n+    ['context.unsilent'] = { context.unsilent, 'boolean', true },\n+    ['context.win'] = { context.win, 'number', true },\n+    ['context.wo'] = { context.wo, 'table', true },\n+  })",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1646312709",
            "id": 1646312709,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5iIL0F",
            "original_commit_id": "8b208ff644a072042652b63f1e2dd6058071dff4",
            "original_line": 1220,
            "original_position": 98,
            "original_start_line": 1164,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2128463253,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1646312709/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "LEFT",
            "subject_type": "line",
            "updated_at": "2024-06-19T14:33:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1646312709",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1646357063"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1646357063"
                }
            },
            "author_association": "MEMBER",
            "body": "My bad, it was more of an assumption that single call to `vim.validate()` is more performant than multiple. However, I did not account that those are the newly added style of vararg calls instead of creating a table every single time.\r\n\r\nI've profiled two versions (single `vim.validate()` with table argument vs multiple with vararg) and indeed vararg version seems to be faster: around 5e-07 seconds for single `vim.validate()` and around 8e-08 seconds for vararg (time for all current 19 calls).\r\n\r\nI'll change back to multiple vararg calls.",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-19T15:03:12Z",
            "diff_hunk": "@@ -1151,34 +1154,70 @@ end\n --- @field keeppatterns? boolean\n --- @field lockmarks? boolean\n --- @field noautocmd? boolean\n---- @field options? table<string, any>\n+--- @field o? table<string, any>\n --- @field sandbox? boolean\n --- @field silent? boolean\n --- @field unsilent? boolean\n --- @field win? integer\n+--- @field wo? table<string, any>\n+\n+local save_set_context = function(context)\n+  local cache = { bo = {}, env = {}, go = {}, wo = {} } ---@type table<string, any>\n+\n+  if context.o then\n+    local scope_map = { buf = 'bo', global = 'go', win = 'wo' }\n+    for name, context_value in pairs(context.o) do\n+      -- Infer scope to be cached along with global, as `vim.o` sets both\n+      local scope = scope_map[vim.api.nvim_get_option_info2(name, {}).scope]\n+      cache[scope][name] = vim[scope][name]\n+      cache.go[name] = vim.go[name]\n+\n+      vim.o[name] = context_value\n+    end\n+  end\n+\n+  -- Set other scopes (so that they have more precedence over `context.o`)\n+  for scope, scope_cache in pairs(cache) do\n+    for name, context_value in pairs(context[scope] or {}) do\n+      -- Do not override already set (from `context.o`) cache\n+      scope_cache[name] = scope_cache[name] or vim[scope][name]\n+      vim[scope][name] = context_value\n+    end\n+  end\n+\n+  return cache\n+end\n \n --- Executes function `f` with the given context specification.\n ---\n --- @param context vim.context.mods\n function vim._with(context, f)\n-  vim.validate('context', context, 'table')\n-  vim.validate('f', f, 'function')\n-\n-  vim.validate('context.buf', context.buf, 'number', true)\n-  vim.validate('context.emsg_silent', context.emsg_silent, 'boolean', true)\n-  vim.validate('context.hide', context.hide, 'boolean', true)\n-  vim.validate('context.horizontal', context.horizontal, 'boolean', true)\n-  vim.validate('context.keepalt', context.keepalt, 'boolean', true)\n-  vim.validate('context.keepjumps', context.keepjumps, 'boolean', true)\n-  vim.validate('context.keepmarks', context.keepmarks, 'boolean', true)\n-  vim.validate('context.keeppatterns', context.keeppatterns, 'boolean', true)\n-  vim.validate('context.lockmarks', context.lockmarks, 'boolean', true)\n-  vim.validate('context.noautocmd', context.noautocmd, 'boolean', true)\n-  vim.validate('context.options', context.options, 'table', true)\n-  vim.validate('context.sandbox', context.sandbox, 'boolean', true)\n-  vim.validate('context.silent', context.silent, 'boolean', true)\n-  vim.validate('context.unsilent', context.unsilent, 'boolean', true)\n-  vim.validate('context.win', context.win, 'number', true)\n+  vim.validate({\n+    context = { context, 'table' },\n+    f = { f, 'function' },\n+  })\n+\n+  vim.validate({\n+    ['context.bo'] = { context.bo, 'table', true },\n+    ['context.buf'] = { context.buf, 'number', true },\n+    ['context.emsg_silent'] = { context.emsg_silent, 'boolean', true },\n+    ['context.env'] = { context.env, 'boolean', true },\n+    ['context.go'] = { context.go, 'table', true },\n+    ['context.hide'] = { context.hide, 'boolean', true },\n+    ['context.horizontal'] = { context.horizontal, 'boolean', true },\n+    ['context.keepalt'] = { context.keepalt, 'boolean', true },\n+    ['context.keepjumps'] = { context.keepjumps, 'boolean', true },\n+    ['context.keepmarks'] = { context.keepmarks, 'boolean', true },\n+    ['context.keeppatterns'] = { context.keeppatterns, 'boolean', true },\n+    ['context.lockmarks'] = { context.lockmarks, 'boolean', true },\n+    ['context.noautocmd'] = { context.noautocmd, 'boolean', true },\n+    ['context.o'] = { context.o, 'table', true },\n+    ['context.sandbox'] = { context.sandbox, 'boolean', true },\n+    ['context.silent'] = { context.silent, 'boolean', true },\n+    ['context.unsilent'] = { context.unsilent, 'boolean', true },\n+    ['context.win'] = { context.win, 'number', true },\n+    ['context.wo'] = { context.wo, 'table', true },\n+  })",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1646357063",
            "id": 1646357063,
            "in_reply_to_id": 1646312709,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5iIWpH",
            "original_commit_id": "8b208ff644a072042652b63f1e2dd6058071dff4",
            "original_line": 1220,
            "original_position": 98,
            "original_start_line": 1164,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2128532823,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1646357063/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "LEFT",
            "subject_type": "line",
            "updated_at": "2024-06-19T15:03:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1646357063",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1646373040"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1646373040"
                }
            },
            "author_association": "MEMBER",
            "body": "I resolved this by compactifying implementation so that it can be reasonably fit inside `vim._with()` body. No helper function - no problem.",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-19T15:14:05Z",
            "diff_hunk": "@@ -1151,34 +1154,70 @@ end\n --- @field keeppatterns? boolean\n --- @field lockmarks? boolean\n --- @field noautocmd? boolean\n---- @field options? table<string, any>\n+--- @field o? table<string, any>\n --- @field sandbox? boolean\n --- @field silent? boolean\n --- @field unsilent? boolean\n --- @field win? integer\n+--- @field wo? table<string, any>\n+\n+local save_set_context = function(context)",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1646373040",
            "id": 1646373040,
            "in_reply_to_id": 1645868635,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5iIaiw",
            "original_commit_id": "8b208ff644a072042652b63f1e2dd6058071dff4",
            "original_line": 1164,
            "original_position": 24,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2128558101,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 1,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1646373040/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-19T15:14:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1646373040",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1649689346"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649689346"
                }
            },
            "author_association": "MEMBER",
            "body": "Do I understand it correctly that e.g. if both `o` and `bo` scopes are used with different values then `o` will be used since it has higher priority?",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-22T12:21:48Z",
            "diff_hunk": "@@ -1192,29 +1221,60 @@ function vim._with(context, f)\n     if not vim.api.nvim_win_is_valid(context.win) then\n       error('Invalid window id: ' .. context.win)\n     end\n+    -- TODO: Maybe allow it?\n+    if context.buf and vim.api.nvim_win_get_buf(context.win) ~= context.buf then\n+      error('Can not set both `buf` and `win` context.')\n+    end\n   end\n \n-  -- Store original options\n-  local previous_options ---@type table<string, any>\n-  if context.options then\n-    previous_options = {}\n-    for k, v in pairs(context.options) do\n-      previous_options[k] =\n-        vim.api.nvim_get_option_value(k, { win = context.win, buf = context.buf })\n-      vim.api.nvim_set_option_value(k, v, { win = context.win, buf = context.buf })\n+  -- Decorate so that save-set-restore options is done in correct window-buffer\n+  local callback = function()\n+    -- Save and set context (NOTE: triggers `OptionSet` event)\n+    local cache = { bo = {}, env = {}, go = {}, wo = {} } ---@type table<string, any>\n+\n+    -- Use specific order from possibly most to least intrusive\n+    for _, scope in ipairs(scope_order) do\n+      for name, context_value in pairs(context[scope] or {}) do\n+        local sc = scope == 'o' and scope_map[vim.api.nvim_get_option_info2(name, {}).scope]\n+          or scope\n+\n+        -- Do not override already set cache and fall back to `vim.NIL` to\n+        -- cache `nil` values (which needs restoring later)\n+        cache[sc][name] = cache[sc][name] or vim[sc][name] or vim.NIL",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1649689346",
            "id": 1649689346,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5iVEMC",
            "original_commit_id": "1632da853646e4736021bc28d7baa05ab66854c2",
            "original_line": 1241,
            "original_position": 105,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2133794876,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649689346/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-22T12:21:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649689346",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1649691610"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649691610"
                }
            },
            "author_association": "MEMBER",
            "body": "Ngl, the code is kinda confusing but I suspect it's mostly because I'm not familiar with options.",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-22T12:32:18Z",
            "diff_hunk": "@@ -1192,29 +1221,60 @@ function vim._with(context, f)\n     if not vim.api.nvim_win_is_valid(context.win) then\n       error('Invalid window id: ' .. context.win)\n     end\n+    -- TODO: Maybe allow it?\n+    if context.buf and vim.api.nvim_win_get_buf(context.win) ~= context.buf then\n+      error('Can not set both `buf` and `win` context.')\n+    end\n   end\n \n-  -- Store original options\n-  local previous_options ---@type table<string, any>\n-  if context.options then\n-    previous_options = {}\n-    for k, v in pairs(context.options) do\n-      previous_options[k] =\n-        vim.api.nvim_get_option_value(k, { win = context.win, buf = context.buf })\n-      vim.api.nvim_set_option_value(k, v, { win = context.win, buf = context.buf })\n+  -- Decorate so that save-set-restore options is done in correct window-buffer\n+  local callback = function()\n+    -- Save and set context (NOTE: triggers `OptionSet` event)\n+    local cache = { bo = {}, env = {}, go = {}, wo = {} } ---@type table<string, any>\n+\n+    -- Use specific order from possibly most to least intrusive\n+    for _, scope in ipairs(scope_order) do",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1649691610",
            "id": 1649691610,
            "line": 1273,
            "node_id": "PRRC_kwDOAPphoM5iVEva",
            "original_commit_id": "1632da853646e4736021bc28d7baa05ab66854c2",
            "original_line": 1273,
            "original_position": 98,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": 141,
            "pull_request_review_id": 2133798964,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649691610/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-22T12:32:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649691610",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1649693084"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649693084"
                }
            },
            "author_association": "MEMBER",
            "body": "This is an error from my part. `horizontal` context does not exists in `vim._with_c` and should probably be removed for the time being.",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-22T12:42:13Z",
            "diff_hunk": "@@ -1151,21 +1154,46 @@ end\n --- @field keeppatterns? boolean\n --- @field lockmarks? boolean\n --- @field noautocmd? boolean\n---- @field options? table<string, any>\n+--- @field o? table<string, any>\n --- @field sandbox? boolean\n --- @field silent? boolean\n --- @field unsilent? boolean\n --- @field win? integer\n+--- @field wo? table<string, any>\n+\n+local scope_order = { 'o', 'wo', 'bo', 'go', 'env' }\n+local cache_restore_order = { 'bo', 'wo', 'go', 'env' }\n+local scope_map = { buf = 'bo', global = 'go', win = 'wo' }\n \n --- Executes function `f` with the given context specification.\n ---\n+--- Notes:\n+--- - Context `{ buf = buf }` has no guarantees about current window when\n+---   inside context.\n+--- - Context `{ buf = buf, win = win }` is yet not allowed, but this seems\n+---   to be an implementation detail.\n+--- - There should be no way to revert currently set `context.sandbox = true`\n+---   (like with nested `vim._with()` calls). Otherwise it kind of breaks the\n+---   whole purpose of sandbox execution.\n+--- - Saving and restoring option contexts (`bo`, `go`, `o`, `wo`) trigger\n+---   `OptionSet` events. This is an implementation issue because not doing it\n+---   seems to mean using either 'eventignore' option or extra nesting with\n+---   `{ noautocmd = true }` (which itself is a wrapper for 'eventignore').\n+---   As `{ go = { eventignore = '...' } }` is a valid context which should be\n+---   properly set and restored, this is not a good approach.\n+---   Not triggering `OptionSet` seems to be a good idea, though. So probably\n+---   only moving context save and restore to lower level might resolve this.\n+---\n --- @param context vim.context.mods\n function vim._with(context, f)\n   vim.validate('context', context, 'table')\n   vim.validate('f', f, 'function')\n \n+  vim.validate('context.bo', context.bo, 'table', true)\n   vim.validate('context.buf', context.buf, 'number', true)\n   vim.validate('context.emsg_silent', context.emsg_silent, 'boolean', true)\n+  vim.validate('context.env', context.env, 'table', true)\n+  vim.validate('context.go', context.go, 'table', true)\n   vim.validate('context.hide', context.hide, 'boolean', true)\n   vim.validate('context.horizontal', context.horizontal, 'boolean', true)",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1649693084",
            "id": 1649693084,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5iVFGc",
            "original_commit_id": "1632da853646e4736021bc28d7baa05ab66854c2",
            "original_line": 1198,
            "original_position": 58,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2133800935,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649693084/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-22T12:42:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649693084",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1649695248"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649695248"
                }
            },
            "author_association": "MEMBER",
            "body": "I am not sure how to make it less confusing, as it is caching and setting inside for loops.\r\n\r\nHere is an example of what it does if it would make it easier to follow. For `{ o = { winblend = 25 }, bo = { undolevels = 0 } }`, it does the following sequence:\r\n- Process `o` context:\r\n    - Get its \"effective\"/\"cachable\" context via `nvim_get_option_info2()`. The result is one of `bo`, `go`, or `wo`. It is `wo` for `winblend`.\r\n    - Cache it via `cache.wo.winblend = cache.wo.winblend or vim.wo.winblend or vim.NIL`. The first `cache.wo.winblend` is there in order to write to cache only once (as the same option name can be supplied in three different `context` fields). The fallback to `vim.NIL` is there mostly for `env` context (as `vim.env` can return `nil`).\r\n    - Cache its global value via `cache.go.winblend = cache.go.winblend or vim.go.winblend`. This is needed because later setting option might affect global values (like for `o` or `wo` contexts).\r\n    - Set it with `vim.o.winblend = 25`.\r\n- Process `bo` context:\r\n    - `cache.bo.undolevels = cache.bo.undolevels or vim.bo.undolevels or vim.NIL`.\r\n    - `cache.go.undolevels = cache.go.undolevels or vim.go.undolevels`.\r\n    - `vim.bo.undolevels = 0`.\r\n- Execute callback `f`.\r\n- Restore cache:\r\n    - `vim.bo.undolevels = cache.bo.undolevels`\r\n    - `vim.wo.winblend = cache.wo.winblend`\r\n    - `vim.go.undolevels = cache.go.undolevels` and `vim.go.winblend = cache.go.winblend`.",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-22T12:58:21Z",
            "diff_hunk": "@@ -1192,29 +1221,60 @@ function vim._with(context, f)\n     if not vim.api.nvim_win_is_valid(context.win) then\n       error('Invalid window id: ' .. context.win)\n     end\n+    -- TODO: Maybe allow it?\n+    if context.buf and vim.api.nvim_win_get_buf(context.win) ~= context.buf then\n+      error('Can not set both `buf` and `win` context.')\n+    end\n   end\n \n-  -- Store original options\n-  local previous_options ---@type table<string, any>\n-  if context.options then\n-    previous_options = {}\n-    for k, v in pairs(context.options) do\n-      previous_options[k] =\n-        vim.api.nvim_get_option_value(k, { win = context.win, buf = context.buf })\n-      vim.api.nvim_set_option_value(k, v, { win = context.win, buf = context.buf })\n+  -- Decorate so that save-set-restore options is done in correct window-buffer\n+  local callback = function()\n+    -- Save and set context (NOTE: triggers `OptionSet` event)\n+    local cache = { bo = {}, env = {}, go = {}, wo = {} } ---@type table<string, any>\n+\n+    -- Use specific order from possibly most to least intrusive\n+    for _, scope in ipairs(scope_order) do",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1649695248",
            "id": 1649695248,
            "in_reply_to_id": 1649691610,
            "line": 1273,
            "node_id": "PRRC_kwDOAPphoM5iVFoQ",
            "original_commit_id": "1632da853646e4736021bc28d7baa05ab66854c2",
            "original_line": 1273,
            "original_position": 98,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": 141,
            "pull_request_review_id": 2133805918,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649695248/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-22T12:58:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649695248",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1649695501"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649695501"
                }
            },
            "author_association": "MEMBER",
            "body": "On the contrary, `bo` will be used as it will be set *after* setting the `o` context.\r\n\r\nUsing `cache[sc][name] = cache[sc][name] or vim[sc][name]` instead of direct `cache[sc][name] = vim[sc][name]` guards exactly from this kind of case. Without it, cache would have been set to user's value from the `o` context and later (erroneously) restored to it.",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-22T13:01:24Z",
            "diff_hunk": "@@ -1192,29 +1221,60 @@ function vim._with(context, f)\n     if not vim.api.nvim_win_is_valid(context.win) then\n       error('Invalid window id: ' .. context.win)\n     end\n+    -- TODO: Maybe allow it?\n+    if context.buf and vim.api.nvim_win_get_buf(context.win) ~= context.buf then\n+      error('Can not set both `buf` and `win` context.')\n+    end\n   end\n \n-  -- Store original options\n-  local previous_options ---@type table<string, any>\n-  if context.options then\n-    previous_options = {}\n-    for k, v in pairs(context.options) do\n-      previous_options[k] =\n-        vim.api.nvim_get_option_value(k, { win = context.win, buf = context.buf })\n-      vim.api.nvim_set_option_value(k, v, { win = context.win, buf = context.buf })\n+  -- Decorate so that save-set-restore options is done in correct window-buffer\n+  local callback = function()\n+    -- Save and set context (NOTE: triggers `OptionSet` event)\n+    local cache = { bo = {}, env = {}, go = {}, wo = {} } ---@type table<string, any>\n+\n+    -- Use specific order from possibly most to least intrusive\n+    for _, scope in ipairs(scope_order) do\n+      for name, context_value in pairs(context[scope] or {}) do\n+        local sc = scope == 'o' and scope_map[vim.api.nvim_get_option_info2(name, {}).scope]\n+          or scope\n+\n+        -- Do not override already set cache and fall back to `vim.NIL` to\n+        -- cache `nil` values (which needs restoring later)\n+        cache[sc][name] = cache[sc][name] or vim[sc][name] or vim.NIL",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1649695501",
            "id": 1649695501,
            "in_reply_to_id": 1649689346,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5iVFsN",
            "original_commit_id": "1632da853646e4736021bc28d7baa05ab66854c2",
            "original_line": 1241,
            "original_position": 105,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2133806472,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649695501/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-22T13:01:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649695501",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1649699676"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649699676"
                }
            },
            "author_association": "MEMBER",
            "body": "I removed it from code, but left pending tests just in case.",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-22T13:31:13Z",
            "diff_hunk": "@@ -1151,21 +1154,46 @@ end\n --- @field keeppatterns? boolean\n --- @field lockmarks? boolean\n --- @field noautocmd? boolean\n---- @field options? table<string, any>\n+--- @field o? table<string, any>\n --- @field sandbox? boolean\n --- @field silent? boolean\n --- @field unsilent? boolean\n --- @field win? integer\n+--- @field wo? table<string, any>\n+\n+local scope_order = { 'o', 'wo', 'bo', 'go', 'env' }\n+local cache_restore_order = { 'bo', 'wo', 'go', 'env' }\n+local scope_map = { buf = 'bo', global = 'go', win = 'wo' }\n \n --- Executes function `f` with the given context specification.\n ---\n+--- Notes:\n+--- - Context `{ buf = buf }` has no guarantees about current window when\n+---   inside context.\n+--- - Context `{ buf = buf, win = win }` is yet not allowed, but this seems\n+---   to be an implementation detail.\n+--- - There should be no way to revert currently set `context.sandbox = true`\n+---   (like with nested `vim._with()` calls). Otherwise it kind of breaks the\n+---   whole purpose of sandbox execution.\n+--- - Saving and restoring option contexts (`bo`, `go`, `o`, `wo`) trigger\n+---   `OptionSet` events. This is an implementation issue because not doing it\n+---   seems to mean using either 'eventignore' option or extra nesting with\n+---   `{ noautocmd = true }` (which itself is a wrapper for 'eventignore').\n+---   As `{ go = { eventignore = '...' } }` is a valid context which should be\n+---   properly set and restored, this is not a good approach.\n+---   Not triggering `OptionSet` seems to be a good idea, though. So probably\n+---   only moving context save and restore to lower level might resolve this.\n+---\n --- @param context vim.context.mods\n function vim._with(context, f)\n   vim.validate('context', context, 'table')\n   vim.validate('f', f, 'function')\n \n+  vim.validate('context.bo', context.bo, 'table', true)\n   vim.validate('context.buf', context.buf, 'number', true)\n   vim.validate('context.emsg_silent', context.emsg_silent, 'boolean', true)\n+  vim.validate('context.env', context.env, 'table', true)\n+  vim.validate('context.go', context.go, 'table', true)\n   vim.validate('context.hide', context.hide, 'boolean', true)\n   vim.validate('context.horizontal', context.horizontal, 'boolean', true)",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1649699676",
            "id": 1649699676,
            "in_reply_to_id": 1649693084,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5iVGtc",
            "original_commit_id": "1632da853646e4736021bc28d7baa05ab66854c2",
            "original_line": 1198,
            "original_position": 58,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2133811738,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649699676/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-22T13:31:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649699676",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1649699758"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649699758"
                }
            },
            "author_association": "MEMBER",
            "body": "But good question, as I realized that there was no test case specifically if same option is supplied in several contexts. Added it.",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-22T13:31:55Z",
            "diff_hunk": "@@ -1192,29 +1221,60 @@ function vim._with(context, f)\n     if not vim.api.nvim_win_is_valid(context.win) then\n       error('Invalid window id: ' .. context.win)\n     end\n+    -- TODO: Maybe allow it?\n+    if context.buf and vim.api.nvim_win_get_buf(context.win) ~= context.buf then\n+      error('Can not set both `buf` and `win` context.')\n+    end\n   end\n \n-  -- Store original options\n-  local previous_options ---@type table<string, any>\n-  if context.options then\n-    previous_options = {}\n-    for k, v in pairs(context.options) do\n-      previous_options[k] =\n-        vim.api.nvim_get_option_value(k, { win = context.win, buf = context.buf })\n-      vim.api.nvim_set_option_value(k, v, { win = context.win, buf = context.buf })\n+  -- Decorate so that save-set-restore options is done in correct window-buffer\n+  local callback = function()\n+    -- Save and set context (NOTE: triggers `OptionSet` event)\n+    local cache = { bo = {}, env = {}, go = {}, wo = {} } ---@type table<string, any>\n+\n+    -- Use specific order from possibly most to least intrusive\n+    for _, scope in ipairs(scope_order) do\n+      for name, context_value in pairs(context[scope] or {}) do\n+        local sc = scope == 'o' and scope_map[vim.api.nvim_get_option_info2(name, {}).scope]\n+          or scope\n+\n+        -- Do not override already set cache and fall back to `vim.NIL` to\n+        -- cache `nil` values (which needs restoring later)\n+        cache[sc][name] = cache[sc][name] or vim[sc][name] or vim.NIL",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1649699758",
            "id": 1649699758,
            "in_reply_to_id": 1649689346,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5iVGuu",
            "original_commit_id": "1632da853646e4736021bc28d7baa05ab66854c2",
            "original_line": 1241,
            "original_position": 105,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2133811835,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649699758/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-22T13:32:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1649699758",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1650050013"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1650050013"
                }
            },
            "author_association": "MEMBER",
            "body": "Ah ok, that clears things up a bit. Hmm, yeah I can't come up with a simpler approach for the time being. Let's go with this 👍 ",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-23T11:25:00Z",
            "diff_hunk": "@@ -1192,29 +1221,60 @@ function vim._with(context, f)\n     if not vim.api.nvim_win_is_valid(context.win) then\n       error('Invalid window id: ' .. context.win)\n     end\n+    -- TODO: Maybe allow it?\n+    if context.buf and vim.api.nvim_win_get_buf(context.win) ~= context.buf then\n+      error('Can not set both `buf` and `win` context.')\n+    end\n   end\n \n-  -- Store original options\n-  local previous_options ---@type table<string, any>\n-  if context.options then\n-    previous_options = {}\n-    for k, v in pairs(context.options) do\n-      previous_options[k] =\n-        vim.api.nvim_get_option_value(k, { win = context.win, buf = context.buf })\n-      vim.api.nvim_set_option_value(k, v, { win = context.win, buf = context.buf })\n+  -- Decorate so that save-set-restore options is done in correct window-buffer\n+  local callback = function()\n+    -- Save and set context (NOTE: triggers `OptionSet` event)\n+    local cache = { bo = {}, env = {}, go = {}, wo = {} } ---@type table<string, any>\n+\n+    -- Use specific order from possibly most to least intrusive\n+    for _, scope in ipairs(scope_order) do",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1650050013",
            "id": 1650050013,
            "in_reply_to_id": 1649691610,
            "line": 1273,
            "node_id": "PRRC_kwDOAPphoM5iWcPd",
            "original_commit_id": "1632da853646e4736021bc28d7baa05ab66854c2",
            "original_line": 1273,
            "original_position": 98,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": 141,
            "pull_request_review_id": 2134252308,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1650050013/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-23T11:25:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1650050013",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1650086340"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1650086340"
                }
            },
            "author_association": "MEMBER",
            "body": "I've recently had a realization that if there is a misplaced option scope (like `{ bo = { winblend = 10 } }`), then the approach of \"cache and set\" inside same double loop would not properly restore already set context values (due to error during `vim.bo.winblend = 10`). So I indeed had to separate `get_context_state()` into a separate function (with brief description of what it does).",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-23T14:18:27Z",
            "diff_hunk": "@@ -1151,34 +1154,70 @@ end\n --- @field keeppatterns? boolean\n --- @field lockmarks? boolean\n --- @field noautocmd? boolean\n---- @field options? table<string, any>\n+--- @field o? table<string, any>\n --- @field sandbox? boolean\n --- @field silent? boolean\n --- @field unsilent? boolean\n --- @field win? integer\n+--- @field wo? table<string, any>\n+\n+local save_set_context = function(context)",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1650086340",
            "id": 1650086340,
            "in_reply_to_id": 1645868635,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5iWlHE",
            "original_commit_id": "8b208ff644a072042652b63f1e2dd6058071dff4",
            "original_line": 1164,
            "original_position": 24,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2134291181,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1650086340/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-23T14:18:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1650086340",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1651185334"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1651185334"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n--- Gets data about current state, enough to properly restore specified options/env/etc.\r\n```",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-24T14:56:49Z",
            "diff_hunk": "@@ -1141,44 +1141,105 @@ end\n \n --- @nodoc\n --- @class vim.context.mods\n+--- @field bo? table<string, any>\n --- @field buf? integer\n --- @field emsg_silent? boolean\n+--- @field env? table<string, any>\n+--- @field go? table<string, any>\n --- @field hide? boolean\n---- @field horizontal? boolean\n --- @field keepalt? boolean\n --- @field keepjumps? boolean\n --- @field keepmarks? boolean\n --- @field keeppatterns? boolean\n --- @field lockmarks? boolean\n --- @field noautocmd? boolean\n---- @field options? table<string, any>\n+--- @field o? table<string, any>\n --- @field sandbox? boolean\n --- @field silent? boolean\n --- @field unsilent? boolean\n --- @field win? integer\n+--- @field wo? table<string, any>\n+\n+--- @nodoc\n+--- @class vim.context.state\n+--- @field bo? table<string, any>\n+--- @field env? table<string, any>\n+--- @field go? table<string, any>\n+--- @field wo? table<string, any>\n+\n+local scope_map = { buf = 'bo', global = 'go', win = 'wo' }\n+local scope_order = { 'o', 'wo', 'bo', 'go', 'env' }\n+local state_restore_order = { 'bo', 'wo', 'go', 'env' }\n+\n+--- Get data about current state, enough to properly undo later context setting",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1651185334",
            "id": 1651185334,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5iaxa2",
            "original_commit_id": "15b5f2fc957a8ad3a21e52d455e7ee157e5c53b3",
            "original_line": 1174,
            "original_position": 36,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2136058439,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1651185334/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-24T14:56:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1651185334",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1651190086"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1651190086"
                }
            },
            "author_association": "MEMBER",
            "body": "we are fairly consistent about using `assert_` prefix for test assertions (except eq/matches/ok).\r\n\r\n```suggestion\r\n    local assert_context = function(bad_context, expected_type)\r\n```",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-24T15:00:01Z",
            "diff_hunk": "@@ -7,286 +7,1620 @@ local api = n.api\n local command = n.command\n local eq = t.eq\n local exec_lua = n.exec_lua\n+local exec_capture = n.exec_capture\n local matches = t.matches\n local pcall_err = t.pcall_err\n \n-before_each(function()\n-  n.clear()\n-end)\n+describe('vim._with', function()\n+  before_each(function()\n+    n.clear()\n+    exec_lua([[\n+      _G.fn = vim.fn\n+      _G.api = vim.api\n \n-describe('vim._with {buf = }', function()\n-  it('does not trigger autocmd', function()\n-    exec_lua [[\n-      local new = vim.api.nvim_create_buf(false, true)\n-      vim.api.nvim_create_autocmd( { 'BufEnter', 'BufLeave', 'BufWinEnter', 'BufWinLeave' }, {\n-        callback = function() _G.n = (_G.n or 0) + 1 end\n-      })\n-      vim._with({buf = new}, function()\n-      end)\n-      assert(_G.n == nil)\n-    ]]\n+      _G.setup_buffers = function()\n+        return api.nvim_create_buf(false, true), api.nvim_get_current_buf()\n+      end\n+\n+      _G.setup_windows = function()\n+        local other_win = api.nvim_get_current_win()\n+        vim.cmd.new()\n+        return other_win, api.nvim_get_current_win()\n+      end\n+    ]])\n   end)\n \n-  it('trigger autocmd if changed within context', function()\n-    exec_lua [[\n-      local new = vim.api.nvim_create_buf(false, true)\n-      vim.api.nvim_create_autocmd( { 'BufEnter', 'BufLeave', 'BufWinEnter', 'BufWinLeave' }, {\n-        callback = function() _G.n = (_G.n or 0) + 1 end\n-      })\n-      vim._with({}, function()\n-        vim.api.nvim_set_current_buf(new)\n-        assert(_G.n ~= nil)\n+  local validate_events_trigger = function()\n+    local out = exec_lua [[\n+      -- Needs three global values defined:\n+      -- - `test_events` - array of events which are tested.\n+      -- - `test_context` - context to be tested.\n+      -- - `test_trig_event` - callable triggering at least one tested event.\n+      _G.n_events = 0\n+      local opts = { callback = function() _G.n_events = _G.n_events + 1 end }\n+      api.nvim_create_autocmd(_G.test_events, opts)\n+\n+      local context = { bo = { commentstring = '-- %s' } }\n+\n+      -- Should not trigger events on its own\n+      vim._with(_G.test_context, function() end)\n+      local is_no_events = _G.n_events == 0\n+\n+      -- Should trigger events if specifically asked inside callback\n+      local is_events = vim._with(_G.test_context, function()\n+        _G.test_trig_event()\n+        return _G.n_events > 0\n       end)\n+      return { is_no_events, is_events }\n     ]]\n+    eq({ true, true }, out)\n+  end\n+\n+  describe('`bo` context', function()\n+    before_each(function()\n+      exec_lua [[\n+        _G.other_buf, _G.cur_buf = setup_buffers()\n+\n+        -- 'commentstring' is local to buffer and string\n+        vim.bo[other_buf].commentstring = '## %s'\n+        vim.bo[cur_buf].commentstring = '// %s'\n+        vim.go.commentstring = '$$ %s'\n+\n+        -- 'undolevels' is global or local to buffer (global-local) and number\n+        vim.bo[other_buf].undolevels = 100\n+        vim.bo[cur_buf].undolevels = 250\n+        vim.go.undolevels = 500\n+\n+        _G.get_state = function()\n+          return {\n+            bo = {\n+              cms_cur = vim.bo[cur_buf].commentstring,\n+              cms_other = vim.bo[other_buf].commentstring,\n+              ul_cur = vim.bo[cur_buf].undolevels,\n+              ul_other = vim.bo[other_buf].undolevels,\n+            },\n+            go = {\n+              cms = vim.go.commentstring,\n+              ul = vim.go.undolevels,\n+            },\n+          }\n+        end\n+      ]]\n+    end)\n+\n+    it('works', function()\n+      local out = exec_lua [[\n+        local context = { bo = { commentstring = '-- %s', undolevels = 0 } }\n+\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_buf() == cur_buf)\n+          return get_state()\n+        end)\n+\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms_cur = '-- %s', cms_other = '## %s', ul_cur = 0, ul_other = 100 },\n+        go = { cms = '$$ %s', ul = 500 },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('sets options in `buf` context', function()\n+      local out = exec_lua [[\n+        local context = { buf = other_buf, bo = { commentstring = '-- %s', undolevels = 0 } }\n+\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_buf() == other_buf)\n+          return get_state()\n+        end)\n+\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms_cur = '// %s', cms_other = '-- %s', ul_cur = 250, ul_other = 0 },\n+        go = { cms = '$$ %s', ul = 500 },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('restores only options from context', function()\n+      local out = exec_lua [[\n+        local context = { bo = { commentstring = '-- %s' } }\n+\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_buf() == cur_buf)\n+          vim.bo[cur_buf].undolevels = 750\n+          vim.bo[cur_buf].commentstring = '!! %s'\n+          return get_state()\n+        end)\n+\n+        return { inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms_cur = '!! %s', cms_other = '## %s', ul_cur = 750, ul_other = 100 },\n+        go = { cms = '$$ %s', ul = 500 },\n+      }, out.inner)\n+      eq({\n+        bo = { cms_cur = '// %s', cms_other = '## %s', ul_cur = 750, ul_other = 100 },\n+        go = { cms = '$$ %s', ul = 500 },\n+      }, out.after)\n+    end)\n+\n+    it('does not trigger events', function()\n+      exec_lua [[\n+        _G.test_events = { 'BufEnter', 'BufLeave', 'BufWinEnter', 'BufWinLeave' }\n+        _G.test_context = { bo = { commentstring = '-- %s' } }\n+        _G.test_trig_event = function() vim.cmd.new() end\n+      ]]\n+      validate_events_trigger()\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        local before, before_inner, after_inner = get_state(), nil, nil\n+        vim._with({ bo = { commentstring = '-- %s', undolevels = 0 } }, function()\n+          before_inner = get_state()\n+          inner = vim._with({ bo = { commentstring = '!! %s' } }, get_state)\n+          after_inner = get_state()\n+        end)\n+        return {\n+          before = before, before_inner = before_inner,\n+          inner = inner,\n+          after_inner = after_inner, after = get_state(),\n+        }\n+      ]]\n+      eq('!! %s', out.inner.bo.cms_cur)\n+      eq(0, out.inner.bo.ul_cur)\n+      eq(out.before_inner, out.after_inner)\n+      eq(out.before, out.after)\n+    end)\n   end)\n \n-  it('can access buf options', function()\n-    local buf1 = api.nvim_get_current_buf()\n-    local buf2 = exec_lua [[\n-      buf2 = vim.api.nvim_create_buf(false, true)\n-      return buf2\n-    ]]\n+  describe('`buf` context', function()\n+    it('works', function()\n+      local out = exec_lua [[\n+        local other_buf, cur_buf = setup_buffers()\n+        local inner = vim._with({ buf = other_buf }, function()\n+          return api.nvim_get_current_buf()\n+        end)\n+        return { inner == other_buf, api.nvim_get_current_buf() == cur_buf }\n+      ]]\n+      eq({ true, true }, out)\n+    end)\n+\n+    it('does not trigger events', function()\n+      exec_lua [[\n+        _G.test_events = { 'BufEnter', 'BufLeave', 'BufWinEnter', 'BufWinLeave' }\n+        _G.test_context = { buf = other_buf }\n+        _G.test_trig_event = function() vim.cmd.new() end\n+      ]]\n+      validate_events_trigger()\n+    end)\n \n-    eq(false, api.nvim_get_option_value('autoindent', { buf = buf1 }))\n-    eq(false, api.nvim_get_option_value('autoindent', { buf = buf2 }))\n+    it('can access buffer options', function()\n+      local out = exec_lua [[\n+        other_buf, cur_buf = setup_buffers()\n+        vim.bo[other_buf].commentstring = '## %s'\n+        vim.bo[cur_buf].commentstring = '// %s'\n \n-    local val = exec_lua [[\n-      return vim._with({buf = buf2}, function()\n-        vim.cmd \"set autoindent\"\n-        return vim.api.nvim_get_current_buf()\n+        vim._with({ buf = other_buf }, function()\n+          vim.cmd.set('commentstring=--\\\\ %s')\n+        end)\n+\n+        return vim.bo[other_buf].commentstring == '-- %s' and\n+          vim.bo[cur_buf].commentstring == '// %s'\n+      ]]\n+      eq(true, out)\n+    end)\n+\n+    it('works with different kinds of buffers', function()\n+      exec_lua [[\n+        local validate = function(buf)\n+          vim._with({ buf = buf }, function()\n+            assert(api.nvim_get_current_buf() == buf)\n+          end)\n+        end\n+\n+        -- Current\n+        validate(api.nvim_get_current_buf())\n+\n+        -- Hidden listed\n+        local listed = api.nvim_create_buf(true, true)\n+        validate(listed)\n+\n+        -- Visible\n+        local other_win, cur_win = setup_windows()\n+        api.nvim_win_set_buf(other_win, listed)\n+        validate(listed)\n+\n+        -- Shown but not visible\n+        vim.cmd.tabnew()\n+        validate(listed)\n+\n+        -- Shown in several windows\n+        api.nvim_win_set_buf(0, listed)\n+        validate(listed)\n+\n+        -- Shown in floating window\n+        local float_buf = api.nvim_create_buf(false, true)\n+        local config = { relative = 'editor', row = 1, col = 1, width = 5, height = 5 }\n+        api.nvim_open_win(float_buf, false, config)\n+        validate(float_buf)\n+      ]]\n+    end)\n+\n+    it('does not cause ml_get errors with invalid visual selection', function()\n+      exec_lua [[\n+        api.nvim_buf_set_lines(0, 0, -1, true, { 'a', 'b', 'c' })\n+        api.nvim_feedkeys(vim.keycode('G<C-V>'), 'txn', false)\n+        local other_buf, _ = setup_buffers()\n+        vim._with({ buf = buf }, function() vim.cmd.redraw() end)\n+      ]]\n+    end)\n+\n+    it('can be nested', function()\n+      exec_lua [[\n+        local other_buf, cur_buf = setup_buffers()\n+        vim._with({ buf = other_buf }, function()\n+          assert(api.nvim_get_current_buf() == other_buf)\n+          inner = vim._with({ buf = cur_buf }, function()\n+            assert(api.nvim_get_current_buf() == cur_buf)\n+          end)\n+          assert(api.nvim_get_current_buf() == other_buf)\n+        end)\n+        assert(api.nvim_get_current_buf() == cur_buf)\n+      ]]\n     end)\n-    ]]\n \n-    eq(false, api.nvim_get_option_value('autoindent', { buf = buf1 }))\n-    eq(true, api.nvim_get_option_value('autoindent', { buf = buf2 }))\n-    eq(buf1, api.nvim_get_current_buf())\n-    eq(buf2, val)\n+    it('can be nested crazily with hidden buffers', function()\n+      local out = exec_lua([[\n+        local n = 0\n+        local function with_recursive_nested_bufs()\n+          n = n + 1\n+          if n > 20 then return true end\n+\n+          local other_buf, _ = setup_buffers()\n+          vim.bo[other_buf].commentstring = '## %s'\n+          local callback = function()\n+            return api.nvim_get_current_buf() == other_buf\n+              and vim.bo[other_buf].commentstring == '## %s'\n+              and with_recursive_nested_bufs()\n+          end\n+          return vim._with({ buf = other_buf }, callback) and\n+            api.nvim_buf_delete(other_buf, {}) == nil\n+        end\n+\n+        return with_recursive_nested_bufs()\n+      ]])\n+      eq(true, out)\n+    end)\n   end)\n \n-  it('does not cause ml_get errors with invalid visual selection', function()\n-    exec_lua [[\n-      local api = vim.api\n-      local t = function(s) return api.nvim_replace_termcodes(s, true, true, true) end\n-      api.nvim_buf_set_lines(0, 0, -1, true, {\"a\", \"b\", \"c\"})\n-      api.nvim_feedkeys(t \"G<C-V>\", \"txn\", false)\n-      vim._with({buf = api.nvim_create_buf(false, true)}, function() vim.cmd \"redraw\" end)\n-    ]]\n+  describe('`emsg_silent` context', function()\n+    pending('works', function()\n+      local ok = pcall(\n+        exec_lua,\n+        [[\n+          _G.f = function()\n+            error('This error should not interfer with execution', 0)\n+          end\n+          -- Should not produce error same as `vim.cmd('silent! lua _G.f()')`\n+          vim._with({ emsg_silent = true }, f)\n+        ]]\n+      )\n+      eq(true, ok)\n+\n+      -- Should properly report errors afterwards\n+      ok = pcall(exec_lua, 'lua _G.f()')\n+      eq(false, ok)\n+    end)\n+\n+    it('can be nested', function()\n+      local ok = pcall(\n+        exec_lua,\n+        [[\n+          _G.f = function()\n+            error('This error should not interfer with execution', 0)\n+          end\n+          -- Should produce error same as `_G.f()`\n+          vim._with({ emsg_silent = true }, function()\n+            vim._with( { emsg_silent = false }, f)\n+          end)\n+        ]]\n+      )\n+      eq(false, ok)\n+    end)\n   end)\n \n-  it('can be nested crazily with hidden buffers', function()\n-    eq(\n-      true,\n-      exec_lua([[\n-      local function scratch_buf_call(fn)\n-        local buf = vim.api.nvim_create_buf(false, true)\n-        vim.api.nvim_set_option_value('cindent', true, {buf = buf})\n-        return vim._with({buf = buf}, function()\n-          return vim.api.nvim_get_current_buf() == buf\n-            and vim.api.nvim_get_option_value('cindent', {buf = buf})\n-            and fn()\n-      end) and vim.api.nvim_buf_delete(buf, {}) == nil\n+  describe('`env` context', function()\n+    before_each(function()\n+      exec_lua [[\n+        vim.fn.setenv('aaa', 'hello')\n+        _G.get_state = function()\n+          return { aaa = vim.fn.getenv('aaa'), bbb = vim.fn.getenv('bbb') }\n+        end\n+      ]]\n+    end)\n+\n+    it('works', function()\n+      local out = exec_lua [[\n+        local context = { env = { aaa = 'inside', bbb = 'wow' } }\n+        local before = get_state()\n+        local inner = vim._with(context, get_state)\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({ aaa = 'inside', bbb = 'wow' }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('restores only variables from context', function()\n+      local out = exec_lua [[\n+        local context = { env = { bbb = 'wow' } }\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          vim.env.aaa = 'inside'\n+          return get_state()\n+        end)\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({ aaa = 'inside', bbb = 'wow' }, out.inner)\n+      eq({ aaa = 'inside', bbb = vim.NIL }, out.after)\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        local before, before_inner, after_inner = get_state(), nil, nil\n+        vim._with({ env = { aaa = 'inside', bbb = 'wow' } }, function()\n+          before_inner = get_state()\n+          inner = vim._with({ env = { aaa = 'more inside' } }, get_state)\n+          after_inner = get_state()\n+        end)\n+        return {\n+          before = before, before_inner = before_inner,\n+          inner = inner,\n+          after_inner = after_inner, after = get_state(),\n+        }\n+      ]]\n+      eq('more inside', out.inner.aaa)\n+      eq('wow', out.inner.bbb)\n+      eq(out.before_inner, out.after_inner)\n+      eq(out.before, out.after)\n+    end)\n+  end)\n+\n+  describe('`go` context', function()\n+    before_each(function()\n+      exec_lua [[\n+        vim.bo.commentstring = '## %s'\n+        vim.go.commentstring = '$$ %s'\n+        vim.wo.winblend = 25\n+        vim.go.winblend = 50\n+        vim.go.langmap = 'xy,yx'\n+\n+        _G.get_state = function()\n+          return {\n+            bo = { cms = vim.bo.commentstring },\n+            wo = { winbl = vim.wo.winblend },\n+            go = {\n+              cms = vim.go.commentstring,\n+              winbl = vim.go.winblend,\n+              lmap = vim.go.langmap,\n+            },\n+          }\n+        end\n+      ]]\n+    end)\n+\n+    it('works', function()\n+      local out = exec_lua [[\n+        local context = {\n+          go = { commentstring = '-- %s', winblend = 75, langmap = 'ab,ba' },\n+        }\n+        local before = get_state()\n+        local inner = vim._with(context, get_state)\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms = '## %s' },\n+        wo = { winbl = 25 },\n+        go = { cms = '-- %s', winbl = 75, lmap = 'ab,ba' },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('works with `eventignore`', function()\n+      -- This might be an issue if saving and restoring option context is done\n+      -- to account for triggering `OptionSet`, but in not a good way\n+      local out = exec_lua [[\n+        vim.go.eventignore = 'ModeChanged'\n+        local inner = vim._with({ go = { eventignore = 'CursorMoved' } }, function()\n+          return vim.go.eventignore\n+        end)\n+        return { inner = inner, after = vim.go.eventignore }\n+      ]]\n+      eq({ inner = 'CursorMoved', after = 'ModeChanged' }, out)\n+    end)\n+\n+    it('restores only options from context', function()\n+      local out = exec_lua [[\n+        local context = { go = { langmap = 'ab,ba' } }\n+\n+        local inner = vim._with(context, function()\n+          vim.go.commentstring = '!! %s'\n+          vim.go.winblend = 75\n+          vim.go.langmap = 'uv,vu'\n+          return get_state()\n+        end)\n+\n+        return { inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms = '## %s' },\n+        wo = { winbl = 25 },\n+        go = { cms = '!! %s', winbl = 75, lmap = 'uv,vu' },\n+      }, out.inner)\n+      eq({\n+        bo = { cms = '## %s' },\n+        wo = { winbl = 25 },\n+        go = { cms = '!! %s', winbl = 75, lmap = 'xy,yx' },\n+      }, out.after)\n+    end)\n+\n+    it('does not trigger events', function()\n+      exec_lua [[\n+        _G.test_events = {\n+          'BufEnter', 'BufLeave', 'BufWinEnter', 'BufWinLeave', 'WinEnter', 'WinLeave'\n+        }\n+        _G.test_context = { go = { commentstring = '-- %s', winblend = 75, langmap = 'ab,ba' } }\n+        _G.test_trig_event = function() vim.cmd.new() end\n+      ]]\n+      validate_events_trigger()\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        local before, before_inner, after_inner = get_state(), nil, nil\n+        vim._with({ go = { langmap = 'ab,ba', commentstring = '-- %s' } }, function()\n+          before_inner = get_state()\n+          inner = vim._with({ go = { langmap = 'uv,vu' } }, get_state)\n+          after_inner = get_state()\n+        end)\n+        return {\n+          before = before, before_inner = before_inner,\n+          inner = inner,\n+          after_inner = after_inner, after = get_state(),\n+        }\n+      ]]\n+      eq('uv,vu', out.inner.go.lmap)\n+      eq('-- %s', out.inner.go.cms)\n+      eq(out.before_inner, out.after_inner)\n+      eq(out.before, out.after)\n+    end)\n+  end)\n+\n+  describe('`hide` context', function()\n+    pending('works', function()\n+      local ok = pcall(\n+        exec_lua,\n+        [[\n+          vim.o.hidden = false\n+          vim.bo.modified = true\n+          local init_buf = api.nvim_get_current_buf()\n+          -- Should not produce error same as `vim.cmd('hide enew')`\n+          vim._with({ hide = true }, function()\n+            vim.cmd.enew()\n+          end)\n+          assert(api.nvim_get_current_buf() ~= init_buf)\n+        ]]\n+      )\n+      eq(true, ok)\n+    end)\n+\n+    it('can be nested', function()\n+      local ok = pcall(\n+        exec_lua,\n+        [[\n+          vim.o.hidden = false\n+          vim.bo.modified = true\n+          -- Should produce error same as `vim.cmd.enew()`\n+          vim._with({ hide = true }, function()\n+            vim._with({ hide = false }, function()\n+              vim.cmd.enew()\n+            end)\n+          end)\n+        ]]\n+      )\n+      eq(false, ok)\n+    end)\n+  end)\n+\n+  describe('`horizontal` context', function()\n+    local is_approx_eq = function(dim, id_1, id_2)\n+      local f = dim == 'height' and api.nvim_win_get_height or api.nvim_win_get_width\n+      return math.abs(f(id_1) - f(id_2)) <= 1\n     end\n \n-    return scratch_buf_call(function()\n-      return scratch_buf_call(function()\n-        return scratch_buf_call(function()\n-          return scratch_buf_call(function()\n-            return scratch_buf_call(function()\n-              return scratch_buf_call(function()\n-                return scratch_buf_call(function()\n-                  return scratch_buf_call(function()\n-                    return scratch_buf_call(function()\n-                      return scratch_buf_call(function()\n-                        return scratch_buf_call(function()\n-                          return scratch_buf_call(function()\n-                            return true\n-                          end)\n-                        end)\n-                      end)\n-                    end)\n-                  end)\n-                end)\n-              end)\n+    local win_id_1, win_id_2, win_id_3\n+    before_each(function()\n+      win_id_1 = api.nvim_get_current_win()\n+      command('wincmd v | wincmd 5>')\n+      win_id_2 = api.nvim_get_current_win()\n+      command('wincmd s | wincmd 5+')\n+      win_id_3 = api.nvim_get_current_win()\n+\n+      eq(is_approx_eq('width', win_id_1, win_id_2), false)\n+      eq(is_approx_eq('height', win_id_3, win_id_2), false)\n+    end)\n+\n+    pending('works', function()\n+      exec_lua [[\n+        -- Should be same as `vim.cmd('horizontal wincmd =')`\n+        vim._with({ horizontal = true }, function()\n+          vim.cmd.wincmd('=')\n+        end)\n+      ]]\n+      eq(is_approx_eq('width', win_id_1, win_id_2), true)\n+      eq(is_approx_eq('height', win_id_3, win_id_2), false)\n+    end)\n+\n+    pending('can be nested', function()\n+      exec_lua [[\n+        -- Should be same as `vim.cmd.wincmd('=')`\n+        vim._with({ horizontal = true }, function()\n+          vim._with({ horizontal = false }, function()\n+            vim.cmd.wincmd('=')\n+          end)\n+        end)\n+      ]]\n+      eq(is_approx_eq('width', win_id_1, win_id_2), true)\n+      eq(is_approx_eq('height', win_id_3, win_id_2), true)\n+    end)\n+  end)\n+\n+  describe('`keepalt` context', function()\n+    pending('works', function()\n+      local out = exec_lua [[\n+        vim.cmd('edit alt')\n+        vim.cmd('edit new')\n+        assert(fn.bufname('#') == 'alt')\n+\n+        -- Should work as `vim.cmd('keepalt edit very-new')`\n+        vim._with({ keepalt = true }, function()\n+          vim.cmd.edit('very-new')\n+        end)\n+        return fn.bufname('#') == 'alt'\n+      ]]\n+      eq(true, out)\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        vim.cmd('edit alt')\n+        vim.cmd('edit new')\n+        assert(fn.bufname('#') == 'alt')\n+\n+        -- Should work as `vim.cmd.edit('very-new')`\n+        vim._with({ keepalt = true }, function()\n+          vim._with({ keepalt = false }, function()\n+            vim.cmd.edit('very-new')\n+          end)\n+        end)\n+        return fn.bufname('#') == 'alt'\n+      ]]\n+      eq(false, out)\n+    end)\n+  end)\n+\n+  describe('`keepjumps` context', function()\n+    pending('works', function()\n+      local out = exec_lua [[\n+        api.nvim_buf_set_lines(0, 0, -1, false, { 'aaa', 'bbb', 'ccc' })\n+        local jumplist_before = fn.getjumplist()\n+        -- Should work as `vim.cmd('keepjumps normal! Ggg')`\n+        vim._with({ keepjumps = true }, function()\n+          vim.cmd('normal! Ggg')\n+        end)\n+        return vim.deep_equal(jumplist_before, fn.getjumplist())\n+      ]]\n+      eq(true, out)\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        api.nvim_buf_set_lines(0, 0, -1, false, { 'aaa', 'bbb', 'ccc' })\n+        local jumplist_before = fn.getjumplist()\n+        vim._with({ keepjumps = true }, function()\n+          vim._with({ keepjumps = false }, function()\n+            vim.cmd('normal! Ggg')\n+          end)\n+        end)\n+        return vim.deep_equal(jumplist_before, fn.getjumplist())\n+      ]]\n+      eq(false, out)\n+    end)\n+  end)\n+\n+  describe('`keepmarks` context', function()\n+    pending('works', function()\n+      local out = exec_lua [[\n+        vim.cmd('set cpoptions+=R')\n+        api.nvim_buf_set_lines(0, 0, -1, false, { 'bbb', 'ccc', 'aaa' })\n+        api.nvim_buf_set_mark(0, 'm', 2, 2, {})\n+\n+        -- Should be the same as `vim.cmd('keepmarks %!sort')`\n+        vim._with({ keepmarks = true }, function()\n+          vim.cmd('%!sort')\n+        end)\n+        return api.nvim_buf_get_mark(0, 'm')\n+      ]]\n+      eq({ 2, 2 }, out)\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        vim.cmd('set cpoptions+=R')\n+        api.nvim_buf_set_lines(0, 0, -1, false, { 'bbb', 'ccc', 'aaa' })\n+        api.nvim_buf_set_mark(0, 'm', 2, 2, {})\n+\n+        vim._with({ keepmarks = true }, function()\n+          vim._with({ keepmarks = false }, function()\n+            vim.cmd('%!sort')\n+          end)\n+        end)\n+        return api.nvim_buf_get_mark(0, 'm')\n+      ]]\n+      eq({ 0, 2 }, out)\n+    end)\n+  end)\n+\n+  describe('`keepatterns` context', function()\n+    pending('works', function()\n+      local out = exec_lua [[\n+        api.nvim_buf_set_lines(0, 0, -1, false, { 'aaa', 'bbb' })\n+        vim.cmd('/aaa')\n+        -- Should be the same as `vim.cmd('keeppatterns /bbb')`\n+        vim._with({ keeppatterns = true }, function()\n+          vim.cmd('/bbb')\n+        end)\n+        return fn.getreg('/')\n+      ]]\n+      eq('aaa', out)\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        api.nvim_buf_set_lines(0, 0, -1, false, { 'aaa', 'bbb' })\n+        vim.cmd('/aaa')\n+        vim._with({ keeppatterns = true }, function()\n+          vim._with({ keeppatterns = false }, function()\n+            vim.cmd('/bbb')\n+          end)\n+        end)\n+        return fn.getreg('/')\n+      ]]\n+      eq('bbb', out)\n+    end)\n+  end)\n+\n+  describe('`lockmarks` context', function()\n+    it('works', function()\n+      local mark = exec_lua [[\n+        api.nvim_buf_set_lines(0, 0, 0, false, { 'aaa', 'bbb', 'ccc' })\n+        api.nvim_buf_set_mark(0, 'm', 2, 2, {})\n+        -- Should be same as `:lockmarks lua api.nvim_buf_set_lines(...)`\n+        vim._with({ lockmarks = true }, function()\n+          api.nvim_buf_set_lines(0, 0, 2, false, { 'uuu', 'vvv', 'www' })\n+        end)\n+        return api.nvim_buf_get_mark(0, 'm')\n+      ]]\n+      eq({ 2, 2 }, mark)\n+    end)\n+\n+    it('can be nested', function()\n+      local mark = exec_lua [[\n+        api.nvim_buf_set_lines(0, 0, 0, false, { 'aaa', 'bbb', 'ccc' })\n+        api.nvim_buf_set_mark(0, 'm', 2, 2, {})\n+        vim._with({ lockmarks = true }, function()\n+          vim._with({ lockmarks = false }, function()\n+            api.nvim_buf_set_lines(0, 0, 2, false, { 'uuu', 'vvv', 'www' })\n+          end)\n+        end)\n+        return api.nvim_buf_get_mark(0, 'm')\n+      ]]\n+      eq({ 0, 2 }, mark)\n+    end)\n+  end)\n+\n+  describe('`noautocmd` context', function()\n+    it('works', function()\n+      local out = exec_lua [[\n+        _G.n_events = 0\n+        vim.cmd('au ModeChanged * lua _G.n_events = _G.n_events + 1')\n+        -- Should be the same as `vim.cmd('noautocmd normal! vv')`\n+        vim._with({ noautocmd = true }, function()\n+          vim.cmd('normal! vv')\n+        end)\n+        return _G.n_events\n+      ]]\n+      eq(0, out)\n+    end)\n+\n+    it('works with User events', function()\n+      local out = exec_lua [[\n+        _G.n_events = 0\n+        vim.cmd('au User MyEvent lua _G.n_events = _G.n_events + 1')\n+        -- Should be the same as `vim.cmd('noautocmd doautocmd User MyEvent')`\n+        vim._with({ noautocmd = true }, function()\n+          api.nvim_exec_autocmds('User', { pattern = 'MyEvent' })\n+        end)\n+        return _G.n_events\n+      ]]\n+      eq(0, out)\n+    end)\n+\n+    pending('can be nested', function()\n+      local out = exec_lua [[\n+        _G.n_events = 0\n+        vim.cmd('au ModeChanged * lua _G.n_events = _G.n_events + 1')\n+        vim._with({ noautocmd = true }, function()\n+          vim._with({ noautocmd = false }, function()\n+            vim.cmd('normal! vv')\n+          end)\n+        end)\n+        return _G.n_events\n+      ]]\n+      eq(2, out)\n+    end)\n+  end)\n+\n+  describe('`o` context', function()\n+    before_each(function()\n+      exec_lua [[\n+        _G.other_win, _G.cur_win = setup_windows()\n+        _G.other_buf, _G.cur_buf = setup_buffers()\n+\n+        vim.bo[other_buf].commentstring = '## %s'\n+        vim.bo[cur_buf].commentstring = '// %s'\n+        vim.go.commentstring = '$$ %s'\n+\n+        vim.bo[other_buf].undolevels = 100\n+        vim.bo[cur_buf].undolevels = 250\n+        vim.go.undolevels = 500\n+\n+        vim.wo[other_win].virtualedit = 'block'\n+        vim.wo[cur_win].virtualedit = 'insert'\n+        vim.go.virtualedit = 'none'\n+\n+        vim.wo[other_win].winblend = 10\n+        vim.wo[cur_win].winblend = 25\n+        vim.go.winblend = 50\n+\n+        vim.go.langmap = 'xy,yx'\n+\n+        _G.get_state = function()\n+          return {\n+            bo = {\n+              cms_cur = vim.bo[cur_buf].commentstring,\n+              cms_other = vim.bo[other_buf].commentstring,\n+              ul_cur = vim.bo[cur_buf].undolevels,\n+              ul_other = vim.bo[other_buf].undolevels,\n+            },\n+            wo = {\n+              ve_cur = vim.wo[cur_win].virtualedit,\n+              ve_other = vim.wo[other_win].virtualedit,\n+              winbl_cur = vim.wo[cur_win].winblend,\n+              winbl_other = vim.wo[other_win].winblend,\n+            },\n+            go = {\n+              cms = vim.go.commentstring,\n+              ul = vim.go.undolevels,\n+              ve = vim.go.virtualedit,\n+              winbl = vim.go.winblend,\n+              lmap = vim.go.langmap,\n+            },\n+          }\n+        end\n+      ]]\n+    end)\n+\n+    it('works', function()\n+      local out = exec_lua [[\n+        local context = {\n+          o = {\n+            commentstring = '-- %s',\n+            undolevels = 0,\n+            virtualedit = 'all',\n+            winblend = 75,\n+            langmap = 'ab,ba',\n+          },\n+        }\n+\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_buf() == cur_buf)\n+          assert(api.nvim_get_current_win() == cur_win)\n+          return get_state()\n+        end)\n+\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      -- Options in context are set with `vim.o`, so usually both local\n+      -- and global values are affected. Yet all of them should be later\n+      -- restored to pre-context values.\n+      eq({\n+        bo = { cms_cur = '-- %s', cms_other = '## %s', ul_cur = -123456, ul_other = 100 },\n+        wo = { ve_cur = 'all', ve_other = 'block', winbl_cur = 75, winbl_other = 10 },\n+        go = { cms = '-- %s', ul = 0, ve = 'all', winbl = 75, lmap = 'ab,ba' },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('sets options in `buf` context', function()\n+      local out = exec_lua [[\n+        local context = { buf = other_buf, o = { commentstring = '-- %s', undolevels = 0 } }\n+\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_buf() == other_buf)\n+          return get_state()\n+        end)\n+\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms_cur = '// %s', cms_other = '-- %s', ul_cur = 250, ul_other = -123456 },\n+        wo = { ve_cur = 'insert', ve_other = 'block', winbl_cur = 25, winbl_other = 10 },\n+        -- Global `winbl` inside context ideally should be untouched and equal\n+        -- to 50. It seems to be equal to 0 because `context.buf` uses\n+        -- `aucmd_prepbuf` C approach which has no guarantees about window or\n+        -- window option values inside context.\n+        go = { cms = '-- %s', ul = 0, ve = 'none', winbl = 0, lmap = 'xy,yx' },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('sets options in `win` context', function()\n+      local out = exec_lua [[\n+        local context = { win = other_win, o = { winblend = 75, virtualedit = 'all' } }\n+\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_win() == other_win)\n+          return get_state()\n+        end)\n+\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms_cur = '// %s', cms_other = '## %s', ul_cur = 250, ul_other = 100 },\n+        wo = { winbl_cur = 25, winbl_other = 75, ve_cur = 'insert', ve_other = 'all' },\n+        go = { cms = '$$ %s', ul = 500, winbl = 75, ve = 'all', lmap = 'xy,yx' },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('restores only options from context', function()\n+      local out = exec_lua [[\n+        local context = { o = { undolevels = 0, winblend = 75, langmap = 'ab,ba' } }\n+\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_buf() == cur_buf)\n+          assert(api.nvim_get_current_win() == cur_win)\n+\n+          vim.o.commentstring = '!! %s'\n+          vim.o.undolevels = 750\n+          vim.o.virtualedit = 'onemore'\n+          vim.o.winblend = 99\n+          vim.o.langmap = 'uv,vu'\n+          return get_state()\n+        end)\n+\n+        return { inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms_cur = '!! %s', cms_other = '## %s', ul_cur = -123456, ul_other = 100 },\n+        wo = { ve_cur = 'onemore', ve_other = 'block', winbl_cur = 99, winbl_other = 10 },\n+        go = { cms = '!! %s', ul = 750, ve = 'onemore', winbl = 99, lmap = 'uv,vu' },\n+      }, out.inner)\n+      eq({\n+        bo = { cms_cur = '!! %s', cms_other = '## %s', ul_cur = 250, ul_other = 100 },\n+        wo = { ve_cur = 'onemore', ve_other = 'block', winbl_cur = 25, winbl_other = 10 },\n+        go = { cms = '!! %s', ul = 500, ve = 'onemore', winbl = 50, lmap = 'xy,yx' },\n+      }, out.after)\n+    end)\n+\n+    it('does not trigger events', function()\n+      exec_lua [[\n+        _G.test_events = {\n+          'BufEnter', 'BufLeave', 'WinEnter', 'WinLeave', 'BufWinEnter', 'BufWinLeave'\n+        }\n+        _G.test_context = { o = { undolevels = 0, winblend = 75, langmap = 'ab,ba' } }\n+        _G.test_trig_event = function() vim.cmd.new() end\n+      ]]\n+      validate_events_trigger()\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        local before, before_inner, after_inner = get_state(), nil, nil\n+        local cxt_o = { commentstring = '-- %s', winblend = 75, langmap = 'ab,ba', undolevels = 0 }\n+        vim._with({ o = cxt_o }, function()\n+          before_inner = get_state()\n+          local inner_cxt_o = { commentstring = '!! %s', winblend = 99, langmap = 'uv,vu' }\n+          inner = vim._with({ o = inner_cxt_o }, get_state)\n+          after_inner = get_state()\n+        end)\n+        return {\n+          before = before, before_inner = before_inner,\n+          inner = inner,\n+          after_inner = after_inner, after = get_state(),\n+        }\n+      ]]\n+      eq('!! %s', out.inner.bo.cms_cur)\n+      eq(99, out.inner.wo.winbl_cur)\n+      eq('uv,vu', out.inner.go.lmap)\n+      eq(0, out.inner.go.ul)\n+      eq(out.before_inner, out.after_inner)\n+      eq(out.before, out.after)\n+    end)\n+  end)\n+\n+  describe('`sandbox` context', function()\n+    it('works', function()\n+      local ok, err = pcall(\n+        exec_lua,\n+        [[\n+          -- Should work as `vim.cmd('sandbox call append(0, \"aaa\")')`\n+          vim._with({ sandbox = true }, function()\n+            fn.append(0, 'aaa')\n+          end)\n+        ]]\n+      )\n+      eq(false, ok)\n+      matches('Not allowed in sandbox', err)\n+    end)\n+\n+    it('can NOT be nested', function()\n+      -- This behavior is intentionally different from other flags as allowing\n+      -- disabling `sandbox` from nested function seems to be against the point\n+      -- of using `sandbox` context in the first place\n+      local ok, err = pcall(\n+        exec_lua,\n+        [[\n+          vim._with({ sandbox = true }, function()\n+            vim._with({ sandbox = false }, function()\n+              fn.append(0, 'aaa')\n             end)\n           end)\n+        ]]\n+      )\n+      eq(false, ok)\n+      matches('Not allowed in sandbox', err)\n+    end)\n+  end)\n+\n+  describe('`silent` context', function()\n+    it('works', function()\n+      exec_lua [[\n+        -- Should be same as `vim.cmd('silent lua print(\"aaa\")')`\n+        vim._with({ silent = true }, function() print('aaa') end)\n+      ]]\n+      eq('', exec_capture('messages'))\n+\n+      exec_lua [[ vim._with({ silent = true }, function() vim.cmd.echomsg('\"bbb\"') end) ]]\n+      eq('', exec_capture('messages'))\n+\n+      local screen = Screen.new(20, 5)\n+      screen:set_default_attr_ids {\n+        [1] = { bold = true, reverse = true },\n+        [2] = { bold = true, foreground = Screen.colors.Blue },\n+      }\n+      screen:attach()\n+      exec_lua [[ vim._with({ silent = true }, function() vim.cmd.echo('\"ccc\"') end) ]]\n+      screen:expect [[\n+        ^                    |\n+        {2:~                   }|*3\n+                            |\n+      ]]\n+    end)\n+\n+    pending('can be nested', function()\n+      exec_lua [[ vim._with({ silent = true }, function()\n+        vim._with({ silent = false }, function()\n+          print('aaa')\n         end)\n-      end)\n+      end)]]\n+      eq('aaa', exec_capture('messages'))\n     end)\n-    ]])\n-    )\n   end)\n \n-  it('can return values by reference', function()\n-    eq(\n-      { 4, 7 },\n+  describe('`unsilent` context', function()\n+    it('works', function()\n       exec_lua [[\n-      local val = {4, 10}\n-      local ref = vim._with({ buf = 0}, function() return val end)\n-      ref[2] = 7\n-      return val\n-    ]]\n-    )\n+        _G.f = function()\n+          -- Should be same as `vim.cmd('unsilent lua print(\"aaa\")')`\n+          vim._with({ unsilent = true }, function() print('aaa') end)\n+        end\n+      ]]\n+      command('silent lua f()')\n+      eq('aaa', exec_capture('messages'))\n+    end)\n+\n+    pending('can be nested', function()\n+      exec_lua [[\n+        _G.f = function()\n+          vim._with({ unsilent = true }, function()\n+            vim._with({ unsilent = false }, function() print('aaa') end)\n+          end)\n+        end\n+      ]]\n+      command('silent lua f()')\n+      eq('', exec_capture('messages'))\n+    end)\n   end)\n-end)\n \n-describe('vim._with {win = }', function()\n-  it('does not trigger autocmd', function()\n-    exec_lua [[\n-      local old = vim.api.nvim_get_current_win()\n-      vim.cmd(\"new\")\n-      local new = vim.api.nvim_get_current_win()\n-      vim.api.nvim_create_autocmd( { 'WinEnter', 'WinLeave' }, {\n-        callback = function() _G.n = (_G.n or 0) + 1 end\n-      })\n-      vim._with({win = old}, function()\n-      end)\n-      assert(_G.n == nil)\n+  describe('`win` context', function()\n+    it('works', function()\n+      local out = exec_lua [[\n+        local other_win, cur_win = setup_windows()\n+        local inner = vim._with({ win = other_win }, function()\n+          return api.nvim_get_current_win()\n+        end)\n+        return { inner == other_win, api.nvim_get_current_win() == cur_win }\n+      ]]\n+      eq({ true, true }, out)\n+    end)\n+\n+    it('does not trigger events', function()\n+      exec_lua [[\n+        _G.test_events = { 'WinEnter', 'WinLeave', 'BufWinEnter', 'BufWinLeave' }\n+        _G.test_context = { win = other_win }\n+        _G.test_trig_event = function() vim.cmd.new() end\n+      ]]\n+      validate_events_trigger()\n+    end)\n+\n+    it('can access window options', function()\n+      local out = exec_lua [[\n+        local other_win, cur_win = setup_windows()\n+        vim.wo[other_win].winblend = 10\n+        vim.wo[cur_win].winblend = 25\n+\n+        vim._with({ win = other_win }, function()\n+          vim.cmd.setlocal('winblend=0')\n+        end)\n+\n+        return vim.wo[other_win].winblend == 0 and vim.wo[cur_win].winblend == 25\n+      ]]\n+      eq(true, out)\n+    end)\n+\n+    it('works with different kinds of windows', function()\n+      exec_lua [[\n+        local validate = function(win)\n+          vim._with({ win = win }, function()\n+            assert(api.nvim_get_current_win() == win)\n+          end)\n+        end\n+\n+        -- Current\n+        validate(api.nvim_get_current_win())\n+\n+        -- Not visible\n+        local other_win, cur_win = setup_windows()\n+        vim.cmd.tabnew()\n+        validate(other_win)\n+\n+        -- Floating\n+        local float_win = api.nvim_open_win(\n+          api.nvim_create_buf(false, true),\n+          false,\n+          { relative = 'editor', row = 1, col = 1, height = 5, width = 5}\n+        )\n+        validate(float_win)\n+      ]]\n+    end)\n+\n+    it('does not cause ml_get errors with invalid visual selection', function()\n+      exec_lua [[\n+        local feedkeys = function(keys) api.nvim_feedkeys(vim.keycode(keys), 'txn', false) end\n+\n+        -- Add lines to the current buffer and make another window looking into an empty buffer.\n+        local win_empty, win_lines = setup_windows()\n+        api.nvim_buf_set_lines(0, 0, -1, true, { 'a', 'b', 'c' })\n+\n+        -- Start Visual in current window, redraw in other window with fewer lines.\n+        -- Should be fixed by vim-patch:8.2.4018.\n+        feedkeys('G<C-V>')\n+        vim._with({ win = win_empty }, function() vim.cmd.redraw() end)\n+\n+        -- Start Visual in current window, extend it in other window with more lines.\n+        -- Fixed for win_execute by vim-patch:8.2.4026, but nvim_win_call should also not be affected.\n+        feedkeys('<Esc>gg')\n+        api.nvim_set_current_win(win_empty)\n+        feedkeys('gg<C-V>')\n+        vim._with({ win = win_lines }, function() feedkeys('G<C-V>') end)\n+        vim.cmd.redraw()\n+      ]]\n+    end)\n+\n+    it('can be nested', function()\n+      exec_lua [[\n+        local other_win, cur_win = setup_windows()\n+        vim._with({ win = other_win }, function()\n+          assert(api.nvim_get_current_win() == other_win)\n+          inner = vim._with({ win = cur_win }, function()\n+            assert(api.nvim_get_current_win() == cur_win)\n+          end)\n+          assert(api.nvim_get_current_win() == other_win)\n+        end)\n+        assert(api.nvim_get_current_win() == cur_win)\n+      ]]\n+    end)\n+\n+    it('updates ruler if cursor moved', function()\n+      local screen = Screen.new(30, 5)\n+      screen:set_default_attr_ids {\n+        [1] = { reverse = true },\n+        [2] = { bold = true, reverse = true },\n+      }\n+      screen:attach()\n+      exec_lua [[\n+        vim.opt.ruler = true\n+        local lines = {}\n+        for i = 0, 499 do lines[#lines + 1] = tostring(i) end\n+        api.nvim_buf_set_lines(0, 0, -1, true, lines)\n+        api.nvim_win_set_cursor(0, { 20, 0 })\n+        vim.cmd 'split'\n+        _G.win = api.nvim_get_current_win()\n+        vim.cmd \"wincmd w | redraw\"\n+      ]]\n+      screen:expect [[\n+        19                            |\n+        {1:[No Name] [+]  20,1         3%}|\n+        ^19                            |\n+        {2:[No Name] [+]  20,1         3%}|\n+                                      |\n+      ]]\n+      exec_lua [[\n+        vim._with({ win = win }, function() api.nvim_win_set_cursor(0, { 100, 0 }) end)\n+        vim.cmd \"redraw\"\n+      ]]\n+      screen:expect [[\n+        99                            |\n+        {1:[No Name] [+]  100,1       19%}|\n+        ^19                            |\n+        {2:[No Name] [+]  20,1         3%}|\n+                                      |\n+      ]]\n+    end)\n+\n+    it('layout in current tabpage does not affect windows in others', function()\n+      command('tab split')\n+      local t2_move_win = api.nvim_get_current_win()\n+      command('vsplit')\n+      local t2_other_win = api.nvim_get_current_win()\n+      command('tabprevious')\n+      matches('E36: Not enough room$', pcall_err(command, 'execute \"split|\"->repeat(&lines)'))\n+      command('vsplit')\n+\n+      exec_lua('vim._with({ win = ... }, function() vim.cmd.wincmd \"J\" end)', t2_move_win)\n+      eq({ 'col', { { 'leaf', t2_other_win }, { 'leaf', t2_move_win } } }, fn.winlayout(2))\n+    end)\n+  end)\n+\n+  describe('`wo` context', function()\n+    before_each(function()\n+      exec_lua [[\n+        _G.other_win, _G.cur_win = setup_windows()\n+\n+        -- 'virtualedit' is global or local to window (global-local) and string\n+        vim.wo[other_win].virtualedit = 'block'\n+        vim.wo[cur_win].virtualedit = 'insert'\n+        vim.go.virtualedit = 'none'\n+\n+        -- 'winblend' is local to window and number\n+        vim.wo[other_win].winblend = 10\n+        vim.wo[cur_win].winblend = 25\n+        vim.go.winblend = 50\n+\n+        _G.get_state = function()\n+          return {\n+            wo = {\n+              ve_cur = vim.wo[cur_win].virtualedit,\n+              ve_other = vim.wo[other_win].virtualedit,\n+              winbl_cur = vim.wo[cur_win].winblend,\n+              winbl_other = vim.wo[other_win].winblend,\n+            },\n+            go = {\n+              ve = vim.go.virtualedit,\n+              winbl = vim.go.winblend,\n+            },\n+          }\n+        end\n+      ]]\n+    end)\n+\n+    it('works', function()\n+      local out = exec_lua [[\n+        local context = { wo = { virtualedit = 'all', winblend = 75 } }\n+\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_win() == cur_win)\n+          return get_state()\n+        end)\n+\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        wo = { ve_cur = 'all', ve_other = 'block', winbl_cur = 75, winbl_other = 10 },\n+        go = { ve = 'none', winbl = 75 },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('sets options in `win` context', function()\n+      local out = exec_lua [[\n+        local context = { win = other_win, wo = { virtualedit = 'all', winblend = 75 } }\n+\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_win() == other_win)\n+          return get_state()\n+        end)\n+\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        wo = { ve_cur = 'insert', ve_other = 'all', winbl_cur = 25, winbl_other = 75 },\n+        go = { ve = 'none', winbl = 75 },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('restores only options from context', function()\n+      local out = exec_lua [[\n+        local context = { wo = { winblend = 75 } }\n+\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_win() == cur_win)\n+          vim.wo[cur_win].virtualedit = 'onemore'\n+          vim.wo[cur_win].winblend = 99\n+          return get_state()\n+        end)\n+\n+        return { inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        wo = { ve_cur = 'onemore', ve_other = 'block', winbl_cur = 99, winbl_other = 10 },\n+        go = { ve = 'none', winbl = 99 },\n+      }, out.inner)\n+      eq({\n+        wo = { ve_cur = 'onemore', ve_other = 'block', winbl_cur = 25, winbl_other = 10 },\n+        go = { ve = 'none', winbl = 50 },\n+      }, out.after)\n+    end)\n+\n+    it('does not trigger events', function()\n+      exec_lua [[\n+        _G.test_events = { 'WinEnter', 'WinLeave', 'BufWinEnter', 'BufWinLeave' }\n+        _G.test_context = { wo = { winblend = 75 } }\n+        _G.test_trig_event = function() vim.cmd.new() end\n+      ]]\n+      validate_events_trigger()\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        local before, before_inner, after_inner = get_state(), nil, nil\n+        vim._with({ wo = { winblend = 75, virtualedit = 'all' } }, function()\n+          before_inner = get_state()\n+          inner = vim._with({ wo = { winblend = 99 } }, get_state)\n+          after_inner = get_state()\n+        end)\n+        return {\n+          before = before, before_inner = before_inner,\n+          inner = inner,\n+          after_inner = after_inner, after = get_state(),\n+        }\n+      ]]\n+      eq(99, out.inner.wo.winbl_cur)\n+      eq('all', out.inner.wo.ve_cur)\n+      eq(out.before_inner, out.after_inner)\n+      eq(out.before, out.after)\n+    end)\n+  end)\n+\n+  it('returns what callback returns', function()\n+    local out_verify = exec_lua [[\n+      out = { vim._with({}, function()\n+        return 'a', 2, nil, { 4 }, function() end\n+      end) }\n+      return {\n+        out[1] == 'a', out[2] == 2, out[3] == nil,\n+        vim.deep_equal(out[4], { 4 }),\n+        type(out[5]) == 'function',\n+        vim.tbl_count(out),\n+      }\n     ]]\n+    eq({ true, true, true, true, true, 4 }, out_verify)\n   end)\n \n-  it('trigger autocmd if changed within context', function()\n-    exec_lua [[\n-      local old = vim.api.nvim_get_current_win()\n-      vim.cmd(\"new\")\n-      local new = vim.api.nvim_get_current_win()\n-      vim.api.nvim_create_autocmd( { 'WinEnter', 'WinLeave' }, {\n-        callback = function() _G.n = (_G.n or 0) + 1 end\n-      })\n-      vim._with({}, function()\n-        vim.api.nvim_set_current_win(old)\n-        assert(_G.n ~= nil)\n-      end)\n+  it('can return values by reference', function()\n+    local out = exec_lua [[\n+      local val = { 4, 10 }\n+      local ref = vim._with({}, function() return val end)\n+      ref[1] = 7\n+      return val\n     ]]\n+    eq({ 7, 10 }, out)\n   end)\n \n-  it('can access window options', function()\n-    command('vsplit')\n-    local win1 = api.nvim_get_current_win()\n-    command('wincmd w')\n-    local win2 = exec_lua [[\n-      win2 = vim.api.nvim_get_current_win()\n-      return win2\n+  it('can not work with conflicting `buf` and `win`', function()\n+    local out = exec_lua [[\n+      local other_buf, cur_buf = setup_buffers()\n+      local other_win, cur_win = setup_windows()\n+      assert(api.nvim_win_get_buf(other_win) ~= other_buf)\n+      local _, err = pcall(vim._with, { buf = other_buf, win = other_win }, function() end)\n+      return err\n     ]]\n-    command('wincmd p')\n+    matches('Can not set both `buf` and `win`', out)\n+  end)\n \n-    eq('', api.nvim_get_option_value('winhighlight', { win = win1 }))\n-    eq('', api.nvim_get_option_value('winhighlight', { win = win2 }))\n+  it('works with several contexts at once', function()\n+    local out = exec_lua [[\n+      local other_buf, cur_buf = setup_buffers()\n+      vim.bo[other_buf].commentstring = '## %s'\n+      api.nvim_buf_set_lines(other_buf, 0, -1, false, { 'aaa', 'bbb', 'ccc' })\n+      api.nvim_buf_set_mark(other_buf, 'm', 2, 2, {})\n \n-    local val = exec_lua [[\n-      return vim._with({win = win2}, function()\n-        vim.cmd \"setlocal winhighlight=Normal:Normal\"\n-        return vim.api.nvim_get_current_win()\n+      vim.go.commentstring = '// %s'\n+      vim.go.langmap = 'xy,yx'\n+\n+      local context = {\n+        buf = other_buf,\n+        bo = { commentstring = '-- %s' },\n+        go = { langmap = 'ab,ba' },\n+        lockmarks = true,\n+      }\n+\n+      local inner = vim._with(context, function()\n+        api.nvim_buf_set_lines(0, 0, -1, false, { 'uuu', 'vvv', 'www' })\n+        return {\n+          buf = api.nvim_get_current_buf(),\n+          bo = { cms = vim.bo.commentstring },\n+          go = { cms = vim.go.commentstring, lmap = vim.go.langmap },\n+          mark = api.nvim_buf_get_mark(0, 'm')\n+        }\n       end)\n+\n+      local after = {\n+        buf = api.nvim_get_current_buf(),\n+        bo = { cms = vim.bo[other_buf].commentstring },\n+        go = { cms = vim.go.commentstring, lmap = vim.go.langmap },\n+        mark = api.nvim_buf_get_mark(other_buf, 'm')\n+      }\n+\n+      return {\n+        context_buf = other_buf, cur_buf = cur_buf,\n+        inner = inner, after = after\n+      }\n     ]]\n \n-    eq('', api.nvim_get_option_value('winhighlight', { win = win1 }))\n-    eq('Normal:Normal', api.nvim_get_option_value('winhighlight', { win = win2 }))\n-    eq(win1, api.nvim_get_current_win())\n-    eq(win2, val)\n+    eq({\n+      buf = out.context_buf,\n+      bo = { cms = '-- %s' },\n+      go = { cms = '// %s', lmap = 'ab,ba' },\n+      mark = { 2, 2 },\n+    }, out.inner)\n+    eq({\n+      buf = out.cur_buf,\n+      bo = { cms = '## %s' },\n+      go = { cms = '// %s', lmap = 'xy,yx' },\n+      mark = { 2, 2 },\n+    }, out.after)\n   end)\n \n-  it('does not cause ml_get errors with invalid visual selection', function()\n-    -- Add lines to the current buffer and make another window looking into an empty buffer.\n-    exec_lua [[\n-      _G.api = vim.api\n-      _G.t = function(s) return api.nvim_replace_termcodes(s, true, true, true) end\n-      _G.win_lines = api.nvim_get_current_win()\n-      vim.cmd \"new\"\n-      _G.win_empty = api.nvim_get_current_win()\n-      api.nvim_set_current_win(win_lines)\n-      api.nvim_buf_set_lines(0, 0, -1, true, {\"a\", \"b\", \"c\"})\n-    ]]\n+  it('works with same option set in different contexts', function()\n+    local out = exec_lua [[\n+      local get_state = function()\n+        return {\n+          bo = { cms = vim.bo.commentstring },\n+          wo = { ve = vim.wo.virtualedit },\n+          go = { cms = vim.go.commentstring, ve = vim.go.virtualedit },\n+        }\n+      end\n \n-    -- Start Visual in current window, redraw in other window with fewer lines.\n-    exec_lua [[\n-      api.nvim_feedkeys(t \"G<C-V>\", \"txn\", false)\n-      vim._with({win = win_empty}, function() vim.cmd \"redraw\" end)\n-    ]]\n+      vim.bo.commentstring = '// %s'\n+      vim.go.commentstring = '$$ %s'\n+      vim.wo.virtualedit = 'insert'\n+      vim.go.virtualedit = 'none'\n \n-    -- Start Visual in current window, extend it in other window with more lines.\n-    exec_lua [[\n-      api.nvim_feedkeys(t \"<Esc>gg\", \"txn\", false)\n-      api.nvim_set_current_win(win_empty)\n-      api.nvim_feedkeys(t \"gg<C-V>\", \"txn\", false)\n-      vim._with({win = win_lines}, function() api.nvim_feedkeys(t \"G<C-V>\", \"txn\", false) end)\n-      vim.cmd \"redraw\"\n+      local before = get_state()\n+      local context_no_go = {\n+        o = { commentstring = '-- %s', virtualedit = 'all' },\n+        bo = { commentstring = '!! %s' },\n+        wo = { virtualedit = 'onemore' },\n+      }\n+      local inner_no_go = vim._with(context_no_go, get_state)\n+      local middle = get_state()\n+      local context_with_go = {\n+        o = { commentstring = '-- %s', virtualedit = 'all' },\n+        bo = { commentstring = '!! %s' },\n+        wo = { virtualedit = 'onemore' },\n+        go = { commentstring = '@@ %s', virtualedit = 'block' },\n+      }\n+      local inner_with_go = vim._with(context_with_go, get_state)\n+      return {\n+        before = before,\n+        inner_no_go = inner_no_go,\n+        middle = middle,\n+        inner_with_go = inner_with_go,\n+        after = get_state(),\n+      }\n     ]]\n+\n+    -- Should prefer explicit local scopes instead of `o`\n+    eq({\n+      bo = { cms = '!! %s' },\n+      wo = { ve = 'onemore' },\n+      go = { cms = '-- %s', ve = 'all' },\n+    }, out.inner_no_go)\n+    eq(out.before, out.middle)\n+\n+    -- Should prefer explicit global scopes instead of `o`\n+    eq({\n+      bo = { cms = '!! %s' },\n+      wo = { ve = 'onemore' },\n+      go = { cms = '@@ %s', ve = 'block' },\n+    }, out.inner_with_go)\n+    eq(out.middle, out.after)\n   end)\n \n-  it('updates ruler if cursor moved', function()\n-    local screen = Screen.new(30, 5)\n-    screen:set_default_attr_ids {\n-      [1] = { reverse = true },\n-      [2] = { bold = true, reverse = true },\n-    }\n-    screen:attach()\n-    exec_lua [[\n-      _G.api = vim.api\n-      vim.opt.ruler = true\n-      local lines = {}\n-      for i = 0, 499 do lines[#lines + 1] = tostring(i) end\n-      api.nvim_buf_set_lines(0, 0, -1, true, lines)\n-      api.nvim_win_set_cursor(0, {20, 0})\n-      vim.cmd \"split\"\n-      _G.win = api.nvim_get_current_win()\n-      vim.cmd \"wincmd w | redraw\"\n-    ]]\n-    screen:expect [[\n-      19                            |\n-      {1:[No Name] [+]  20,1         3%}|\n-      ^19                            |\n-      {2:[No Name] [+]  20,1         3%}|\n-                                    |\n-    ]]\n-    exec_lua [[\n-      vim._with({win = win}, function() api.nvim_win_set_cursor(0, {100, 0}) end)\n-      vim.cmd \"redraw\"\n-    ]]\n-    screen:expect [[\n-      99                            |\n-      {1:[No Name] [+]  100,1       19%}|\n-      ^19                            |\n-      {2:[No Name] [+]  20,1         3%}|\n-                                    |\n+  pending('can forward command modifiers to user command', function()\n+    local out = exec_lua [[\n+      local test_flags = {\n+        'emsg_silent',\n+        'hide',\n+        'keepalt',\n+        'keepjumps',\n+        'keepmarks',\n+        'keeppatterns',\n+        'lockmarks',\n+        'noautocmd',\n+        'silent',\n+        'unsilent',\n+      }\n+\n+      local used_smods\n+      local command = function(data)\n+        used_smods = data.smods\n+      end\n+      api.nvim_create_user_command('DummyLog', command, {})\n+\n+      local res = {}\n+      for _, flag in ipairs(test_flags) do\n+        used_smods = nil\n+        vim._with({ [flag] = true }, function() vim.cmd('DummyLog') end)\n+        res[flag] = used_smods[flag]\n+      end\n+      return res\n     ]]\n+    for k, v in pairs(out) do\n+      eq({ k, true }, { k, v })\n+    end\n   end)\n \n-  it('can return values by reference', function()\n-    eq(\n-      { 7, 10 },\n-      exec_lua [[\n-      local val = {4, 10}\n-      local ref = vim._with({win = 0}, function() return val end)\n-      ref[1] = 7\n-      return val\n+  it('handles error in callback', function()\n+    -- Should still restore initial context\n+    local out_buf = exec_lua [[\n+      local other_buf, cur_buf = setup_buffers()\n+      vim.bo[other_buf].commentstring = '## %s'\n+\n+      local context = { buf = other_buf, bo = { commentstring = '-- %s' } }\n+      local ok, err = pcall(vim._with, context, function() error('Oops buf', 0) end)\n+\n+      return {\n+        ok,\n+        err,\n+        api.nvim_get_current_buf() == cur_buf,\n+        vim.bo[other_buf].commentstring,\n+      }\n+    ]]\n+    eq({ false, 'Oops buf', true, '## %s' }, out_buf)\n+\n+    local out_win = exec_lua [[\n+      local other_win, cur_win = setup_windows()\n+      vim.wo[other_win].winblend = 25\n+\n+      local context = { win = other_win, wo = { winblend = 50 } }\n+      local ok, err = pcall(vim._with, context, function() error('Oops win', 0) end)\n+\n+      return {\n+        ok,\n+        err,\n+        api.nvim_get_current_win() == cur_win,\n+        vim.wo[other_win].winblend,\n+      }\n     ]]\n-    )\n+    eq({ false, 'Oops win', true, 25 }, out_win)\n   end)\n \n-  it('layout in current tabpage does not affect windows in others', function()\n-    command('tab split')\n-    local t2_move_win = api.nvim_get_current_win()\n-    command('vsplit')\n-    local t2_other_win = api.nvim_get_current_win()\n-    command('tabprevious')\n-    matches('E36: Not enough room$', pcall_err(command, 'execute \"split|\"->repeat(&lines)'))\n-    command('vsplit')\n-\n-    exec_lua('vim._with({win = ...}, function() vim.cmd.wincmd \"J\" end)', t2_move_win)\n-    eq({ 'col', { { 'leaf', t2_other_win }, { 'leaf', t2_move_win } } }, fn.winlayout(2))\n+  it('handles not supported option', function()\n+    local out = exec_lua [[\n+      -- Should still restore initial state\n+      vim.bo.commentstring = '## %s'\n+\n+      local context = { o = { commentstring = '-- %s' }, bo = { winblend = 10 } }\n+      local ok, err = pcall(vim._with, context, function() end)\n+\n+      return { ok = ok, err = err, cms = vim.bo.commentstring }\n+    ]]\n+    eq(false, out.ok)\n+    matches('window.*option.*winblend', out.err)\n+    eq('## %s', out.cms)\n   end)\n-end)\n \n-describe('vim._with {lockmarks = true}', function()\n-  it('is reset', function()\n-    local mark = exec_lua [[\n-      vim.api.nvim_buf_set_lines(0, 0, 0, false, {\"marky\", \"snarky\", \"malarkey\"})\n-      vim.api.nvim_buf_set_mark(0,\"m\",1,0, {})\n-      vim._with({lockmarks = true}, function()\n-        vim.api.nvim_buf_set_lines(0, 0, 2, false, {\"mass\", \"mess\", \"moss\"})\n-      end)\n-      return vim.api.nvim_buf_get_mark(0,\"m\")\n+  it('validates arguments', function()\n+    exec_lua [[\n+      _G.get_error = function(...)\n+        local _, err = pcall(vim._with, ...)\n+        return err or ''\n+      end\n     ]]\n-    t.eq(mark, { 1, 0 })\n+    local get_error = function(string_args)\n+      return exec_lua('return get_error(' .. string_args .. ')')\n+    end\n+\n+    matches('context.*table', get_error(\"'a', function() end\"))\n+    matches('f.*function', get_error('{}, 1'))\n+\n+    local validate_context = function(bad_context, expected_type)",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1651190086",
            "id": 1651190086,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5iaylG",
            "original_commit_id": "15b5f2fc957a8ad3a21e52d455e7ee157e5c53b3",
            "original_line": 1596,
            "original_position": 1814,
            "original_start_line": null,
            "path": "test/functional/lua/with_spec.lua",
            "position": null,
            "pull_request_review_id": 2136066242,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1651190086/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-24T15:00:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1651190086",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/29280#discussion_r1651378667"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/29280"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1651378667"
                }
            },
            "author_association": "MEMBER",
            "body": "Done. Also replaced other instances of `validate_*` usage.",
            "commit_id": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
            "created_at": "2024-06-24T17:24:21Z",
            "diff_hunk": "@@ -7,286 +7,1620 @@ local api = n.api\n local command = n.command\n local eq = t.eq\n local exec_lua = n.exec_lua\n+local exec_capture = n.exec_capture\n local matches = t.matches\n local pcall_err = t.pcall_err\n \n-before_each(function()\n-  n.clear()\n-end)\n+describe('vim._with', function()\n+  before_each(function()\n+    n.clear()\n+    exec_lua([[\n+      _G.fn = vim.fn\n+      _G.api = vim.api\n \n-describe('vim._with {buf = }', function()\n-  it('does not trigger autocmd', function()\n-    exec_lua [[\n-      local new = vim.api.nvim_create_buf(false, true)\n-      vim.api.nvim_create_autocmd( { 'BufEnter', 'BufLeave', 'BufWinEnter', 'BufWinLeave' }, {\n-        callback = function() _G.n = (_G.n or 0) + 1 end\n-      })\n-      vim._with({buf = new}, function()\n-      end)\n-      assert(_G.n == nil)\n-    ]]\n+      _G.setup_buffers = function()\n+        return api.nvim_create_buf(false, true), api.nvim_get_current_buf()\n+      end\n+\n+      _G.setup_windows = function()\n+        local other_win = api.nvim_get_current_win()\n+        vim.cmd.new()\n+        return other_win, api.nvim_get_current_win()\n+      end\n+    ]])\n   end)\n \n-  it('trigger autocmd if changed within context', function()\n-    exec_lua [[\n-      local new = vim.api.nvim_create_buf(false, true)\n-      vim.api.nvim_create_autocmd( { 'BufEnter', 'BufLeave', 'BufWinEnter', 'BufWinLeave' }, {\n-        callback = function() _G.n = (_G.n or 0) + 1 end\n-      })\n-      vim._with({}, function()\n-        vim.api.nvim_set_current_buf(new)\n-        assert(_G.n ~= nil)\n+  local validate_events_trigger = function()\n+    local out = exec_lua [[\n+      -- Needs three global values defined:\n+      -- - `test_events` - array of events which are tested.\n+      -- - `test_context` - context to be tested.\n+      -- - `test_trig_event` - callable triggering at least one tested event.\n+      _G.n_events = 0\n+      local opts = { callback = function() _G.n_events = _G.n_events + 1 end }\n+      api.nvim_create_autocmd(_G.test_events, opts)\n+\n+      local context = { bo = { commentstring = '-- %s' } }\n+\n+      -- Should not trigger events on its own\n+      vim._with(_G.test_context, function() end)\n+      local is_no_events = _G.n_events == 0\n+\n+      -- Should trigger events if specifically asked inside callback\n+      local is_events = vim._with(_G.test_context, function()\n+        _G.test_trig_event()\n+        return _G.n_events > 0\n       end)\n+      return { is_no_events, is_events }\n     ]]\n+    eq({ true, true }, out)\n+  end\n+\n+  describe('`bo` context', function()\n+    before_each(function()\n+      exec_lua [[\n+        _G.other_buf, _G.cur_buf = setup_buffers()\n+\n+        -- 'commentstring' is local to buffer and string\n+        vim.bo[other_buf].commentstring = '## %s'\n+        vim.bo[cur_buf].commentstring = '// %s'\n+        vim.go.commentstring = '$$ %s'\n+\n+        -- 'undolevels' is global or local to buffer (global-local) and number\n+        vim.bo[other_buf].undolevels = 100\n+        vim.bo[cur_buf].undolevels = 250\n+        vim.go.undolevels = 500\n+\n+        _G.get_state = function()\n+          return {\n+            bo = {\n+              cms_cur = vim.bo[cur_buf].commentstring,\n+              cms_other = vim.bo[other_buf].commentstring,\n+              ul_cur = vim.bo[cur_buf].undolevels,\n+              ul_other = vim.bo[other_buf].undolevels,\n+            },\n+            go = {\n+              cms = vim.go.commentstring,\n+              ul = vim.go.undolevels,\n+            },\n+          }\n+        end\n+      ]]\n+    end)\n+\n+    it('works', function()\n+      local out = exec_lua [[\n+        local context = { bo = { commentstring = '-- %s', undolevels = 0 } }\n+\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_buf() == cur_buf)\n+          return get_state()\n+        end)\n+\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms_cur = '-- %s', cms_other = '## %s', ul_cur = 0, ul_other = 100 },\n+        go = { cms = '$$ %s', ul = 500 },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('sets options in `buf` context', function()\n+      local out = exec_lua [[\n+        local context = { buf = other_buf, bo = { commentstring = '-- %s', undolevels = 0 } }\n+\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_buf() == other_buf)\n+          return get_state()\n+        end)\n+\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms_cur = '// %s', cms_other = '-- %s', ul_cur = 250, ul_other = 0 },\n+        go = { cms = '$$ %s', ul = 500 },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('restores only options from context', function()\n+      local out = exec_lua [[\n+        local context = { bo = { commentstring = '-- %s' } }\n+\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_buf() == cur_buf)\n+          vim.bo[cur_buf].undolevels = 750\n+          vim.bo[cur_buf].commentstring = '!! %s'\n+          return get_state()\n+        end)\n+\n+        return { inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms_cur = '!! %s', cms_other = '## %s', ul_cur = 750, ul_other = 100 },\n+        go = { cms = '$$ %s', ul = 500 },\n+      }, out.inner)\n+      eq({\n+        bo = { cms_cur = '// %s', cms_other = '## %s', ul_cur = 750, ul_other = 100 },\n+        go = { cms = '$$ %s', ul = 500 },\n+      }, out.after)\n+    end)\n+\n+    it('does not trigger events', function()\n+      exec_lua [[\n+        _G.test_events = { 'BufEnter', 'BufLeave', 'BufWinEnter', 'BufWinLeave' }\n+        _G.test_context = { bo = { commentstring = '-- %s' } }\n+        _G.test_trig_event = function() vim.cmd.new() end\n+      ]]\n+      validate_events_trigger()\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        local before, before_inner, after_inner = get_state(), nil, nil\n+        vim._with({ bo = { commentstring = '-- %s', undolevels = 0 } }, function()\n+          before_inner = get_state()\n+          inner = vim._with({ bo = { commentstring = '!! %s' } }, get_state)\n+          after_inner = get_state()\n+        end)\n+        return {\n+          before = before, before_inner = before_inner,\n+          inner = inner,\n+          after_inner = after_inner, after = get_state(),\n+        }\n+      ]]\n+      eq('!! %s', out.inner.bo.cms_cur)\n+      eq(0, out.inner.bo.ul_cur)\n+      eq(out.before_inner, out.after_inner)\n+      eq(out.before, out.after)\n+    end)\n   end)\n \n-  it('can access buf options', function()\n-    local buf1 = api.nvim_get_current_buf()\n-    local buf2 = exec_lua [[\n-      buf2 = vim.api.nvim_create_buf(false, true)\n-      return buf2\n-    ]]\n+  describe('`buf` context', function()\n+    it('works', function()\n+      local out = exec_lua [[\n+        local other_buf, cur_buf = setup_buffers()\n+        local inner = vim._with({ buf = other_buf }, function()\n+          return api.nvim_get_current_buf()\n+        end)\n+        return { inner == other_buf, api.nvim_get_current_buf() == cur_buf }\n+      ]]\n+      eq({ true, true }, out)\n+    end)\n+\n+    it('does not trigger events', function()\n+      exec_lua [[\n+        _G.test_events = { 'BufEnter', 'BufLeave', 'BufWinEnter', 'BufWinLeave' }\n+        _G.test_context = { buf = other_buf }\n+        _G.test_trig_event = function() vim.cmd.new() end\n+      ]]\n+      validate_events_trigger()\n+    end)\n \n-    eq(false, api.nvim_get_option_value('autoindent', { buf = buf1 }))\n-    eq(false, api.nvim_get_option_value('autoindent', { buf = buf2 }))\n+    it('can access buffer options', function()\n+      local out = exec_lua [[\n+        other_buf, cur_buf = setup_buffers()\n+        vim.bo[other_buf].commentstring = '## %s'\n+        vim.bo[cur_buf].commentstring = '// %s'\n \n-    local val = exec_lua [[\n-      return vim._with({buf = buf2}, function()\n-        vim.cmd \"set autoindent\"\n-        return vim.api.nvim_get_current_buf()\n+        vim._with({ buf = other_buf }, function()\n+          vim.cmd.set('commentstring=--\\\\ %s')\n+        end)\n+\n+        return vim.bo[other_buf].commentstring == '-- %s' and\n+          vim.bo[cur_buf].commentstring == '// %s'\n+      ]]\n+      eq(true, out)\n+    end)\n+\n+    it('works with different kinds of buffers', function()\n+      exec_lua [[\n+        local validate = function(buf)\n+          vim._with({ buf = buf }, function()\n+            assert(api.nvim_get_current_buf() == buf)\n+          end)\n+        end\n+\n+        -- Current\n+        validate(api.nvim_get_current_buf())\n+\n+        -- Hidden listed\n+        local listed = api.nvim_create_buf(true, true)\n+        validate(listed)\n+\n+        -- Visible\n+        local other_win, cur_win = setup_windows()\n+        api.nvim_win_set_buf(other_win, listed)\n+        validate(listed)\n+\n+        -- Shown but not visible\n+        vim.cmd.tabnew()\n+        validate(listed)\n+\n+        -- Shown in several windows\n+        api.nvim_win_set_buf(0, listed)\n+        validate(listed)\n+\n+        -- Shown in floating window\n+        local float_buf = api.nvim_create_buf(false, true)\n+        local config = { relative = 'editor', row = 1, col = 1, width = 5, height = 5 }\n+        api.nvim_open_win(float_buf, false, config)\n+        validate(float_buf)\n+      ]]\n+    end)\n+\n+    it('does not cause ml_get errors with invalid visual selection', function()\n+      exec_lua [[\n+        api.nvim_buf_set_lines(0, 0, -1, true, { 'a', 'b', 'c' })\n+        api.nvim_feedkeys(vim.keycode('G<C-V>'), 'txn', false)\n+        local other_buf, _ = setup_buffers()\n+        vim._with({ buf = buf }, function() vim.cmd.redraw() end)\n+      ]]\n+    end)\n+\n+    it('can be nested', function()\n+      exec_lua [[\n+        local other_buf, cur_buf = setup_buffers()\n+        vim._with({ buf = other_buf }, function()\n+          assert(api.nvim_get_current_buf() == other_buf)\n+          inner = vim._with({ buf = cur_buf }, function()\n+            assert(api.nvim_get_current_buf() == cur_buf)\n+          end)\n+          assert(api.nvim_get_current_buf() == other_buf)\n+        end)\n+        assert(api.nvim_get_current_buf() == cur_buf)\n+      ]]\n     end)\n-    ]]\n \n-    eq(false, api.nvim_get_option_value('autoindent', { buf = buf1 }))\n-    eq(true, api.nvim_get_option_value('autoindent', { buf = buf2 }))\n-    eq(buf1, api.nvim_get_current_buf())\n-    eq(buf2, val)\n+    it('can be nested crazily with hidden buffers', function()\n+      local out = exec_lua([[\n+        local n = 0\n+        local function with_recursive_nested_bufs()\n+          n = n + 1\n+          if n > 20 then return true end\n+\n+          local other_buf, _ = setup_buffers()\n+          vim.bo[other_buf].commentstring = '## %s'\n+          local callback = function()\n+            return api.nvim_get_current_buf() == other_buf\n+              and vim.bo[other_buf].commentstring == '## %s'\n+              and with_recursive_nested_bufs()\n+          end\n+          return vim._with({ buf = other_buf }, callback) and\n+            api.nvim_buf_delete(other_buf, {}) == nil\n+        end\n+\n+        return with_recursive_nested_bufs()\n+      ]])\n+      eq(true, out)\n+    end)\n   end)\n \n-  it('does not cause ml_get errors with invalid visual selection', function()\n-    exec_lua [[\n-      local api = vim.api\n-      local t = function(s) return api.nvim_replace_termcodes(s, true, true, true) end\n-      api.nvim_buf_set_lines(0, 0, -1, true, {\"a\", \"b\", \"c\"})\n-      api.nvim_feedkeys(t \"G<C-V>\", \"txn\", false)\n-      vim._with({buf = api.nvim_create_buf(false, true)}, function() vim.cmd \"redraw\" end)\n-    ]]\n+  describe('`emsg_silent` context', function()\n+    pending('works', function()\n+      local ok = pcall(\n+        exec_lua,\n+        [[\n+          _G.f = function()\n+            error('This error should not interfer with execution', 0)\n+          end\n+          -- Should not produce error same as `vim.cmd('silent! lua _G.f()')`\n+          vim._with({ emsg_silent = true }, f)\n+        ]]\n+      )\n+      eq(true, ok)\n+\n+      -- Should properly report errors afterwards\n+      ok = pcall(exec_lua, 'lua _G.f()')\n+      eq(false, ok)\n+    end)\n+\n+    it('can be nested', function()\n+      local ok = pcall(\n+        exec_lua,\n+        [[\n+          _G.f = function()\n+            error('This error should not interfer with execution', 0)\n+          end\n+          -- Should produce error same as `_G.f()`\n+          vim._with({ emsg_silent = true }, function()\n+            vim._with( { emsg_silent = false }, f)\n+          end)\n+        ]]\n+      )\n+      eq(false, ok)\n+    end)\n   end)\n \n-  it('can be nested crazily with hidden buffers', function()\n-    eq(\n-      true,\n-      exec_lua([[\n-      local function scratch_buf_call(fn)\n-        local buf = vim.api.nvim_create_buf(false, true)\n-        vim.api.nvim_set_option_value('cindent', true, {buf = buf})\n-        return vim._with({buf = buf}, function()\n-          return vim.api.nvim_get_current_buf() == buf\n-            and vim.api.nvim_get_option_value('cindent', {buf = buf})\n-            and fn()\n-      end) and vim.api.nvim_buf_delete(buf, {}) == nil\n+  describe('`env` context', function()\n+    before_each(function()\n+      exec_lua [[\n+        vim.fn.setenv('aaa', 'hello')\n+        _G.get_state = function()\n+          return { aaa = vim.fn.getenv('aaa'), bbb = vim.fn.getenv('bbb') }\n+        end\n+      ]]\n+    end)\n+\n+    it('works', function()\n+      local out = exec_lua [[\n+        local context = { env = { aaa = 'inside', bbb = 'wow' } }\n+        local before = get_state()\n+        local inner = vim._with(context, get_state)\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({ aaa = 'inside', bbb = 'wow' }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('restores only variables from context', function()\n+      local out = exec_lua [[\n+        local context = { env = { bbb = 'wow' } }\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          vim.env.aaa = 'inside'\n+          return get_state()\n+        end)\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({ aaa = 'inside', bbb = 'wow' }, out.inner)\n+      eq({ aaa = 'inside', bbb = vim.NIL }, out.after)\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        local before, before_inner, after_inner = get_state(), nil, nil\n+        vim._with({ env = { aaa = 'inside', bbb = 'wow' } }, function()\n+          before_inner = get_state()\n+          inner = vim._with({ env = { aaa = 'more inside' } }, get_state)\n+          after_inner = get_state()\n+        end)\n+        return {\n+          before = before, before_inner = before_inner,\n+          inner = inner,\n+          after_inner = after_inner, after = get_state(),\n+        }\n+      ]]\n+      eq('more inside', out.inner.aaa)\n+      eq('wow', out.inner.bbb)\n+      eq(out.before_inner, out.after_inner)\n+      eq(out.before, out.after)\n+    end)\n+  end)\n+\n+  describe('`go` context', function()\n+    before_each(function()\n+      exec_lua [[\n+        vim.bo.commentstring = '## %s'\n+        vim.go.commentstring = '$$ %s'\n+        vim.wo.winblend = 25\n+        vim.go.winblend = 50\n+        vim.go.langmap = 'xy,yx'\n+\n+        _G.get_state = function()\n+          return {\n+            bo = { cms = vim.bo.commentstring },\n+            wo = { winbl = vim.wo.winblend },\n+            go = {\n+              cms = vim.go.commentstring,\n+              winbl = vim.go.winblend,\n+              lmap = vim.go.langmap,\n+            },\n+          }\n+        end\n+      ]]\n+    end)\n+\n+    it('works', function()\n+      local out = exec_lua [[\n+        local context = {\n+          go = { commentstring = '-- %s', winblend = 75, langmap = 'ab,ba' },\n+        }\n+        local before = get_state()\n+        local inner = vim._with(context, get_state)\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms = '## %s' },\n+        wo = { winbl = 25 },\n+        go = { cms = '-- %s', winbl = 75, lmap = 'ab,ba' },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('works with `eventignore`', function()\n+      -- This might be an issue if saving and restoring option context is done\n+      -- to account for triggering `OptionSet`, but in not a good way\n+      local out = exec_lua [[\n+        vim.go.eventignore = 'ModeChanged'\n+        local inner = vim._with({ go = { eventignore = 'CursorMoved' } }, function()\n+          return vim.go.eventignore\n+        end)\n+        return { inner = inner, after = vim.go.eventignore }\n+      ]]\n+      eq({ inner = 'CursorMoved', after = 'ModeChanged' }, out)\n+    end)\n+\n+    it('restores only options from context', function()\n+      local out = exec_lua [[\n+        local context = { go = { langmap = 'ab,ba' } }\n+\n+        local inner = vim._with(context, function()\n+          vim.go.commentstring = '!! %s'\n+          vim.go.winblend = 75\n+          vim.go.langmap = 'uv,vu'\n+          return get_state()\n+        end)\n+\n+        return { inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms = '## %s' },\n+        wo = { winbl = 25 },\n+        go = { cms = '!! %s', winbl = 75, lmap = 'uv,vu' },\n+      }, out.inner)\n+      eq({\n+        bo = { cms = '## %s' },\n+        wo = { winbl = 25 },\n+        go = { cms = '!! %s', winbl = 75, lmap = 'xy,yx' },\n+      }, out.after)\n+    end)\n+\n+    it('does not trigger events', function()\n+      exec_lua [[\n+        _G.test_events = {\n+          'BufEnter', 'BufLeave', 'BufWinEnter', 'BufWinLeave', 'WinEnter', 'WinLeave'\n+        }\n+        _G.test_context = { go = { commentstring = '-- %s', winblend = 75, langmap = 'ab,ba' } }\n+        _G.test_trig_event = function() vim.cmd.new() end\n+      ]]\n+      validate_events_trigger()\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        local before, before_inner, after_inner = get_state(), nil, nil\n+        vim._with({ go = { langmap = 'ab,ba', commentstring = '-- %s' } }, function()\n+          before_inner = get_state()\n+          inner = vim._with({ go = { langmap = 'uv,vu' } }, get_state)\n+          after_inner = get_state()\n+        end)\n+        return {\n+          before = before, before_inner = before_inner,\n+          inner = inner,\n+          after_inner = after_inner, after = get_state(),\n+        }\n+      ]]\n+      eq('uv,vu', out.inner.go.lmap)\n+      eq('-- %s', out.inner.go.cms)\n+      eq(out.before_inner, out.after_inner)\n+      eq(out.before, out.after)\n+    end)\n+  end)\n+\n+  describe('`hide` context', function()\n+    pending('works', function()\n+      local ok = pcall(\n+        exec_lua,\n+        [[\n+          vim.o.hidden = false\n+          vim.bo.modified = true\n+          local init_buf = api.nvim_get_current_buf()\n+          -- Should not produce error same as `vim.cmd('hide enew')`\n+          vim._with({ hide = true }, function()\n+            vim.cmd.enew()\n+          end)\n+          assert(api.nvim_get_current_buf() ~= init_buf)\n+        ]]\n+      )\n+      eq(true, ok)\n+    end)\n+\n+    it('can be nested', function()\n+      local ok = pcall(\n+        exec_lua,\n+        [[\n+          vim.o.hidden = false\n+          vim.bo.modified = true\n+          -- Should produce error same as `vim.cmd.enew()`\n+          vim._with({ hide = true }, function()\n+            vim._with({ hide = false }, function()\n+              vim.cmd.enew()\n+            end)\n+          end)\n+        ]]\n+      )\n+      eq(false, ok)\n+    end)\n+  end)\n+\n+  describe('`horizontal` context', function()\n+    local is_approx_eq = function(dim, id_1, id_2)\n+      local f = dim == 'height' and api.nvim_win_get_height or api.nvim_win_get_width\n+      return math.abs(f(id_1) - f(id_2)) <= 1\n     end\n \n-    return scratch_buf_call(function()\n-      return scratch_buf_call(function()\n-        return scratch_buf_call(function()\n-          return scratch_buf_call(function()\n-            return scratch_buf_call(function()\n-              return scratch_buf_call(function()\n-                return scratch_buf_call(function()\n-                  return scratch_buf_call(function()\n-                    return scratch_buf_call(function()\n-                      return scratch_buf_call(function()\n-                        return scratch_buf_call(function()\n-                          return scratch_buf_call(function()\n-                            return true\n-                          end)\n-                        end)\n-                      end)\n-                    end)\n-                  end)\n-                end)\n-              end)\n+    local win_id_1, win_id_2, win_id_3\n+    before_each(function()\n+      win_id_1 = api.nvim_get_current_win()\n+      command('wincmd v | wincmd 5>')\n+      win_id_2 = api.nvim_get_current_win()\n+      command('wincmd s | wincmd 5+')\n+      win_id_3 = api.nvim_get_current_win()\n+\n+      eq(is_approx_eq('width', win_id_1, win_id_2), false)\n+      eq(is_approx_eq('height', win_id_3, win_id_2), false)\n+    end)\n+\n+    pending('works', function()\n+      exec_lua [[\n+        -- Should be same as `vim.cmd('horizontal wincmd =')`\n+        vim._with({ horizontal = true }, function()\n+          vim.cmd.wincmd('=')\n+        end)\n+      ]]\n+      eq(is_approx_eq('width', win_id_1, win_id_2), true)\n+      eq(is_approx_eq('height', win_id_3, win_id_2), false)\n+    end)\n+\n+    pending('can be nested', function()\n+      exec_lua [[\n+        -- Should be same as `vim.cmd.wincmd('=')`\n+        vim._with({ horizontal = true }, function()\n+          vim._with({ horizontal = false }, function()\n+            vim.cmd.wincmd('=')\n+          end)\n+        end)\n+      ]]\n+      eq(is_approx_eq('width', win_id_1, win_id_2), true)\n+      eq(is_approx_eq('height', win_id_3, win_id_2), true)\n+    end)\n+  end)\n+\n+  describe('`keepalt` context', function()\n+    pending('works', function()\n+      local out = exec_lua [[\n+        vim.cmd('edit alt')\n+        vim.cmd('edit new')\n+        assert(fn.bufname('#') == 'alt')\n+\n+        -- Should work as `vim.cmd('keepalt edit very-new')`\n+        vim._with({ keepalt = true }, function()\n+          vim.cmd.edit('very-new')\n+        end)\n+        return fn.bufname('#') == 'alt'\n+      ]]\n+      eq(true, out)\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        vim.cmd('edit alt')\n+        vim.cmd('edit new')\n+        assert(fn.bufname('#') == 'alt')\n+\n+        -- Should work as `vim.cmd.edit('very-new')`\n+        vim._with({ keepalt = true }, function()\n+          vim._with({ keepalt = false }, function()\n+            vim.cmd.edit('very-new')\n+          end)\n+        end)\n+        return fn.bufname('#') == 'alt'\n+      ]]\n+      eq(false, out)\n+    end)\n+  end)\n+\n+  describe('`keepjumps` context', function()\n+    pending('works', function()\n+      local out = exec_lua [[\n+        api.nvim_buf_set_lines(0, 0, -1, false, { 'aaa', 'bbb', 'ccc' })\n+        local jumplist_before = fn.getjumplist()\n+        -- Should work as `vim.cmd('keepjumps normal! Ggg')`\n+        vim._with({ keepjumps = true }, function()\n+          vim.cmd('normal! Ggg')\n+        end)\n+        return vim.deep_equal(jumplist_before, fn.getjumplist())\n+      ]]\n+      eq(true, out)\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        api.nvim_buf_set_lines(0, 0, -1, false, { 'aaa', 'bbb', 'ccc' })\n+        local jumplist_before = fn.getjumplist()\n+        vim._with({ keepjumps = true }, function()\n+          vim._with({ keepjumps = false }, function()\n+            vim.cmd('normal! Ggg')\n+          end)\n+        end)\n+        return vim.deep_equal(jumplist_before, fn.getjumplist())\n+      ]]\n+      eq(false, out)\n+    end)\n+  end)\n+\n+  describe('`keepmarks` context', function()\n+    pending('works', function()\n+      local out = exec_lua [[\n+        vim.cmd('set cpoptions+=R')\n+        api.nvim_buf_set_lines(0, 0, -1, false, { 'bbb', 'ccc', 'aaa' })\n+        api.nvim_buf_set_mark(0, 'm', 2, 2, {})\n+\n+        -- Should be the same as `vim.cmd('keepmarks %!sort')`\n+        vim._with({ keepmarks = true }, function()\n+          vim.cmd('%!sort')\n+        end)\n+        return api.nvim_buf_get_mark(0, 'm')\n+      ]]\n+      eq({ 2, 2 }, out)\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        vim.cmd('set cpoptions+=R')\n+        api.nvim_buf_set_lines(0, 0, -1, false, { 'bbb', 'ccc', 'aaa' })\n+        api.nvim_buf_set_mark(0, 'm', 2, 2, {})\n+\n+        vim._with({ keepmarks = true }, function()\n+          vim._with({ keepmarks = false }, function()\n+            vim.cmd('%!sort')\n+          end)\n+        end)\n+        return api.nvim_buf_get_mark(0, 'm')\n+      ]]\n+      eq({ 0, 2 }, out)\n+    end)\n+  end)\n+\n+  describe('`keepatterns` context', function()\n+    pending('works', function()\n+      local out = exec_lua [[\n+        api.nvim_buf_set_lines(0, 0, -1, false, { 'aaa', 'bbb' })\n+        vim.cmd('/aaa')\n+        -- Should be the same as `vim.cmd('keeppatterns /bbb')`\n+        vim._with({ keeppatterns = true }, function()\n+          vim.cmd('/bbb')\n+        end)\n+        return fn.getreg('/')\n+      ]]\n+      eq('aaa', out)\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        api.nvim_buf_set_lines(0, 0, -1, false, { 'aaa', 'bbb' })\n+        vim.cmd('/aaa')\n+        vim._with({ keeppatterns = true }, function()\n+          vim._with({ keeppatterns = false }, function()\n+            vim.cmd('/bbb')\n+          end)\n+        end)\n+        return fn.getreg('/')\n+      ]]\n+      eq('bbb', out)\n+    end)\n+  end)\n+\n+  describe('`lockmarks` context', function()\n+    it('works', function()\n+      local mark = exec_lua [[\n+        api.nvim_buf_set_lines(0, 0, 0, false, { 'aaa', 'bbb', 'ccc' })\n+        api.nvim_buf_set_mark(0, 'm', 2, 2, {})\n+        -- Should be same as `:lockmarks lua api.nvim_buf_set_lines(...)`\n+        vim._with({ lockmarks = true }, function()\n+          api.nvim_buf_set_lines(0, 0, 2, false, { 'uuu', 'vvv', 'www' })\n+        end)\n+        return api.nvim_buf_get_mark(0, 'm')\n+      ]]\n+      eq({ 2, 2 }, mark)\n+    end)\n+\n+    it('can be nested', function()\n+      local mark = exec_lua [[\n+        api.nvim_buf_set_lines(0, 0, 0, false, { 'aaa', 'bbb', 'ccc' })\n+        api.nvim_buf_set_mark(0, 'm', 2, 2, {})\n+        vim._with({ lockmarks = true }, function()\n+          vim._with({ lockmarks = false }, function()\n+            api.nvim_buf_set_lines(0, 0, 2, false, { 'uuu', 'vvv', 'www' })\n+          end)\n+        end)\n+        return api.nvim_buf_get_mark(0, 'm')\n+      ]]\n+      eq({ 0, 2 }, mark)\n+    end)\n+  end)\n+\n+  describe('`noautocmd` context', function()\n+    it('works', function()\n+      local out = exec_lua [[\n+        _G.n_events = 0\n+        vim.cmd('au ModeChanged * lua _G.n_events = _G.n_events + 1')\n+        -- Should be the same as `vim.cmd('noautocmd normal! vv')`\n+        vim._with({ noautocmd = true }, function()\n+          vim.cmd('normal! vv')\n+        end)\n+        return _G.n_events\n+      ]]\n+      eq(0, out)\n+    end)\n+\n+    it('works with User events', function()\n+      local out = exec_lua [[\n+        _G.n_events = 0\n+        vim.cmd('au User MyEvent lua _G.n_events = _G.n_events + 1')\n+        -- Should be the same as `vim.cmd('noautocmd doautocmd User MyEvent')`\n+        vim._with({ noautocmd = true }, function()\n+          api.nvim_exec_autocmds('User', { pattern = 'MyEvent' })\n+        end)\n+        return _G.n_events\n+      ]]\n+      eq(0, out)\n+    end)\n+\n+    pending('can be nested', function()\n+      local out = exec_lua [[\n+        _G.n_events = 0\n+        vim.cmd('au ModeChanged * lua _G.n_events = _G.n_events + 1')\n+        vim._with({ noautocmd = true }, function()\n+          vim._with({ noautocmd = false }, function()\n+            vim.cmd('normal! vv')\n+          end)\n+        end)\n+        return _G.n_events\n+      ]]\n+      eq(2, out)\n+    end)\n+  end)\n+\n+  describe('`o` context', function()\n+    before_each(function()\n+      exec_lua [[\n+        _G.other_win, _G.cur_win = setup_windows()\n+        _G.other_buf, _G.cur_buf = setup_buffers()\n+\n+        vim.bo[other_buf].commentstring = '## %s'\n+        vim.bo[cur_buf].commentstring = '// %s'\n+        vim.go.commentstring = '$$ %s'\n+\n+        vim.bo[other_buf].undolevels = 100\n+        vim.bo[cur_buf].undolevels = 250\n+        vim.go.undolevels = 500\n+\n+        vim.wo[other_win].virtualedit = 'block'\n+        vim.wo[cur_win].virtualedit = 'insert'\n+        vim.go.virtualedit = 'none'\n+\n+        vim.wo[other_win].winblend = 10\n+        vim.wo[cur_win].winblend = 25\n+        vim.go.winblend = 50\n+\n+        vim.go.langmap = 'xy,yx'\n+\n+        _G.get_state = function()\n+          return {\n+            bo = {\n+              cms_cur = vim.bo[cur_buf].commentstring,\n+              cms_other = vim.bo[other_buf].commentstring,\n+              ul_cur = vim.bo[cur_buf].undolevels,\n+              ul_other = vim.bo[other_buf].undolevels,\n+            },\n+            wo = {\n+              ve_cur = vim.wo[cur_win].virtualedit,\n+              ve_other = vim.wo[other_win].virtualedit,\n+              winbl_cur = vim.wo[cur_win].winblend,\n+              winbl_other = vim.wo[other_win].winblend,\n+            },\n+            go = {\n+              cms = vim.go.commentstring,\n+              ul = vim.go.undolevels,\n+              ve = vim.go.virtualedit,\n+              winbl = vim.go.winblend,\n+              lmap = vim.go.langmap,\n+            },\n+          }\n+        end\n+      ]]\n+    end)\n+\n+    it('works', function()\n+      local out = exec_lua [[\n+        local context = {\n+          o = {\n+            commentstring = '-- %s',\n+            undolevels = 0,\n+            virtualedit = 'all',\n+            winblend = 75,\n+            langmap = 'ab,ba',\n+          },\n+        }\n+\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_buf() == cur_buf)\n+          assert(api.nvim_get_current_win() == cur_win)\n+          return get_state()\n+        end)\n+\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      -- Options in context are set with `vim.o`, so usually both local\n+      -- and global values are affected. Yet all of them should be later\n+      -- restored to pre-context values.\n+      eq({\n+        bo = { cms_cur = '-- %s', cms_other = '## %s', ul_cur = -123456, ul_other = 100 },\n+        wo = { ve_cur = 'all', ve_other = 'block', winbl_cur = 75, winbl_other = 10 },\n+        go = { cms = '-- %s', ul = 0, ve = 'all', winbl = 75, lmap = 'ab,ba' },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('sets options in `buf` context', function()\n+      local out = exec_lua [[\n+        local context = { buf = other_buf, o = { commentstring = '-- %s', undolevels = 0 } }\n+\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_buf() == other_buf)\n+          return get_state()\n+        end)\n+\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms_cur = '// %s', cms_other = '-- %s', ul_cur = 250, ul_other = -123456 },\n+        wo = { ve_cur = 'insert', ve_other = 'block', winbl_cur = 25, winbl_other = 10 },\n+        -- Global `winbl` inside context ideally should be untouched and equal\n+        -- to 50. It seems to be equal to 0 because `context.buf` uses\n+        -- `aucmd_prepbuf` C approach which has no guarantees about window or\n+        -- window option values inside context.\n+        go = { cms = '-- %s', ul = 0, ve = 'none', winbl = 0, lmap = 'xy,yx' },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('sets options in `win` context', function()\n+      local out = exec_lua [[\n+        local context = { win = other_win, o = { winblend = 75, virtualedit = 'all' } }\n+\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_win() == other_win)\n+          return get_state()\n+        end)\n+\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms_cur = '// %s', cms_other = '## %s', ul_cur = 250, ul_other = 100 },\n+        wo = { winbl_cur = 25, winbl_other = 75, ve_cur = 'insert', ve_other = 'all' },\n+        go = { cms = '$$ %s', ul = 500, winbl = 75, ve = 'all', lmap = 'xy,yx' },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('restores only options from context', function()\n+      local out = exec_lua [[\n+        local context = { o = { undolevels = 0, winblend = 75, langmap = 'ab,ba' } }\n+\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_buf() == cur_buf)\n+          assert(api.nvim_get_current_win() == cur_win)\n+\n+          vim.o.commentstring = '!! %s'\n+          vim.o.undolevels = 750\n+          vim.o.virtualedit = 'onemore'\n+          vim.o.winblend = 99\n+          vim.o.langmap = 'uv,vu'\n+          return get_state()\n+        end)\n+\n+        return { inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        bo = { cms_cur = '!! %s', cms_other = '## %s', ul_cur = -123456, ul_other = 100 },\n+        wo = { ve_cur = 'onemore', ve_other = 'block', winbl_cur = 99, winbl_other = 10 },\n+        go = { cms = '!! %s', ul = 750, ve = 'onemore', winbl = 99, lmap = 'uv,vu' },\n+      }, out.inner)\n+      eq({\n+        bo = { cms_cur = '!! %s', cms_other = '## %s', ul_cur = 250, ul_other = 100 },\n+        wo = { ve_cur = 'onemore', ve_other = 'block', winbl_cur = 25, winbl_other = 10 },\n+        go = { cms = '!! %s', ul = 500, ve = 'onemore', winbl = 50, lmap = 'xy,yx' },\n+      }, out.after)\n+    end)\n+\n+    it('does not trigger events', function()\n+      exec_lua [[\n+        _G.test_events = {\n+          'BufEnter', 'BufLeave', 'WinEnter', 'WinLeave', 'BufWinEnter', 'BufWinLeave'\n+        }\n+        _G.test_context = { o = { undolevels = 0, winblend = 75, langmap = 'ab,ba' } }\n+        _G.test_trig_event = function() vim.cmd.new() end\n+      ]]\n+      validate_events_trigger()\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        local before, before_inner, after_inner = get_state(), nil, nil\n+        local cxt_o = { commentstring = '-- %s', winblend = 75, langmap = 'ab,ba', undolevels = 0 }\n+        vim._with({ o = cxt_o }, function()\n+          before_inner = get_state()\n+          local inner_cxt_o = { commentstring = '!! %s', winblend = 99, langmap = 'uv,vu' }\n+          inner = vim._with({ o = inner_cxt_o }, get_state)\n+          after_inner = get_state()\n+        end)\n+        return {\n+          before = before, before_inner = before_inner,\n+          inner = inner,\n+          after_inner = after_inner, after = get_state(),\n+        }\n+      ]]\n+      eq('!! %s', out.inner.bo.cms_cur)\n+      eq(99, out.inner.wo.winbl_cur)\n+      eq('uv,vu', out.inner.go.lmap)\n+      eq(0, out.inner.go.ul)\n+      eq(out.before_inner, out.after_inner)\n+      eq(out.before, out.after)\n+    end)\n+  end)\n+\n+  describe('`sandbox` context', function()\n+    it('works', function()\n+      local ok, err = pcall(\n+        exec_lua,\n+        [[\n+          -- Should work as `vim.cmd('sandbox call append(0, \"aaa\")')`\n+          vim._with({ sandbox = true }, function()\n+            fn.append(0, 'aaa')\n+          end)\n+        ]]\n+      )\n+      eq(false, ok)\n+      matches('Not allowed in sandbox', err)\n+    end)\n+\n+    it('can NOT be nested', function()\n+      -- This behavior is intentionally different from other flags as allowing\n+      -- disabling `sandbox` from nested function seems to be against the point\n+      -- of using `sandbox` context in the first place\n+      local ok, err = pcall(\n+        exec_lua,\n+        [[\n+          vim._with({ sandbox = true }, function()\n+            vim._with({ sandbox = false }, function()\n+              fn.append(0, 'aaa')\n             end)\n           end)\n+        ]]\n+      )\n+      eq(false, ok)\n+      matches('Not allowed in sandbox', err)\n+    end)\n+  end)\n+\n+  describe('`silent` context', function()\n+    it('works', function()\n+      exec_lua [[\n+        -- Should be same as `vim.cmd('silent lua print(\"aaa\")')`\n+        vim._with({ silent = true }, function() print('aaa') end)\n+      ]]\n+      eq('', exec_capture('messages'))\n+\n+      exec_lua [[ vim._with({ silent = true }, function() vim.cmd.echomsg('\"bbb\"') end) ]]\n+      eq('', exec_capture('messages'))\n+\n+      local screen = Screen.new(20, 5)\n+      screen:set_default_attr_ids {\n+        [1] = { bold = true, reverse = true },\n+        [2] = { bold = true, foreground = Screen.colors.Blue },\n+      }\n+      screen:attach()\n+      exec_lua [[ vim._with({ silent = true }, function() vim.cmd.echo('\"ccc\"') end) ]]\n+      screen:expect [[\n+        ^                    |\n+        {2:~                   }|*3\n+                            |\n+      ]]\n+    end)\n+\n+    pending('can be nested', function()\n+      exec_lua [[ vim._with({ silent = true }, function()\n+        vim._with({ silent = false }, function()\n+          print('aaa')\n         end)\n-      end)\n+      end)]]\n+      eq('aaa', exec_capture('messages'))\n     end)\n-    ]])\n-    )\n   end)\n \n-  it('can return values by reference', function()\n-    eq(\n-      { 4, 7 },\n+  describe('`unsilent` context', function()\n+    it('works', function()\n       exec_lua [[\n-      local val = {4, 10}\n-      local ref = vim._with({ buf = 0}, function() return val end)\n-      ref[2] = 7\n-      return val\n-    ]]\n-    )\n+        _G.f = function()\n+          -- Should be same as `vim.cmd('unsilent lua print(\"aaa\")')`\n+          vim._with({ unsilent = true }, function() print('aaa') end)\n+        end\n+      ]]\n+      command('silent lua f()')\n+      eq('aaa', exec_capture('messages'))\n+    end)\n+\n+    pending('can be nested', function()\n+      exec_lua [[\n+        _G.f = function()\n+          vim._with({ unsilent = true }, function()\n+            vim._with({ unsilent = false }, function() print('aaa') end)\n+          end)\n+        end\n+      ]]\n+      command('silent lua f()')\n+      eq('', exec_capture('messages'))\n+    end)\n   end)\n-end)\n \n-describe('vim._with {win = }', function()\n-  it('does not trigger autocmd', function()\n-    exec_lua [[\n-      local old = vim.api.nvim_get_current_win()\n-      vim.cmd(\"new\")\n-      local new = vim.api.nvim_get_current_win()\n-      vim.api.nvim_create_autocmd( { 'WinEnter', 'WinLeave' }, {\n-        callback = function() _G.n = (_G.n or 0) + 1 end\n-      })\n-      vim._with({win = old}, function()\n-      end)\n-      assert(_G.n == nil)\n+  describe('`win` context', function()\n+    it('works', function()\n+      local out = exec_lua [[\n+        local other_win, cur_win = setup_windows()\n+        local inner = vim._with({ win = other_win }, function()\n+          return api.nvim_get_current_win()\n+        end)\n+        return { inner == other_win, api.nvim_get_current_win() == cur_win }\n+      ]]\n+      eq({ true, true }, out)\n+    end)\n+\n+    it('does not trigger events', function()\n+      exec_lua [[\n+        _G.test_events = { 'WinEnter', 'WinLeave', 'BufWinEnter', 'BufWinLeave' }\n+        _G.test_context = { win = other_win }\n+        _G.test_trig_event = function() vim.cmd.new() end\n+      ]]\n+      validate_events_trigger()\n+    end)\n+\n+    it('can access window options', function()\n+      local out = exec_lua [[\n+        local other_win, cur_win = setup_windows()\n+        vim.wo[other_win].winblend = 10\n+        vim.wo[cur_win].winblend = 25\n+\n+        vim._with({ win = other_win }, function()\n+          vim.cmd.setlocal('winblend=0')\n+        end)\n+\n+        return vim.wo[other_win].winblend == 0 and vim.wo[cur_win].winblend == 25\n+      ]]\n+      eq(true, out)\n+    end)\n+\n+    it('works with different kinds of windows', function()\n+      exec_lua [[\n+        local validate = function(win)\n+          vim._with({ win = win }, function()\n+            assert(api.nvim_get_current_win() == win)\n+          end)\n+        end\n+\n+        -- Current\n+        validate(api.nvim_get_current_win())\n+\n+        -- Not visible\n+        local other_win, cur_win = setup_windows()\n+        vim.cmd.tabnew()\n+        validate(other_win)\n+\n+        -- Floating\n+        local float_win = api.nvim_open_win(\n+          api.nvim_create_buf(false, true),\n+          false,\n+          { relative = 'editor', row = 1, col = 1, height = 5, width = 5}\n+        )\n+        validate(float_win)\n+      ]]\n+    end)\n+\n+    it('does not cause ml_get errors with invalid visual selection', function()\n+      exec_lua [[\n+        local feedkeys = function(keys) api.nvim_feedkeys(vim.keycode(keys), 'txn', false) end\n+\n+        -- Add lines to the current buffer and make another window looking into an empty buffer.\n+        local win_empty, win_lines = setup_windows()\n+        api.nvim_buf_set_lines(0, 0, -1, true, { 'a', 'b', 'c' })\n+\n+        -- Start Visual in current window, redraw in other window with fewer lines.\n+        -- Should be fixed by vim-patch:8.2.4018.\n+        feedkeys('G<C-V>')\n+        vim._with({ win = win_empty }, function() vim.cmd.redraw() end)\n+\n+        -- Start Visual in current window, extend it in other window with more lines.\n+        -- Fixed for win_execute by vim-patch:8.2.4026, but nvim_win_call should also not be affected.\n+        feedkeys('<Esc>gg')\n+        api.nvim_set_current_win(win_empty)\n+        feedkeys('gg<C-V>')\n+        vim._with({ win = win_lines }, function() feedkeys('G<C-V>') end)\n+        vim.cmd.redraw()\n+      ]]\n+    end)\n+\n+    it('can be nested', function()\n+      exec_lua [[\n+        local other_win, cur_win = setup_windows()\n+        vim._with({ win = other_win }, function()\n+          assert(api.nvim_get_current_win() == other_win)\n+          inner = vim._with({ win = cur_win }, function()\n+            assert(api.nvim_get_current_win() == cur_win)\n+          end)\n+          assert(api.nvim_get_current_win() == other_win)\n+        end)\n+        assert(api.nvim_get_current_win() == cur_win)\n+      ]]\n+    end)\n+\n+    it('updates ruler if cursor moved', function()\n+      local screen = Screen.new(30, 5)\n+      screen:set_default_attr_ids {\n+        [1] = { reverse = true },\n+        [2] = { bold = true, reverse = true },\n+      }\n+      screen:attach()\n+      exec_lua [[\n+        vim.opt.ruler = true\n+        local lines = {}\n+        for i = 0, 499 do lines[#lines + 1] = tostring(i) end\n+        api.nvim_buf_set_lines(0, 0, -1, true, lines)\n+        api.nvim_win_set_cursor(0, { 20, 0 })\n+        vim.cmd 'split'\n+        _G.win = api.nvim_get_current_win()\n+        vim.cmd \"wincmd w | redraw\"\n+      ]]\n+      screen:expect [[\n+        19                            |\n+        {1:[No Name] [+]  20,1         3%}|\n+        ^19                            |\n+        {2:[No Name] [+]  20,1         3%}|\n+                                      |\n+      ]]\n+      exec_lua [[\n+        vim._with({ win = win }, function() api.nvim_win_set_cursor(0, { 100, 0 }) end)\n+        vim.cmd \"redraw\"\n+      ]]\n+      screen:expect [[\n+        99                            |\n+        {1:[No Name] [+]  100,1       19%}|\n+        ^19                            |\n+        {2:[No Name] [+]  20,1         3%}|\n+                                      |\n+      ]]\n+    end)\n+\n+    it('layout in current tabpage does not affect windows in others', function()\n+      command('tab split')\n+      local t2_move_win = api.nvim_get_current_win()\n+      command('vsplit')\n+      local t2_other_win = api.nvim_get_current_win()\n+      command('tabprevious')\n+      matches('E36: Not enough room$', pcall_err(command, 'execute \"split|\"->repeat(&lines)'))\n+      command('vsplit')\n+\n+      exec_lua('vim._with({ win = ... }, function() vim.cmd.wincmd \"J\" end)', t2_move_win)\n+      eq({ 'col', { { 'leaf', t2_other_win }, { 'leaf', t2_move_win } } }, fn.winlayout(2))\n+    end)\n+  end)\n+\n+  describe('`wo` context', function()\n+    before_each(function()\n+      exec_lua [[\n+        _G.other_win, _G.cur_win = setup_windows()\n+\n+        -- 'virtualedit' is global or local to window (global-local) and string\n+        vim.wo[other_win].virtualedit = 'block'\n+        vim.wo[cur_win].virtualedit = 'insert'\n+        vim.go.virtualedit = 'none'\n+\n+        -- 'winblend' is local to window and number\n+        vim.wo[other_win].winblend = 10\n+        vim.wo[cur_win].winblend = 25\n+        vim.go.winblend = 50\n+\n+        _G.get_state = function()\n+          return {\n+            wo = {\n+              ve_cur = vim.wo[cur_win].virtualedit,\n+              ve_other = vim.wo[other_win].virtualedit,\n+              winbl_cur = vim.wo[cur_win].winblend,\n+              winbl_other = vim.wo[other_win].winblend,\n+            },\n+            go = {\n+              ve = vim.go.virtualedit,\n+              winbl = vim.go.winblend,\n+            },\n+          }\n+        end\n+      ]]\n+    end)\n+\n+    it('works', function()\n+      local out = exec_lua [[\n+        local context = { wo = { virtualedit = 'all', winblend = 75 } }\n+\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_win() == cur_win)\n+          return get_state()\n+        end)\n+\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        wo = { ve_cur = 'all', ve_other = 'block', winbl_cur = 75, winbl_other = 10 },\n+        go = { ve = 'none', winbl = 75 },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('sets options in `win` context', function()\n+      local out = exec_lua [[\n+        local context = { win = other_win, wo = { virtualedit = 'all', winblend = 75 } }\n+\n+        local before = get_state()\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_win() == other_win)\n+          return get_state()\n+        end)\n+\n+        return { before = before, inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        wo = { ve_cur = 'insert', ve_other = 'all', winbl_cur = 25, winbl_other = 75 },\n+        go = { ve = 'none', winbl = 75 },\n+      }, out.inner)\n+      eq(out.before, out.after)\n+    end)\n+\n+    it('restores only options from context', function()\n+      local out = exec_lua [[\n+        local context = { wo = { winblend = 75 } }\n+\n+        local inner = vim._with(context, function()\n+          assert(api.nvim_get_current_win() == cur_win)\n+          vim.wo[cur_win].virtualedit = 'onemore'\n+          vim.wo[cur_win].winblend = 99\n+          return get_state()\n+        end)\n+\n+        return { inner = inner, after = get_state() }\n+      ]]\n+\n+      eq({\n+        wo = { ve_cur = 'onemore', ve_other = 'block', winbl_cur = 99, winbl_other = 10 },\n+        go = { ve = 'none', winbl = 99 },\n+      }, out.inner)\n+      eq({\n+        wo = { ve_cur = 'onemore', ve_other = 'block', winbl_cur = 25, winbl_other = 10 },\n+        go = { ve = 'none', winbl = 50 },\n+      }, out.after)\n+    end)\n+\n+    it('does not trigger events', function()\n+      exec_lua [[\n+        _G.test_events = { 'WinEnter', 'WinLeave', 'BufWinEnter', 'BufWinLeave' }\n+        _G.test_context = { wo = { winblend = 75 } }\n+        _G.test_trig_event = function() vim.cmd.new() end\n+      ]]\n+      validate_events_trigger()\n+    end)\n+\n+    it('can be nested', function()\n+      local out = exec_lua [[\n+        local before, before_inner, after_inner = get_state(), nil, nil\n+        vim._with({ wo = { winblend = 75, virtualedit = 'all' } }, function()\n+          before_inner = get_state()\n+          inner = vim._with({ wo = { winblend = 99 } }, get_state)\n+          after_inner = get_state()\n+        end)\n+        return {\n+          before = before, before_inner = before_inner,\n+          inner = inner,\n+          after_inner = after_inner, after = get_state(),\n+        }\n+      ]]\n+      eq(99, out.inner.wo.winbl_cur)\n+      eq('all', out.inner.wo.ve_cur)\n+      eq(out.before_inner, out.after_inner)\n+      eq(out.before, out.after)\n+    end)\n+  end)\n+\n+  it('returns what callback returns', function()\n+    local out_verify = exec_lua [[\n+      out = { vim._with({}, function()\n+        return 'a', 2, nil, { 4 }, function() end\n+      end) }\n+      return {\n+        out[1] == 'a', out[2] == 2, out[3] == nil,\n+        vim.deep_equal(out[4], { 4 }),\n+        type(out[5]) == 'function',\n+        vim.tbl_count(out),\n+      }\n     ]]\n+    eq({ true, true, true, true, true, 4 }, out_verify)\n   end)\n \n-  it('trigger autocmd if changed within context', function()\n-    exec_lua [[\n-      local old = vim.api.nvim_get_current_win()\n-      vim.cmd(\"new\")\n-      local new = vim.api.nvim_get_current_win()\n-      vim.api.nvim_create_autocmd( { 'WinEnter', 'WinLeave' }, {\n-        callback = function() _G.n = (_G.n or 0) + 1 end\n-      })\n-      vim._with({}, function()\n-        vim.api.nvim_set_current_win(old)\n-        assert(_G.n ~= nil)\n-      end)\n+  it('can return values by reference', function()\n+    local out = exec_lua [[\n+      local val = { 4, 10 }\n+      local ref = vim._with({}, function() return val end)\n+      ref[1] = 7\n+      return val\n     ]]\n+    eq({ 7, 10 }, out)\n   end)\n \n-  it('can access window options', function()\n-    command('vsplit')\n-    local win1 = api.nvim_get_current_win()\n-    command('wincmd w')\n-    local win2 = exec_lua [[\n-      win2 = vim.api.nvim_get_current_win()\n-      return win2\n+  it('can not work with conflicting `buf` and `win`', function()\n+    local out = exec_lua [[\n+      local other_buf, cur_buf = setup_buffers()\n+      local other_win, cur_win = setup_windows()\n+      assert(api.nvim_win_get_buf(other_win) ~= other_buf)\n+      local _, err = pcall(vim._with, { buf = other_buf, win = other_win }, function() end)\n+      return err\n     ]]\n-    command('wincmd p')\n+    matches('Can not set both `buf` and `win`', out)\n+  end)\n \n-    eq('', api.nvim_get_option_value('winhighlight', { win = win1 }))\n-    eq('', api.nvim_get_option_value('winhighlight', { win = win2 }))\n+  it('works with several contexts at once', function()\n+    local out = exec_lua [[\n+      local other_buf, cur_buf = setup_buffers()\n+      vim.bo[other_buf].commentstring = '## %s'\n+      api.nvim_buf_set_lines(other_buf, 0, -1, false, { 'aaa', 'bbb', 'ccc' })\n+      api.nvim_buf_set_mark(other_buf, 'm', 2, 2, {})\n \n-    local val = exec_lua [[\n-      return vim._with({win = win2}, function()\n-        vim.cmd \"setlocal winhighlight=Normal:Normal\"\n-        return vim.api.nvim_get_current_win()\n+      vim.go.commentstring = '// %s'\n+      vim.go.langmap = 'xy,yx'\n+\n+      local context = {\n+        buf = other_buf,\n+        bo = { commentstring = '-- %s' },\n+        go = { langmap = 'ab,ba' },\n+        lockmarks = true,\n+      }\n+\n+      local inner = vim._with(context, function()\n+        api.nvim_buf_set_lines(0, 0, -1, false, { 'uuu', 'vvv', 'www' })\n+        return {\n+          buf = api.nvim_get_current_buf(),\n+          bo = { cms = vim.bo.commentstring },\n+          go = { cms = vim.go.commentstring, lmap = vim.go.langmap },\n+          mark = api.nvim_buf_get_mark(0, 'm')\n+        }\n       end)\n+\n+      local after = {\n+        buf = api.nvim_get_current_buf(),\n+        bo = { cms = vim.bo[other_buf].commentstring },\n+        go = { cms = vim.go.commentstring, lmap = vim.go.langmap },\n+        mark = api.nvim_buf_get_mark(other_buf, 'm')\n+      }\n+\n+      return {\n+        context_buf = other_buf, cur_buf = cur_buf,\n+        inner = inner, after = after\n+      }\n     ]]\n \n-    eq('', api.nvim_get_option_value('winhighlight', { win = win1 }))\n-    eq('Normal:Normal', api.nvim_get_option_value('winhighlight', { win = win2 }))\n-    eq(win1, api.nvim_get_current_win())\n-    eq(win2, val)\n+    eq({\n+      buf = out.context_buf,\n+      bo = { cms = '-- %s' },\n+      go = { cms = '// %s', lmap = 'ab,ba' },\n+      mark = { 2, 2 },\n+    }, out.inner)\n+    eq({\n+      buf = out.cur_buf,\n+      bo = { cms = '## %s' },\n+      go = { cms = '// %s', lmap = 'xy,yx' },\n+      mark = { 2, 2 },\n+    }, out.after)\n   end)\n \n-  it('does not cause ml_get errors with invalid visual selection', function()\n-    -- Add lines to the current buffer and make another window looking into an empty buffer.\n-    exec_lua [[\n-      _G.api = vim.api\n-      _G.t = function(s) return api.nvim_replace_termcodes(s, true, true, true) end\n-      _G.win_lines = api.nvim_get_current_win()\n-      vim.cmd \"new\"\n-      _G.win_empty = api.nvim_get_current_win()\n-      api.nvim_set_current_win(win_lines)\n-      api.nvim_buf_set_lines(0, 0, -1, true, {\"a\", \"b\", \"c\"})\n-    ]]\n+  it('works with same option set in different contexts', function()\n+    local out = exec_lua [[\n+      local get_state = function()\n+        return {\n+          bo = { cms = vim.bo.commentstring },\n+          wo = { ve = vim.wo.virtualedit },\n+          go = { cms = vim.go.commentstring, ve = vim.go.virtualedit },\n+        }\n+      end\n \n-    -- Start Visual in current window, redraw in other window with fewer lines.\n-    exec_lua [[\n-      api.nvim_feedkeys(t \"G<C-V>\", \"txn\", false)\n-      vim._with({win = win_empty}, function() vim.cmd \"redraw\" end)\n-    ]]\n+      vim.bo.commentstring = '// %s'\n+      vim.go.commentstring = '$$ %s'\n+      vim.wo.virtualedit = 'insert'\n+      vim.go.virtualedit = 'none'\n \n-    -- Start Visual in current window, extend it in other window with more lines.\n-    exec_lua [[\n-      api.nvim_feedkeys(t \"<Esc>gg\", \"txn\", false)\n-      api.nvim_set_current_win(win_empty)\n-      api.nvim_feedkeys(t \"gg<C-V>\", \"txn\", false)\n-      vim._with({win = win_lines}, function() api.nvim_feedkeys(t \"G<C-V>\", \"txn\", false) end)\n-      vim.cmd \"redraw\"\n+      local before = get_state()\n+      local context_no_go = {\n+        o = { commentstring = '-- %s', virtualedit = 'all' },\n+        bo = { commentstring = '!! %s' },\n+        wo = { virtualedit = 'onemore' },\n+      }\n+      local inner_no_go = vim._with(context_no_go, get_state)\n+      local middle = get_state()\n+      local context_with_go = {\n+        o = { commentstring = '-- %s', virtualedit = 'all' },\n+        bo = { commentstring = '!! %s' },\n+        wo = { virtualedit = 'onemore' },\n+        go = { commentstring = '@@ %s', virtualedit = 'block' },\n+      }\n+      local inner_with_go = vim._with(context_with_go, get_state)\n+      return {\n+        before = before,\n+        inner_no_go = inner_no_go,\n+        middle = middle,\n+        inner_with_go = inner_with_go,\n+        after = get_state(),\n+      }\n     ]]\n+\n+    -- Should prefer explicit local scopes instead of `o`\n+    eq({\n+      bo = { cms = '!! %s' },\n+      wo = { ve = 'onemore' },\n+      go = { cms = '-- %s', ve = 'all' },\n+    }, out.inner_no_go)\n+    eq(out.before, out.middle)\n+\n+    -- Should prefer explicit global scopes instead of `o`\n+    eq({\n+      bo = { cms = '!! %s' },\n+      wo = { ve = 'onemore' },\n+      go = { cms = '@@ %s', ve = 'block' },\n+    }, out.inner_with_go)\n+    eq(out.middle, out.after)\n   end)\n \n-  it('updates ruler if cursor moved', function()\n-    local screen = Screen.new(30, 5)\n-    screen:set_default_attr_ids {\n-      [1] = { reverse = true },\n-      [2] = { bold = true, reverse = true },\n-    }\n-    screen:attach()\n-    exec_lua [[\n-      _G.api = vim.api\n-      vim.opt.ruler = true\n-      local lines = {}\n-      for i = 0, 499 do lines[#lines + 1] = tostring(i) end\n-      api.nvim_buf_set_lines(0, 0, -1, true, lines)\n-      api.nvim_win_set_cursor(0, {20, 0})\n-      vim.cmd \"split\"\n-      _G.win = api.nvim_get_current_win()\n-      vim.cmd \"wincmd w | redraw\"\n-    ]]\n-    screen:expect [[\n-      19                            |\n-      {1:[No Name] [+]  20,1         3%}|\n-      ^19                            |\n-      {2:[No Name] [+]  20,1         3%}|\n-                                    |\n-    ]]\n-    exec_lua [[\n-      vim._with({win = win}, function() api.nvim_win_set_cursor(0, {100, 0}) end)\n-      vim.cmd \"redraw\"\n-    ]]\n-    screen:expect [[\n-      99                            |\n-      {1:[No Name] [+]  100,1       19%}|\n-      ^19                            |\n-      {2:[No Name] [+]  20,1         3%}|\n-                                    |\n+  pending('can forward command modifiers to user command', function()\n+    local out = exec_lua [[\n+      local test_flags = {\n+        'emsg_silent',\n+        'hide',\n+        'keepalt',\n+        'keepjumps',\n+        'keepmarks',\n+        'keeppatterns',\n+        'lockmarks',\n+        'noautocmd',\n+        'silent',\n+        'unsilent',\n+      }\n+\n+      local used_smods\n+      local command = function(data)\n+        used_smods = data.smods\n+      end\n+      api.nvim_create_user_command('DummyLog', command, {})\n+\n+      local res = {}\n+      for _, flag in ipairs(test_flags) do\n+        used_smods = nil\n+        vim._with({ [flag] = true }, function() vim.cmd('DummyLog') end)\n+        res[flag] = used_smods[flag]\n+      end\n+      return res\n     ]]\n+    for k, v in pairs(out) do\n+      eq({ k, true }, { k, v })\n+    end\n   end)\n \n-  it('can return values by reference', function()\n-    eq(\n-      { 7, 10 },\n-      exec_lua [[\n-      local val = {4, 10}\n-      local ref = vim._with({win = 0}, function() return val end)\n-      ref[1] = 7\n-      return val\n+  it('handles error in callback', function()\n+    -- Should still restore initial context\n+    local out_buf = exec_lua [[\n+      local other_buf, cur_buf = setup_buffers()\n+      vim.bo[other_buf].commentstring = '## %s'\n+\n+      local context = { buf = other_buf, bo = { commentstring = '-- %s' } }\n+      local ok, err = pcall(vim._with, context, function() error('Oops buf', 0) end)\n+\n+      return {\n+        ok,\n+        err,\n+        api.nvim_get_current_buf() == cur_buf,\n+        vim.bo[other_buf].commentstring,\n+      }\n+    ]]\n+    eq({ false, 'Oops buf', true, '## %s' }, out_buf)\n+\n+    local out_win = exec_lua [[\n+      local other_win, cur_win = setup_windows()\n+      vim.wo[other_win].winblend = 25\n+\n+      local context = { win = other_win, wo = { winblend = 50 } }\n+      local ok, err = pcall(vim._with, context, function() error('Oops win', 0) end)\n+\n+      return {\n+        ok,\n+        err,\n+        api.nvim_get_current_win() == cur_win,\n+        vim.wo[other_win].winblend,\n+      }\n     ]]\n-    )\n+    eq({ false, 'Oops win', true, 25 }, out_win)\n   end)\n \n-  it('layout in current tabpage does not affect windows in others', function()\n-    command('tab split')\n-    local t2_move_win = api.nvim_get_current_win()\n-    command('vsplit')\n-    local t2_other_win = api.nvim_get_current_win()\n-    command('tabprevious')\n-    matches('E36: Not enough room$', pcall_err(command, 'execute \"split|\"->repeat(&lines)'))\n-    command('vsplit')\n-\n-    exec_lua('vim._with({win = ...}, function() vim.cmd.wincmd \"J\" end)', t2_move_win)\n-    eq({ 'col', { { 'leaf', t2_other_win }, { 'leaf', t2_move_win } } }, fn.winlayout(2))\n+  it('handles not supported option', function()\n+    local out = exec_lua [[\n+      -- Should still restore initial state\n+      vim.bo.commentstring = '## %s'\n+\n+      local context = { o = { commentstring = '-- %s' }, bo = { winblend = 10 } }\n+      local ok, err = pcall(vim._with, context, function() end)\n+\n+      return { ok = ok, err = err, cms = vim.bo.commentstring }\n+    ]]\n+    eq(false, out.ok)\n+    matches('window.*option.*winblend', out.err)\n+    eq('## %s', out.cms)\n   end)\n-end)\n \n-describe('vim._with {lockmarks = true}', function()\n-  it('is reset', function()\n-    local mark = exec_lua [[\n-      vim.api.nvim_buf_set_lines(0, 0, 0, false, {\"marky\", \"snarky\", \"malarkey\"})\n-      vim.api.nvim_buf_set_mark(0,\"m\",1,0, {})\n-      vim._with({lockmarks = true}, function()\n-        vim.api.nvim_buf_set_lines(0, 0, 2, false, {\"mass\", \"mess\", \"moss\"})\n-      end)\n-      return vim.api.nvim_buf_get_mark(0,\"m\")\n+  it('validates arguments', function()\n+    exec_lua [[\n+      _G.get_error = function(...)\n+        local _, err = pcall(vim._with, ...)\n+        return err or ''\n+      end\n     ]]\n-    t.eq(mark, { 1, 0 })\n+    local get_error = function(string_args)\n+      return exec_lua('return get_error(' .. string_args .. ')')\n+    end\n+\n+    matches('context.*table', get_error(\"'a', function() end\"))\n+    matches('f.*function', get_error('{}, 1'))\n+\n+    local validate_context = function(bad_context, expected_type)",
            "html_url": "https://github.com/neovim/neovim/pull/29280#discussion_r1651378667",
            "id": 1651378667,
            "in_reply_to_id": 1651190086,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ibgnr",
            "original_commit_id": "15b5f2fc957a8ad3a21e52d455e7ee157e5c53b3",
            "original_line": 1596,
            "original_position": 1814,
            "original_start_line": null,
            "path": "test/functional/lua/with_spec.lua",
            "position": null,
            "pull_request_review_id": 2136375945,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1651378667/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-06-24T17:24:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1651378667",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "This is super valuable. Thanks for championing this.\r\n\r\nFollow-up work (not necessarily by you, I'm talking in general): ensure all the tests marked as `pending` passes. It looks like it involved primarily ensuring that `vim._with` can be nested which will need adjustments in the C code.",
            "created_at": "2024-06-26T10:26:10Z",
            "html_url": "https://github.com/neovim/neovim/pull/29280#issuecomment-2191349716",
            "id": 2191349716,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/29280",
            "node_id": "IC_kwDOAPphoM6CnVfU",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2191349716/reactions"
            },
            "updated_at": "2024-06-26T10:26:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2191349716",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> Follow-up work (not necessarily by you, I'm talking in general): ensure all the tests marked as `pending` passes. It looks like it involved primarily ensuring that `vim._with` can be nested which will need adjustments in the C code.\r\n\r\nNot only those, I am afraid. Quite a few context fields coming from command modifiers don't seem to work:\r\n- [`emsg_silent`](https://github.com/neovim/neovim/blob/76dd07e572935742f6dfa0d3364e262ebc047dcc/test/functional/lua/with_spec.lua#L306)\r\n- [`hide`](https://github.com/neovim/neovim/blob/76dd07e572935742f6dfa0d3364e262ebc047dcc/test/functional/lua/with_spec.lua#L512)\r\n- [`horizontal`](https://github.com/neovim/neovim/blob/76dd07e572935742f6dfa0d3364e262ebc047dcc/test/functional/lua/with_spec.lua#L565) (although it is not even implemented in C part)\r\n- [`keepalt`](https://github.com/neovim/neovim/blob/76dd07e572935742f6dfa0d3364e262ebc047dcc/test/functional/lua/with_spec.lua#L591)\r\n- [`keepjumps`](https://github.com/neovim/neovim/blob/76dd07e572935742f6dfa0d3364e262ebc047dcc/test/functional/lua/with_spec.lua#L625)\r\n- [`keepmarks`](https://github.com/neovim/neovim/blob/76dd07e572935742f6dfa0d3364e262ebc047dcc/test/functional/lua/with_spec.lua#L654)\r\n- [`keeppatterns`](https://github.com/neovim/neovim/blob/76dd07e572935742f6dfa0d3364e262ebc047dcc/test/functional/lua/with_spec.lua#L687)\r\n\r\nSoo... basically most part of the flags :)",
            "created_at": "2024-06-26T10:33:36Z",
            "html_url": "https://github.com/neovim/neovim/pull/29280#issuecomment-2191362369",
            "id": 2191362369,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/29280",
            "node_id": "IC_kwDOAPphoM6CnYlB",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2191362369/reactions"
            },
            "updated_at": "2024-06-26T10:33:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2191362369",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/29280/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/29280/commits",
    "created_at": "2024-06-11T09:09:35Z",
    "diff_url": "https://github.com/neovim/neovim/pull/29280.diff",
    "draft": false,
    "head": {
        "label": "echasnovski:with-owobogo",
        "ref": "with-owobogo",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/echasnovski/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/echasnovski/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/echasnovski/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/echasnovski/neovim/branches{/branch}",
            "clone_url": "https://github.com/echasnovski/neovim.git",
            "collaborators_url": "https://api.github.com/repos/echasnovski/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/echasnovski/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/echasnovski/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/echasnovski/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/echasnovski/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/echasnovski/neovim/contributors",
            "created_at": "2021-12-02T09:43:59Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/echasnovski/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/echasnovski/neovim/downloads",
            "events_url": "https://api.github.com/repos/echasnovski/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/echasnovski/neovim/forks",
            "full_name": "echasnovski/neovim",
            "git_commits_url": "https://api.github.com/repos/echasnovski/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/echasnovski/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/echasnovski/neovim/git/tags{/sha}",
            "git_url": "git://github.com/echasnovski/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/echasnovski/neovim/hooks",
            "html_url": "https://github.com/echasnovski/neovim",
            "id": 434162461,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/echasnovski/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/echasnovski/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/echasnovski/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/echasnovski/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/echasnovski/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/echasnovski/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/echasnovski/neovim/merges",
            "milestones_url": "https://api.github.com/repos/echasnovski/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOGeDLHQ",
            "notifications_url": "https://api.github.com/repos/echasnovski/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
                "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
                "followers_url": "https://api.github.com/users/echasnovski/followers",
                "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
                "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/echasnovski",
                "id": 24854248,
                "login": "echasnovski",
                "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
                "organizations_url": "https://api.github.com/users/echasnovski/orgs",
                "received_events_url": "https://api.github.com/users/echasnovski/received_events",
                "repos_url": "https://api.github.com/users/echasnovski/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/echasnovski"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/echasnovski/neovim/pulls{/number}",
            "pushed_at": "2024-06-27T06:43:23Z",
            "releases_url": "https://api.github.com/repos/echasnovski/neovim/releases{/id}",
            "size": 271151,
            "ssh_url": "git@github.com:echasnovski/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/echasnovski/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/echasnovski/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/echasnovski/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/echasnovski/neovim/subscription",
            "svn_url": "https://github.com/echasnovski/neovim",
            "tags_url": "https://api.github.com/repos/echasnovski/neovim/tags",
            "teams_url": "https://api.github.com/repos/echasnovski/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/echasnovski/neovim/git/trees{/sha}",
            "updated_at": "2024-06-27T06:43:28Z",
            "url": "https://api.github.com/repos/echasnovski/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "cd53db2157f0cd27877451a6b00d66e9bed74e73",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
            "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
            "followers_url": "https://api.github.com/users/echasnovski/followers",
            "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
            "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/echasnovski",
            "id": 24854248,
            "login": "echasnovski",
            "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
            "organizations_url": "https://api.github.com/users/echasnovski/orgs",
            "received_events_url": "https://api.github.com/users/echasnovski/received_events",
            "repos_url": "https://api.github.com/users/echasnovski/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/echasnovski"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/29280",
    "id": 1913952482,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/29280",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": "stdlib",
            "id": 573222693,
            "name": "lua",
            "node_id": "MDU6TGFiZWw1NzMyMjI2OTM=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lua"
        },
        {
            "color": "0052CC",
            "default": false,
            "description": "",
            "id": 6664957181,
            "name": "ci:skip-news",
            "node_id": "LA_kwDOAPphoM8AAAABjUMs_Q",
            "url": "https://api.github.com/repos/neovim/neovim/labels/ci:skip-news"
        }
    ],
    "locked": false,
    "merge_commit_sha": "76dd07e572935742f6dfa0d3364e262ebc047dcc",
    "merged_at": "2024-06-26T10:23:35Z",
    "milestone": null,
    "node_id": "PR_kwDOAPphoM5yFJji",
    "number": 29280,
    "patch_url": "https://github.com/neovim/neovim/pull/29280.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/29280/comments",
    "state": "closed",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/cd53db2157f0cd27877451a6b00d66e9bed74e73",
    "title": "Add several updates to `vim._with` (tests, granular option contexts, `env` context)",
    "updated_at": "2024-06-26T10:33:38Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/29280",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/24854248?v=4",
        "events_url": "https://api.github.com/users/echasnovski/events{/privacy}",
        "followers_url": "https://api.github.com/users/echasnovski/followers",
        "following_url": "https://api.github.com/users/echasnovski/following{/other_user}",
        "gists_url": "https://api.github.com/users/echasnovski/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/echasnovski",
        "id": 24854248,
        "login": "echasnovski",
        "node_id": "MDQ6VXNlcjI0ODU0MjQ4",
        "organizations_url": "https://api.github.com/users/echasnovski/orgs",
        "received_events_url": "https://api.github.com/users/echasnovski/received_events",
        "repos_url": "https://api.github.com/users/echasnovski/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/echasnovski/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/echasnovski/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/echasnovski"
    }
}