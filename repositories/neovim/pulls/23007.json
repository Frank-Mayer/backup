{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/23007/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/23007/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/23007"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/23007"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/23007/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/700509262c11156b180b24900c5224536ce9bd75"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 5142,
            "forks_count": 5142,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1740,
            "open_issues_count": 1740,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2024-01-16T01:33:17Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 247954,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 72793,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2024-01-16T01:52:35Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 72793,
            "watchers_count": 72793,
            "web_commit_signoff_required": false
        },
        "sha": "aab95ec67e4d80e63cc5c5acc42f3832e76e0781",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim"
        }
    },
    "body": "* Prefer pure Lua functions over vim.fn\n* Split up provider healthchecks into separate modules to help manage\n  complexity\n",
    "closed_at": "2024-01-01T18:06:19Z",
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1162977039"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1162977039"
                }
            },
            "author_association": "MEMBER",
            "body": "Users will be able to access this function. Should we perhaps add an underscore prefix to mark it's for internal use only?",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T15:15:58Z",
            "diff_hunk": "@@ -4,22 +4,140 @@ function M.report_start(msg)\n   vim.fn['health#report_start'](msg)\n end\n \n+M.start = M.report_start\n+\n function M.report_info(msg)\n   vim.fn['health#report_info'](msg)\n end\n \n+M.info = M.report_info\n+\n function M.report_ok(msg)\n   vim.fn['health#report_ok'](msg)\n end\n \n+M.ok = M.report_ok\n+\n function M.report_warn(msg, ...)\n   vim.fn['health#report_warn'](msg, ...)\n end\n \n+M.warn = M.report_warn\n+\n function M.report_error(msg, ...)\n   vim.fn['health#report_error'](msg, ...)\n end\n \n+M.error = M.report_error\n+\n+function M.provider_disabled(provider)",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1162977039",
            "id": 1162977039,
            "line": 33,
            "node_id": "PRRC_kwDOAPphoM5FUZ8P",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 33,
            "original_position": 30,
            "original_start_line": null,
            "path": "runtime/lua/vim/health.lua",
            "position": 30,
            "pull_request_review_id": 1379528195,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1162977039/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T15:21:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1162977039",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1162993718"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1162993718"
                }
            },
            "author_association": "MEMBER",
            "body": "In hindsight the `is_blank`/`:find` is unnecessary. The original function was `empty()` and reading the docs now it's only true if the length is zero, aka `''`. Feel free to replace these with `if str == ''` if you think it simplifies the code, I don't think they're needed.",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T15:28:40Z",
            "diff_hunk": "@@ -0,0 +1,39 @@\n+local health = vim.health\n+\n+local M = {}\n+\n+function M.check()\n+  health.start('Clipboard (optional)')\n+\n+  if\n+      os.getenv('TMUX')\n+      and vim.fn.executable('tmux') == 1\n+      and vim.fn.executable('pbpaste') == 1\n+      and not health.cmd_ok('pbpaste')\n+  then\n+    local tmux_version = string.match(vim.fn.system('tmux -V'), '%d+%.%d+')\n+    local advice = {\n+      'Install tmux 2.6+.  https://superuser.com/q/231130',\n+      'or use tmux with reattach-to-user-namespace.  https://superuser.com/a/413233',\n+    }\n+    health.error('pbcopy does not work with tmux version: ' .. tmux_version, advice)\n+  end\n+\n+  local clipboard_tool = vim.fn['provider#clipboard#Executable']()\n+  if vim.g.clipboard and clipboard_tool:find('^%s$') then",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1162993718",
            "id": 1162993718,
            "line": 23,
            "node_id": "PRRC_kwDOAPphoM5FUeA2",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 23,
            "original_position": 23,
            "original_start_line": null,
            "path": "runtime/lua/provider/clipboard/health.lua",
            "position": 23,
            "pull_request_review_id": 1379556383,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1162993718/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T15:29:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1162993718",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163006304"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163006304"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n      vim.fn.executable('node') == 0\r\n```",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T15:38:31Z",
            "diff_hunk": "@@ -0,0 +1,106 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+function M.check()\n+  health.start('Node.js provider (optional)')\n+\n+  if health.provider_disabled('node') then\n+    return\n+  end\n+\n+  if\n+      not vim.fn.executable('node') == 1",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163006304",
            "id": 1163006304,
            "line": 15,
            "node_id": "PRRC_kwDOAPphoM5FUhFg",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 15,
            "original_position": 15,
            "original_start_line": null,
            "path": "runtime/lua/provider/node/health.lua",
            "position": 15,
            "pull_request_review_id": 1379577706,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163006304/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T15:38:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163006304",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163009851"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163009851"
                }
            },
            "author_association": "MEMBER",
            "body": "I know I wrote this, but rereading it I think this can be simplified to\r\n\r\n```suggestion\r\n  local pcall_ok, pkg_data = pcall(vim.json.decode, latest_npm)\r\n  if not pcall_ok then\r\n    return 'error: ' .. latest_npm\r\n  end\r\n```",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T15:41:33Z",
            "diff_hunk": "@@ -0,0 +1,106 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+function M.check()\n+  health.start('Node.js provider (optional)')\n+\n+  if health.provider_disabled('node') then\n+    return\n+  end\n+\n+  if\n+      not vim.fn.executable('node') == 1\n+      or (vim.fn.executable('npm') == 0 and vim.fn.executable('yarn') == 0 and vim.fn.executable('pnpm') == 0)\n+  then\n+    health.warn(\n+      '`node` and `npm` (or `yarn`, `pnpm`) must be in $PATH.',\n+      'Install Node.js and verify that `node` and `npm` (or `yarn`, `pnpm`) commands work.'\n+    )\n+    return\n+  end\n+\n+  -- local node_v = vim.fn.split(system({'node', '-v'}), \"\\n\")[1] or ''\n+  local ok, node_v = health.cmd_ok({ 'node', '-v' })\n+  health.info('Node.js: ' .. node_v)\n+  if not ok or vim.version.lt(node_v, '6.0.0') then\n+    health.warn('Nvim node.js host does not support Node ' .. node_v)\n+    -- Skip further checks, they are nonsense if nodejs is too old.\n+    return\n+  end\n+  if vim.fn['provider#node#can_inspect']() == 0 then\n+    health.warn(\n+      'node.js on this system does not support --inspect-brk so $NVIM_NODE_HOST_DEBUG is ignored.'\n+    )\n+  end\n+\n+  local node_detect_table = vim.fn['provider#node#Detect']()\n+  local host = node_detect_table[1]\n+  if host:find('^%s*$') then\n+    health.warn('Missing \"neovim\" npm (or yarn, pnpm) package.', {\n+      'Run in shell: npm install -g neovim',\n+      'Run in shell (if you use yarn): yarn global add neovim',\n+      'Run in shell (if you use pnpm): pnpm install -g neovim',\n+      'You may disable this provider (and warning) by adding `let g:loaded_node_provider = 0` to your init.vim',\n+    })\n+    return\n+  end\n+  health.info('Nvim node.js host: ' .. host)\n+\n+  local manager = 'npm'\n+  if vim.fn.executable('yarn') == 1 then\n+    manager = 'yarn'\n+  elseif vim.fn.executable('pnpm') == 1 then\n+    manager = 'pnpm'\n+  end\n+\n+  local latest_npm_cmd = (\n+      iswin and 'cmd /c ' .. manager .. ' info neovim --json' or manager .. ' info neovim --json'\n+      )\n+  local ok, latest_npm = health.cmd_ok(vim.split(latest_npm_cmd, \" \"))\n+  if not ok or latest_npm:find('^%s$') then\n+    health.error(\n+      'Failed to run: ' .. latest_npm_cmd,\n+      { \"Make sure you're connected to the internet.\", 'Are you behind a firewall or proxy?' }\n+    )\n+    return\n+  end\n+\n+  local pcall_ok, output = pcall(vim.json.decode, latest_npm)\n+  local pkg_data\n+  if pcall_ok then\n+    pkg_data = output\n+  else\n+    return 'error: ' .. latest_npm\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163009851",
            "id": 1163009851,
            "line": 77,
            "node_id": "PRRC_kwDOAPphoM5FUh87",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 77,
            "original_position": 77,
            "original_start_line": 71,
            "path": "runtime/lua/provider/node/health.lua",
            "position": 77,
            "pull_request_review_id": 1379583885,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163009851/reactions"
            },
            "side": "RIGHT",
            "start_line": 71,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-04-11T15:41:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163009851",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163020648"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163020648"
                }
            },
            "author_association": "MEMBER",
            "body": "Nice call on replacing the `system()` calls to `cmd_ok`.",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T15:48:51Z",
            "diff_hunk": "@@ -0,0 +1,94 @@\n+local health = vim.health\n+\n+local M = {}\n+\n+function M.check()\n+  health.start('Perl provider (optional)')\n+\n+  if health.provider_disabled('perl') then\n+    return\n+  end\n+\n+  local perl_detect_table = vim.fn['provider#perl#Detect']()\n+  local perl_exec = perl_detect_table[1]\n+  local perl_warnings = perl_detect_table[2]\n+\n+  if perl_exec:find('^%s*$') then\n+    if perl_warnings:find('%S') then\n+      health.warn(perl_warnings, {\n+        'See :help provider-perl for more information.',\n+        'You may disable this provider (and warning) by adding `let g:loaded_perl_provider = 0` to your init.vim',\n+      })\n+    else\n+      health.warn('No usable perl executable found')\n+    end\n+    return\n+  end\n+\n+  health.info('perl executable: ' .. perl_exec)\n+\n+  -- we cannot use cpanm that is on the path, as it may not be for the perl\n+  -- set with g:perl_host_prog\n+  local ok = health.cmd_ok({ perl_exec, '-W', '-MApp::cpanminus', '-e', '' })\n+  if not ok then\n+    return { perl_exec, '\"App::cpanminus\" module is not installed' }\n+  end\n+\n+  local latest_cpan_cmd = {\n+    perl_exec,\n+    '-MApp::cpanminus::fatscript',\n+    '-e',\n+    'my $app = App::cpanminus::script->new; $app->parse_options (\"--info\", \"-q\", \"Neovim::Ext\"); exit $app->doit',\n+  }\n+\n+  local ok, latest_cpan = health.cmd_ok(latest_cpan_cmd)",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163020648",
            "id": 1163020648,
            "line": 44,
            "node_id": "PRRC_kwDOAPphoM5FUklo",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 44,
            "original_position": 44,
            "original_start_line": null,
            "path": "runtime/lua/provider/perl/health.lua",
            "position": 44,
            "pull_request_review_id": 1379603006,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163020648/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T15:48:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163020648",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163023035"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163023035"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    health.error('Cannot parse version number from cpanm output: ' .. latest_cpan)\r\n```",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T15:50:19Z",
            "diff_hunk": "@@ -0,0 +1,94 @@\n+local health = vim.health\n+\n+local M = {}\n+\n+function M.check()\n+  health.start('Perl provider (optional)')\n+\n+  if health.provider_disabled('perl') then\n+    return\n+  end\n+\n+  local perl_detect_table = vim.fn['provider#perl#Detect']()\n+  local perl_exec = perl_detect_table[1]\n+  local perl_warnings = perl_detect_table[2]\n+\n+  if perl_exec:find('^%s*$') then\n+    if perl_warnings:find('%S') then\n+      health.warn(perl_warnings, {\n+        'See :help provider-perl for more information.',\n+        'You may disable this provider (and warning) by adding `let g:loaded_perl_provider = 0` to your init.vim',\n+      })\n+    else\n+      health.warn('No usable perl executable found')\n+    end\n+    return\n+  end\n+\n+  health.info('perl executable: ' .. perl_exec)\n+\n+  -- we cannot use cpanm that is on the path, as it may not be for the perl\n+  -- set with g:perl_host_prog\n+  local ok = health.cmd_ok({ perl_exec, '-W', '-MApp::cpanminus', '-e', '' })\n+  if not ok then\n+    return { perl_exec, '\"App::cpanminus\" module is not installed' }\n+  end\n+\n+  local latest_cpan_cmd = {\n+    perl_exec,\n+    '-MApp::cpanminus::fatscript',\n+    '-e',\n+    'my $app = App::cpanminus::script->new; $app->parse_options (\"--info\", \"-q\", \"Neovim::Ext\"); exit $app->doit',\n+  }\n+\n+  local ok, latest_cpan = health.cmd_ok(latest_cpan_cmd)\n+  if not ok or latest_cpan:find('^%s*$') then\n+    health.error(\n+      'Failed to run: ' .. table.concat(latest_cpan_cmd, ' '),\n+      { \"Make sure you're connected to the internet.\", 'Are you behind a firewall or proxy?' }\n+    )\n+    return\n+  elseif latest_cpan[1] == '!' then\n+    local cpanm_errs = vim.split(latest_cpan, '!')\n+    if cpanm_errs[1]:find(\"Can't write to \") then\n+      local advice = {}\n+      for i = 2, #cpanm_errs do\n+        advice[#advice + 1] = cpanm_errs[i]\n+      end\n+\n+      health.warn(cpanm_errs[1], advice)\n+      -- Last line is the package info\n+      latest_cpan = cpanm_errs[#cpanm_errs]\n+    else\n+      health.error('Unknown warning from command: ' .. latest_cpan_cmd, cpanm_errs)\n+      return\n+    end\n+  end\n+  latest_cpan = vim.fn.matchstr(latest_cpan, [[\\(\\.\\?\\d\\)\\+]])\n+  if latest_cpan:find('^%s*$') then\n+    error('Cannot parse version number from cpanm output: ' .. latest_cpan)",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163023035",
            "id": 1163023035,
            "line": 69,
            "node_id": "PRRC_kwDOAPphoM5FUlK7",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 69,
            "original_position": 69,
            "original_start_line": null,
            "path": "runtime/lua/provider/perl/health.lua",
            "position": 69,
            "pull_request_review_id": 1379606890,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163023035/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T15:50:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163023035",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163025799"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163025799"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  if vim.g.clipboard ~= nil and clipboard_tool == '' then\r\n```\r\n\r\nNit: I'd check against nil `g:clipboard` so `provider#clipboard#Executable()` can show `invalid g:clipboard` if it's set to `v:false` for whatever reason.\r\n\r\nAlso, yeah I'd replace the `find()s` with empty string checks like dun suggested, as that's what `empty()` does for strings anyway",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T15:52:19Z",
            "diff_hunk": "@@ -0,0 +1,39 @@\n+local health = vim.health\n+\n+local M = {}\n+\n+function M.check()\n+  health.start('Clipboard (optional)')\n+\n+  if\n+      os.getenv('TMUX')\n+      and vim.fn.executable('tmux') == 1\n+      and vim.fn.executable('pbpaste') == 1\n+      and not health.cmd_ok('pbpaste')\n+  then\n+    local tmux_version = string.match(vim.fn.system('tmux -V'), '%d+%.%d+')\n+    local advice = {\n+      'Install tmux 2.6+.  https://superuser.com/q/231130',\n+      'or use tmux with reattach-to-user-namespace.  https://superuser.com/a/413233',\n+    }\n+    health.error('pbcopy does not work with tmux version: ' .. tmux_version, advice)\n+  end\n+\n+  local clipboard_tool = vim.fn['provider#clipboard#Executable']()\n+  if vim.g.clipboard and clipboard_tool:find('^%s$') then",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163025799",
            "id": 1163025799,
            "line": 23,
            "node_id": "PRRC_kwDOAPphoM5FUl2H",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 23,
            "original_position": 23,
            "original_start_line": null,
            "path": "runtime/lua/provider/clipboard/health.lua",
            "position": 23,
            "pull_request_review_id": 1379610839,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163025799/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T16:49:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163025799",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163031865"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163031865"
                }
            },
            "author_association": "MEMBER",
            "body": "Unsure if `health.system` is needed here over `vim.fn.system` or `health.cmd_ok`. No real preference, but mentioning in case it got unnoticed.",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T15:57:17Z",
            "diff_hunk": "@@ -0,0 +1,69 @@\n+local health = vim.health\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+function M.check()\n+  health.start('Ruby provider (optional)')\n+\n+  if health.provider_disabled('ruby') then\n+    return\n+  end\n+\n+  if vim.fn.executable('ruby') == 0 or vim.fn.executable('gem') == 0 then\n+    health.warn(\n+      '`ruby` and `gem` must be in $PATH.',\n+      'Install Ruby and verify that `ruby` and `gem` commands work.'\n+    )\n+    return\n+  end\n+  health.info('Ruby: ' .. health.system({ 'ruby', '-v' }))",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163031865",
            "id": 1163031865,
            "line": 20,
            "node_id": "PRRC_kwDOAPphoM5FUnU5",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 20,
            "original_position": 20,
            "original_start_line": null,
            "path": "runtime/lua/provider/ruby/health.lua",
            "position": 20,
            "pull_request_review_id": 1379620674,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163031865/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T15:57:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163031865",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163060104"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163060104"
                }
            },
            "author_association": "MEMBER",
            "body": "This looks like it's to replace `empty()`. For empty strings, you can just compare against `\"\"` instead.",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T16:22:07Z",
            "diff_hunk": "@@ -0,0 +1,490 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+local function is(path, ty)\n+  if not path then\n+    return false\n+  end\n+  local stat = vim.loop.fs_stat(path)\n+  if not stat then\n+    return false\n+  end\n+  return stat.type == ty\n+end\n+\n+-- Resolves Python executable path by invoking and checking `sys.executable`.\n+local function python_exepath(invocation)\n+  local python = vim.fn.fnameescape(invocation)\n+  local out = vim.fn.system(python .. ' -c \"import sys; sys.stdout.write(sys.executable)\"')\n+  assert(vim.v.shell_error == 0, out)\n+  return vim.fs.normalize(vim.trim(out))\n+end\n+\n+local function is_blank(v)\n+  return v:find('^%s*$') ~= nil\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163060104",
            "id": 1163060104,
            "line": 28,
            "node_id": "PRRC_kwDOAPphoM5FUuOI",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 28,
            "original_position": 28,
            "original_start_line": 26,
            "path": "runtime/lua/provider/python/health.lua",
            "position": 28,
            "pull_request_review_id": 1379610839,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163060104/reactions"
            },
            "side": "RIGHT",
            "start_line": 26,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-04-11T16:49:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163060104",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163066812"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163066812"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    if not pcall_ok then\r\n      return 'error: ' .. pypi_response\r\n    end\r\n    local pypi_data = output\r\n```\r\n\r\njust a tiny nit",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T16:28:06Z",
            "diff_hunk": "@@ -0,0 +1,490 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+local function is(path, ty)\n+  if not path then\n+    return false\n+  end\n+  local stat = vim.loop.fs_stat(path)\n+  if not stat then\n+    return false\n+  end\n+  return stat.type == ty\n+end\n+\n+-- Resolves Python executable path by invoking and checking `sys.executable`.\n+local function python_exepath(invocation)\n+  local python = vim.fn.fnameescape(invocation)\n+  local out = vim.fn.system(python .. ' -c \"import sys; sys.stdout.write(sys.executable)\"')\n+  assert(vim.v.shell_error == 0, out)\n+  return vim.fs.normalize(vim.trim(out))\n+end\n+\n+local function is_blank(v)\n+  return v:find('^%s*$') ~= nil\n+end\n+\n+-- Check if pyenv is available and a valid pyenv root can be found, then return\n+-- their respective paths. If either of those is invalid, return two empty\n+-- strings, effectively ignoring pyenv.\n+local function check_for_pyenv()\n+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))\n+\n+  if is_blank(pyenv_path) then\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Path: ' .. pyenv_path)\n+\n+  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''\n+\n+  if is_blank(pyenv_root) then\n+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })\n+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')\n+  end\n+\n+  if not is(pyenv_root, 'directory') then\n+    local message = string.format(\n+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',\n+      pyenv_root\n+    )\n+    health.warn(message)\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Root: ' .. pyenv_root)\n+\n+  return { pyenv_path, pyenv_root }\n+end\n+\n+-- Check the Python interpreter's usability.\n+local function check_bin(bin)\n+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then\n+    health.error('\"' .. bin .. '\" was not found.')\n+    return false\n+  elseif vim.fn.executable(bin) ~= 1 then\n+    health.error('\"' .. bin .. '\" is not executable.')\n+    return false\n+  end\n+  return true\n+end\n+\n+-- Fetch the contents of a URL.\n+local function download(url)\n+  local has_curl = vim.fn.executable('curl') == 1\n+  if has_curl and vim.fn.system({ 'curl', '-V' }):find('Protocols:.*https') then\n+    local out, rc = health.system({ 'curl', '-sL', url }, { stderr = true, ignore_error = true })\n+    if rc ~= 0 then\n+      return 'curl error with ' .. url .. ': ' .. rc\n+    else\n+      return out\n+    end\n+  elseif vim.fn.executable('python') == 1 then\n+    local script = \"try:\\n\\\n+          from urllib.request import urlopen\\n\\\n+          except ImportError:\\n\\\n+          from urllib2 import urlopen\\n\\\n+          response = urlopen('\" .. url .. \"')\\n\\\n+          print(response.read().decode('utf8'))\\n\"\n+    local out, rc = health.system({ 'python', '-c', script })\n+    if is_blank(out) and rc ~= 0 then\n+      return 'python urllib.request error: ' .. rc\n+    else\n+      return out\n+    end\n+  end\n+\n+  local message = 'missing `curl` '\n+\n+  if has_curl then\n+    message = message .. '(with HTTPS support) '\n+  end\n+  message = message .. 'and `python`, cannot make web request'\n+\n+  return message\n+end\n+\n+\n+-- Get the latest Nvim Python client (pynvim) version from PyPI.\n+local function latest_pypi_version()\n+  local pypi_version = 'unable to get pypi response'\n+  local pypi_response = download('https://pypi.python.org/pypi/pynvim/json')\n+  if not is_blank(pypi_response) then\n+    local pcall_ok, output = pcall(vim.fn.json_decode, pypi_response)\n+    local pypi_data\n+    if pcall_ok then\n+      pypi_data = output\n+    else\n+      return 'error: ' .. pypi_response\n+    end",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163066812",
            "id": 1163066812,
            "line": 122,
            "node_id": "PRRC_kwDOAPphoM5FUv28",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 122,
            "original_position": 122,
            "original_start_line": 117,
            "path": "runtime/lua/provider/python/health.lua",
            "position": 122,
            "pull_request_review_id": 1379610839,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163066812/reactions"
            },
            "side": "RIGHT",
            "start_line": 117,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-04-11T16:49:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163066812",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163073150"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163073150"
                }
            },
            "author_association": "MEMBER",
            "body": ":eyes: ",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T16:34:06Z",
            "diff_hunk": "@@ -4,22 +4,140 @@ function M.report_start(msg)\n   vim.fn['health#report_start'](msg)\n end\n \n+M.start = M.report_start\n+\n function M.report_info(msg)\n   vim.fn['health#report_info'](msg)\n end\n \n+M.info = M.report_info\n+\n function M.report_ok(msg)\n   vim.fn['health#report_ok'](msg)\n end\n \n+M.ok = M.report_ok\n+\n function M.report_warn(msg, ...)\n   vim.fn['health#report_warn'](msg, ...)\n end\n \n+M.warn = M.report_warn\n+\n function M.report_error(msg, ...)\n   vim.fn['health#report_error'](msg, ...)\n end\n \n+M.error = M.report_error\n+\n+function M.provider_disabled(provider)\n+  local loaded_var = 'loaded_' .. provider .. '_provider'\n+  local v = vim.g[loaded_var]\n+  if v == 0 then\n+    M.report_info('Disabled (' .. loaded_var .. '=' .. v .. ').')\n+    return true\n+  end\n+  return false\n+end\n+\n+-- Handler for s:system() function.\n+local function system_handler(self, _, data, event)\n+  if event == 'stderr' then\n+    if self.add_stderr_to_output then\n+      self.output = self.output .. table.concat(data, '')\n+    else\n+      self.stderr = self.stderr .. table.concat(data, '')\n+    end\n+  elseif event == 'stdout' then\n+    self.output = self.output .. table.concat(data, '')\n+  end\n+end\n+\n+-- Attempts to construct a shell command from an args list.\n+-- Only for display, to help users debug a failed command.\n+local function shellify(cmd)\n+  if type(cmd) ~= 'table' then\n+    return cmd\n+  end\n+  local escaped = {}\n+  for i, v in ipairs(cmd) do\n+    if v:match('[^A-Za-z_/.-]') then\n+      escaped[i] = vim.fn.shellescape(v)\n+    else\n+      escaped[i] = v\n+    end\n+  end\n+  return table.concat(escaped, ' ')\n+end\n+\n+function M.cmd_ok(cmd)\n+  local out = vim.fn.system(cmd)\n+  return vim.v.shell_error == 0, out\n+end\n+\n+--- Run a system command and timeout after 30 seconds.\n+---\n+--- @param cmd table List of command arguments to execute\n+--- @param args ?table Optional arguments:\n+---                   - stdin (string): Data to write to the job's stdin\n+---                   - stderr (boolean): Append stderr to stdout\n+---                   - ignore_error (boolean): If true, ignore error output\n+---                   - timeout (number): Number of seconds to wait before timing out (default 30)\n+function M.system(cmd, args)\n+  args = args or {}\n+  local stdin = args.stdin or ''\n+  local stderr = vim.F.if_nil(args.stderr, false)\n+  local ignore_error = vim.F.if_nil(args.ignore_error, false)\n+\n+  local shell_error_code = 0\n+  local opts = {\n+    add_stderr_to_output = stderr,\n+    output = '',\n+    stderr = '',\n+    on_stdout = system_handler,\n+    on_stderr = system_handler,\n+    on_exit = function(_, data)\n+      shell_error_code = data\n+    end,\n+  }\n+  local jobid = vim.fn.jobstart(cmd, opts)\n+\n+  if jobid < 1 then\n+    local message =\n+        string.format('Command error (job=%d): %s (in %s)', jobid, shellify(cmd), vim.loop.cwd())\n+    error(message)\n+    return opts.output, 1\n+  end\n+\n+  if stdin:find('^%s$') then\n+    vim.fn.jobsend(jobid, stdin)\n+  end\n+\n+  local res = vim.fn.jobwait({ jobid }, vim.F.if_nil(args.timeout, 30) * 1000)\n+  if res[1] == -1 then\n+    error('Command timed out: ' .. shellify(cmd))\n+    vim.fn.jobstop(jobid)\n+  elseif shell_error_code ~= 0 and not ignore_error then\n+    local emsg = string.format(\n+      'Command error (job=%d, exit code %d): %s (in %s)',\n+      jobid,\n+      shell_error_code,\n+      shellify(cmd),\n+      vim.loop.cwd()\n+    )\n+    if opts.output:find('%S') then\n+      emsg = string.format('%s\\noutput: %s', emsg, opts.output)\n+    end\n+    if opts.stderr:find('%S') then\n+      emsg = string.format('%s\\nstderr: %s', emsg, opts.stderr)\n+    end\n+    error(emsg)\n+  end\n+\n+  -- return opts.output\n+  return vim.trim(vim.fn.system(cmd)), shell_error_code",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163073150",
            "id": 1163073150,
            "line": 138,
            "node_id": "PRRC_kwDOAPphoM5FUxZ-",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 138,
            "original_position": 135,
            "original_start_line": 137,
            "path": "runtime/lua/vim/health.lua",
            "position": 135,
            "pull_request_review_id": 1379610839,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163073150/reactions"
            },
            "side": "RIGHT",
            "start_line": 137,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-04-11T16:49:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163073150",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163078180"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163078180"
                }
            },
            "author_association": "MEMBER",
            "body": "This is used in table.sort below, but I have a feeling this won't work properly as a Lua comparator, as it expects bool, and this'll act like its returning `true` all the time? :thinking: ",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T16:38:58Z",
            "diff_hunk": "@@ -0,0 +1,490 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+local function is(path, ty)\n+  if not path then\n+    return false\n+  end\n+  local stat = vim.loop.fs_stat(path)\n+  if not stat then\n+    return false\n+  end\n+  return stat.type == ty\n+end\n+\n+-- Resolves Python executable path by invoking and checking `sys.executable`.\n+local function python_exepath(invocation)\n+  local python = vim.fn.fnameescape(invocation)\n+  local out = vim.fn.system(python .. ' -c \"import sys; sys.stdout.write(sys.executable)\"')\n+  assert(vim.v.shell_error == 0, out)\n+  return vim.fs.normalize(vim.trim(out))\n+end\n+\n+local function is_blank(v)\n+  return v:find('^%s*$') ~= nil\n+end\n+\n+-- Check if pyenv is available and a valid pyenv root can be found, then return\n+-- their respective paths. If either of those is invalid, return two empty\n+-- strings, effectively ignoring pyenv.\n+local function check_for_pyenv()\n+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))\n+\n+  if is_blank(pyenv_path) then\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Path: ' .. pyenv_path)\n+\n+  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''\n+\n+  if is_blank(pyenv_root) then\n+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })\n+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')\n+  end\n+\n+  if not is(pyenv_root, 'directory') then\n+    local message = string.format(\n+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',\n+      pyenv_root\n+    )\n+    health.warn(message)\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Root: ' .. pyenv_root)\n+\n+  return { pyenv_path, pyenv_root }\n+end\n+\n+-- Check the Python interpreter's usability.\n+local function check_bin(bin)\n+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then\n+    health.error('\"' .. bin .. '\" was not found.')\n+    return false\n+  elseif vim.fn.executable(bin) ~= 1 then\n+    health.error('\"' .. bin .. '\" is not executable.')\n+    return false\n+  end\n+  return true\n+end\n+\n+-- Fetch the contents of a URL.\n+local function download(url)\n+  local has_curl = vim.fn.executable('curl') == 1\n+  if has_curl and vim.fn.system({ 'curl', '-V' }):find('Protocols:.*https') then\n+    local out, rc = health.system({ 'curl', '-sL', url }, { stderr = true, ignore_error = true })\n+    if rc ~= 0 then\n+      return 'curl error with ' .. url .. ': ' .. rc\n+    else\n+      return out\n+    end\n+  elseif vim.fn.executable('python') == 1 then\n+    local script = \"try:\\n\\\n+          from urllib.request import urlopen\\n\\\n+          except ImportError:\\n\\\n+          from urllib2 import urlopen\\n\\\n+          response = urlopen('\" .. url .. \"')\\n\\\n+          print(response.read().decode('utf8'))\\n\"\n+    local out, rc = health.system({ 'python', '-c', script })\n+    if is_blank(out) and rc ~= 0 then\n+      return 'python urllib.request error: ' .. rc\n+    else\n+      return out\n+    end\n+  end\n+\n+  local message = 'missing `curl` '\n+\n+  if has_curl then\n+    message = message .. '(with HTTPS support) '\n+  end\n+  message = message .. 'and `python`, cannot make web request'\n+\n+  return message\n+end\n+\n+\n+-- Get the latest Nvim Python client (pynvim) version from PyPI.\n+local function latest_pypi_version()\n+  local pypi_version = 'unable to get pypi response'\n+  local pypi_response = download('https://pypi.python.org/pypi/pynvim/json')\n+  if not is_blank(pypi_response) then\n+    local pcall_ok, output = pcall(vim.fn.json_decode, pypi_response)\n+    local pypi_data\n+    if pcall_ok then\n+      pypi_data = output\n+    else\n+      return 'error: ' .. pypi_response\n+    end\n+\n+    local pypi_element = pypi_data['info'] or {}\n+    pypi_version = pypi_element['version'] or 'unable to parse'\n+  end\n+  return pypi_version\n+end\n+\n+local function is_bad_response(s)\n+  local lower = s:lower()\n+  return vim.startswith(lower, 'unable')\n+      or vim.startswith(lower, 'error')\n+      or vim.startswith(lower, 'outdated')\n+end\n+\n+\n+-- Get version information using the specified interpreter.  The interpreter is\n+-- used directly in case breaking changes were introduced since the last time\n+-- Nvim's Python client was updated.\n+--\n+-- Returns: {\n+--     {python executable version},\n+--     {current nvim version},\n+--     {current pypi nvim status},\n+--     {installed version status}\n+-- }\n+local function version_info(python)\n+  local pypi_version = latest_pypi_version()\n+\n+  local python_version, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; print(\".\".join(str(x) for x in sys.version_info[:3]))',\n+  })\n+\n+  if rc ~= 0 or is_blank(python_version) then\n+    python_version = 'unable to parse ' .. python .. ' response'\n+  end\n+\n+  local nvim_path, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; sys.path = [p for p in sys.path if p != \"\"]; import neovim; print(neovim.__file__)',\n+  })\n+  if rc ~= 0 or is_blank(nvim_path) then\n+    return { python_version, 'unable to load neovim Python module', pypi_version, nvim_path }\n+  end\n+\n+  -- Assuming that multiple versions of a package are installed, sort them\n+  -- numerically in descending order.\n+  local function compare(metapath1, metapath2)\n+    local a = vim.fn.matchstr(vim.fn.fnamemodify(metapath1, ':p:h:t'), [[[0-9.]\\+]])\n+    local b = vim.fn.matchstr(vim.fn.fnamemodify(metapath2, ':p:h:t'), [[[0-9.]\\+]])\n+    if a == b then\n+      return 0\n+    elseif a > b then\n+      return 1\n+    else\n+      return -1\n+    end\n+  end\n+",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163078180",
            "id": 1163078180,
            "line": 183,
            "node_id": "PRRC_kwDOAPphoM5FUyok",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 183,
            "original_position": 183,
            "original_start_line": 172,
            "path": "runtime/lua/provider/python/health.lua",
            "position": 183,
            "pull_request_review_id": 1379610839,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163078180/reactions"
            },
            "side": "RIGHT",
            "start_line": 172,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-04-11T16:49:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163078180",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163080454"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163080454"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        return vim.fs.basename(v)\r\n```",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T16:41:02Z",
            "diff_hunk": "@@ -0,0 +1,490 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+local function is(path, ty)\n+  if not path then\n+    return false\n+  end\n+  local stat = vim.loop.fs_stat(path)\n+  if not stat then\n+    return false\n+  end\n+  return stat.type == ty\n+end\n+\n+-- Resolves Python executable path by invoking and checking `sys.executable`.\n+local function python_exepath(invocation)\n+  local python = vim.fn.fnameescape(invocation)\n+  local out = vim.fn.system(python .. ' -c \"import sys; sys.stdout.write(sys.executable)\"')\n+  assert(vim.v.shell_error == 0, out)\n+  return vim.fs.normalize(vim.trim(out))\n+end\n+\n+local function is_blank(v)\n+  return v:find('^%s*$') ~= nil\n+end\n+\n+-- Check if pyenv is available and a valid pyenv root can be found, then return\n+-- their respective paths. If either of those is invalid, return two empty\n+-- strings, effectively ignoring pyenv.\n+local function check_for_pyenv()\n+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))\n+\n+  if is_blank(pyenv_path) then\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Path: ' .. pyenv_path)\n+\n+  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''\n+\n+  if is_blank(pyenv_root) then\n+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })\n+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')\n+  end\n+\n+  if not is(pyenv_root, 'directory') then\n+    local message = string.format(\n+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',\n+      pyenv_root\n+    )\n+    health.warn(message)\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Root: ' .. pyenv_root)\n+\n+  return { pyenv_path, pyenv_root }\n+end\n+\n+-- Check the Python interpreter's usability.\n+local function check_bin(bin)\n+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then\n+    health.error('\"' .. bin .. '\" was not found.')\n+    return false\n+  elseif vim.fn.executable(bin) ~= 1 then\n+    health.error('\"' .. bin .. '\" is not executable.')\n+    return false\n+  end\n+  return true\n+end\n+\n+-- Fetch the contents of a URL.\n+local function download(url)\n+  local has_curl = vim.fn.executable('curl') == 1\n+  if has_curl and vim.fn.system({ 'curl', '-V' }):find('Protocols:.*https') then\n+    local out, rc = health.system({ 'curl', '-sL', url }, { stderr = true, ignore_error = true })\n+    if rc ~= 0 then\n+      return 'curl error with ' .. url .. ': ' .. rc\n+    else\n+      return out\n+    end\n+  elseif vim.fn.executable('python') == 1 then\n+    local script = \"try:\\n\\\n+          from urllib.request import urlopen\\n\\\n+          except ImportError:\\n\\\n+          from urllib2 import urlopen\\n\\\n+          response = urlopen('\" .. url .. \"')\\n\\\n+          print(response.read().decode('utf8'))\\n\"\n+    local out, rc = health.system({ 'python', '-c', script })\n+    if is_blank(out) and rc ~= 0 then\n+      return 'python urllib.request error: ' .. rc\n+    else\n+      return out\n+    end\n+  end\n+\n+  local message = 'missing `curl` '\n+\n+  if has_curl then\n+    message = message .. '(with HTTPS support) '\n+  end\n+  message = message .. 'and `python`, cannot make web request'\n+\n+  return message\n+end\n+\n+\n+-- Get the latest Nvim Python client (pynvim) version from PyPI.\n+local function latest_pypi_version()\n+  local pypi_version = 'unable to get pypi response'\n+  local pypi_response = download('https://pypi.python.org/pypi/pynvim/json')\n+  if not is_blank(pypi_response) then\n+    local pcall_ok, output = pcall(vim.fn.json_decode, pypi_response)\n+    local pypi_data\n+    if pcall_ok then\n+      pypi_data = output\n+    else\n+      return 'error: ' .. pypi_response\n+    end\n+\n+    local pypi_element = pypi_data['info'] or {}\n+    pypi_version = pypi_element['version'] or 'unable to parse'\n+  end\n+  return pypi_version\n+end\n+\n+local function is_bad_response(s)\n+  local lower = s:lower()\n+  return vim.startswith(lower, 'unable')\n+      or vim.startswith(lower, 'error')\n+      or vim.startswith(lower, 'outdated')\n+end\n+\n+\n+-- Get version information using the specified interpreter.  The interpreter is\n+-- used directly in case breaking changes were introduced since the last time\n+-- Nvim's Python client was updated.\n+--\n+-- Returns: {\n+--     {python executable version},\n+--     {current nvim version},\n+--     {current pypi nvim status},\n+--     {installed version status}\n+-- }\n+local function version_info(python)\n+  local pypi_version = latest_pypi_version()\n+\n+  local python_version, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; print(\".\".join(str(x) for x in sys.version_info[:3]))',\n+  })\n+\n+  if rc ~= 0 or is_blank(python_version) then\n+    python_version = 'unable to parse ' .. python .. ' response'\n+  end\n+\n+  local nvim_path, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; sys.path = [p for p in sys.path if p != \"\"]; import neovim; print(neovim.__file__)',\n+  })\n+  if rc ~= 0 or is_blank(nvim_path) then\n+    return { python_version, 'unable to load neovim Python module', pypi_version, nvim_path }\n+  end\n+\n+  -- Assuming that multiple versions of a package are installed, sort them\n+  -- numerically in descending order.\n+  local function compare(metapath1, metapath2)\n+    local a = vim.fn.matchstr(vim.fn.fnamemodify(metapath1, ':p:h:t'), [[[0-9.]\\+]])\n+    local b = vim.fn.matchstr(vim.fn.fnamemodify(metapath2, ':p:h:t'), [[[0-9.]\\+]])\n+    if a == b then\n+      return 0\n+    elseif a > b then\n+      return 1\n+    else\n+      return -1\n+    end\n+  end\n+\n+  -- Try to get neovim.VERSION (added in 0.1.11dev).\n+  local nvim_version, rc = health.system({\n+    python,\n+    '-c',\n+    'from neovim import VERSION as v; print(\"{}.{}.{}{}\".format(v.major, v.minor, v.patch, v.prerelease))',\n+  }, { stderr = true, ignore_error = true })\n+  if rc ~= 0 or is_blank(nvim_version) then\n+    nvim_version = 'unable to find pynvim module version'\n+    local base = vim.fs.basename(nvim_path)\n+    local metas = vim.fn.glob(base .. '-*/METADATA', 1, 1)\n+    vim.list_extend(metas, vim.fn.glob(base .. '-*/PKG-INFO', 1, 1))\n+    vim.list_extend(metas, vim.fn.glob(base .. '.egg-info/PKG-INFO', 1, 1))\n+    metas = table.sort(metas, compare)\n+\n+    if metas and next(metas) ~= nil then\n+      for line in io.lines(metas[1]) do\n+        local version = line:match('^Version: (%S+)')\n+        if version then\n+          nvim_version = version\n+          break\n+        end\n+      end\n+    end\n+  end\n+\n+  local nvim_path_base = vim.fn.fnamemodify(nvim_path, [[:~:h]])\n+  local version_status = 'unknown; ' .. nvim_path_base\n+  if is_bad_response(nvim_version) and is_bad_response(pypi_version) then\n+    if vim.version.lt(nvim_version, pypi_version) then\n+      version_status = 'outdated; from ' .. nvim_path_base\n+    else\n+      version_status = 'up to date'\n+    end\n+  end\n+\n+  return { python_version, nvim_version, pypi_version, version_status }\n+end\n+\n+function M.check()\n+  health.start('Python 3 provider (optional)')\n+\n+  local pyname = 'python3'\n+  local python_exe = ''\n+  local virtual_env = os.getenv('VIRTUAL_ENV')\n+  local venv = virtual_env and vim.fn.resolve(virtual_env) or ''\n+  local host_prog_var = pyname .. '_host_prog'\n+  local python_multiple = {}\n+\n+  if health.provider_disabled(pyname) then\n+    return\n+  end\n+\n+  local pyenv_table = check_for_pyenv()\n+  local pyenv = pyenv_table[1]\n+  local pyenv_root = pyenv_table[2]\n+\n+  if vim.g[host_prog_var] then\n+    local message = string.format('Using: g:%s = \"%s\"', host_prog_var, vim.g[host_prog_var])\n+    health.info(message)\n+  end\n+\n+  local python_table = vim.fn['provider#pythonx#Detect'](3)\n+  pyname = python_table[1]\n+  local pythonx_warnings = python_table[2]\n+\n+  if is_blank(pyname) then\n+    health.warn(\n+      'No Python executable found that can `import neovim`. '\n+      .. 'Using the first available executable for diagnostics.'\n+    )\n+  elseif vim.g[host_prog_var] then\n+    python_exe = pyname\n+  end\n+\n+  -- No Python executable could `import neovim`, or host_prog_var was used.\n+  if not is_blank(pythonx_warnings) then\n+    health.warn(pythonx_warnings, {\n+      'See :help provider-python for more information.',\n+      'You may disable this provider (and warning) by adding `let g:loaded_python3_provider = 0` to your init.vim',\n+    })\n+  elseif not is_blank(pyname) and is_blank(python_exe) then\n+    if not vim.g[host_prog_var] then\n+      local message = string.format(\n+        '`g:%s` is not set. Searching for %s in the environment.',\n+        host_prog_var,\n+        pyname\n+      )\n+      health.info(message)\n+    end\n+\n+    if not is_blank(pyenv) then\n+      python_exe = health.system({ pyenv, 'which', pyname }, { stderr = true })\n+      if is_blank(python_exe) then\n+        health.warn('pyenv could not find ' .. pyname .. '.')\n+      end\n+    end\n+\n+    if is_blank(python_exe) then\n+      python_exe = vim.fn.exepath(pyname)\n+\n+      if os.getenv('PATH') then\n+        local path_sep = iswin and ';' or ':'\n+        local paths = vim.split(os.getenv('PATH') or '', path_sep)\n+\n+        for _, path in ipairs(paths) do\n+          local path_bin = vim.fs.normalize(path .. '/' .. pyname)\n+          if\n+              path_bin ~= vim.fs.normalize(python_exe)\n+              and vim.tbl_contains(python_multiple, path_bin)\n+              and vim.fn.executable(path_bin) == 1\n+          then\n+            python_multiple[#python_multiple + 1] = path_bin\n+          end\n+        end\n+\n+        if vim.tbl_count(python_multiple) > 0 then\n+          -- This is worth noting since the user may install something\n+          -- that changes $PATH, like homebrew.\n+          local message = string.format('Multiple %s executables found. Set `g:%s` to avoid surprises.', pyname,\n+            host_prog_var)\n+          health.info(message)\n+        end\n+\n+        if python_exe:find('shims') then\n+          local message = string.format('`%s` appears to be a pyenv shim.', python_exe)\n+          local advice = string.format(\n+            '`pyenv` is not in $PATH, your pyenv installation is broken. Set `g:%s` to avoid surprises.', host_prog_var)\n+          health.warn(message, advice)\n+        end\n+      end\n+    end\n+  end\n+\n+  if not is_blank(python_exe) and not vim.g[host_prog_var] then\n+    if\n+        is_blank(venv)\n+        and not is_blank(pyenv)\n+        and not is_blank(pyenv_root)\n+        and vim.startswith(vim.fn.resolve(python_exe), pyenv_root .. '/')\n+    then\n+      local advice = string.format(\n+        'Create a virtualenv specifically for Nvim using pyenv, and set `g:%s`.  This will avoid the need to install the pynvim module in each version/virtualenv.',\n+        host_prog_var)\n+      health.warn('pyenv is not set up optimally.', advice)\n+    elseif not is_blank(venv) then\n+      local venv_root\n+      if not is_blank(pyenv_root) then\n+        venv_root = pyenv_root\n+      else\n+        venv_root = vim.fs.dirname(venv)\n+      end\n+\n+      if vim.startswith(vim.fn.resolve(python_exe), venv_root .. '/') then\n+        local advice = string.format(\n+          'Create a virtualenv specifically for Nvim and use `g:%s`.  This will avoid the need to install the pynvim module in each virtualenv.',\n+          host_prog_var)\n+        health.warn('Your virtualenv is not set up optimally.', advice)\n+      end\n+    end\n+  end\n+\n+  if is_blank(python_exe) and not is_blank(pyname) then\n+    -- An error message should have already printed.\n+    health.error('`' .. pyname .. '` was not found.')\n+  elseif not is_blank(python_exe) and not check_bin(python_exe) then\n+    python_exe = ''\n+  end\n+\n+  -- Diagnostic output\n+  health.info('Executable: ' .. (is_blank(python_exe) and 'Not found' or python_exe))\n+  if vim.tbl_count(python_multiple) > 0 then\n+    for _, path_bin in ipairs(python_multiple) do\n+      health.info('Other python executable: ' .. path_bin)\n+    end\n+  end\n+\n+  if is_blank(python_exe) then\n+    -- No Python executable can import 'neovim'. Check if any Python executable\n+    -- can import 'pynvim'. If so, that Python failed to import 'neovim' as\n+    -- well, which is most probably due to a failed pip upgrade:\n+    -- https://github.com/neovim/neovim/wiki/Following-HEAD#20181118\n+    local pynvim_table = vim.fn['provider#pythonx#DetectByModule']('pynvim', 3)\n+    local pynvim_exe = pynvim_table[1]\n+    if not is_blank(pynvim_exe) then\n+      local message = 'Detected pip upgrade failure: Python executable can import \"pynvim\" but not \"neovim\": '\n+          .. pynvim_exe\n+      local advice = {\n+        'Use that Python version to reinstall \"pynvim\" and optionally \"neovim\".',\n+        pynvim_exe .. ' -m pip uninstall pynvim neovim',\n+        pynvim_exe .. ' -m pip install pynvim',\n+        pynvim_exe .. ' -m pip install neovim  # only if needed by third-party software',\n+      }\n+      health.error(message, advice)\n+    end\n+  else\n+    local version_info_table = version_info(python_exe)\n+    local pyversion = version_info_table[1]\n+    local current = version_info_table[2]\n+    local latest = version_info_table[3]\n+    local status = version_info_table[4]\n+\n+    if not vim.version.range('~3'):has(pyversion) then\n+      health.warn('Unexpected Python version. This could lead to confusing error messages.')\n+    end\n+\n+    health.info('Python version: ' .. pyversion)\n+\n+    if is_bad_response(status) then\n+      health.info('pynvim version: ' .. current .. ' (' .. status .. ')')\n+    else\n+      health.info('pynvim version: ' .. current)\n+    end\n+\n+    if is_bad_response(current) then\n+      health.error(\n+        'pynvim is not installed.\\nError: ' .. current,\n+        'Run in shell: ' .. python_exe .. ' -m pip install pynvim'\n+      )\n+    end\n+\n+    if is_bad_response(latest) then\n+      health.warn('Could not contact PyPI to get latest version.')\n+      health.error('HTTP request failed: ' .. latest)\n+    elseif is_bad_response(status) then\n+      health.warn('Latest pynvim is NOT installed: ' .. latest)\n+    elseif not is_bad_response(current) then\n+      health.ok('Latest pynvim is installed.')\n+    end\n+  end\n+\n+  health.start('Python virtualenv')\n+  if not virtual_env then\n+    health.ok('no $VIRTUAL_ENV')\n+    return\n+  end\n+  local errors = {}\n+  -- Keep hints as dict keys in order to discard duplicates.\n+  local hints = {}\n+  -- The virtualenv should contain some Python executables, and those\n+  -- executables should be first both on Nvim's $PATH and the $PATH of\n+  -- subshells launched from Nvim.\n+  local bin_dir = iswin and 'Scripts' or 'bin'\n+  local venv_bins = vim.fn.glob(string.format('%s/%s/python*', virtual_env, bin_dir), true, true)\n+  venv_bins = vim.tbl_filter(function(v)\n+    -- XXX: Remove irrelevant executables found in bin/.\n+    return not v:match('python%-config')\n+  end, venv_bins)\n+  if vim.tbl_count(venv_bins) > 0 then\n+    for _, venv_bin in pairs(venv_bins) do\n+      venv_bin = vim.fs.normalize(venv_bin)\n+      local py_bin_basename = vim.fs.basename(venv_bin)\n+      local nvim_py_bin = python_exepath(vim.fn.exepath(py_bin_basename))\n+      local subshell_py_bin = python_exepath(py_bin_basename)\n+      if venv_bin ~= nvim_py_bin then\n+        errors[#errors + 1] = '$PATH yields this '\n+            .. py_bin_basename\n+            .. ' executable: '\n+            .. nvim_py_bin\n+        local hint = '$PATH ambiguities arise if the virtualenv is not '\n+            .. 'properly activated prior to launching Nvim. Close Nvim, activate the virtualenv, '\n+            .. 'check that invoking Python from the command line launches the correct one, '\n+            .. 'then relaunch Nvim.'\n+        hints[hint] = true\n+      end\n+      if venv_bin ~= subshell_py_bin then\n+        errors[#errors + 1] = '$PATH in subshells yields this '\n+            .. py_bin_basename\n+            .. ' executable: '\n+            .. subshell_py_bin\n+        local hint = '$PATH ambiguities in subshells typically are '\n+            .. 'caused by your shell config overriding the $PATH previously set by the '\n+            .. 'virtualenv. Either prevent them from doing so, or use this workaround: '\n+            .. 'https://vi.stackexchange.com/a/34996'\n+        hints[hint] = true\n+      end\n+    end\n+  else\n+    errors[#errors + 1] = 'no Python executables found in the virtualenv '\n+        .. bin_dir\n+        .. ' directory.'\n+  end\n+\n+  local msg = '$VIRTUAL_ENV is set to: ' .. virtual_env\n+  if vim.tbl_count(errors) > 0 then\n+    if vim.tbl_count(venv_bins) > 0 then\n+      msg = string.format('%s\\nAnd its %s directory contains: %s', msg, bin_dir, table.concat(vim.tbl_map(function(v)\n+        return vim.fn.fnamemodify(v, ':t')",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163080454",
            "id": 1163080454,
            "line": 470,
            "node_id": "PRRC_kwDOAPphoM5FUzMG",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 470,
            "original_position": 470,
            "original_start_line": null,
            "path": "runtime/lua/provider/python/health.lua",
            "position": 470,
            "pull_request_review_id": 1379694665,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163080454/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T16:41:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163080454",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163081263"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163081263"
                }
            },
            "author_association": "MEMBER",
            "body": "Clearer IMO\r\n\r\n```suggestion\r\n  elseif vim.fn.executable(bin) == 0 then\r\n```",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T16:41:52Z",
            "diff_hunk": "@@ -0,0 +1,490 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+local function is(path, ty)\n+  if not path then\n+    return false\n+  end\n+  local stat = vim.loop.fs_stat(path)\n+  if not stat then\n+    return false\n+  end\n+  return stat.type == ty\n+end\n+\n+-- Resolves Python executable path by invoking and checking `sys.executable`.\n+local function python_exepath(invocation)\n+  local python = vim.fn.fnameescape(invocation)\n+  local out = vim.fn.system(python .. ' -c \"import sys; sys.stdout.write(sys.executable)\"')\n+  assert(vim.v.shell_error == 0, out)\n+  return vim.fs.normalize(vim.trim(out))\n+end\n+\n+local function is_blank(v)\n+  return v:find('^%s*$') ~= nil\n+end\n+\n+-- Check if pyenv is available and a valid pyenv root can be found, then return\n+-- their respective paths. If either of those is invalid, return two empty\n+-- strings, effectively ignoring pyenv.\n+local function check_for_pyenv()\n+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))\n+\n+  if is_blank(pyenv_path) then\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Path: ' .. pyenv_path)\n+\n+  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''\n+\n+  if is_blank(pyenv_root) then\n+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })\n+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')\n+  end\n+\n+  if not is(pyenv_root, 'directory') then\n+    local message = string.format(\n+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',\n+      pyenv_root\n+    )\n+    health.warn(message)\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Root: ' .. pyenv_root)\n+\n+  return { pyenv_path, pyenv_root }\n+end\n+\n+-- Check the Python interpreter's usability.\n+local function check_bin(bin)\n+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then\n+    health.error('\"' .. bin .. '\" was not found.')\n+    return false\n+  elseif vim.fn.executable(bin) ~= 1 then",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163081263",
            "id": 1163081263,
            "line": 68,
            "node_id": "PRRC_kwDOAPphoM5FUzYv",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 68,
            "original_position": 68,
            "original_start_line": null,
            "path": "runtime/lua/provider/python/health.lua",
            "position": 68,
            "pull_request_review_id": 1379695849,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163081263/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T16:41:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163081263",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163082257"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163082257"
                }
            },
            "author_association": "MEMBER",
            "body": "Could we not check if version is less than 3?\r\n\r\n```suggestion\r\n    if vim.version.lt(pyversion, 3) then\r\n```",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T16:42:55Z",
            "diff_hunk": "@@ -0,0 +1,490 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+local function is(path, ty)\n+  if not path then\n+    return false\n+  end\n+  local stat = vim.loop.fs_stat(path)\n+  if not stat then\n+    return false\n+  end\n+  return stat.type == ty\n+end\n+\n+-- Resolves Python executable path by invoking and checking `sys.executable`.\n+local function python_exepath(invocation)\n+  local python = vim.fn.fnameescape(invocation)\n+  local out = vim.fn.system(python .. ' -c \"import sys; sys.stdout.write(sys.executable)\"')\n+  assert(vim.v.shell_error == 0, out)\n+  return vim.fs.normalize(vim.trim(out))\n+end\n+\n+local function is_blank(v)\n+  return v:find('^%s*$') ~= nil\n+end\n+\n+-- Check if pyenv is available and a valid pyenv root can be found, then return\n+-- their respective paths. If either of those is invalid, return two empty\n+-- strings, effectively ignoring pyenv.\n+local function check_for_pyenv()\n+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))\n+\n+  if is_blank(pyenv_path) then\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Path: ' .. pyenv_path)\n+\n+  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''\n+\n+  if is_blank(pyenv_root) then\n+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })\n+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')\n+  end\n+\n+  if not is(pyenv_root, 'directory') then\n+    local message = string.format(\n+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',\n+      pyenv_root\n+    )\n+    health.warn(message)\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Root: ' .. pyenv_root)\n+\n+  return { pyenv_path, pyenv_root }\n+end\n+\n+-- Check the Python interpreter's usability.\n+local function check_bin(bin)\n+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then\n+    health.error('\"' .. bin .. '\" was not found.')\n+    return false\n+  elseif vim.fn.executable(bin) ~= 1 then\n+    health.error('\"' .. bin .. '\" is not executable.')\n+    return false\n+  end\n+  return true\n+end\n+\n+-- Fetch the contents of a URL.\n+local function download(url)\n+  local has_curl = vim.fn.executable('curl') == 1\n+  if has_curl and vim.fn.system({ 'curl', '-V' }):find('Protocols:.*https') then\n+    local out, rc = health.system({ 'curl', '-sL', url }, { stderr = true, ignore_error = true })\n+    if rc ~= 0 then\n+      return 'curl error with ' .. url .. ': ' .. rc\n+    else\n+      return out\n+    end\n+  elseif vim.fn.executable('python') == 1 then\n+    local script = \"try:\\n\\\n+          from urllib.request import urlopen\\n\\\n+          except ImportError:\\n\\\n+          from urllib2 import urlopen\\n\\\n+          response = urlopen('\" .. url .. \"')\\n\\\n+          print(response.read().decode('utf8'))\\n\"\n+    local out, rc = health.system({ 'python', '-c', script })\n+    if is_blank(out) and rc ~= 0 then\n+      return 'python urllib.request error: ' .. rc\n+    else\n+      return out\n+    end\n+  end\n+\n+  local message = 'missing `curl` '\n+\n+  if has_curl then\n+    message = message .. '(with HTTPS support) '\n+  end\n+  message = message .. 'and `python`, cannot make web request'\n+\n+  return message\n+end\n+\n+\n+-- Get the latest Nvim Python client (pynvim) version from PyPI.\n+local function latest_pypi_version()\n+  local pypi_version = 'unable to get pypi response'\n+  local pypi_response = download('https://pypi.python.org/pypi/pynvim/json')\n+  if not is_blank(pypi_response) then\n+    local pcall_ok, output = pcall(vim.fn.json_decode, pypi_response)\n+    local pypi_data\n+    if pcall_ok then\n+      pypi_data = output\n+    else\n+      return 'error: ' .. pypi_response\n+    end\n+\n+    local pypi_element = pypi_data['info'] or {}\n+    pypi_version = pypi_element['version'] or 'unable to parse'\n+  end\n+  return pypi_version\n+end\n+\n+local function is_bad_response(s)\n+  local lower = s:lower()\n+  return vim.startswith(lower, 'unable')\n+      or vim.startswith(lower, 'error')\n+      or vim.startswith(lower, 'outdated')\n+end\n+\n+\n+-- Get version information using the specified interpreter.  The interpreter is\n+-- used directly in case breaking changes were introduced since the last time\n+-- Nvim's Python client was updated.\n+--\n+-- Returns: {\n+--     {python executable version},\n+--     {current nvim version},\n+--     {current pypi nvim status},\n+--     {installed version status}\n+-- }\n+local function version_info(python)\n+  local pypi_version = latest_pypi_version()\n+\n+  local python_version, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; print(\".\".join(str(x) for x in sys.version_info[:3]))',\n+  })\n+\n+  if rc ~= 0 or is_blank(python_version) then\n+    python_version = 'unable to parse ' .. python .. ' response'\n+  end\n+\n+  local nvim_path, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; sys.path = [p for p in sys.path if p != \"\"]; import neovim; print(neovim.__file__)',\n+  })\n+  if rc ~= 0 or is_blank(nvim_path) then\n+    return { python_version, 'unable to load neovim Python module', pypi_version, nvim_path }\n+  end\n+\n+  -- Assuming that multiple versions of a package are installed, sort them\n+  -- numerically in descending order.\n+  local function compare(metapath1, metapath2)\n+    local a = vim.fn.matchstr(vim.fn.fnamemodify(metapath1, ':p:h:t'), [[[0-9.]\\+]])\n+    local b = vim.fn.matchstr(vim.fn.fnamemodify(metapath2, ':p:h:t'), [[[0-9.]\\+]])\n+    if a == b then\n+      return 0\n+    elseif a > b then\n+      return 1\n+    else\n+      return -1\n+    end\n+  end\n+\n+  -- Try to get neovim.VERSION (added in 0.1.11dev).\n+  local nvim_version, rc = health.system({\n+    python,\n+    '-c',\n+    'from neovim import VERSION as v; print(\"{}.{}.{}{}\".format(v.major, v.minor, v.patch, v.prerelease))',\n+  }, { stderr = true, ignore_error = true })\n+  if rc ~= 0 or is_blank(nvim_version) then\n+    nvim_version = 'unable to find pynvim module version'\n+    local base = vim.fs.basename(nvim_path)\n+    local metas = vim.fn.glob(base .. '-*/METADATA', 1, 1)\n+    vim.list_extend(metas, vim.fn.glob(base .. '-*/PKG-INFO', 1, 1))\n+    vim.list_extend(metas, vim.fn.glob(base .. '.egg-info/PKG-INFO', 1, 1))\n+    metas = table.sort(metas, compare)\n+\n+    if metas and next(metas) ~= nil then\n+      for line in io.lines(metas[1]) do\n+        local version = line:match('^Version: (%S+)')\n+        if version then\n+          nvim_version = version\n+          break\n+        end\n+      end\n+    end\n+  end\n+\n+  local nvim_path_base = vim.fn.fnamemodify(nvim_path, [[:~:h]])\n+  local version_status = 'unknown; ' .. nvim_path_base\n+  if is_bad_response(nvim_version) and is_bad_response(pypi_version) then\n+    if vim.version.lt(nvim_version, pypi_version) then\n+      version_status = 'outdated; from ' .. nvim_path_base\n+    else\n+      version_status = 'up to date'\n+    end\n+  end\n+\n+  return { python_version, nvim_version, pypi_version, version_status }\n+end\n+\n+function M.check()\n+  health.start('Python 3 provider (optional)')\n+\n+  local pyname = 'python3'\n+  local python_exe = ''\n+  local virtual_env = os.getenv('VIRTUAL_ENV')\n+  local venv = virtual_env and vim.fn.resolve(virtual_env) or ''\n+  local host_prog_var = pyname .. '_host_prog'\n+  local python_multiple = {}\n+\n+  if health.provider_disabled(pyname) then\n+    return\n+  end\n+\n+  local pyenv_table = check_for_pyenv()\n+  local pyenv = pyenv_table[1]\n+  local pyenv_root = pyenv_table[2]\n+\n+  if vim.g[host_prog_var] then\n+    local message = string.format('Using: g:%s = \"%s\"', host_prog_var, vim.g[host_prog_var])\n+    health.info(message)\n+  end\n+\n+  local python_table = vim.fn['provider#pythonx#Detect'](3)\n+  pyname = python_table[1]\n+  local pythonx_warnings = python_table[2]\n+\n+  if is_blank(pyname) then\n+    health.warn(\n+      'No Python executable found that can `import neovim`. '\n+      .. 'Using the first available executable for diagnostics.'\n+    )\n+  elseif vim.g[host_prog_var] then\n+    python_exe = pyname\n+  end\n+\n+  -- No Python executable could `import neovim`, or host_prog_var was used.\n+  if not is_blank(pythonx_warnings) then\n+    health.warn(pythonx_warnings, {\n+      'See :help provider-python for more information.',\n+      'You may disable this provider (and warning) by adding `let g:loaded_python3_provider = 0` to your init.vim',\n+    })\n+  elseif not is_blank(pyname) and is_blank(python_exe) then\n+    if not vim.g[host_prog_var] then\n+      local message = string.format(\n+        '`g:%s` is not set. Searching for %s in the environment.',\n+        host_prog_var,\n+        pyname\n+      )\n+      health.info(message)\n+    end\n+\n+    if not is_blank(pyenv) then\n+      python_exe = health.system({ pyenv, 'which', pyname }, { stderr = true })\n+      if is_blank(python_exe) then\n+        health.warn('pyenv could not find ' .. pyname .. '.')\n+      end\n+    end\n+\n+    if is_blank(python_exe) then\n+      python_exe = vim.fn.exepath(pyname)\n+\n+      if os.getenv('PATH') then\n+        local path_sep = iswin and ';' or ':'\n+        local paths = vim.split(os.getenv('PATH') or '', path_sep)\n+\n+        for _, path in ipairs(paths) do\n+          local path_bin = vim.fs.normalize(path .. '/' .. pyname)\n+          if\n+              path_bin ~= vim.fs.normalize(python_exe)\n+              and vim.tbl_contains(python_multiple, path_bin)\n+              and vim.fn.executable(path_bin) == 1\n+          then\n+            python_multiple[#python_multiple + 1] = path_bin\n+          end\n+        end\n+\n+        if vim.tbl_count(python_multiple) > 0 then\n+          -- This is worth noting since the user may install something\n+          -- that changes $PATH, like homebrew.\n+          local message = string.format('Multiple %s executables found. Set `g:%s` to avoid surprises.', pyname,\n+            host_prog_var)\n+          health.info(message)\n+        end\n+\n+        if python_exe:find('shims') then\n+          local message = string.format('`%s` appears to be a pyenv shim.', python_exe)\n+          local advice = string.format(\n+            '`pyenv` is not in $PATH, your pyenv installation is broken. Set `g:%s` to avoid surprises.', host_prog_var)\n+          health.warn(message, advice)\n+        end\n+      end\n+    end\n+  end\n+\n+  if not is_blank(python_exe) and not vim.g[host_prog_var] then\n+    if\n+        is_blank(venv)\n+        and not is_blank(pyenv)\n+        and not is_blank(pyenv_root)\n+        and vim.startswith(vim.fn.resolve(python_exe), pyenv_root .. '/')\n+    then\n+      local advice = string.format(\n+        'Create a virtualenv specifically for Nvim using pyenv, and set `g:%s`.  This will avoid the need to install the pynvim module in each version/virtualenv.',\n+        host_prog_var)\n+      health.warn('pyenv is not set up optimally.', advice)\n+    elseif not is_blank(venv) then\n+      local venv_root\n+      if not is_blank(pyenv_root) then\n+        venv_root = pyenv_root\n+      else\n+        venv_root = vim.fs.dirname(venv)\n+      end\n+\n+      if vim.startswith(vim.fn.resolve(python_exe), venv_root .. '/') then\n+        local advice = string.format(\n+          'Create a virtualenv specifically for Nvim and use `g:%s`.  This will avoid the need to install the pynvim module in each virtualenv.',\n+          host_prog_var)\n+        health.warn('Your virtualenv is not set up optimally.', advice)\n+      end\n+    end\n+  end\n+\n+  if is_blank(python_exe) and not is_blank(pyname) then\n+    -- An error message should have already printed.\n+    health.error('`' .. pyname .. '` was not found.')\n+  elseif not is_blank(python_exe) and not check_bin(python_exe) then\n+    python_exe = ''\n+  end\n+\n+  -- Diagnostic output\n+  health.info('Executable: ' .. (is_blank(python_exe) and 'Not found' or python_exe))\n+  if vim.tbl_count(python_multiple) > 0 then\n+    for _, path_bin in ipairs(python_multiple) do\n+      health.info('Other python executable: ' .. path_bin)\n+    end\n+  end\n+\n+  if is_blank(python_exe) then\n+    -- No Python executable can import 'neovim'. Check if any Python executable\n+    -- can import 'pynvim'. If so, that Python failed to import 'neovim' as\n+    -- well, which is most probably due to a failed pip upgrade:\n+    -- https://github.com/neovim/neovim/wiki/Following-HEAD#20181118\n+    local pynvim_table = vim.fn['provider#pythonx#DetectByModule']('pynvim', 3)\n+    local pynvim_exe = pynvim_table[1]\n+    if not is_blank(pynvim_exe) then\n+      local message = 'Detected pip upgrade failure: Python executable can import \"pynvim\" but not \"neovim\": '\n+          .. pynvim_exe\n+      local advice = {\n+        'Use that Python version to reinstall \"pynvim\" and optionally \"neovim\".',\n+        pynvim_exe .. ' -m pip uninstall pynvim neovim',\n+        pynvim_exe .. ' -m pip install pynvim',\n+        pynvim_exe .. ' -m pip install neovim  # only if needed by third-party software',\n+      }\n+      health.error(message, advice)\n+    end\n+  else\n+    local version_info_table = version_info(python_exe)\n+    local pyversion = version_info_table[1]\n+    local current = version_info_table[2]\n+    local latest = version_info_table[3]\n+    local status = version_info_table[4]\n+\n+    if not vim.version.range('~3'):has(pyversion) then",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163082257",
            "id": 1163082257,
            "line": 385,
            "node_id": "PRRC_kwDOAPphoM5FUzoR",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 385,
            "original_position": 385,
            "original_start_line": null,
            "path": "runtime/lua/provider/python/health.lua",
            "position": 385,
            "pull_request_review_id": 1379697365,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163082257/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T16:42:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163082257",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163103057"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163103057"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        local paths = vim.split(os.getenv('PATH'), path_sep)\r\n```",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T17:02:34Z",
            "diff_hunk": "@@ -0,0 +1,490 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+local function is(path, ty)\n+  if not path then\n+    return false\n+  end\n+  local stat = vim.loop.fs_stat(path)\n+  if not stat then\n+    return false\n+  end\n+  return stat.type == ty\n+end\n+\n+-- Resolves Python executable path by invoking and checking `sys.executable`.\n+local function python_exepath(invocation)\n+  local python = vim.fn.fnameescape(invocation)\n+  local out = vim.fn.system(python .. ' -c \"import sys; sys.stdout.write(sys.executable)\"')\n+  assert(vim.v.shell_error == 0, out)\n+  return vim.fs.normalize(vim.trim(out))\n+end\n+\n+local function is_blank(v)\n+  return v:find('^%s*$') ~= nil\n+end\n+\n+-- Check if pyenv is available and a valid pyenv root can be found, then return\n+-- their respective paths. If either of those is invalid, return two empty\n+-- strings, effectively ignoring pyenv.\n+local function check_for_pyenv()\n+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))\n+\n+  if is_blank(pyenv_path) then\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Path: ' .. pyenv_path)\n+\n+  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''\n+\n+  if is_blank(pyenv_root) then\n+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })\n+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')\n+  end\n+\n+  if not is(pyenv_root, 'directory') then\n+    local message = string.format(\n+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',\n+      pyenv_root\n+    )\n+    health.warn(message)\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Root: ' .. pyenv_root)\n+\n+  return { pyenv_path, pyenv_root }\n+end\n+\n+-- Check the Python interpreter's usability.\n+local function check_bin(bin)\n+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then\n+    health.error('\"' .. bin .. '\" was not found.')\n+    return false\n+  elseif vim.fn.executable(bin) ~= 1 then\n+    health.error('\"' .. bin .. '\" is not executable.')\n+    return false\n+  end\n+  return true\n+end\n+\n+-- Fetch the contents of a URL.\n+local function download(url)\n+  local has_curl = vim.fn.executable('curl') == 1\n+  if has_curl and vim.fn.system({ 'curl', '-V' }):find('Protocols:.*https') then\n+    local out, rc = health.system({ 'curl', '-sL', url }, { stderr = true, ignore_error = true })\n+    if rc ~= 0 then\n+      return 'curl error with ' .. url .. ': ' .. rc\n+    else\n+      return out\n+    end\n+  elseif vim.fn.executable('python') == 1 then\n+    local script = \"try:\\n\\\n+          from urllib.request import urlopen\\n\\\n+          except ImportError:\\n\\\n+          from urllib2 import urlopen\\n\\\n+          response = urlopen('\" .. url .. \"')\\n\\\n+          print(response.read().decode('utf8'))\\n\"\n+    local out, rc = health.system({ 'python', '-c', script })\n+    if is_blank(out) and rc ~= 0 then\n+      return 'python urllib.request error: ' .. rc\n+    else\n+      return out\n+    end\n+  end\n+\n+  local message = 'missing `curl` '\n+\n+  if has_curl then\n+    message = message .. '(with HTTPS support) '\n+  end\n+  message = message .. 'and `python`, cannot make web request'\n+\n+  return message\n+end\n+\n+\n+-- Get the latest Nvim Python client (pynvim) version from PyPI.\n+local function latest_pypi_version()\n+  local pypi_version = 'unable to get pypi response'\n+  local pypi_response = download('https://pypi.python.org/pypi/pynvim/json')\n+  if not is_blank(pypi_response) then\n+    local pcall_ok, output = pcall(vim.fn.json_decode, pypi_response)\n+    local pypi_data\n+    if pcall_ok then\n+      pypi_data = output\n+    else\n+      return 'error: ' .. pypi_response\n+    end\n+\n+    local pypi_element = pypi_data['info'] or {}\n+    pypi_version = pypi_element['version'] or 'unable to parse'\n+  end\n+  return pypi_version\n+end\n+\n+local function is_bad_response(s)\n+  local lower = s:lower()\n+  return vim.startswith(lower, 'unable')\n+      or vim.startswith(lower, 'error')\n+      or vim.startswith(lower, 'outdated')\n+end\n+\n+\n+-- Get version information using the specified interpreter.  The interpreter is\n+-- used directly in case breaking changes were introduced since the last time\n+-- Nvim's Python client was updated.\n+--\n+-- Returns: {\n+--     {python executable version},\n+--     {current nvim version},\n+--     {current pypi nvim status},\n+--     {installed version status}\n+-- }\n+local function version_info(python)\n+  local pypi_version = latest_pypi_version()\n+\n+  local python_version, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; print(\".\".join(str(x) for x in sys.version_info[:3]))',\n+  })\n+\n+  if rc ~= 0 or is_blank(python_version) then\n+    python_version = 'unable to parse ' .. python .. ' response'\n+  end\n+\n+  local nvim_path, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; sys.path = [p for p in sys.path if p != \"\"]; import neovim; print(neovim.__file__)',\n+  })\n+  if rc ~= 0 or is_blank(nvim_path) then\n+    return { python_version, 'unable to load neovim Python module', pypi_version, nvim_path }\n+  end\n+\n+  -- Assuming that multiple versions of a package are installed, sort them\n+  -- numerically in descending order.\n+  local function compare(metapath1, metapath2)\n+    local a = vim.fn.matchstr(vim.fn.fnamemodify(metapath1, ':p:h:t'), [[[0-9.]\\+]])\n+    local b = vim.fn.matchstr(vim.fn.fnamemodify(metapath2, ':p:h:t'), [[[0-9.]\\+]])\n+    if a == b then\n+      return 0\n+    elseif a > b then\n+      return 1\n+    else\n+      return -1\n+    end\n+  end\n+\n+  -- Try to get neovim.VERSION (added in 0.1.11dev).\n+  local nvim_version, rc = health.system({\n+    python,\n+    '-c',\n+    'from neovim import VERSION as v; print(\"{}.{}.{}{}\".format(v.major, v.minor, v.patch, v.prerelease))',\n+  }, { stderr = true, ignore_error = true })\n+  if rc ~= 0 or is_blank(nvim_version) then\n+    nvim_version = 'unable to find pynvim module version'\n+    local base = vim.fs.basename(nvim_path)\n+    local metas = vim.fn.glob(base .. '-*/METADATA', 1, 1)\n+    vim.list_extend(metas, vim.fn.glob(base .. '-*/PKG-INFO', 1, 1))\n+    vim.list_extend(metas, vim.fn.glob(base .. '.egg-info/PKG-INFO', 1, 1))\n+    metas = table.sort(metas, compare)\n+\n+    if metas and next(metas) ~= nil then\n+      for line in io.lines(metas[1]) do\n+        local version = line:match('^Version: (%S+)')\n+        if version then\n+          nvim_version = version\n+          break\n+        end\n+      end\n+    end\n+  end\n+\n+  local nvim_path_base = vim.fn.fnamemodify(nvim_path, [[:~:h]])\n+  local version_status = 'unknown; ' .. nvim_path_base\n+  if is_bad_response(nvim_version) and is_bad_response(pypi_version) then\n+    if vim.version.lt(nvim_version, pypi_version) then\n+      version_status = 'outdated; from ' .. nvim_path_base\n+    else\n+      version_status = 'up to date'\n+    end\n+  end\n+\n+  return { python_version, nvim_version, pypi_version, version_status }\n+end\n+\n+function M.check()\n+  health.start('Python 3 provider (optional)')\n+\n+  local pyname = 'python3'\n+  local python_exe = ''\n+  local virtual_env = os.getenv('VIRTUAL_ENV')\n+  local venv = virtual_env and vim.fn.resolve(virtual_env) or ''\n+  local host_prog_var = pyname .. '_host_prog'\n+  local python_multiple = {}\n+\n+  if health.provider_disabled(pyname) then\n+    return\n+  end\n+\n+  local pyenv_table = check_for_pyenv()\n+  local pyenv = pyenv_table[1]\n+  local pyenv_root = pyenv_table[2]\n+\n+  if vim.g[host_prog_var] then\n+    local message = string.format('Using: g:%s = \"%s\"', host_prog_var, vim.g[host_prog_var])\n+    health.info(message)\n+  end\n+\n+  local python_table = vim.fn['provider#pythonx#Detect'](3)\n+  pyname = python_table[1]\n+  local pythonx_warnings = python_table[2]\n+\n+  if is_blank(pyname) then\n+    health.warn(\n+      'No Python executable found that can `import neovim`. '\n+      .. 'Using the first available executable for diagnostics.'\n+    )\n+  elseif vim.g[host_prog_var] then\n+    python_exe = pyname\n+  end\n+\n+  -- No Python executable could `import neovim`, or host_prog_var was used.\n+  if not is_blank(pythonx_warnings) then\n+    health.warn(pythonx_warnings, {\n+      'See :help provider-python for more information.',\n+      'You may disable this provider (and warning) by adding `let g:loaded_python3_provider = 0` to your init.vim',\n+    })\n+  elseif not is_blank(pyname) and is_blank(python_exe) then\n+    if not vim.g[host_prog_var] then\n+      local message = string.format(\n+        '`g:%s` is not set. Searching for %s in the environment.',\n+        host_prog_var,\n+        pyname\n+      )\n+      health.info(message)\n+    end\n+\n+    if not is_blank(pyenv) then\n+      python_exe = health.system({ pyenv, 'which', pyname }, { stderr = true })\n+      if is_blank(python_exe) then\n+        health.warn('pyenv could not find ' .. pyname .. '.')\n+      end\n+    end\n+\n+    if is_blank(python_exe) then\n+      python_exe = vim.fn.exepath(pyname)\n+\n+      if os.getenv('PATH') then\n+        local path_sep = iswin and ';' or ':'\n+        local paths = vim.split(os.getenv('PATH') or '', path_sep)",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163103057",
            "id": 1163103057,
            "line": 286,
            "node_id": "PRRC_kwDOAPphoM5FU4tR",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 286,
            "original_position": 286,
            "original_start_line": null,
            "path": "runtime/lua/provider/python/health.lua",
            "position": 286,
            "pull_request_review_id": 1379728789,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163103057/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T17:41:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163103057",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163107680"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163107680"
                }
            },
            "author_association": "MEMBER",
            "body": "nit: `#` would also work",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T17:07:38Z",
            "diff_hunk": "@@ -0,0 +1,490 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+local function is(path, ty)\n+  if not path then\n+    return false\n+  end\n+  local stat = vim.loop.fs_stat(path)\n+  if not stat then\n+    return false\n+  end\n+  return stat.type == ty\n+end\n+\n+-- Resolves Python executable path by invoking and checking `sys.executable`.\n+local function python_exepath(invocation)\n+  local python = vim.fn.fnameescape(invocation)\n+  local out = vim.fn.system(python .. ' -c \"import sys; sys.stdout.write(sys.executable)\"')\n+  assert(vim.v.shell_error == 0, out)\n+  return vim.fs.normalize(vim.trim(out))\n+end\n+\n+local function is_blank(v)\n+  return v:find('^%s*$') ~= nil\n+end\n+\n+-- Check if pyenv is available and a valid pyenv root can be found, then return\n+-- their respective paths. If either of those is invalid, return two empty\n+-- strings, effectively ignoring pyenv.\n+local function check_for_pyenv()\n+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))\n+\n+  if is_blank(pyenv_path) then\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Path: ' .. pyenv_path)\n+\n+  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''\n+\n+  if is_blank(pyenv_root) then\n+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })\n+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')\n+  end\n+\n+  if not is(pyenv_root, 'directory') then\n+    local message = string.format(\n+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',\n+      pyenv_root\n+    )\n+    health.warn(message)\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Root: ' .. pyenv_root)\n+\n+  return { pyenv_path, pyenv_root }\n+end\n+\n+-- Check the Python interpreter's usability.\n+local function check_bin(bin)\n+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then\n+    health.error('\"' .. bin .. '\" was not found.')\n+    return false\n+  elseif vim.fn.executable(bin) ~= 1 then\n+    health.error('\"' .. bin .. '\" is not executable.')\n+    return false\n+  end\n+  return true\n+end\n+\n+-- Fetch the contents of a URL.\n+local function download(url)\n+  local has_curl = vim.fn.executable('curl') == 1\n+  if has_curl and vim.fn.system({ 'curl', '-V' }):find('Protocols:.*https') then\n+    local out, rc = health.system({ 'curl', '-sL', url }, { stderr = true, ignore_error = true })\n+    if rc ~= 0 then\n+      return 'curl error with ' .. url .. ': ' .. rc\n+    else\n+      return out\n+    end\n+  elseif vim.fn.executable('python') == 1 then\n+    local script = \"try:\\n\\\n+          from urllib.request import urlopen\\n\\\n+          except ImportError:\\n\\\n+          from urllib2 import urlopen\\n\\\n+          response = urlopen('\" .. url .. \"')\\n\\\n+          print(response.read().decode('utf8'))\\n\"\n+    local out, rc = health.system({ 'python', '-c', script })\n+    if is_blank(out) and rc ~= 0 then\n+      return 'python urllib.request error: ' .. rc\n+    else\n+      return out\n+    end\n+  end\n+\n+  local message = 'missing `curl` '\n+\n+  if has_curl then\n+    message = message .. '(with HTTPS support) '\n+  end\n+  message = message .. 'and `python`, cannot make web request'\n+\n+  return message\n+end\n+\n+\n+-- Get the latest Nvim Python client (pynvim) version from PyPI.\n+local function latest_pypi_version()\n+  local pypi_version = 'unable to get pypi response'\n+  local pypi_response = download('https://pypi.python.org/pypi/pynvim/json')\n+  if not is_blank(pypi_response) then\n+    local pcall_ok, output = pcall(vim.fn.json_decode, pypi_response)\n+    local pypi_data\n+    if pcall_ok then\n+      pypi_data = output\n+    else\n+      return 'error: ' .. pypi_response\n+    end\n+\n+    local pypi_element = pypi_data['info'] or {}\n+    pypi_version = pypi_element['version'] or 'unable to parse'\n+  end\n+  return pypi_version\n+end\n+\n+local function is_bad_response(s)\n+  local lower = s:lower()\n+  return vim.startswith(lower, 'unable')\n+      or vim.startswith(lower, 'error')\n+      or vim.startswith(lower, 'outdated')\n+end\n+\n+\n+-- Get version information using the specified interpreter.  The interpreter is\n+-- used directly in case breaking changes were introduced since the last time\n+-- Nvim's Python client was updated.\n+--\n+-- Returns: {\n+--     {python executable version},\n+--     {current nvim version},\n+--     {current pypi nvim status},\n+--     {installed version status}\n+-- }\n+local function version_info(python)\n+  local pypi_version = latest_pypi_version()\n+\n+  local python_version, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; print(\".\".join(str(x) for x in sys.version_info[:3]))',\n+  })\n+\n+  if rc ~= 0 or is_blank(python_version) then\n+    python_version = 'unable to parse ' .. python .. ' response'\n+  end\n+\n+  local nvim_path, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; sys.path = [p for p in sys.path if p != \"\"]; import neovim; print(neovim.__file__)',\n+  })\n+  if rc ~= 0 or is_blank(nvim_path) then\n+    return { python_version, 'unable to load neovim Python module', pypi_version, nvim_path }\n+  end\n+\n+  -- Assuming that multiple versions of a package are installed, sort them\n+  -- numerically in descending order.\n+  local function compare(metapath1, metapath2)\n+    local a = vim.fn.matchstr(vim.fn.fnamemodify(metapath1, ':p:h:t'), [[[0-9.]\\+]])\n+    local b = vim.fn.matchstr(vim.fn.fnamemodify(metapath2, ':p:h:t'), [[[0-9.]\\+]])\n+    if a == b then\n+      return 0\n+    elseif a > b then\n+      return 1\n+    else\n+      return -1\n+    end\n+  end\n+\n+  -- Try to get neovim.VERSION (added in 0.1.11dev).\n+  local nvim_version, rc = health.system({\n+    python,\n+    '-c',\n+    'from neovim import VERSION as v; print(\"{}.{}.{}{}\".format(v.major, v.minor, v.patch, v.prerelease))',\n+  }, { stderr = true, ignore_error = true })\n+  if rc ~= 0 or is_blank(nvim_version) then\n+    nvim_version = 'unable to find pynvim module version'\n+    local base = vim.fs.basename(nvim_path)\n+    local metas = vim.fn.glob(base .. '-*/METADATA', 1, 1)\n+    vim.list_extend(metas, vim.fn.glob(base .. '-*/PKG-INFO', 1, 1))\n+    vim.list_extend(metas, vim.fn.glob(base .. '.egg-info/PKG-INFO', 1, 1))\n+    metas = table.sort(metas, compare)\n+\n+    if metas and next(metas) ~= nil then\n+      for line in io.lines(metas[1]) do\n+        local version = line:match('^Version: (%S+)')\n+        if version then\n+          nvim_version = version\n+          break\n+        end\n+      end\n+    end\n+  end\n+\n+  local nvim_path_base = vim.fn.fnamemodify(nvim_path, [[:~:h]])\n+  local version_status = 'unknown; ' .. nvim_path_base\n+  if is_bad_response(nvim_version) and is_bad_response(pypi_version) then\n+    if vim.version.lt(nvim_version, pypi_version) then\n+      version_status = 'outdated; from ' .. nvim_path_base\n+    else\n+      version_status = 'up to date'\n+    end\n+  end\n+\n+  return { python_version, nvim_version, pypi_version, version_status }\n+end\n+\n+function M.check()\n+  health.start('Python 3 provider (optional)')\n+\n+  local pyname = 'python3'\n+  local python_exe = ''\n+  local virtual_env = os.getenv('VIRTUAL_ENV')\n+  local venv = virtual_env and vim.fn.resolve(virtual_env) or ''\n+  local host_prog_var = pyname .. '_host_prog'\n+  local python_multiple = {}\n+\n+  if health.provider_disabled(pyname) then\n+    return\n+  end\n+\n+  local pyenv_table = check_for_pyenv()\n+  local pyenv = pyenv_table[1]\n+  local pyenv_root = pyenv_table[2]\n+\n+  if vim.g[host_prog_var] then\n+    local message = string.format('Using: g:%s = \"%s\"', host_prog_var, vim.g[host_prog_var])\n+    health.info(message)\n+  end\n+\n+  local python_table = vim.fn['provider#pythonx#Detect'](3)\n+  pyname = python_table[1]\n+  local pythonx_warnings = python_table[2]\n+\n+  if is_blank(pyname) then\n+    health.warn(\n+      'No Python executable found that can `import neovim`. '\n+      .. 'Using the first available executable for diagnostics.'\n+    )\n+  elseif vim.g[host_prog_var] then\n+    python_exe = pyname\n+  end\n+\n+  -- No Python executable could `import neovim`, or host_prog_var was used.\n+  if not is_blank(pythonx_warnings) then\n+    health.warn(pythonx_warnings, {\n+      'See :help provider-python for more information.',\n+      'You may disable this provider (and warning) by adding `let g:loaded_python3_provider = 0` to your init.vim',\n+    })\n+  elseif not is_blank(pyname) and is_blank(python_exe) then\n+    if not vim.g[host_prog_var] then\n+      local message = string.format(\n+        '`g:%s` is not set. Searching for %s in the environment.',\n+        host_prog_var,\n+        pyname\n+      )\n+      health.info(message)\n+    end\n+\n+    if not is_blank(pyenv) then\n+      python_exe = health.system({ pyenv, 'which', pyname }, { stderr = true })\n+      if is_blank(python_exe) then\n+        health.warn('pyenv could not find ' .. pyname .. '.')\n+      end\n+    end\n+\n+    if is_blank(python_exe) then\n+      python_exe = vim.fn.exepath(pyname)\n+\n+      if os.getenv('PATH') then\n+        local path_sep = iswin and ';' or ':'\n+        local paths = vim.split(os.getenv('PATH') or '', path_sep)\n+\n+        for _, path in ipairs(paths) do\n+          local path_bin = vim.fs.normalize(path .. '/' .. pyname)\n+          if\n+              path_bin ~= vim.fs.normalize(python_exe)\n+              and vim.tbl_contains(python_multiple, path_bin)\n+              and vim.fn.executable(path_bin) == 1\n+          then\n+            python_multiple[#python_multiple + 1] = path_bin\n+          end\n+        end\n+\n+        if vim.tbl_count(python_multiple) > 0 then",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163107680",
            "id": 1163107680,
            "line": 299,
            "node_id": "PRRC_kwDOAPphoM5FU51g",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 299,
            "original_position": 299,
            "original_start_line": null,
            "path": "runtime/lua/provider/python/health.lua",
            "position": 299,
            "pull_request_review_id": 1379728789,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163107680/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T17:41:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163107680",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163110989"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163110989"
                }
            },
            "author_association": "MEMBER",
            "body": "Original pattern was `\\<shims\\>`, which matches at word boundaries.\r\nI dunno much about python, so idk if ignoring it makes any difference :shrug: ",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T17:10:50Z",
            "diff_hunk": "@@ -0,0 +1,490 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+local function is(path, ty)\n+  if not path then\n+    return false\n+  end\n+  local stat = vim.loop.fs_stat(path)\n+  if not stat then\n+    return false\n+  end\n+  return stat.type == ty\n+end\n+\n+-- Resolves Python executable path by invoking and checking `sys.executable`.\n+local function python_exepath(invocation)\n+  local python = vim.fn.fnameescape(invocation)\n+  local out = vim.fn.system(python .. ' -c \"import sys; sys.stdout.write(sys.executable)\"')\n+  assert(vim.v.shell_error == 0, out)\n+  return vim.fs.normalize(vim.trim(out))\n+end\n+\n+local function is_blank(v)\n+  return v:find('^%s*$') ~= nil\n+end\n+\n+-- Check if pyenv is available and a valid pyenv root can be found, then return\n+-- their respective paths. If either of those is invalid, return two empty\n+-- strings, effectively ignoring pyenv.\n+local function check_for_pyenv()\n+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))\n+\n+  if is_blank(pyenv_path) then\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Path: ' .. pyenv_path)\n+\n+  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''\n+\n+  if is_blank(pyenv_root) then\n+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })\n+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')\n+  end\n+\n+  if not is(pyenv_root, 'directory') then\n+    local message = string.format(\n+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',\n+      pyenv_root\n+    )\n+    health.warn(message)\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Root: ' .. pyenv_root)\n+\n+  return { pyenv_path, pyenv_root }\n+end\n+\n+-- Check the Python interpreter's usability.\n+local function check_bin(bin)\n+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then\n+    health.error('\"' .. bin .. '\" was not found.')\n+    return false\n+  elseif vim.fn.executable(bin) ~= 1 then\n+    health.error('\"' .. bin .. '\" is not executable.')\n+    return false\n+  end\n+  return true\n+end\n+\n+-- Fetch the contents of a URL.\n+local function download(url)\n+  local has_curl = vim.fn.executable('curl') == 1\n+  if has_curl and vim.fn.system({ 'curl', '-V' }):find('Protocols:.*https') then\n+    local out, rc = health.system({ 'curl', '-sL', url }, { stderr = true, ignore_error = true })\n+    if rc ~= 0 then\n+      return 'curl error with ' .. url .. ': ' .. rc\n+    else\n+      return out\n+    end\n+  elseif vim.fn.executable('python') == 1 then\n+    local script = \"try:\\n\\\n+          from urllib.request import urlopen\\n\\\n+          except ImportError:\\n\\\n+          from urllib2 import urlopen\\n\\\n+          response = urlopen('\" .. url .. \"')\\n\\\n+          print(response.read().decode('utf8'))\\n\"\n+    local out, rc = health.system({ 'python', '-c', script })\n+    if is_blank(out) and rc ~= 0 then\n+      return 'python urllib.request error: ' .. rc\n+    else\n+      return out\n+    end\n+  end\n+\n+  local message = 'missing `curl` '\n+\n+  if has_curl then\n+    message = message .. '(with HTTPS support) '\n+  end\n+  message = message .. 'and `python`, cannot make web request'\n+\n+  return message\n+end\n+\n+\n+-- Get the latest Nvim Python client (pynvim) version from PyPI.\n+local function latest_pypi_version()\n+  local pypi_version = 'unable to get pypi response'\n+  local pypi_response = download('https://pypi.python.org/pypi/pynvim/json')\n+  if not is_blank(pypi_response) then\n+    local pcall_ok, output = pcall(vim.fn.json_decode, pypi_response)\n+    local pypi_data\n+    if pcall_ok then\n+      pypi_data = output\n+    else\n+      return 'error: ' .. pypi_response\n+    end\n+\n+    local pypi_element = pypi_data['info'] or {}\n+    pypi_version = pypi_element['version'] or 'unable to parse'\n+  end\n+  return pypi_version\n+end\n+\n+local function is_bad_response(s)\n+  local lower = s:lower()\n+  return vim.startswith(lower, 'unable')\n+      or vim.startswith(lower, 'error')\n+      or vim.startswith(lower, 'outdated')\n+end\n+\n+\n+-- Get version information using the specified interpreter.  The interpreter is\n+-- used directly in case breaking changes were introduced since the last time\n+-- Nvim's Python client was updated.\n+--\n+-- Returns: {\n+--     {python executable version},\n+--     {current nvim version},\n+--     {current pypi nvim status},\n+--     {installed version status}\n+-- }\n+local function version_info(python)\n+  local pypi_version = latest_pypi_version()\n+\n+  local python_version, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; print(\".\".join(str(x) for x in sys.version_info[:3]))',\n+  })\n+\n+  if rc ~= 0 or is_blank(python_version) then\n+    python_version = 'unable to parse ' .. python .. ' response'\n+  end\n+\n+  local nvim_path, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; sys.path = [p for p in sys.path if p != \"\"]; import neovim; print(neovim.__file__)',\n+  })\n+  if rc ~= 0 or is_blank(nvim_path) then\n+    return { python_version, 'unable to load neovim Python module', pypi_version, nvim_path }\n+  end\n+\n+  -- Assuming that multiple versions of a package are installed, sort them\n+  -- numerically in descending order.\n+  local function compare(metapath1, metapath2)\n+    local a = vim.fn.matchstr(vim.fn.fnamemodify(metapath1, ':p:h:t'), [[[0-9.]\\+]])\n+    local b = vim.fn.matchstr(vim.fn.fnamemodify(metapath2, ':p:h:t'), [[[0-9.]\\+]])\n+    if a == b then\n+      return 0\n+    elseif a > b then\n+      return 1\n+    else\n+      return -1\n+    end\n+  end\n+\n+  -- Try to get neovim.VERSION (added in 0.1.11dev).\n+  local nvim_version, rc = health.system({\n+    python,\n+    '-c',\n+    'from neovim import VERSION as v; print(\"{}.{}.{}{}\".format(v.major, v.minor, v.patch, v.prerelease))',\n+  }, { stderr = true, ignore_error = true })\n+  if rc ~= 0 or is_blank(nvim_version) then\n+    nvim_version = 'unable to find pynvim module version'\n+    local base = vim.fs.basename(nvim_path)\n+    local metas = vim.fn.glob(base .. '-*/METADATA', 1, 1)\n+    vim.list_extend(metas, vim.fn.glob(base .. '-*/PKG-INFO', 1, 1))\n+    vim.list_extend(metas, vim.fn.glob(base .. '.egg-info/PKG-INFO', 1, 1))\n+    metas = table.sort(metas, compare)\n+\n+    if metas and next(metas) ~= nil then\n+      for line in io.lines(metas[1]) do\n+        local version = line:match('^Version: (%S+)')\n+        if version then\n+          nvim_version = version\n+          break\n+        end\n+      end\n+    end\n+  end\n+\n+  local nvim_path_base = vim.fn.fnamemodify(nvim_path, [[:~:h]])\n+  local version_status = 'unknown; ' .. nvim_path_base\n+  if is_bad_response(nvim_version) and is_bad_response(pypi_version) then\n+    if vim.version.lt(nvim_version, pypi_version) then\n+      version_status = 'outdated; from ' .. nvim_path_base\n+    else\n+      version_status = 'up to date'\n+    end\n+  end\n+\n+  return { python_version, nvim_version, pypi_version, version_status }\n+end\n+\n+function M.check()\n+  health.start('Python 3 provider (optional)')\n+\n+  local pyname = 'python3'\n+  local python_exe = ''\n+  local virtual_env = os.getenv('VIRTUAL_ENV')\n+  local venv = virtual_env and vim.fn.resolve(virtual_env) or ''\n+  local host_prog_var = pyname .. '_host_prog'\n+  local python_multiple = {}\n+\n+  if health.provider_disabled(pyname) then\n+    return\n+  end\n+\n+  local pyenv_table = check_for_pyenv()\n+  local pyenv = pyenv_table[1]\n+  local pyenv_root = pyenv_table[2]\n+\n+  if vim.g[host_prog_var] then\n+    local message = string.format('Using: g:%s = \"%s\"', host_prog_var, vim.g[host_prog_var])\n+    health.info(message)\n+  end\n+\n+  local python_table = vim.fn['provider#pythonx#Detect'](3)\n+  pyname = python_table[1]\n+  local pythonx_warnings = python_table[2]\n+\n+  if is_blank(pyname) then\n+    health.warn(\n+      'No Python executable found that can `import neovim`. '\n+      .. 'Using the first available executable for diagnostics.'\n+    )\n+  elseif vim.g[host_prog_var] then\n+    python_exe = pyname\n+  end\n+\n+  -- No Python executable could `import neovim`, or host_prog_var was used.\n+  if not is_blank(pythonx_warnings) then\n+    health.warn(pythonx_warnings, {\n+      'See :help provider-python for more information.',\n+      'You may disable this provider (and warning) by adding `let g:loaded_python3_provider = 0` to your init.vim',\n+    })\n+  elseif not is_blank(pyname) and is_blank(python_exe) then\n+    if not vim.g[host_prog_var] then\n+      local message = string.format(\n+        '`g:%s` is not set. Searching for %s in the environment.',\n+        host_prog_var,\n+        pyname\n+      )\n+      health.info(message)\n+    end\n+\n+    if not is_blank(pyenv) then\n+      python_exe = health.system({ pyenv, 'which', pyname }, { stderr = true })\n+      if is_blank(python_exe) then\n+        health.warn('pyenv could not find ' .. pyname .. '.')\n+      end\n+    end\n+\n+    if is_blank(python_exe) then\n+      python_exe = vim.fn.exepath(pyname)\n+\n+      if os.getenv('PATH') then\n+        local path_sep = iswin and ';' or ':'\n+        local paths = vim.split(os.getenv('PATH') or '', path_sep)\n+\n+        for _, path in ipairs(paths) do\n+          local path_bin = vim.fs.normalize(path .. '/' .. pyname)\n+          if\n+              path_bin ~= vim.fs.normalize(python_exe)\n+              and vim.tbl_contains(python_multiple, path_bin)\n+              and vim.fn.executable(path_bin) == 1\n+          then\n+            python_multiple[#python_multiple + 1] = path_bin\n+          end\n+        end\n+\n+        if vim.tbl_count(python_multiple) > 0 then\n+          -- This is worth noting since the user may install something\n+          -- that changes $PATH, like homebrew.\n+          local message = string.format('Multiple %s executables found. Set `g:%s` to avoid surprises.', pyname,\n+            host_prog_var)\n+          health.info(message)\n+        end\n+\n+        if python_exe:find('shims') then",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163110989",
            "id": 1163110989,
            "line": 307,
            "node_id": "PRRC_kwDOAPphoM5FU6pN",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 307,
            "original_position": 307,
            "original_start_line": null,
            "path": "runtime/lua/provider/python/health.lua",
            "position": 307,
            "pull_request_review_id": 1379728789,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163110989/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T17:41:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163110989",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163113998"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163113998"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        and not vim.startswith(vim.fn.resolve(python_exe), pyenv_root .. '/')\r\n```\r\n\r\nI guess, as the original used `!~#`.",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T17:13:03Z",
            "diff_hunk": "@@ -0,0 +1,490 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+local function is(path, ty)\n+  if not path then\n+    return false\n+  end\n+  local stat = vim.loop.fs_stat(path)\n+  if not stat then\n+    return false\n+  end\n+  return stat.type == ty\n+end\n+\n+-- Resolves Python executable path by invoking and checking `sys.executable`.\n+local function python_exepath(invocation)\n+  local python = vim.fn.fnameescape(invocation)\n+  local out = vim.fn.system(python .. ' -c \"import sys; sys.stdout.write(sys.executable)\"')\n+  assert(vim.v.shell_error == 0, out)\n+  return vim.fs.normalize(vim.trim(out))\n+end\n+\n+local function is_blank(v)\n+  return v:find('^%s*$') ~= nil\n+end\n+\n+-- Check if pyenv is available and a valid pyenv root can be found, then return\n+-- their respective paths. If either of those is invalid, return two empty\n+-- strings, effectively ignoring pyenv.\n+local function check_for_pyenv()\n+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))\n+\n+  if is_blank(pyenv_path) then\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Path: ' .. pyenv_path)\n+\n+  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''\n+\n+  if is_blank(pyenv_root) then\n+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })\n+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')\n+  end\n+\n+  if not is(pyenv_root, 'directory') then\n+    local message = string.format(\n+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',\n+      pyenv_root\n+    )\n+    health.warn(message)\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Root: ' .. pyenv_root)\n+\n+  return { pyenv_path, pyenv_root }\n+end\n+\n+-- Check the Python interpreter's usability.\n+local function check_bin(bin)\n+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then\n+    health.error('\"' .. bin .. '\" was not found.')\n+    return false\n+  elseif vim.fn.executable(bin) ~= 1 then\n+    health.error('\"' .. bin .. '\" is not executable.')\n+    return false\n+  end\n+  return true\n+end\n+\n+-- Fetch the contents of a URL.\n+local function download(url)\n+  local has_curl = vim.fn.executable('curl') == 1\n+  if has_curl and vim.fn.system({ 'curl', '-V' }):find('Protocols:.*https') then\n+    local out, rc = health.system({ 'curl', '-sL', url }, { stderr = true, ignore_error = true })\n+    if rc ~= 0 then\n+      return 'curl error with ' .. url .. ': ' .. rc\n+    else\n+      return out\n+    end\n+  elseif vim.fn.executable('python') == 1 then\n+    local script = \"try:\\n\\\n+          from urllib.request import urlopen\\n\\\n+          except ImportError:\\n\\\n+          from urllib2 import urlopen\\n\\\n+          response = urlopen('\" .. url .. \"')\\n\\\n+          print(response.read().decode('utf8'))\\n\"\n+    local out, rc = health.system({ 'python', '-c', script })\n+    if is_blank(out) and rc ~= 0 then\n+      return 'python urllib.request error: ' .. rc\n+    else\n+      return out\n+    end\n+  end\n+\n+  local message = 'missing `curl` '\n+\n+  if has_curl then\n+    message = message .. '(with HTTPS support) '\n+  end\n+  message = message .. 'and `python`, cannot make web request'\n+\n+  return message\n+end\n+\n+\n+-- Get the latest Nvim Python client (pynvim) version from PyPI.\n+local function latest_pypi_version()\n+  local pypi_version = 'unable to get pypi response'\n+  local pypi_response = download('https://pypi.python.org/pypi/pynvim/json')\n+  if not is_blank(pypi_response) then\n+    local pcall_ok, output = pcall(vim.fn.json_decode, pypi_response)\n+    local pypi_data\n+    if pcall_ok then\n+      pypi_data = output\n+    else\n+      return 'error: ' .. pypi_response\n+    end\n+\n+    local pypi_element = pypi_data['info'] or {}\n+    pypi_version = pypi_element['version'] or 'unable to parse'\n+  end\n+  return pypi_version\n+end\n+\n+local function is_bad_response(s)\n+  local lower = s:lower()\n+  return vim.startswith(lower, 'unable')\n+      or vim.startswith(lower, 'error')\n+      or vim.startswith(lower, 'outdated')\n+end\n+\n+\n+-- Get version information using the specified interpreter.  The interpreter is\n+-- used directly in case breaking changes were introduced since the last time\n+-- Nvim's Python client was updated.\n+--\n+-- Returns: {\n+--     {python executable version},\n+--     {current nvim version},\n+--     {current pypi nvim status},\n+--     {installed version status}\n+-- }\n+local function version_info(python)\n+  local pypi_version = latest_pypi_version()\n+\n+  local python_version, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; print(\".\".join(str(x) for x in sys.version_info[:3]))',\n+  })\n+\n+  if rc ~= 0 or is_blank(python_version) then\n+    python_version = 'unable to parse ' .. python .. ' response'\n+  end\n+\n+  local nvim_path, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; sys.path = [p for p in sys.path if p != \"\"]; import neovim; print(neovim.__file__)',\n+  })\n+  if rc ~= 0 or is_blank(nvim_path) then\n+    return { python_version, 'unable to load neovim Python module', pypi_version, nvim_path }\n+  end\n+\n+  -- Assuming that multiple versions of a package are installed, sort them\n+  -- numerically in descending order.\n+  local function compare(metapath1, metapath2)\n+    local a = vim.fn.matchstr(vim.fn.fnamemodify(metapath1, ':p:h:t'), [[[0-9.]\\+]])\n+    local b = vim.fn.matchstr(vim.fn.fnamemodify(metapath2, ':p:h:t'), [[[0-9.]\\+]])\n+    if a == b then\n+      return 0\n+    elseif a > b then\n+      return 1\n+    else\n+      return -1\n+    end\n+  end\n+\n+  -- Try to get neovim.VERSION (added in 0.1.11dev).\n+  local nvim_version, rc = health.system({\n+    python,\n+    '-c',\n+    'from neovim import VERSION as v; print(\"{}.{}.{}{}\".format(v.major, v.minor, v.patch, v.prerelease))',\n+  }, { stderr = true, ignore_error = true })\n+  if rc ~= 0 or is_blank(nvim_version) then\n+    nvim_version = 'unable to find pynvim module version'\n+    local base = vim.fs.basename(nvim_path)\n+    local metas = vim.fn.glob(base .. '-*/METADATA', 1, 1)\n+    vim.list_extend(metas, vim.fn.glob(base .. '-*/PKG-INFO', 1, 1))\n+    vim.list_extend(metas, vim.fn.glob(base .. '.egg-info/PKG-INFO', 1, 1))\n+    metas = table.sort(metas, compare)\n+\n+    if metas and next(metas) ~= nil then\n+      for line in io.lines(metas[1]) do\n+        local version = line:match('^Version: (%S+)')\n+        if version then\n+          nvim_version = version\n+          break\n+        end\n+      end\n+    end\n+  end\n+\n+  local nvim_path_base = vim.fn.fnamemodify(nvim_path, [[:~:h]])\n+  local version_status = 'unknown; ' .. nvim_path_base\n+  if is_bad_response(nvim_version) and is_bad_response(pypi_version) then\n+    if vim.version.lt(nvim_version, pypi_version) then\n+      version_status = 'outdated; from ' .. nvim_path_base\n+    else\n+      version_status = 'up to date'\n+    end\n+  end\n+\n+  return { python_version, nvim_version, pypi_version, version_status }\n+end\n+\n+function M.check()\n+  health.start('Python 3 provider (optional)')\n+\n+  local pyname = 'python3'\n+  local python_exe = ''\n+  local virtual_env = os.getenv('VIRTUAL_ENV')\n+  local venv = virtual_env and vim.fn.resolve(virtual_env) or ''\n+  local host_prog_var = pyname .. '_host_prog'\n+  local python_multiple = {}\n+\n+  if health.provider_disabled(pyname) then\n+    return\n+  end\n+\n+  local pyenv_table = check_for_pyenv()\n+  local pyenv = pyenv_table[1]\n+  local pyenv_root = pyenv_table[2]\n+\n+  if vim.g[host_prog_var] then\n+    local message = string.format('Using: g:%s = \"%s\"', host_prog_var, vim.g[host_prog_var])\n+    health.info(message)\n+  end\n+\n+  local python_table = vim.fn['provider#pythonx#Detect'](3)\n+  pyname = python_table[1]\n+  local pythonx_warnings = python_table[2]\n+\n+  if is_blank(pyname) then\n+    health.warn(\n+      'No Python executable found that can `import neovim`. '\n+      .. 'Using the first available executable for diagnostics.'\n+    )\n+  elseif vim.g[host_prog_var] then\n+    python_exe = pyname\n+  end\n+\n+  -- No Python executable could `import neovim`, or host_prog_var was used.\n+  if not is_blank(pythonx_warnings) then\n+    health.warn(pythonx_warnings, {\n+      'See :help provider-python for more information.',\n+      'You may disable this provider (and warning) by adding `let g:loaded_python3_provider = 0` to your init.vim',\n+    })\n+  elseif not is_blank(pyname) and is_blank(python_exe) then\n+    if not vim.g[host_prog_var] then\n+      local message = string.format(\n+        '`g:%s` is not set. Searching for %s in the environment.',\n+        host_prog_var,\n+        pyname\n+      )\n+      health.info(message)\n+    end\n+\n+    if not is_blank(pyenv) then\n+      python_exe = health.system({ pyenv, 'which', pyname }, { stderr = true })\n+      if is_blank(python_exe) then\n+        health.warn('pyenv could not find ' .. pyname .. '.')\n+      end\n+    end\n+\n+    if is_blank(python_exe) then\n+      python_exe = vim.fn.exepath(pyname)\n+\n+      if os.getenv('PATH') then\n+        local path_sep = iswin and ';' or ':'\n+        local paths = vim.split(os.getenv('PATH') or '', path_sep)\n+\n+        for _, path in ipairs(paths) do\n+          local path_bin = vim.fs.normalize(path .. '/' .. pyname)\n+          if\n+              path_bin ~= vim.fs.normalize(python_exe)\n+              and vim.tbl_contains(python_multiple, path_bin)\n+              and vim.fn.executable(path_bin) == 1\n+          then\n+            python_multiple[#python_multiple + 1] = path_bin\n+          end\n+        end\n+\n+        if vim.tbl_count(python_multiple) > 0 then\n+          -- This is worth noting since the user may install something\n+          -- that changes $PATH, like homebrew.\n+          local message = string.format('Multiple %s executables found. Set `g:%s` to avoid surprises.', pyname,\n+            host_prog_var)\n+          health.info(message)\n+        end\n+\n+        if python_exe:find('shims') then\n+          local message = string.format('`%s` appears to be a pyenv shim.', python_exe)\n+          local advice = string.format(\n+            '`pyenv` is not in $PATH, your pyenv installation is broken. Set `g:%s` to avoid surprises.', host_prog_var)\n+          health.warn(message, advice)\n+        end\n+      end\n+    end\n+  end\n+\n+  if not is_blank(python_exe) and not vim.g[host_prog_var] then\n+    if\n+        is_blank(venv)\n+        and not is_blank(pyenv)\n+        and not is_blank(pyenv_root)\n+        and vim.startswith(vim.fn.resolve(python_exe), pyenv_root .. '/')",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163113998",
            "id": 1163113998,
            "line": 322,
            "node_id": "PRRC_kwDOAPphoM5FU7YO",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 322,
            "original_position": 322,
            "original_start_line": null,
            "path": "runtime/lua/provider/python/health.lua",
            "position": 322,
            "pull_request_review_id": 1379728789,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163113998/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T17:41:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163113998",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163115337"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163115337"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n      if vim.startswith(vim.fn.resolve(python_exe), venv_root .. '/') then\r\n```\r\n\r\nAlso used `!~#`",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T17:14:06Z",
            "diff_hunk": "@@ -0,0 +1,490 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+local function is(path, ty)\n+  if not path then\n+    return false\n+  end\n+  local stat = vim.loop.fs_stat(path)\n+  if not stat then\n+    return false\n+  end\n+  return stat.type == ty\n+end\n+\n+-- Resolves Python executable path by invoking and checking `sys.executable`.\n+local function python_exepath(invocation)\n+  local python = vim.fn.fnameescape(invocation)\n+  local out = vim.fn.system(python .. ' -c \"import sys; sys.stdout.write(sys.executable)\"')\n+  assert(vim.v.shell_error == 0, out)\n+  return vim.fs.normalize(vim.trim(out))\n+end\n+\n+local function is_blank(v)\n+  return v:find('^%s*$') ~= nil\n+end\n+\n+-- Check if pyenv is available and a valid pyenv root can be found, then return\n+-- their respective paths. If either of those is invalid, return two empty\n+-- strings, effectively ignoring pyenv.\n+local function check_for_pyenv()\n+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))\n+\n+  if is_blank(pyenv_path) then\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Path: ' .. pyenv_path)\n+\n+  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''\n+\n+  if is_blank(pyenv_root) then\n+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })\n+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')\n+  end\n+\n+  if not is(pyenv_root, 'directory') then\n+    local message = string.format(\n+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',\n+      pyenv_root\n+    )\n+    health.warn(message)\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Root: ' .. pyenv_root)\n+\n+  return { pyenv_path, pyenv_root }\n+end\n+\n+-- Check the Python interpreter's usability.\n+local function check_bin(bin)\n+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then\n+    health.error('\"' .. bin .. '\" was not found.')\n+    return false\n+  elseif vim.fn.executable(bin) ~= 1 then\n+    health.error('\"' .. bin .. '\" is not executable.')\n+    return false\n+  end\n+  return true\n+end\n+\n+-- Fetch the contents of a URL.\n+local function download(url)\n+  local has_curl = vim.fn.executable('curl') == 1\n+  if has_curl and vim.fn.system({ 'curl', '-V' }):find('Protocols:.*https') then\n+    local out, rc = health.system({ 'curl', '-sL', url }, { stderr = true, ignore_error = true })\n+    if rc ~= 0 then\n+      return 'curl error with ' .. url .. ': ' .. rc\n+    else\n+      return out\n+    end\n+  elseif vim.fn.executable('python') == 1 then\n+    local script = \"try:\\n\\\n+          from urllib.request import urlopen\\n\\\n+          except ImportError:\\n\\\n+          from urllib2 import urlopen\\n\\\n+          response = urlopen('\" .. url .. \"')\\n\\\n+          print(response.read().decode('utf8'))\\n\"\n+    local out, rc = health.system({ 'python', '-c', script })\n+    if is_blank(out) and rc ~= 0 then\n+      return 'python urllib.request error: ' .. rc\n+    else\n+      return out\n+    end\n+  end\n+\n+  local message = 'missing `curl` '\n+\n+  if has_curl then\n+    message = message .. '(with HTTPS support) '\n+  end\n+  message = message .. 'and `python`, cannot make web request'\n+\n+  return message\n+end\n+\n+\n+-- Get the latest Nvim Python client (pynvim) version from PyPI.\n+local function latest_pypi_version()\n+  local pypi_version = 'unable to get pypi response'\n+  local pypi_response = download('https://pypi.python.org/pypi/pynvim/json')\n+  if not is_blank(pypi_response) then\n+    local pcall_ok, output = pcall(vim.fn.json_decode, pypi_response)\n+    local pypi_data\n+    if pcall_ok then\n+      pypi_data = output\n+    else\n+      return 'error: ' .. pypi_response\n+    end\n+\n+    local pypi_element = pypi_data['info'] or {}\n+    pypi_version = pypi_element['version'] or 'unable to parse'\n+  end\n+  return pypi_version\n+end\n+\n+local function is_bad_response(s)\n+  local lower = s:lower()\n+  return vim.startswith(lower, 'unable')\n+      or vim.startswith(lower, 'error')\n+      or vim.startswith(lower, 'outdated')\n+end\n+\n+\n+-- Get version information using the specified interpreter.  The interpreter is\n+-- used directly in case breaking changes were introduced since the last time\n+-- Nvim's Python client was updated.\n+--\n+-- Returns: {\n+--     {python executable version},\n+--     {current nvim version},\n+--     {current pypi nvim status},\n+--     {installed version status}\n+-- }\n+local function version_info(python)\n+  local pypi_version = latest_pypi_version()\n+\n+  local python_version, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; print(\".\".join(str(x) for x in sys.version_info[:3]))',\n+  })\n+\n+  if rc ~= 0 or is_blank(python_version) then\n+    python_version = 'unable to parse ' .. python .. ' response'\n+  end\n+\n+  local nvim_path, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; sys.path = [p for p in sys.path if p != \"\"]; import neovim; print(neovim.__file__)',\n+  })\n+  if rc ~= 0 or is_blank(nvim_path) then\n+    return { python_version, 'unable to load neovim Python module', pypi_version, nvim_path }\n+  end\n+\n+  -- Assuming that multiple versions of a package are installed, sort them\n+  -- numerically in descending order.\n+  local function compare(metapath1, metapath2)\n+    local a = vim.fn.matchstr(vim.fn.fnamemodify(metapath1, ':p:h:t'), [[[0-9.]\\+]])\n+    local b = vim.fn.matchstr(vim.fn.fnamemodify(metapath2, ':p:h:t'), [[[0-9.]\\+]])\n+    if a == b then\n+      return 0\n+    elseif a > b then\n+      return 1\n+    else\n+      return -1\n+    end\n+  end\n+\n+  -- Try to get neovim.VERSION (added in 0.1.11dev).\n+  local nvim_version, rc = health.system({\n+    python,\n+    '-c',\n+    'from neovim import VERSION as v; print(\"{}.{}.{}{}\".format(v.major, v.minor, v.patch, v.prerelease))',\n+  }, { stderr = true, ignore_error = true })\n+  if rc ~= 0 or is_blank(nvim_version) then\n+    nvim_version = 'unable to find pynvim module version'\n+    local base = vim.fs.basename(nvim_path)\n+    local metas = vim.fn.glob(base .. '-*/METADATA', 1, 1)\n+    vim.list_extend(metas, vim.fn.glob(base .. '-*/PKG-INFO', 1, 1))\n+    vim.list_extend(metas, vim.fn.glob(base .. '.egg-info/PKG-INFO', 1, 1))\n+    metas = table.sort(metas, compare)\n+\n+    if metas and next(metas) ~= nil then\n+      for line in io.lines(metas[1]) do\n+        local version = line:match('^Version: (%S+)')\n+        if version then\n+          nvim_version = version\n+          break\n+        end\n+      end\n+    end\n+  end\n+\n+  local nvim_path_base = vim.fn.fnamemodify(nvim_path, [[:~:h]])\n+  local version_status = 'unknown; ' .. nvim_path_base\n+  if is_bad_response(nvim_version) and is_bad_response(pypi_version) then\n+    if vim.version.lt(nvim_version, pypi_version) then\n+      version_status = 'outdated; from ' .. nvim_path_base\n+    else\n+      version_status = 'up to date'\n+    end\n+  end\n+\n+  return { python_version, nvim_version, pypi_version, version_status }\n+end\n+\n+function M.check()\n+  health.start('Python 3 provider (optional)')\n+\n+  local pyname = 'python3'\n+  local python_exe = ''\n+  local virtual_env = os.getenv('VIRTUAL_ENV')\n+  local venv = virtual_env and vim.fn.resolve(virtual_env) or ''\n+  local host_prog_var = pyname .. '_host_prog'\n+  local python_multiple = {}\n+\n+  if health.provider_disabled(pyname) then\n+    return\n+  end\n+\n+  local pyenv_table = check_for_pyenv()\n+  local pyenv = pyenv_table[1]\n+  local pyenv_root = pyenv_table[2]\n+\n+  if vim.g[host_prog_var] then\n+    local message = string.format('Using: g:%s = \"%s\"', host_prog_var, vim.g[host_prog_var])\n+    health.info(message)\n+  end\n+\n+  local python_table = vim.fn['provider#pythonx#Detect'](3)\n+  pyname = python_table[1]\n+  local pythonx_warnings = python_table[2]\n+\n+  if is_blank(pyname) then\n+    health.warn(\n+      'No Python executable found that can `import neovim`. '\n+      .. 'Using the first available executable for diagnostics.'\n+    )\n+  elseif vim.g[host_prog_var] then\n+    python_exe = pyname\n+  end\n+\n+  -- No Python executable could `import neovim`, or host_prog_var was used.\n+  if not is_blank(pythonx_warnings) then\n+    health.warn(pythonx_warnings, {\n+      'See :help provider-python for more information.',\n+      'You may disable this provider (and warning) by adding `let g:loaded_python3_provider = 0` to your init.vim',\n+    })\n+  elseif not is_blank(pyname) and is_blank(python_exe) then\n+    if not vim.g[host_prog_var] then\n+      local message = string.format(\n+        '`g:%s` is not set. Searching for %s in the environment.',\n+        host_prog_var,\n+        pyname\n+      )\n+      health.info(message)\n+    end\n+\n+    if not is_blank(pyenv) then\n+      python_exe = health.system({ pyenv, 'which', pyname }, { stderr = true })\n+      if is_blank(python_exe) then\n+        health.warn('pyenv could not find ' .. pyname .. '.')\n+      end\n+    end\n+\n+    if is_blank(python_exe) then\n+      python_exe = vim.fn.exepath(pyname)\n+\n+      if os.getenv('PATH') then\n+        local path_sep = iswin and ';' or ':'\n+        local paths = vim.split(os.getenv('PATH') or '', path_sep)\n+\n+        for _, path in ipairs(paths) do\n+          local path_bin = vim.fs.normalize(path .. '/' .. pyname)\n+          if\n+              path_bin ~= vim.fs.normalize(python_exe)\n+              and vim.tbl_contains(python_multiple, path_bin)\n+              and vim.fn.executable(path_bin) == 1\n+          then\n+            python_multiple[#python_multiple + 1] = path_bin\n+          end\n+        end\n+\n+        if vim.tbl_count(python_multiple) > 0 then\n+          -- This is worth noting since the user may install something\n+          -- that changes $PATH, like homebrew.\n+          local message = string.format('Multiple %s executables found. Set `g:%s` to avoid surprises.', pyname,\n+            host_prog_var)\n+          health.info(message)\n+        end\n+\n+        if python_exe:find('shims') then\n+          local message = string.format('`%s` appears to be a pyenv shim.', python_exe)\n+          local advice = string.format(\n+            '`pyenv` is not in $PATH, your pyenv installation is broken. Set `g:%s` to avoid surprises.', host_prog_var)\n+          health.warn(message, advice)\n+        end\n+      end\n+    end\n+  end\n+\n+  if not is_blank(python_exe) and not vim.g[host_prog_var] then\n+    if\n+        is_blank(venv)\n+        and not is_blank(pyenv)\n+        and not is_blank(pyenv_root)\n+        and vim.startswith(vim.fn.resolve(python_exe), pyenv_root .. '/')\n+    then\n+      local advice = string.format(\n+        'Create a virtualenv specifically for Nvim using pyenv, and set `g:%s`.  This will avoid the need to install the pynvim module in each version/virtualenv.',\n+        host_prog_var)\n+      health.warn('pyenv is not set up optimally.', advice)\n+    elseif not is_blank(venv) then\n+      local venv_root\n+      if not is_blank(pyenv_root) then\n+        venv_root = pyenv_root\n+      else\n+        venv_root = vim.fs.dirname(venv)\n+      end\n+\n+      if vim.startswith(vim.fn.resolve(python_exe), venv_root .. '/') then",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163115337",
            "id": 1163115337,
            "line": 336,
            "node_id": "PRRC_kwDOAPphoM5FU7tJ",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 336,
            "original_position": 336,
            "original_start_line": null,
            "path": "runtime/lua/provider/python/health.lua",
            "position": 336,
            "pull_request_review_id": 1379728789,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163115337/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T17:41:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163115337",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163134247"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163134247"
                }
            },
            "author_association": "MEMBER",
            "body": "I think this is trying to replicate `cpanm_errors[1:-2]`, but this doesn't look like it skips the last item for `advice` like the slice does",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T17:33:38Z",
            "diff_hunk": "@@ -0,0 +1,94 @@\n+local health = vim.health\n+\n+local M = {}\n+\n+function M.check()\n+  health.start('Perl provider (optional)')\n+\n+  if health.provider_disabled('perl') then\n+    return\n+  end\n+\n+  local perl_detect_table = vim.fn['provider#perl#Detect']()\n+  local perl_exec = perl_detect_table[1]\n+  local perl_warnings = perl_detect_table[2]\n+\n+  if perl_exec:find('^%s*$') then\n+    if perl_warnings:find('%S') then\n+      health.warn(perl_warnings, {\n+        'See :help provider-perl for more information.',\n+        'You may disable this provider (and warning) by adding `let g:loaded_perl_provider = 0` to your init.vim',\n+      })\n+    else\n+      health.warn('No usable perl executable found')\n+    end\n+    return\n+  end\n+\n+  health.info('perl executable: ' .. perl_exec)\n+\n+  -- we cannot use cpanm that is on the path, as it may not be for the perl\n+  -- set with g:perl_host_prog\n+  local ok = health.cmd_ok({ perl_exec, '-W', '-MApp::cpanminus', '-e', '' })\n+  if not ok then\n+    return { perl_exec, '\"App::cpanminus\" module is not installed' }\n+  end\n+\n+  local latest_cpan_cmd = {\n+    perl_exec,\n+    '-MApp::cpanminus::fatscript',\n+    '-e',\n+    'my $app = App::cpanminus::script->new; $app->parse_options (\"--info\", \"-q\", \"Neovim::Ext\"); exit $app->doit',\n+  }\n+\n+  local ok, latest_cpan = health.cmd_ok(latest_cpan_cmd)\n+  if not ok or latest_cpan:find('^%s*$') then\n+    health.error(\n+      'Failed to run: ' .. table.concat(latest_cpan_cmd, ' '),\n+      { \"Make sure you're connected to the internet.\", 'Are you behind a firewall or proxy?' }\n+    )\n+    return\n+  elseif latest_cpan[1] == '!' then\n+    local cpanm_errs = vim.split(latest_cpan, '!')\n+    if cpanm_errs[1]:find(\"Can't write to \") then\n+      local advice = {}\n+      for i = 2, #cpanm_errs do\n+        advice[#advice + 1] = cpanm_errs[i]\n+      end",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163134247",
            "id": 1163134247,
            "line": 57,
            "node_id": "PRRC_kwDOAPphoM5FVAUn",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 57,
            "original_position": 57,
            "original_start_line": 54,
            "path": "runtime/lua/provider/perl/health.lua",
            "position": 57,
            "pull_request_review_id": 1379728789,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163134247/reactions"
            },
            "side": "RIGHT",
            "start_line": 54,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-04-11T17:41:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163134247",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163139407"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163139407"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  -- local node_v = vim.fn.split(system({'node', '-v'}), \"\\n\")[1] or ''\r\n  local ok, node_v = health.cmd_ok({ 'node', '-v' })\r\n```\r\n\r\nAs it's commented out, I guess not splitting the lines was deliberate? The original code splits and just uses the 0th element as `node_v` if it exists, else \"\".",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T17:39:05Z",
            "diff_hunk": "@@ -0,0 +1,106 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+function M.check()\n+  health.start('Node.js provider (optional)')\n+\n+  if health.provider_disabled('node') then\n+    return\n+  end\n+\n+  if\n+      not vim.fn.executable('node') == 1\n+      or (vim.fn.executable('npm') == 0 and vim.fn.executable('yarn') == 0 and vim.fn.executable('pnpm') == 0)\n+  then\n+    health.warn(\n+      '`node` and `npm` (or `yarn`, `pnpm`) must be in $PATH.',\n+      'Install Node.js and verify that `node` and `npm` (or `yarn`, `pnpm`) commands work.'\n+    )\n+    return\n+  end\n+\n+  -- local node_v = vim.fn.split(system({'node', '-v'}), \"\\n\")[1] or ''\n+  local ok, node_v = health.cmd_ok({ 'node', '-v' })",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163139407",
            "id": 1163139407,
            "line": 26,
            "node_id": "PRRC_kwDOAPphoM5FVBlP",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 26,
            "original_position": 26,
            "original_start_line": 25,
            "path": "runtime/lua/provider/node/health.lua",
            "position": 26,
            "pull_request_review_id": 1379728789,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163139407/reactions"
            },
            "side": "RIGHT",
            "start_line": 25,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-04-11T17:41:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163139407",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163150025"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163150025"
                }
            },
            "author_association": "MEMBER",
            "body": "Sorry for the second-hand review, but doesn't `os.getenv()` return `nil` if environment variable doesn't exist?",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T17:50:10Z",
            "diff_hunk": "@@ -0,0 +1,490 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+local function is(path, ty)\n+  if not path then\n+    return false\n+  end\n+  local stat = vim.loop.fs_stat(path)\n+  if not stat then\n+    return false\n+  end\n+  return stat.type == ty\n+end\n+\n+-- Resolves Python executable path by invoking and checking `sys.executable`.\n+local function python_exepath(invocation)\n+  local python = vim.fn.fnameescape(invocation)\n+  local out = vim.fn.system(python .. ' -c \"import sys; sys.stdout.write(sys.executable)\"')\n+  assert(vim.v.shell_error == 0, out)\n+  return vim.fs.normalize(vim.trim(out))\n+end\n+\n+local function is_blank(v)\n+  return v:find('^%s*$') ~= nil\n+end\n+\n+-- Check if pyenv is available and a valid pyenv root can be found, then return\n+-- their respective paths. If either of those is invalid, return two empty\n+-- strings, effectively ignoring pyenv.\n+local function check_for_pyenv()\n+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))\n+\n+  if is_blank(pyenv_path) then\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Path: ' .. pyenv_path)\n+\n+  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''\n+\n+  if is_blank(pyenv_root) then\n+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })\n+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')\n+  end\n+\n+  if not is(pyenv_root, 'directory') then\n+    local message = string.format(\n+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',\n+      pyenv_root\n+    )\n+    health.warn(message)\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Root: ' .. pyenv_root)\n+\n+  return { pyenv_path, pyenv_root }\n+end\n+\n+-- Check the Python interpreter's usability.\n+local function check_bin(bin)\n+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then\n+    health.error('\"' .. bin .. '\" was not found.')\n+    return false\n+  elseif vim.fn.executable(bin) ~= 1 then\n+    health.error('\"' .. bin .. '\" is not executable.')\n+    return false\n+  end\n+  return true\n+end\n+\n+-- Fetch the contents of a URL.\n+local function download(url)\n+  local has_curl = vim.fn.executable('curl') == 1\n+  if has_curl and vim.fn.system({ 'curl', '-V' }):find('Protocols:.*https') then\n+    local out, rc = health.system({ 'curl', '-sL', url }, { stderr = true, ignore_error = true })\n+    if rc ~= 0 then\n+      return 'curl error with ' .. url .. ': ' .. rc\n+    else\n+      return out\n+    end\n+  elseif vim.fn.executable('python') == 1 then\n+    local script = \"try:\\n\\\n+          from urllib.request import urlopen\\n\\\n+          except ImportError:\\n\\\n+          from urllib2 import urlopen\\n\\\n+          response = urlopen('\" .. url .. \"')\\n\\\n+          print(response.read().decode('utf8'))\\n\"\n+    local out, rc = health.system({ 'python', '-c', script })\n+    if is_blank(out) and rc ~= 0 then\n+      return 'python urllib.request error: ' .. rc\n+    else\n+      return out\n+    end\n+  end\n+\n+  local message = 'missing `curl` '\n+\n+  if has_curl then\n+    message = message .. '(with HTTPS support) '\n+  end\n+  message = message .. 'and `python`, cannot make web request'\n+\n+  return message\n+end\n+\n+\n+-- Get the latest Nvim Python client (pynvim) version from PyPI.\n+local function latest_pypi_version()\n+  local pypi_version = 'unable to get pypi response'\n+  local pypi_response = download('https://pypi.python.org/pypi/pynvim/json')\n+  if not is_blank(pypi_response) then\n+    local pcall_ok, output = pcall(vim.fn.json_decode, pypi_response)\n+    local pypi_data\n+    if pcall_ok then\n+      pypi_data = output\n+    else\n+      return 'error: ' .. pypi_response\n+    end\n+\n+    local pypi_element = pypi_data['info'] or {}\n+    pypi_version = pypi_element['version'] or 'unable to parse'\n+  end\n+  return pypi_version\n+end\n+\n+local function is_bad_response(s)\n+  local lower = s:lower()\n+  return vim.startswith(lower, 'unable')\n+      or vim.startswith(lower, 'error')\n+      or vim.startswith(lower, 'outdated')\n+end\n+\n+\n+-- Get version information using the specified interpreter.  The interpreter is\n+-- used directly in case breaking changes were introduced since the last time\n+-- Nvim's Python client was updated.\n+--\n+-- Returns: {\n+--     {python executable version},\n+--     {current nvim version},\n+--     {current pypi nvim status},\n+--     {installed version status}\n+-- }\n+local function version_info(python)\n+  local pypi_version = latest_pypi_version()\n+\n+  local python_version, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; print(\".\".join(str(x) for x in sys.version_info[:3]))',\n+  })\n+\n+  if rc ~= 0 or is_blank(python_version) then\n+    python_version = 'unable to parse ' .. python .. ' response'\n+  end\n+\n+  local nvim_path, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; sys.path = [p for p in sys.path if p != \"\"]; import neovim; print(neovim.__file__)',\n+  })\n+  if rc ~= 0 or is_blank(nvim_path) then\n+    return { python_version, 'unable to load neovim Python module', pypi_version, nvim_path }\n+  end\n+\n+  -- Assuming that multiple versions of a package are installed, sort them\n+  -- numerically in descending order.\n+  local function compare(metapath1, metapath2)\n+    local a = vim.fn.matchstr(vim.fn.fnamemodify(metapath1, ':p:h:t'), [[[0-9.]\\+]])\n+    local b = vim.fn.matchstr(vim.fn.fnamemodify(metapath2, ':p:h:t'), [[[0-9.]\\+]])\n+    if a == b then\n+      return 0\n+    elseif a > b then\n+      return 1\n+    else\n+      return -1\n+    end\n+  end\n+\n+  -- Try to get neovim.VERSION (added in 0.1.11dev).\n+  local nvim_version, rc = health.system({\n+    python,\n+    '-c',\n+    'from neovim import VERSION as v; print(\"{}.{}.{}{}\".format(v.major, v.minor, v.patch, v.prerelease))',\n+  }, { stderr = true, ignore_error = true })\n+  if rc ~= 0 or is_blank(nvim_version) then\n+    nvim_version = 'unable to find pynvim module version'\n+    local base = vim.fs.basename(nvim_path)\n+    local metas = vim.fn.glob(base .. '-*/METADATA', 1, 1)\n+    vim.list_extend(metas, vim.fn.glob(base .. '-*/PKG-INFO', 1, 1))\n+    vim.list_extend(metas, vim.fn.glob(base .. '.egg-info/PKG-INFO', 1, 1))\n+    metas = table.sort(metas, compare)\n+\n+    if metas and next(metas) ~= nil then\n+      for line in io.lines(metas[1]) do\n+        local version = line:match('^Version: (%S+)')\n+        if version then\n+          nvim_version = version\n+          break\n+        end\n+      end\n+    end\n+  end\n+\n+  local nvim_path_base = vim.fn.fnamemodify(nvim_path, [[:~:h]])\n+  local version_status = 'unknown; ' .. nvim_path_base\n+  if is_bad_response(nvim_version) and is_bad_response(pypi_version) then\n+    if vim.version.lt(nvim_version, pypi_version) then\n+      version_status = 'outdated; from ' .. nvim_path_base\n+    else\n+      version_status = 'up to date'\n+    end\n+  end\n+\n+  return { python_version, nvim_version, pypi_version, version_status }\n+end\n+\n+function M.check()\n+  health.start('Python 3 provider (optional)')\n+\n+  local pyname = 'python3'\n+  local python_exe = ''\n+  local virtual_env = os.getenv('VIRTUAL_ENV')\n+  local venv = virtual_env and vim.fn.resolve(virtual_env) or ''\n+  local host_prog_var = pyname .. '_host_prog'\n+  local python_multiple = {}\n+\n+  if health.provider_disabled(pyname) then\n+    return\n+  end\n+\n+  local pyenv_table = check_for_pyenv()\n+  local pyenv = pyenv_table[1]\n+  local pyenv_root = pyenv_table[2]\n+\n+  if vim.g[host_prog_var] then\n+    local message = string.format('Using: g:%s = \"%s\"', host_prog_var, vim.g[host_prog_var])\n+    health.info(message)\n+  end\n+\n+  local python_table = vim.fn['provider#pythonx#Detect'](3)\n+  pyname = python_table[1]\n+  local pythonx_warnings = python_table[2]\n+\n+  if is_blank(pyname) then\n+    health.warn(\n+      'No Python executable found that can `import neovim`. '\n+      .. 'Using the first available executable for diagnostics.'\n+    )\n+  elseif vim.g[host_prog_var] then\n+    python_exe = pyname\n+  end\n+\n+  -- No Python executable could `import neovim`, or host_prog_var was used.\n+  if not is_blank(pythonx_warnings) then\n+    health.warn(pythonx_warnings, {\n+      'See :help provider-python for more information.',\n+      'You may disable this provider (and warning) by adding `let g:loaded_python3_provider = 0` to your init.vim',\n+    })\n+  elseif not is_blank(pyname) and is_blank(python_exe) then\n+    if not vim.g[host_prog_var] then\n+      local message = string.format(\n+        '`g:%s` is not set. Searching for %s in the environment.',\n+        host_prog_var,\n+        pyname\n+      )\n+      health.info(message)\n+    end\n+\n+    if not is_blank(pyenv) then\n+      python_exe = health.system({ pyenv, 'which', pyname }, { stderr = true })\n+      if is_blank(python_exe) then\n+        health.warn('pyenv could not find ' .. pyname .. '.')\n+      end\n+    end\n+\n+    if is_blank(python_exe) then\n+      python_exe = vim.fn.exepath(pyname)\n+\n+      if os.getenv('PATH') then\n+        local path_sep = iswin and ';' or ':'\n+        local paths = vim.split(os.getenv('PATH') or '', path_sep)",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163150025",
            "id": 1163150025,
            "in_reply_to_id": 1163103057,
            "line": 286,
            "node_id": "PRRC_kwDOAPphoM5FVELJ",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 286,
            "original_position": 286,
            "original_start_line": null,
            "path": "runtime/lua/provider/python/health.lua",
            "position": 286,
            "pull_request_review_id": 1379803364,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163150025/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T17:50:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163150025",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163150839"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163150839"
                }
            },
            "author_association": "MEMBER",
            "body": "Eh, in hindsight never mind, `$PATH` should always be defined. Ignore :)",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T17:51:06Z",
            "diff_hunk": "@@ -0,0 +1,490 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+local function is(path, ty)\n+  if not path then\n+    return false\n+  end\n+  local stat = vim.loop.fs_stat(path)\n+  if not stat then\n+    return false\n+  end\n+  return stat.type == ty\n+end\n+\n+-- Resolves Python executable path by invoking and checking `sys.executable`.\n+local function python_exepath(invocation)\n+  local python = vim.fn.fnameescape(invocation)\n+  local out = vim.fn.system(python .. ' -c \"import sys; sys.stdout.write(sys.executable)\"')\n+  assert(vim.v.shell_error == 0, out)\n+  return vim.fs.normalize(vim.trim(out))\n+end\n+\n+local function is_blank(v)\n+  return v:find('^%s*$') ~= nil\n+end\n+\n+-- Check if pyenv is available and a valid pyenv root can be found, then return\n+-- their respective paths. If either of those is invalid, return two empty\n+-- strings, effectively ignoring pyenv.\n+local function check_for_pyenv()\n+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))\n+\n+  if is_blank(pyenv_path) then\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Path: ' .. pyenv_path)\n+\n+  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''\n+\n+  if is_blank(pyenv_root) then\n+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })\n+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')\n+  end\n+\n+  if not is(pyenv_root, 'directory') then\n+    local message = string.format(\n+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',\n+      pyenv_root\n+    )\n+    health.warn(message)\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Root: ' .. pyenv_root)\n+\n+  return { pyenv_path, pyenv_root }\n+end\n+\n+-- Check the Python interpreter's usability.\n+local function check_bin(bin)\n+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then\n+    health.error('\"' .. bin .. '\" was not found.')\n+    return false\n+  elseif vim.fn.executable(bin) ~= 1 then\n+    health.error('\"' .. bin .. '\" is not executable.')\n+    return false\n+  end\n+  return true\n+end\n+\n+-- Fetch the contents of a URL.\n+local function download(url)\n+  local has_curl = vim.fn.executable('curl') == 1\n+  if has_curl and vim.fn.system({ 'curl', '-V' }):find('Protocols:.*https') then\n+    local out, rc = health.system({ 'curl', '-sL', url }, { stderr = true, ignore_error = true })\n+    if rc ~= 0 then\n+      return 'curl error with ' .. url .. ': ' .. rc\n+    else\n+      return out\n+    end\n+  elseif vim.fn.executable('python') == 1 then\n+    local script = \"try:\\n\\\n+          from urllib.request import urlopen\\n\\\n+          except ImportError:\\n\\\n+          from urllib2 import urlopen\\n\\\n+          response = urlopen('\" .. url .. \"')\\n\\\n+          print(response.read().decode('utf8'))\\n\"\n+    local out, rc = health.system({ 'python', '-c', script })\n+    if is_blank(out) and rc ~= 0 then\n+      return 'python urllib.request error: ' .. rc\n+    else\n+      return out\n+    end\n+  end\n+\n+  local message = 'missing `curl` '\n+\n+  if has_curl then\n+    message = message .. '(with HTTPS support) '\n+  end\n+  message = message .. 'and `python`, cannot make web request'\n+\n+  return message\n+end\n+\n+\n+-- Get the latest Nvim Python client (pynvim) version from PyPI.\n+local function latest_pypi_version()\n+  local pypi_version = 'unable to get pypi response'\n+  local pypi_response = download('https://pypi.python.org/pypi/pynvim/json')\n+  if not is_blank(pypi_response) then\n+    local pcall_ok, output = pcall(vim.fn.json_decode, pypi_response)\n+    local pypi_data\n+    if pcall_ok then\n+      pypi_data = output\n+    else\n+      return 'error: ' .. pypi_response\n+    end\n+\n+    local pypi_element = pypi_data['info'] or {}\n+    pypi_version = pypi_element['version'] or 'unable to parse'\n+  end\n+  return pypi_version\n+end\n+\n+local function is_bad_response(s)\n+  local lower = s:lower()\n+  return vim.startswith(lower, 'unable')\n+      or vim.startswith(lower, 'error')\n+      or vim.startswith(lower, 'outdated')\n+end\n+\n+\n+-- Get version information using the specified interpreter.  The interpreter is\n+-- used directly in case breaking changes were introduced since the last time\n+-- Nvim's Python client was updated.\n+--\n+-- Returns: {\n+--     {python executable version},\n+--     {current nvim version},\n+--     {current pypi nvim status},\n+--     {installed version status}\n+-- }\n+local function version_info(python)\n+  local pypi_version = latest_pypi_version()\n+\n+  local python_version, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; print(\".\".join(str(x) for x in sys.version_info[:3]))',\n+  })\n+\n+  if rc ~= 0 or is_blank(python_version) then\n+    python_version = 'unable to parse ' .. python .. ' response'\n+  end\n+\n+  local nvim_path, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; sys.path = [p for p in sys.path if p != \"\"]; import neovim; print(neovim.__file__)',\n+  })\n+  if rc ~= 0 or is_blank(nvim_path) then\n+    return { python_version, 'unable to load neovim Python module', pypi_version, nvim_path }\n+  end\n+\n+  -- Assuming that multiple versions of a package are installed, sort them\n+  -- numerically in descending order.\n+  local function compare(metapath1, metapath2)\n+    local a = vim.fn.matchstr(vim.fn.fnamemodify(metapath1, ':p:h:t'), [[[0-9.]\\+]])\n+    local b = vim.fn.matchstr(vim.fn.fnamemodify(metapath2, ':p:h:t'), [[[0-9.]\\+]])\n+    if a == b then\n+      return 0\n+    elseif a > b then\n+      return 1\n+    else\n+      return -1\n+    end\n+  end\n+\n+  -- Try to get neovim.VERSION (added in 0.1.11dev).\n+  local nvim_version, rc = health.system({\n+    python,\n+    '-c',\n+    'from neovim import VERSION as v; print(\"{}.{}.{}{}\".format(v.major, v.minor, v.patch, v.prerelease))',\n+  }, { stderr = true, ignore_error = true })\n+  if rc ~= 0 or is_blank(nvim_version) then\n+    nvim_version = 'unable to find pynvim module version'\n+    local base = vim.fs.basename(nvim_path)\n+    local metas = vim.fn.glob(base .. '-*/METADATA', 1, 1)\n+    vim.list_extend(metas, vim.fn.glob(base .. '-*/PKG-INFO', 1, 1))\n+    vim.list_extend(metas, vim.fn.glob(base .. '.egg-info/PKG-INFO', 1, 1))\n+    metas = table.sort(metas, compare)\n+\n+    if metas and next(metas) ~= nil then\n+      for line in io.lines(metas[1]) do\n+        local version = line:match('^Version: (%S+)')\n+        if version then\n+          nvim_version = version\n+          break\n+        end\n+      end\n+    end\n+  end\n+\n+  local nvim_path_base = vim.fn.fnamemodify(nvim_path, [[:~:h]])\n+  local version_status = 'unknown; ' .. nvim_path_base\n+  if is_bad_response(nvim_version) and is_bad_response(pypi_version) then\n+    if vim.version.lt(nvim_version, pypi_version) then\n+      version_status = 'outdated; from ' .. nvim_path_base\n+    else\n+      version_status = 'up to date'\n+    end\n+  end\n+\n+  return { python_version, nvim_version, pypi_version, version_status }\n+end\n+\n+function M.check()\n+  health.start('Python 3 provider (optional)')\n+\n+  local pyname = 'python3'\n+  local python_exe = ''\n+  local virtual_env = os.getenv('VIRTUAL_ENV')\n+  local venv = virtual_env and vim.fn.resolve(virtual_env) or ''\n+  local host_prog_var = pyname .. '_host_prog'\n+  local python_multiple = {}\n+\n+  if health.provider_disabled(pyname) then\n+    return\n+  end\n+\n+  local pyenv_table = check_for_pyenv()\n+  local pyenv = pyenv_table[1]\n+  local pyenv_root = pyenv_table[2]\n+\n+  if vim.g[host_prog_var] then\n+    local message = string.format('Using: g:%s = \"%s\"', host_prog_var, vim.g[host_prog_var])\n+    health.info(message)\n+  end\n+\n+  local python_table = vim.fn['provider#pythonx#Detect'](3)\n+  pyname = python_table[1]\n+  local pythonx_warnings = python_table[2]\n+\n+  if is_blank(pyname) then\n+    health.warn(\n+      'No Python executable found that can `import neovim`. '\n+      .. 'Using the first available executable for diagnostics.'\n+    )\n+  elseif vim.g[host_prog_var] then\n+    python_exe = pyname\n+  end\n+\n+  -- No Python executable could `import neovim`, or host_prog_var was used.\n+  if not is_blank(pythonx_warnings) then\n+    health.warn(pythonx_warnings, {\n+      'See :help provider-python for more information.',\n+      'You may disable this provider (and warning) by adding `let g:loaded_python3_provider = 0` to your init.vim',\n+    })\n+  elseif not is_blank(pyname) and is_blank(python_exe) then\n+    if not vim.g[host_prog_var] then\n+      local message = string.format(\n+        '`g:%s` is not set. Searching for %s in the environment.',\n+        host_prog_var,\n+        pyname\n+      )\n+      health.info(message)\n+    end\n+\n+    if not is_blank(pyenv) then\n+      python_exe = health.system({ pyenv, 'which', pyname }, { stderr = true })\n+      if is_blank(python_exe) then\n+        health.warn('pyenv could not find ' .. pyname .. '.')\n+      end\n+    end\n+\n+    if is_blank(python_exe) then\n+      python_exe = vim.fn.exepath(pyname)\n+\n+      if os.getenv('PATH') then\n+        local path_sep = iswin and ';' or ':'\n+        local paths = vim.split(os.getenv('PATH') or '', path_sep)",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163150839",
            "id": 1163150839,
            "in_reply_to_id": 1163103057,
            "line": 286,
            "node_id": "PRRC_kwDOAPphoM5FVEX3",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 286,
            "original_position": 286,
            "original_start_line": null,
            "path": "runtime/lua/provider/python/health.lua",
            "position": 286,
            "pull_request_review_id": 1379804665,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163150839/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T17:51:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163150839",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163152913"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163152913"
                }
            },
            "author_association": "MEMBER",
            "body": "ye the enclosing if statement already checked it",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T17:53:15Z",
            "diff_hunk": "@@ -0,0 +1,490 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+local function is(path, ty)\n+  if not path then\n+    return false\n+  end\n+  local stat = vim.loop.fs_stat(path)\n+  if not stat then\n+    return false\n+  end\n+  return stat.type == ty\n+end\n+\n+-- Resolves Python executable path by invoking and checking `sys.executable`.\n+local function python_exepath(invocation)\n+  local python = vim.fn.fnameescape(invocation)\n+  local out = vim.fn.system(python .. ' -c \"import sys; sys.stdout.write(sys.executable)\"')\n+  assert(vim.v.shell_error == 0, out)\n+  return vim.fs.normalize(vim.trim(out))\n+end\n+\n+local function is_blank(v)\n+  return v:find('^%s*$') ~= nil\n+end\n+\n+-- Check if pyenv is available and a valid pyenv root can be found, then return\n+-- their respective paths. If either of those is invalid, return two empty\n+-- strings, effectively ignoring pyenv.\n+local function check_for_pyenv()\n+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))\n+\n+  if is_blank(pyenv_path) then\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Path: ' .. pyenv_path)\n+\n+  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''\n+\n+  if is_blank(pyenv_root) then\n+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })\n+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')\n+  end\n+\n+  if not is(pyenv_root, 'directory') then\n+    local message = string.format(\n+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',\n+      pyenv_root\n+    )\n+    health.warn(message)\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Root: ' .. pyenv_root)\n+\n+  return { pyenv_path, pyenv_root }\n+end\n+\n+-- Check the Python interpreter's usability.\n+local function check_bin(bin)\n+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then\n+    health.error('\"' .. bin .. '\" was not found.')\n+    return false\n+  elseif vim.fn.executable(bin) ~= 1 then\n+    health.error('\"' .. bin .. '\" is not executable.')\n+    return false\n+  end\n+  return true\n+end\n+\n+-- Fetch the contents of a URL.\n+local function download(url)\n+  local has_curl = vim.fn.executable('curl') == 1\n+  if has_curl and vim.fn.system({ 'curl', '-V' }):find('Protocols:.*https') then\n+    local out, rc = health.system({ 'curl', '-sL', url }, { stderr = true, ignore_error = true })\n+    if rc ~= 0 then\n+      return 'curl error with ' .. url .. ': ' .. rc\n+    else\n+      return out\n+    end\n+  elseif vim.fn.executable('python') == 1 then\n+    local script = \"try:\\n\\\n+          from urllib.request import urlopen\\n\\\n+          except ImportError:\\n\\\n+          from urllib2 import urlopen\\n\\\n+          response = urlopen('\" .. url .. \"')\\n\\\n+          print(response.read().decode('utf8'))\\n\"\n+    local out, rc = health.system({ 'python', '-c', script })\n+    if is_blank(out) and rc ~= 0 then\n+      return 'python urllib.request error: ' .. rc\n+    else\n+      return out\n+    end\n+  end\n+\n+  local message = 'missing `curl` '\n+\n+  if has_curl then\n+    message = message .. '(with HTTPS support) '\n+  end\n+  message = message .. 'and `python`, cannot make web request'\n+\n+  return message\n+end\n+\n+\n+-- Get the latest Nvim Python client (pynvim) version from PyPI.\n+local function latest_pypi_version()\n+  local pypi_version = 'unable to get pypi response'\n+  local pypi_response = download('https://pypi.python.org/pypi/pynvim/json')\n+  if not is_blank(pypi_response) then\n+    local pcall_ok, output = pcall(vim.fn.json_decode, pypi_response)\n+    local pypi_data\n+    if pcall_ok then\n+      pypi_data = output\n+    else\n+      return 'error: ' .. pypi_response\n+    end\n+\n+    local pypi_element = pypi_data['info'] or {}\n+    pypi_version = pypi_element['version'] or 'unable to parse'\n+  end\n+  return pypi_version\n+end\n+\n+local function is_bad_response(s)\n+  local lower = s:lower()\n+  return vim.startswith(lower, 'unable')\n+      or vim.startswith(lower, 'error')\n+      or vim.startswith(lower, 'outdated')\n+end\n+\n+\n+-- Get version information using the specified interpreter.  The interpreter is\n+-- used directly in case breaking changes were introduced since the last time\n+-- Nvim's Python client was updated.\n+--\n+-- Returns: {\n+--     {python executable version},\n+--     {current nvim version},\n+--     {current pypi nvim status},\n+--     {installed version status}\n+-- }\n+local function version_info(python)\n+  local pypi_version = latest_pypi_version()\n+\n+  local python_version, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; print(\".\".join(str(x) for x in sys.version_info[:3]))',\n+  })\n+\n+  if rc ~= 0 or is_blank(python_version) then\n+    python_version = 'unable to parse ' .. python .. ' response'\n+  end\n+\n+  local nvim_path, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; sys.path = [p for p in sys.path if p != \"\"]; import neovim; print(neovim.__file__)',\n+  })\n+  if rc ~= 0 or is_blank(nvim_path) then\n+    return { python_version, 'unable to load neovim Python module', pypi_version, nvim_path }\n+  end\n+\n+  -- Assuming that multiple versions of a package are installed, sort them\n+  -- numerically in descending order.\n+  local function compare(metapath1, metapath2)\n+    local a = vim.fn.matchstr(vim.fn.fnamemodify(metapath1, ':p:h:t'), [[[0-9.]\\+]])\n+    local b = vim.fn.matchstr(vim.fn.fnamemodify(metapath2, ':p:h:t'), [[[0-9.]\\+]])\n+    if a == b then\n+      return 0\n+    elseif a > b then\n+      return 1\n+    else\n+      return -1\n+    end\n+  end\n+\n+  -- Try to get neovim.VERSION (added in 0.1.11dev).\n+  local nvim_version, rc = health.system({\n+    python,\n+    '-c',\n+    'from neovim import VERSION as v; print(\"{}.{}.{}{}\".format(v.major, v.minor, v.patch, v.prerelease))',\n+  }, { stderr = true, ignore_error = true })\n+  if rc ~= 0 or is_blank(nvim_version) then\n+    nvim_version = 'unable to find pynvim module version'\n+    local base = vim.fs.basename(nvim_path)\n+    local metas = vim.fn.glob(base .. '-*/METADATA', 1, 1)\n+    vim.list_extend(metas, vim.fn.glob(base .. '-*/PKG-INFO', 1, 1))\n+    vim.list_extend(metas, vim.fn.glob(base .. '.egg-info/PKG-INFO', 1, 1))\n+    metas = table.sort(metas, compare)\n+\n+    if metas and next(metas) ~= nil then\n+      for line in io.lines(metas[1]) do\n+        local version = line:match('^Version: (%S+)')\n+        if version then\n+          nvim_version = version\n+          break\n+        end\n+      end\n+    end\n+  end\n+\n+  local nvim_path_base = vim.fn.fnamemodify(nvim_path, [[:~:h]])\n+  local version_status = 'unknown; ' .. nvim_path_base\n+  if is_bad_response(nvim_version) and is_bad_response(pypi_version) then\n+    if vim.version.lt(nvim_version, pypi_version) then\n+      version_status = 'outdated; from ' .. nvim_path_base\n+    else\n+      version_status = 'up to date'\n+    end\n+  end\n+\n+  return { python_version, nvim_version, pypi_version, version_status }\n+end\n+\n+function M.check()\n+  health.start('Python 3 provider (optional)')\n+\n+  local pyname = 'python3'\n+  local python_exe = ''\n+  local virtual_env = os.getenv('VIRTUAL_ENV')\n+  local venv = virtual_env and vim.fn.resolve(virtual_env) or ''\n+  local host_prog_var = pyname .. '_host_prog'\n+  local python_multiple = {}\n+\n+  if health.provider_disabled(pyname) then\n+    return\n+  end\n+\n+  local pyenv_table = check_for_pyenv()\n+  local pyenv = pyenv_table[1]\n+  local pyenv_root = pyenv_table[2]\n+\n+  if vim.g[host_prog_var] then\n+    local message = string.format('Using: g:%s = \"%s\"', host_prog_var, vim.g[host_prog_var])\n+    health.info(message)\n+  end\n+\n+  local python_table = vim.fn['provider#pythonx#Detect'](3)\n+  pyname = python_table[1]\n+  local pythonx_warnings = python_table[2]\n+\n+  if is_blank(pyname) then\n+    health.warn(\n+      'No Python executable found that can `import neovim`. '\n+      .. 'Using the first available executable for diagnostics.'\n+    )\n+  elseif vim.g[host_prog_var] then\n+    python_exe = pyname\n+  end\n+\n+  -- No Python executable could `import neovim`, or host_prog_var was used.\n+  if not is_blank(pythonx_warnings) then\n+    health.warn(pythonx_warnings, {\n+      'See :help provider-python for more information.',\n+      'You may disable this provider (and warning) by adding `let g:loaded_python3_provider = 0` to your init.vim',\n+    })\n+  elseif not is_blank(pyname) and is_blank(python_exe) then\n+    if not vim.g[host_prog_var] then\n+      local message = string.format(\n+        '`g:%s` is not set. Searching for %s in the environment.',\n+        host_prog_var,\n+        pyname\n+      )\n+      health.info(message)\n+    end\n+\n+    if not is_blank(pyenv) then\n+      python_exe = health.system({ pyenv, 'which', pyname }, { stderr = true })\n+      if is_blank(python_exe) then\n+        health.warn('pyenv could not find ' .. pyname .. '.')\n+      end\n+    end\n+\n+    if is_blank(python_exe) then\n+      python_exe = vim.fn.exepath(pyname)\n+\n+      if os.getenv('PATH') then\n+        local path_sep = iswin and ';' or ':'\n+        local paths = vim.split(os.getenv('PATH') or '', path_sep)",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163152913",
            "id": 1163152913,
            "in_reply_to_id": 1163103057,
            "line": 286,
            "node_id": "PRRC_kwDOAPphoM5FVE4R",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 286,
            "original_position": 286,
            "original_start_line": null,
            "path": "runtime/lua/provider/python/health.lua",
            "position": 286,
            "pull_request_review_id": 1379807682,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163152913/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T17:53:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163152913",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1163156831"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163156831"
                }
            },
            "author_association": "MEMBER",
            "body": "You're smart lol",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2023-04-11T17:57:18Z",
            "diff_hunk": "@@ -0,0 +1,490 @@\n+local health = vim.health\n+\n+local iswin = vim.loop.os_uname().sysname == 'Windows_NT'\n+\n+local M = {}\n+\n+local function is(path, ty)\n+  if not path then\n+    return false\n+  end\n+  local stat = vim.loop.fs_stat(path)\n+  if not stat then\n+    return false\n+  end\n+  return stat.type == ty\n+end\n+\n+-- Resolves Python executable path by invoking and checking `sys.executable`.\n+local function python_exepath(invocation)\n+  local python = vim.fn.fnameescape(invocation)\n+  local out = vim.fn.system(python .. ' -c \"import sys; sys.stdout.write(sys.executable)\"')\n+  assert(vim.v.shell_error == 0, out)\n+  return vim.fs.normalize(vim.trim(out))\n+end\n+\n+local function is_blank(v)\n+  return v:find('^%s*$') ~= nil\n+end\n+\n+-- Check if pyenv is available and a valid pyenv root can be found, then return\n+-- their respective paths. If either of those is invalid, return two empty\n+-- strings, effectively ignoring pyenv.\n+local function check_for_pyenv()\n+  local pyenv_path = vim.fn.resolve(vim.fn.exepath('pyenv'))\n+\n+  if is_blank(pyenv_path) then\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Path: ' .. pyenv_path)\n+\n+  local pyenv_root = os.getenv('PYENV_ROOT') and vim.fn.resolve('$PYENV_ROOT') or ''\n+\n+  if is_blank(pyenv_root) then\n+    pyenv_root = vim.fn.system({ pyenv_path, 'root' })\n+    health.info('pyenv: $PYENV_ROOT is not set. Infer from `pyenv root`.')\n+  end\n+\n+  if not is(pyenv_root, 'directory') then\n+    local message = string.format(\n+      'pyenv: Root does not exist: %s. Ignoring pyenv for all following checks.',\n+      pyenv_root\n+    )\n+    health.warn(message)\n+    return { '', '' }\n+  end\n+\n+  health.info('pyenv: Root: ' .. pyenv_root)\n+\n+  return { pyenv_path, pyenv_root }\n+end\n+\n+-- Check the Python interpreter's usability.\n+local function check_bin(bin)\n+  if not is(bin, 'file') and (not iswin or not is(bin .. '.exe', 'file')) then\n+    health.error('\"' .. bin .. '\" was not found.')\n+    return false\n+  elseif vim.fn.executable(bin) ~= 1 then\n+    health.error('\"' .. bin .. '\" is not executable.')\n+    return false\n+  end\n+  return true\n+end\n+\n+-- Fetch the contents of a URL.\n+local function download(url)\n+  local has_curl = vim.fn.executable('curl') == 1\n+  if has_curl and vim.fn.system({ 'curl', '-V' }):find('Protocols:.*https') then\n+    local out, rc = health.system({ 'curl', '-sL', url }, { stderr = true, ignore_error = true })\n+    if rc ~= 0 then\n+      return 'curl error with ' .. url .. ': ' .. rc\n+    else\n+      return out\n+    end\n+  elseif vim.fn.executable('python') == 1 then\n+    local script = \"try:\\n\\\n+          from urllib.request import urlopen\\n\\\n+          except ImportError:\\n\\\n+          from urllib2 import urlopen\\n\\\n+          response = urlopen('\" .. url .. \"')\\n\\\n+          print(response.read().decode('utf8'))\\n\"\n+    local out, rc = health.system({ 'python', '-c', script })\n+    if is_blank(out) and rc ~= 0 then\n+      return 'python urllib.request error: ' .. rc\n+    else\n+      return out\n+    end\n+  end\n+\n+  local message = 'missing `curl` '\n+\n+  if has_curl then\n+    message = message .. '(with HTTPS support) '\n+  end\n+  message = message .. 'and `python`, cannot make web request'\n+\n+  return message\n+end\n+\n+\n+-- Get the latest Nvim Python client (pynvim) version from PyPI.\n+local function latest_pypi_version()\n+  local pypi_version = 'unable to get pypi response'\n+  local pypi_response = download('https://pypi.python.org/pypi/pynvim/json')\n+  if not is_blank(pypi_response) then\n+    local pcall_ok, output = pcall(vim.fn.json_decode, pypi_response)\n+    local pypi_data\n+    if pcall_ok then\n+      pypi_data = output\n+    else\n+      return 'error: ' .. pypi_response\n+    end\n+\n+    local pypi_element = pypi_data['info'] or {}\n+    pypi_version = pypi_element['version'] or 'unable to parse'\n+  end\n+  return pypi_version\n+end\n+\n+local function is_bad_response(s)\n+  local lower = s:lower()\n+  return vim.startswith(lower, 'unable')\n+      or vim.startswith(lower, 'error')\n+      or vim.startswith(lower, 'outdated')\n+end\n+\n+\n+-- Get version information using the specified interpreter.  The interpreter is\n+-- used directly in case breaking changes were introduced since the last time\n+-- Nvim's Python client was updated.\n+--\n+-- Returns: {\n+--     {python executable version},\n+--     {current nvim version},\n+--     {current pypi nvim status},\n+--     {installed version status}\n+-- }\n+local function version_info(python)\n+  local pypi_version = latest_pypi_version()\n+\n+  local python_version, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; print(\".\".join(str(x) for x in sys.version_info[:3]))',\n+  })\n+\n+  if rc ~= 0 or is_blank(python_version) then\n+    python_version = 'unable to parse ' .. python .. ' response'\n+  end\n+\n+  local nvim_path, rc = health.system({\n+    python,\n+    '-c',\n+    'import sys; sys.path = [p for p in sys.path if p != \"\"]; import neovim; print(neovim.__file__)',\n+  })\n+  if rc ~= 0 or is_blank(nvim_path) then\n+    return { python_version, 'unable to load neovim Python module', pypi_version, nvim_path }\n+  end\n+\n+  -- Assuming that multiple versions of a package are installed, sort them\n+  -- numerically in descending order.\n+  local function compare(metapath1, metapath2)\n+    local a = vim.fn.matchstr(vim.fn.fnamemodify(metapath1, ':p:h:t'), [[[0-9.]\\+]])\n+    local b = vim.fn.matchstr(vim.fn.fnamemodify(metapath2, ':p:h:t'), [[[0-9.]\\+]])\n+    if a == b then\n+      return 0\n+    elseif a > b then\n+      return 1\n+    else\n+      return -1\n+    end\n+  end\n+\n+  -- Try to get neovim.VERSION (added in 0.1.11dev).\n+  local nvim_version, rc = health.system({\n+    python,\n+    '-c',\n+    'from neovim import VERSION as v; print(\"{}.{}.{}{}\".format(v.major, v.minor, v.patch, v.prerelease))',\n+  }, { stderr = true, ignore_error = true })\n+  if rc ~= 0 or is_blank(nvim_version) then\n+    nvim_version = 'unable to find pynvim module version'\n+    local base = vim.fs.basename(nvim_path)\n+    local metas = vim.fn.glob(base .. '-*/METADATA', 1, 1)\n+    vim.list_extend(metas, vim.fn.glob(base .. '-*/PKG-INFO', 1, 1))\n+    vim.list_extend(metas, vim.fn.glob(base .. '.egg-info/PKG-INFO', 1, 1))\n+    metas = table.sort(metas, compare)\n+\n+    if metas and next(metas) ~= nil then\n+      for line in io.lines(metas[1]) do\n+        local version = line:match('^Version: (%S+)')\n+        if version then\n+          nvim_version = version\n+          break\n+        end\n+      end\n+    end\n+  end\n+\n+  local nvim_path_base = vim.fn.fnamemodify(nvim_path, [[:~:h]])\n+  local version_status = 'unknown; ' .. nvim_path_base\n+  if is_bad_response(nvim_version) and is_bad_response(pypi_version) then\n+    if vim.version.lt(nvim_version, pypi_version) then\n+      version_status = 'outdated; from ' .. nvim_path_base\n+    else\n+      version_status = 'up to date'\n+    end\n+  end\n+\n+  return { python_version, nvim_version, pypi_version, version_status }\n+end\n+\n+function M.check()\n+  health.start('Python 3 provider (optional)')\n+\n+  local pyname = 'python3'\n+  local python_exe = ''\n+  local virtual_env = os.getenv('VIRTUAL_ENV')\n+  local venv = virtual_env and vim.fn.resolve(virtual_env) or ''\n+  local host_prog_var = pyname .. '_host_prog'\n+  local python_multiple = {}\n+\n+  if health.provider_disabled(pyname) then\n+    return\n+  end\n+\n+  local pyenv_table = check_for_pyenv()\n+  local pyenv = pyenv_table[1]\n+  local pyenv_root = pyenv_table[2]\n+\n+  if vim.g[host_prog_var] then\n+    local message = string.format('Using: g:%s = \"%s\"', host_prog_var, vim.g[host_prog_var])\n+    health.info(message)\n+  end\n+\n+  local python_table = vim.fn['provider#pythonx#Detect'](3)\n+  pyname = python_table[1]\n+  local pythonx_warnings = python_table[2]\n+\n+  if is_blank(pyname) then\n+    health.warn(\n+      'No Python executable found that can `import neovim`. '\n+      .. 'Using the first available executable for diagnostics.'\n+    )\n+  elseif vim.g[host_prog_var] then\n+    python_exe = pyname\n+  end\n+\n+  -- No Python executable could `import neovim`, or host_prog_var was used.\n+  if not is_blank(pythonx_warnings) then\n+    health.warn(pythonx_warnings, {\n+      'See :help provider-python for more information.',\n+      'You may disable this provider (and warning) by adding `let g:loaded_python3_provider = 0` to your init.vim',\n+    })\n+  elseif not is_blank(pyname) and is_blank(python_exe) then\n+    if not vim.g[host_prog_var] then\n+      local message = string.format(\n+        '`g:%s` is not set. Searching for %s in the environment.',\n+        host_prog_var,\n+        pyname\n+      )\n+      health.info(message)\n+    end\n+\n+    if not is_blank(pyenv) then\n+      python_exe = health.system({ pyenv, 'which', pyname }, { stderr = true })\n+      if is_blank(python_exe) then\n+        health.warn('pyenv could not find ' .. pyname .. '.')\n+      end\n+    end\n+\n+    if is_blank(python_exe) then\n+      python_exe = vim.fn.exepath(pyname)\n+\n+      if os.getenv('PATH') then\n+        local path_sep = iswin and ';' or ':'\n+        local paths = vim.split(os.getenv('PATH') or '', path_sep)",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1163156831",
            "id": 1163156831,
            "in_reply_to_id": 1163103057,
            "line": 286,
            "node_id": "PRRC_kwDOAPphoM5FVF1f",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 286,
            "original_position": 286,
            "original_start_line": null,
            "path": "runtime/lua/provider/python/health.lua",
            "position": 286,
            "pull_request_review_id": 1379813442,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 1,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163156831/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-04-11T17:57:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1163156831",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1439021449"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1439021449"
                }
            },
            "author_association": "MEMBER",
            "body": "Why the googly eyes?",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2024-01-01T12:43:55Z",
            "diff_hunk": "@@ -4,22 +4,140 @@ function M.report_start(msg)\n   vim.fn['health#report_start'](msg)\n end\n \n+M.start = M.report_start\n+\n function M.report_info(msg)\n   vim.fn['health#report_info'](msg)\n end\n \n+M.info = M.report_info\n+\n function M.report_ok(msg)\n   vim.fn['health#report_ok'](msg)\n end\n \n+M.ok = M.report_ok\n+\n function M.report_warn(msg, ...)\n   vim.fn['health#report_warn'](msg, ...)\n end\n \n+M.warn = M.report_warn\n+\n function M.report_error(msg, ...)\n   vim.fn['health#report_error'](msg, ...)\n end\n \n+M.error = M.report_error\n+\n+function M.provider_disabled(provider)\n+  local loaded_var = 'loaded_' .. provider .. '_provider'\n+  local v = vim.g[loaded_var]\n+  if v == 0 then\n+    M.report_info('Disabled (' .. loaded_var .. '=' .. v .. ').')\n+    return true\n+  end\n+  return false\n+end\n+\n+-- Handler for s:system() function.\n+local function system_handler(self, _, data, event)\n+  if event == 'stderr' then\n+    if self.add_stderr_to_output then\n+      self.output = self.output .. table.concat(data, '')\n+    else\n+      self.stderr = self.stderr .. table.concat(data, '')\n+    end\n+  elseif event == 'stdout' then\n+    self.output = self.output .. table.concat(data, '')\n+  end\n+end\n+\n+-- Attempts to construct a shell command from an args list.\n+-- Only for display, to help users debug a failed command.\n+local function shellify(cmd)\n+  if type(cmd) ~= 'table' then\n+    return cmd\n+  end\n+  local escaped = {}\n+  for i, v in ipairs(cmd) do\n+    if v:match('[^A-Za-z_/.-]') then\n+      escaped[i] = vim.fn.shellescape(v)\n+    else\n+      escaped[i] = v\n+    end\n+  end\n+  return table.concat(escaped, ' ')\n+end\n+\n+function M.cmd_ok(cmd)\n+  local out = vim.fn.system(cmd)\n+  return vim.v.shell_error == 0, out\n+end\n+\n+--- Run a system command and timeout after 30 seconds.\n+---\n+--- @param cmd table List of command arguments to execute\n+--- @param args ?table Optional arguments:\n+---                   - stdin (string): Data to write to the job's stdin\n+---                   - stderr (boolean): Append stderr to stdout\n+---                   - ignore_error (boolean): If true, ignore error output\n+---                   - timeout (number): Number of seconds to wait before timing out (default 30)\n+function M.system(cmd, args)\n+  args = args or {}\n+  local stdin = args.stdin or ''\n+  local stderr = vim.F.if_nil(args.stderr, false)\n+  local ignore_error = vim.F.if_nil(args.ignore_error, false)\n+\n+  local shell_error_code = 0\n+  local opts = {\n+    add_stderr_to_output = stderr,\n+    output = '',\n+    stderr = '',\n+    on_stdout = system_handler,\n+    on_stderr = system_handler,\n+    on_exit = function(_, data)\n+      shell_error_code = data\n+    end,\n+  }\n+  local jobid = vim.fn.jobstart(cmd, opts)\n+\n+  if jobid < 1 then\n+    local message =\n+        string.format('Command error (job=%d): %s (in %s)', jobid, shellify(cmd), vim.loop.cwd())\n+    error(message)\n+    return opts.output, 1\n+  end\n+\n+  if stdin:find('^%s$') then\n+    vim.fn.jobsend(jobid, stdin)\n+  end\n+\n+  local res = vim.fn.jobwait({ jobid }, vim.F.if_nil(args.timeout, 30) * 1000)\n+  if res[1] == -1 then\n+    error('Command timed out: ' .. shellify(cmd))\n+    vim.fn.jobstop(jobid)\n+  elseif shell_error_code ~= 0 and not ignore_error then\n+    local emsg = string.format(\n+      'Command error (job=%d, exit code %d): %s (in %s)',\n+      jobid,\n+      shell_error_code,\n+      shellify(cmd),\n+      vim.loop.cwd()\n+    )\n+    if opts.output:find('%S') then\n+      emsg = string.format('%s\\noutput: %s', emsg, opts.output)\n+    end\n+    if opts.stderr:find('%S') then\n+      emsg = string.format('%s\\nstderr: %s', emsg, opts.stderr)\n+    end\n+    error(emsg)\n+  end\n+\n+  -- return opts.output\n+  return vim.trim(vim.fn.system(cmd)), shell_error_code",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1439021449",
            "id": 1439021449,
            "in_reply_to_id": 1163073150,
            "line": 138,
            "node_id": "PRRC_kwDOAPphoM5VxbmJ",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 138,
            "original_position": 135,
            "original_start_line": 137,
            "path": "runtime/lua/vim/health.lua",
            "position": 135,
            "pull_request_review_id": 1799796182,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1439021449/reactions"
            },
            "side": "RIGHT",
            "start_line": 137,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-01-01T12:43:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1439021449",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/23007#discussion_r1451738391"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/23007"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451738391"
                }
            },
            "author_association": "MEMBER",
            "body": "The job is started with jobstart(), but ignores the output from it, and then re-runs the command with system() to get the output. Anyways, looks like #26848 addresses this.",
            "commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "created_at": "2024-01-14T13:55:28Z",
            "diff_hunk": "@@ -4,22 +4,140 @@ function M.report_start(msg)\n   vim.fn['health#report_start'](msg)\n end\n \n+M.start = M.report_start\n+\n function M.report_info(msg)\n   vim.fn['health#report_info'](msg)\n end\n \n+M.info = M.report_info\n+\n function M.report_ok(msg)\n   vim.fn['health#report_ok'](msg)\n end\n \n+M.ok = M.report_ok\n+\n function M.report_warn(msg, ...)\n   vim.fn['health#report_warn'](msg, ...)\n end\n \n+M.warn = M.report_warn\n+\n function M.report_error(msg, ...)\n   vim.fn['health#report_error'](msg, ...)\n end\n \n+M.error = M.report_error\n+\n+function M.provider_disabled(provider)\n+  local loaded_var = 'loaded_' .. provider .. '_provider'\n+  local v = vim.g[loaded_var]\n+  if v == 0 then\n+    M.report_info('Disabled (' .. loaded_var .. '=' .. v .. ').')\n+    return true\n+  end\n+  return false\n+end\n+\n+-- Handler for s:system() function.\n+local function system_handler(self, _, data, event)\n+  if event == 'stderr' then\n+    if self.add_stderr_to_output then\n+      self.output = self.output .. table.concat(data, '')\n+    else\n+      self.stderr = self.stderr .. table.concat(data, '')\n+    end\n+  elseif event == 'stdout' then\n+    self.output = self.output .. table.concat(data, '')\n+  end\n+end\n+\n+-- Attempts to construct a shell command from an args list.\n+-- Only for display, to help users debug a failed command.\n+local function shellify(cmd)\n+  if type(cmd) ~= 'table' then\n+    return cmd\n+  end\n+  local escaped = {}\n+  for i, v in ipairs(cmd) do\n+    if v:match('[^A-Za-z_/.-]') then\n+      escaped[i] = vim.fn.shellescape(v)\n+    else\n+      escaped[i] = v\n+    end\n+  end\n+  return table.concat(escaped, ' ')\n+end\n+\n+function M.cmd_ok(cmd)\n+  local out = vim.fn.system(cmd)\n+  return vim.v.shell_error == 0, out\n+end\n+\n+--- Run a system command and timeout after 30 seconds.\n+---\n+--- @param cmd table List of command arguments to execute\n+--- @param args ?table Optional arguments:\n+---                   - stdin (string): Data to write to the job's stdin\n+---                   - stderr (boolean): Append stderr to stdout\n+---                   - ignore_error (boolean): If true, ignore error output\n+---                   - timeout (number): Number of seconds to wait before timing out (default 30)\n+function M.system(cmd, args)\n+  args = args or {}\n+  local stdin = args.stdin or ''\n+  local stderr = vim.F.if_nil(args.stderr, false)\n+  local ignore_error = vim.F.if_nil(args.ignore_error, false)\n+\n+  local shell_error_code = 0\n+  local opts = {\n+    add_stderr_to_output = stderr,\n+    output = '',\n+    stderr = '',\n+    on_stdout = system_handler,\n+    on_stderr = system_handler,\n+    on_exit = function(_, data)\n+      shell_error_code = data\n+    end,\n+  }\n+  local jobid = vim.fn.jobstart(cmd, opts)\n+\n+  if jobid < 1 then\n+    local message =\n+        string.format('Command error (job=%d): %s (in %s)', jobid, shellify(cmd), vim.loop.cwd())\n+    error(message)\n+    return opts.output, 1\n+  end\n+\n+  if stdin:find('^%s$') then\n+    vim.fn.jobsend(jobid, stdin)\n+  end\n+\n+  local res = vim.fn.jobwait({ jobid }, vim.F.if_nil(args.timeout, 30) * 1000)\n+  if res[1] == -1 then\n+    error('Command timed out: ' .. shellify(cmd))\n+    vim.fn.jobstop(jobid)\n+  elseif shell_error_code ~= 0 and not ignore_error then\n+    local emsg = string.format(\n+      'Command error (job=%d, exit code %d): %s (in %s)',\n+      jobid,\n+      shell_error_code,\n+      shellify(cmd),\n+      vim.loop.cwd()\n+    )\n+    if opts.output:find('%S') then\n+      emsg = string.format('%s\\noutput: %s', emsg, opts.output)\n+    end\n+    if opts.stderr:find('%S') then\n+      emsg = string.format('%s\\nstderr: %s', emsg, opts.stderr)\n+    end\n+    error(emsg)\n+  end\n+\n+  -- return opts.output\n+  return vim.trim(vim.fn.system(cmd)), shell_error_code",
            "html_url": "https://github.com/neovim/neovim/pull/23007#discussion_r1451738391",
            "id": 1451738391,
            "in_reply_to_id": 1163073150,
            "line": 138,
            "node_id": "PRRC_kwDOAPphoM5Wh8UX",
            "original_commit_id": "700509262c11156b180b24900c5224536ce9bd75",
            "original_line": 138,
            "original_position": 135,
            "original_start_line": 137,
            "path": "runtime/lua/vim/health.lua",
            "position": 135,
            "pull_request_review_id": 1820235140,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451738391/reactions"
            },
            "side": "RIGHT",
            "start_line": 137,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-01-14T13:55:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451738391",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6256228?v=4",
                "events_url": "https://api.github.com/users/seandewar/events{/privacy}",
                "followers_url": "https://api.github.com/users/seandewar/followers",
                "following_url": "https://api.github.com/users/seandewar/following{/other_user}",
                "gists_url": "https://api.github.com/users/seandewar/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/seandewar",
                "id": 6256228,
                "login": "seandewar",
                "node_id": "MDQ6VXNlcjYyNTYyMjg=",
                "organizations_url": "https://api.github.com/users/seandewar/orgs",
                "received_events_url": "https://api.github.com/users/seandewar/received_events",
                "repos_url": "https://api.github.com/users/seandewar/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/seandewar/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/seandewar/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/seandewar"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "Only mentioning this as a note for future and should in no way block or affect this PR: the checkhealth completion will become very crowded as each `health.lua` file will create an additional entry. I'm unsure of the best way to tackle this at the moment, but mentioning this to raise awareness.",
            "created_at": "2023-04-11T18:12:23Z",
            "html_url": "https://github.com/neovim/neovim/pull/23007#issuecomment-1503867916",
            "id": 1503867916,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/23007",
            "node_id": "IC_kwDOAPphoM5ZozQM",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1503867916/reactions"
            },
            "updated_at": "2023-04-11T18:12:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1503867916",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Continued in https://github.com/neovim/neovim/pull/26839",
            "created_at": "2024-01-01T18:06:19Z",
            "html_url": "https://github.com/neovim/neovim/pull/23007#issuecomment-1873422778",
            "id": 1873422778,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/23007",
            "node_id": "IC_kwDOAPphoM5vqim6",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1873422778/reactions"
            },
            "updated_at": "2024-01-01T18:06:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1873422778",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/23007/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/23007/commits",
    "created_at": "2023-04-10T22:53:07Z",
    "diff_url": "https://github.com/neovim/neovim/pull/23007.diff",
    "draft": false,
    "head": {
        "label": "gpanders:health",
        "ref": "health",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/gpanders/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/gpanders/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/gpanders/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/gpanders/neovim/branches{/branch}",
            "clone_url": "https://github.com/gpanders/neovim.git",
            "collaborators_url": "https://api.github.com/repos/gpanders/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/gpanders/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/gpanders/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/gpanders/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/gpanders/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/gpanders/neovim/contributors",
            "created_at": "2021-06-11T03:58:44Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/gpanders/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/gpanders/neovim/downloads",
            "events_url": "https://api.github.com/repos/gpanders/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/gpanders/neovim/forks",
            "full_name": "gpanders/neovim",
            "git_commits_url": "https://api.github.com/repos/gpanders/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/gpanders/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/gpanders/neovim/git/tags{/sha}",
            "git_url": "git://github.com/gpanders/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/gpanders/neovim/hooks",
            "html_url": "https://github.com/gpanders/neovim",
            "id": 375899052,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/gpanders/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/gpanders/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/gpanders/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/gpanders/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/gpanders/neovim/labels{/name}",
            "language": "Vim script",
            "languages_url": "https://api.github.com/repos/gpanders/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/gpanders/neovim/merges",
            "milestones_url": "https://api.github.com/repos/gpanders/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkzNzU4OTkwNTI=",
            "notifications_url": "https://api.github.com/repos/gpanders/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
                "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
                "followers_url": "https://api.github.com/users/gpanders/followers",
                "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
                "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/gpanders",
                "id": 8965202,
                "login": "gpanders",
                "node_id": "MDQ6VXNlcjg5NjUyMDI=",
                "organizations_url": "https://api.github.com/users/gpanders/orgs",
                "received_events_url": "https://api.github.com/users/gpanders/received_events",
                "repos_url": "https://api.github.com/users/gpanders/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/gpanders"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/gpanders/neovim/pulls{/number}",
            "pushed_at": "2024-01-15T20:26:02Z",
            "releases_url": "https://api.github.com/repos/gpanders/neovim/releases{/id}",
            "size": 242066,
            "ssh_url": "git@github.com:gpanders/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/gpanders/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/gpanders/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/gpanders/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/gpanders/neovim/subscription",
            "svn_url": "https://github.com/gpanders/neovim",
            "tags_url": "https://api.github.com/repos/gpanders/neovim/tags",
            "teams_url": "https://api.github.com/repos/gpanders/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/gpanders/neovim/git/trees{/sha}",
            "updated_at": "2022-01-07T19:38:08Z",
            "url": "https://api.github.com/repos/gpanders/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "700509262c11156b180b24900c5224536ce9bd75",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
            "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
            "followers_url": "https://api.github.com/users/gpanders/followers",
            "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
            "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/gpanders",
            "id": 8965202,
            "login": "gpanders",
            "node_id": "MDQ6VXNlcjg5NjUyMDI=",
            "organizations_url": "https://api.github.com/users/gpanders/orgs",
            "received_events_url": "https://api.github.com/users/gpanders/received_events",
            "repos_url": "https://api.github.com/users/gpanders/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/gpanders"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/23007",
    "id": 1308164357,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/23007",
    "labels": [
        {
            "color": "C5DEF5",
            "default": false,
            "description": "changes that are not features or bugfixes",
            "id": 106949155,
            "name": "refactor",
            "node_id": "MDU6TGFiZWwxMDY5NDkxNTU=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/refactor"
        }
    ],
    "locked": false,
    "merge_commit_sha": "4d3d93ff97e1b7e5fcfda36b5f19ce9bbc010f10",
    "merged_at": null,
    "milestone": null,
    "node_id": "PR_kwDOAPphoM5N-QEF",
    "number": 23007,
    "patch_url": "https://github.com/neovim/neovim/pull/23007.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/23007/comments",
    "state": "closed",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/700509262c11156b180b24900c5224536ce9bd75",
    "title": "refactor(health): refactor provider healthchecks",
    "updated_at": "2024-01-14T13:55:29Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/23007",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/8965202?v=4",
        "events_url": "https://api.github.com/users/gpanders/events{/privacy}",
        "followers_url": "https://api.github.com/users/gpanders/followers",
        "following_url": "https://api.github.com/users/gpanders/following{/other_user}",
        "gists_url": "https://api.github.com/users/gpanders/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/gpanders",
        "id": 8965202,
        "login": "gpanders",
        "node_id": "MDQ6VXNlcjg5NjUyMDI=",
        "organizations_url": "https://api.github.com/users/gpanders/orgs",
        "received_events_url": "https://api.github.com/users/gpanders/received_events",
        "repos_url": "https://api.github.com/users/gpanders/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/gpanders/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/gpanders/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/gpanders"
    }
}