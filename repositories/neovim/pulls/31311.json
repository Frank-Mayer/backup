{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/31311/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/31311/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/31311"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/31311"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/31311/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/ec2f70266129fa843a7228809ea2a5be50cd2335"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "CONTRIBUTOR",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 5713,
            "forks_count": 5713,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1844,
            "open_issues_count": 1844,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2024-11-25T23:53:08Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 296619,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 83592,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2024-11-26T01:58:04Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 83592,
            "watchers_count": 83592,
            "web_commit_signoff_required": false
        },
        "sha": "66bb1e577c96d8eb63c04dcc737394b4ce2b0f5d",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "Closes https://github.com/neovim/neovim/issues/12836\r\n\r\nImplemented the [`textDocument/foldingRange`](https://microsoft.github.io/language-server-protocol/specification/#textDocument_foldingRange) of LSP.\r\n\r\n* Provides `vim.lsp.foldexpr()` which can be used to enable LSP folding.\r\n* Provides `vim.lsp.foldtext()` which can be used to display the `collapsedText` returned by LSP servers.\r\n* Provides `vim.lsp.folding_range.foldclose(kind, winid)`, which can be used to fold a certain kind, and it can be used to fold imports automatically.",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1853921125"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853921125"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\r\n    Efficiently remove items from middle of a list.\r\n```",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-22T13:32:36Z",
            "diff_hunk": "@@ -2138,6 +2138,37 @@ vim.list_extend({dst}, {src}, {start}, {finish})           *vim.list_extend()*\n     See also: ~\n       • |vim.tbl_extend()|\n \n+vim.list_insert({t}, {first}, {last}, {v})                 *vim.list_insert()*\n+    Efficiently insert items into the middle of a list.\n+\n+    Calling table.insert() in a loop will re-index the tail of the table on\n+    every iteration, instead this function will re-index the table exactly\n+    once.\n+\n+    Based on\n+    https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+\n+    Parameters: ~\n+      • {t}      (`any[]`)\n+      • {first}  (`integer`)\n+      • {last}   (`integer`)\n+      • {v}      (`any`)\n+\n+vim.list_remove({t}, {first}, {last})                      *vim.list_remove()*\n+    Efficiently remove items from middle of a list a list.",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1853921125",
            "id": 1853921125,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ugJdl",
            "original_commit_id": "d0b3fdadecf5088e77c043239fad3c1357c11151",
            "original_line": 2158,
            "original_position": 21,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2454463370,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853921125/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T13:32:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853921125",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/329822?v=4",
                "events_url": "https://api.github.com/users/Julian/events{/privacy}",
                "followers_url": "https://api.github.com/users/Julian/followers",
                "following_url": "https://api.github.com/users/Julian/following{/other_user}",
                "gists_url": "https://api.github.com/users/Julian/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Julian",
                "id": 329822,
                "login": "Julian",
                "node_id": "MDQ6VXNlcjMyOTgyMg==",
                "organizations_url": "https://api.github.com/users/Julian/orgs",
                "received_events_url": "https://api.github.com/users/Julian/received_events",
                "repos_url": "https://api.github.com/users/Julian/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Julian/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Julian/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Julian",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1853921653"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853921653"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\r\n  insert/remove items from middle of a list.\r\n```",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-22T13:32:57Z",
            "diff_hunk": "@@ -230,6 +232,8 @@ LUA\n   is more performant and easier to read.\n • |vim.str_byteindex()| and |vim.str_utfindex()| gained overload signatures\n   supporting two new parameters, `encoding` and `strict_indexing`.\n+• |vim.list_insert()| and |vim.list_remove()| were added to efficiently\n+  insert/remove items from middle of a list a list.",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1853921653",
            "id": 1853921653,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ugJl1",
            "original_commit_id": "d0b3fdadecf5088e77c043239fad3c1357c11151",
            "original_line": 236,
            "original_position": 14,
            "original_start_line": null,
            "path": "runtime/doc/news.txt",
            "position": null,
            "pull_request_review_id": 2454464679,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853921653/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T13:32:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853921653",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/329822?v=4",
                "events_url": "https://api.github.com/users/Julian/events{/privacy}",
                "followers_url": "https://api.github.com/users/Julian/followers",
                "following_url": "https://api.github.com/users/Julian/following{/other_user}",
                "gists_url": "https://api.github.com/users/Julian/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Julian",
                "id": 329822,
                "login": "Julian",
                "node_id": "MDQ6VXNlcjMyOTgyMg==",
                "organizations_url": "https://api.github.com/users/Julian/orgs",
                "received_events_url": "https://api.github.com/users/Julian/received_events",
                "repos_url": "https://api.github.com/users/Julian/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Julian/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Julian/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Julian",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1853922956"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853922956"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\r\n• Implemented LSP folding ranges: |vim.lsp.foldexpr()|\r\n```",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-22T13:33:33Z",
            "diff_hunk": "@@ -222,6 +222,8 @@ LSP\n • |vim.lsp.buf.hover()| now highlights hover ranges using the\n   |hl-LspReferenceTarget| highlight group.\n • Functions in |vim.lsp.Client| can now be called as methods.\n+• Implemented LSP inlay hints: |vim.lsp.foldexpr()|",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1853922956",
            "id": 1853922956,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ugJ6M",
            "original_commit_id": "d0b3fdadecf5088e77c043239fad3c1357c11151",
            "original_line": 225,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/doc/news.txt",
            "position": null,
            "pull_request_review_id": 2454465862,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853922956/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T13:33:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853922956",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/329822?v=4",
                "events_url": "https://api.github.com/users/Julian/events{/privacy}",
                "followers_url": "https://api.github.com/users/Julian/followers",
                "following_url": "https://api.github.com/users/Julian/following{/other_user}",
                "gists_url": "https://api.github.com/users/Julian/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Julian",
                "id": 329822,
                "login": "Julian",
                "node_id": "MDQ6VXNlcjMyOTgyMg==",
                "organizations_url": "https://api.github.com/users/Julian/orgs",
                "received_events_url": "https://api.github.com/users/Julian/received_events",
                "repos_url": "https://api.github.com/users/Julian/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Julian/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Julian/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Julian",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1853965396"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853965396"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Thanks.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-22T14:03:53Z",
            "diff_hunk": "@@ -222,6 +222,8 @@ LSP\n • |vim.lsp.buf.hover()| now highlights hover ranges using the\n   |hl-LspReferenceTarget| highlight group.\n • Functions in |vim.lsp.Client| can now be called as methods.\n+• Implemented LSP inlay hints: |vim.lsp.foldexpr()|",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1853965396",
            "id": 1853965396,
            "in_reply_to_id": 1853922956,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ugURU",
            "original_commit_id": "d0b3fdadecf5088e77c043239fad3c1357c11151",
            "original_line": 225,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/doc/news.txt",
            "position": null,
            "pull_request_review_id": 2454536052,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853965396/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T14:03:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853965396",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1854573205"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854573205"
                }
            },
            "author_association": "MEMBER",
            "body": "Can you not expose this by prefixing it with an `_`.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-22T19:52:21Z",
            "diff_hunk": "@@ -737,6 +737,51 @@ function vim.list_slice(list, start, finish)\n   return new_list\n end\n \n+--- Efficiently insert items into the middle of a list.\n+---\n+--- Calling table.insert() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+---@param v any\n+function vim.list_insert(t, first, last, v)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1854573205",
            "id": 1854573205,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5uioqV",
            "original_commit_id": "7edd6718f050815fe399ed630cd7c69ab8cd9835",
            "original_line": 752,
            "original_position": 16,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2455516400,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854573205/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T19:53:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854573205",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1854573606"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854573606"
                }
            },
            "author_association": "MEMBER",
            "body": "Same here.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-22T19:52:47Z",
            "diff_hunk": "@@ -737,6 +737,51 @@ function vim.list_slice(list, start, finish)\n   return new_list\n end\n \n+--- Efficiently insert items into the middle of a list.\n+---\n+--- Calling table.insert() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+---@param v any\n+function vim.list_insert(t, first, last, v)\n+  local n = #t\n+\n+  -- Shift table forward\n+  for i = n - first, 0, -1 do\n+    t[last + 1 + i] = t[first + i]\n+  end\n+\n+  -- Fill in new values\n+  for i = first, last do\n+    t[i] = v\n+  end\n+end\n+\n+--- Efficiently remove items from middle of a list.\n+---\n+--- Calling table.remove() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+function vim.list_remove(t, first, last)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1854573606",
            "id": 1854573606,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5uiowm",
            "original_commit_id": "7edd6718f050815fe399ed630cd7c69ab8cd9835",
            "original_line": 777,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2455516400,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854573606/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T19:53:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854573606",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1854601238"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854601238"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Do you mean to consider it as an internal API? Then I will also remove it from the commit messages.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-22T20:16:41Z",
            "diff_hunk": "@@ -737,6 +737,51 @@ function vim.list_slice(list, start, finish)\n   return new_list\n end\n \n+--- Efficiently insert items into the middle of a list.\n+---\n+--- Calling table.insert() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+---@param v any\n+function vim.list_insert(t, first, last, v)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1854601238",
            "id": 1854601238,
            "in_reply_to_id": 1854573205,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5uivgW",
            "original_commit_id": "7edd6718f050815fe399ed630cd7c69ab8cd9835",
            "original_line": 752,
            "original_position": 16,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2455559068,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854601238/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T20:16:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854601238",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1854762776"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854762776"
                }
            },
            "author_association": "MEMBER",
            "body": "Yes please.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-22T21:47:41Z",
            "diff_hunk": "@@ -737,6 +737,51 @@ function vim.list_slice(list, start, finish)\n   return new_list\n end\n \n+--- Efficiently insert items into the middle of a list.\n+---\n+--- Calling table.insert() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+---@param v any\n+function vim.list_insert(t, first, last, v)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1854762776",
            "id": 1854762776,
            "in_reply_to_id": 1854573205,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ujW8Y",
            "original_commit_id": "7edd6718f050815fe399ed630cd7c69ab8cd9835",
            "original_line": 752,
            "original_position": 16,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2455793000,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854762776/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T21:47:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854762776",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855056877"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855056877"
                }
            },
            "author_association": "MEMBER",
            "body": "Nit, but let's put this above `textDocument/formatting` to keep the alphabetical order.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T03:35:53Z",
            "diff_hunk": "@@ -205,6 +205,7 @@ won't run if your server doesn't support them.\n - `'textDocument/documentHighlight'`\n - `'textDocument/documentSymbol'`\n - `'textDocument/formatting'`\n+- `'textDocument/foldingRange'`",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855056877",
            "id": 1855056877,
            "line": 207,
            "node_id": "PRRC_kwDOAPphoM5ukevt",
            "original_commit_id": "1f90bbe7ffd3e76f0976d349143b657911aa2479",
            "original_line": 207,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 4,
            "pull_request_review_id": 2456244920,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855056877/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T03:48:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855056877",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855056904"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855056904"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    Provides a `foldtext` function that shows the `collapsedText` retrieved,\r\n```",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T03:36:20Z",
            "diff_hunk": "@@ -697,6 +698,17 @@ commands                                                    *vim.lsp.commands*\n \n     The second argument is the `ctx` of |lsp-handler|\n \n+foldexpr({lnum})                                          *vim.lsp.foldexpr()*\n+    Provides an interface between the built-in client and a `foldexpr`\n+    function.\n+\n+    Parameters: ~\n+      • {lnum}  (`integer`) line number\n+\n+foldtext()                                                *vim.lsp.foldtext()*\n+    Provides a `foldtext` function that shows `collapsedText` retrieved,",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855056904",
            "id": 1855056904,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ukewI",
            "original_commit_id": "1f90bbe7ffd3e76f0976d349143b657911aa2479",
            "original_line": 709,
            "original_position": 20,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2456244920,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855056904/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T03:48:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855056904",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855057011"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855057011"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    defaults to the first folded line if `collapsedText` is not provided.\r\n```",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T03:37:12Z",
            "diff_hunk": "@@ -697,6 +698,17 @@ commands                                                    *vim.lsp.commands*\n \n     The second argument is the `ctx` of |lsp-handler|\n \n+foldexpr({lnum})                                          *vim.lsp.foldexpr()*\n+    Provides an interface between the built-in client and a `foldexpr`\n+    function.\n+\n+    Parameters: ~\n+      • {lnum}  (`integer`) line number\n+\n+foldtext()                                                *vim.lsp.foldtext()*\n+    Provides a `foldtext` function that shows `collapsedText` retrieved,\n+    default to the first folded line if `collapsedText` is not available.",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855057011",
            "id": 1855057011,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ukexz",
            "original_commit_id": "1f90bbe7ffd3e76f0976d349143b657911aa2479",
            "original_line": 710,
            "original_position": 21,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2456244920,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855057011/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T03:48:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855057011",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855057477"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855057477"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    To automatically fold imports when opening a file, you can use an autocommand: >lua\r\n```",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T03:37:55Z",
            "diff_hunk": "@@ -1644,6 +1656,27 @@ trigger()                                       *vim.lsp.completion.trigger()*\n     Trigger LSP completion in the current buffer.\n \n \n+==============================================================================\n+Lua module: vim.lsp.folding_range                          *lsp-folding_range*\n+\n+foldclose({kind}, {winid})                 *vim.lsp.folding_range.foldclose()*\n+    Close all {kind} of folds in the the window with {winid}.\n+\n+    To automatically fold imports, use an autocmd: >lua",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855057477",
            "id": 1855057477,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5uke5F",
            "original_commit_id": "1f90bbe7ffd3e76f0976d349143b657911aa2479",
            "original_line": 1665,
            "original_position": 36,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2456244920,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855057477/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T03:48:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855057477",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855060413"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855060413"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        client:supports_method(ms.textDocument_foldingRange)\r\n```",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T03:45:57Z",
            "diff_hunk": "@@ -0,0 +1,297 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRangeProvider`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client.server_capabilities.foldingRangeProvider",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855060413",
            "id": 1855060413,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ukfm9",
            "original_commit_id": "1f90bbe7ffd3e76f0976d349143b657911aa2479",
            "original_line": 142,
            "original_position": 142,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456244920,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855060413/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T03:48:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855060413",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855060525"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855060525"
                }
            },
            "author_association": "MEMBER",
            "body": "See previous suggestion about using `supports_method`",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T03:46:39Z",
            "diff_hunk": "@@ -0,0 +1,297 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRangeProvider`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client.server_capabilities.foldingRangeProvider\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        if client.server_capabilities.foldingRangeProvider then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855060525",
            "id": 1855060525,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ukfot",
            "original_commit_id": "1f90bbe7ffd3e76f0976d349143b657911aa2479",
            "original_line": 167,
            "original_position": 167,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456244920,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855060525/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T03:48:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855060525",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855063066"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855063066"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Oh, I know the reason now, `foldingRange` was not added to the supported methods of `client:supports_method` 😆. These checks should not be necessary because there is `get_clients()`",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T03:56:53Z",
            "diff_hunk": "@@ -0,0 +1,297 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRangeProvider`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client.server_capabilities.foldingRangeProvider\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        if client.server_capabilities.foldingRangeProvider then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855063066",
            "id": 1855063066,
            "in_reply_to_id": 1855060525,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ukgQa",
            "original_commit_id": "1f90bbe7ffd3e76f0976d349143b657911aa2479",
            "original_line": 167,
            "original_position": 167,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456253222,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855063066/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T03:56:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855063066",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855209433"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855209433"
                }
            },
            "author_association": "MEMBER",
            "body": "Is this really doing anything useful? It just seems to be returning the text of the top of the folded region?",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:08:13Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855209433",
            "id": 1855209433,
            "line": 367,
            "node_id": "PRRC_kwDOAPphoM5ulD_Z",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 367,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 367,
            "pull_request_review_id": 2456420959,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855209433/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:11:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855209433",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855209886"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855209886"
                }
            },
            "author_association": "MEMBER",
            "body": "We don't add handlers here anymore. Instead this should be inlined into the fold module.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:11:09Z",
            "diff_hunk": "@@ -217,6 +217,11 @@ RCS[ms.textDocument_diagnostic] = function(...)\n   return vim.lsp.diagnostic.on_diagnostic(...)\n end\n \n+--- @private\n+RCS[ms.textDocument_foldingRange] = function(...)\n+  return vim.lsp.folding_range.on_folding_range(...)\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855209886",
            "id": 1855209886,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulEGe",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 223,
            "original_position": 7,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/handlers.lua",
            "position": null,
            "pull_request_review_id": 2456420959,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855209886/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:11:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855209886",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855210172"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210172"
                }
            },
            "author_association": "MEMBER",
            "body": "Should this collect the results of all servers and process them in one loop so we then only schedule one update at the end?",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:13:07Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855210172",
            "id": 1855210172,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulEK8",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 62,
            "original_position": 62,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456421602,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210172/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:14:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210172",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855210341"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210341"
                }
            },
            "author_association": "MEMBER",
            "body": "Is this condition really necessary, especially since the expr could be something different anyway?",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:14:37Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855210341",
            "id": 1855210341,
            "line": 63,
            "node_id": "PRRC_kwDOAPphoM5ulENl",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 63,
            "original_position": 30,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 63,
            "pull_request_review_id": 2456421602,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210341/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:14:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210341",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855210582"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210582"
                }
            },
            "author_association": "MEMBER",
            "body": "Instead of collecting autocmds, would it be better to send an id and check for that instead?",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:16:15Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855210582",
            "id": 1855210582,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulERW",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 45,
            "original_position": 45,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456422000,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210582/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:16:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210582",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213282"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213282"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n      if next(clients) then\n```\n",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:35:43Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213282",
            "id": 1855213282,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulE7i",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 177,
            "original_position": 177,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213282/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213282",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213349"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213349"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n```\n",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:36:30Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213349",
            "id": 1855213349,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulE8l",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 122,
            "original_position": 122,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213349/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213349",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213399"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213399"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n        refresh(bufnr, client)\n```\n",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:37:06Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213399",
            "id": 1855213399,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulE9X",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 202,
            "original_position": 202,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213399/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213399",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213406"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213406"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n          refresh(bufnr, client)\n```\n",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:37:20Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213406",
            "id": 1855213406,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulE9e",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 179,
            "original_position": 179,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213406/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213406",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213414"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213414"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n        refresh(bufnr, client)\n```\n",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:37:30Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213414",
            "id": 1855213414,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulE9m",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 150,
            "original_position": 150,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213414/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213414",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213451"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213451"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\nlocal function refresh(bufnr, client)\n```\n",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:37:45Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213451",
            "id": 1855213451,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulE-L",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 124,
            "original_position": 124,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213451/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213451",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213479"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213479"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n```\n",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:38:07Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213479",
            "id": 1855213479,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulE-n",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 127,
            "original_position": 127,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213479/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213479",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213591"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213591"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n    refresh(bufnr, client)\n```\n",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:38:37Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213591",
            "id": 1855213591,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulFAX",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 210,
            "original_position": 210,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213591/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213591",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213632"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213632"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n      local request_id = refresh(bufnr, client)\n```\n",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:38:57Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213632",
            "id": 1855213632,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulFBA",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 274,
            "original_position": 274,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213632/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213632",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213683"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213683"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "It is to support `collapsedText` in `lsp.foldingRange` (proposed). To be honest, I haven't found a server that supports it, but I have a friend who is trying to implement LSP for Verilog and said this feature is somewhat useful. Considering it is very simple, I added it.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:39:14Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213683",
            "id": 1855213683,
            "in_reply_to_id": 1855209433,
            "line": 367,
            "node_id": "PRRC_kwDOAPphoM5ulFBz",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 367,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 367,
            "pull_request_review_id": 2456424703,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213683/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:39:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213683",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855214424"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855214424"
                }
            },
            "author_association": "MEMBER",
            "body": "This autocmd seems a bit redundant, isn't the callback unconditional?",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:41:46Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855214424",
            "id": 1855214424,
            "line": 348,
            "node_id": "PRRC_kwDOAPphoM5ulFNY",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 348,
            "original_position": 275,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 348,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855214424/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855214424",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855214803"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855214803"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I am currently not considering support for multiple servers. This is because such functionality is generally provided by a single server, and I feel that vim's own fold feature is unlikely to support this (correct me if I'm wrong), as multiple sources of `foldingRange` may have intersections, making it impossible to calculate the `foldlevel` in that case.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:43:41Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855214803",
            "id": 1855214803,
            "in_reply_to_id": 1855210172,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulFTT",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 62,
            "original_position": 62,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456425310,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855214803/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:43:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855214803",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855215145"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855215145"
                }
            },
            "author_association": "MEMBER",
            "body": "Need to also detach the buffer when all clients detach too.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:45:35Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855215145",
            "id": 1855215145,
            "line": 161,
            "node_id": "PRRC_kwDOAPphoM5ulFYp",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 161,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 161,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855215145/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855215145",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855215750"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855215750"
                }
            },
            "author_association": "MEMBER",
            "body": "Let's wait until it's actually part of the spec then; things might change too much until then.\r\n\r\n(It's better to leave something as a follow-up than to risk adding an API we have to do the deprecation dance around.)",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:49:18Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855215750",
            "id": 1855215750,
            "in_reply_to_id": 1855209433,
            "line": 367,
            "node_id": "PRRC_kwDOAPphoM5ulFiG",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 367,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 367,
            "pull_request_review_id": 2456426043,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855215750/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:49:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855215750",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855216166"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855216166"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "`foldupdate` to be called is possible only after the `vim.lsp.foldexpr` setup, which means that when it is called, `foldexpr` has already been ensured to be `vim.lsp.foldexpr`. This is to prevent the situation where `expr` is set but `foldmethod` is not set.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T15:52:07Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855216166",
            "id": 1855216166,
            "in_reply_to_id": 1855210341,
            "line": 63,
            "node_id": "PRRC_kwDOAPphoM5ulFom",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 63,
            "original_position": 30,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 63,
            "pull_request_review_id": 2456426458,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855216166/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:52:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855216166",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855218106"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855218106"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "This is to avoid executing `foldclose` when the buffer has already been modified, but the bufstate has not yet been updated. This ensures that the result of `foldclose` corresponds to the modified buffer.\r\n\r\nMore specifically, there is a situation where `foldclose` is executed immediately when opening a file (common in autocmd, such as the automatic folding import example given above). At this point, the bufstate is likely not updated yet, but what you actually want is the result after it has been updated, corresponding to the content you see in the buffer.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:06:43Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855218106",
            "id": 1855218106,
            "in_reply_to_id": 1855214424,
            "line": 348,
            "node_id": "PRRC_kwDOAPphoM5ulGG6",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 348,
            "original_position": 275,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 348,
            "pull_request_review_id": 2456428272,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855218106/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:06:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855218106",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855218877"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855218877"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Is [this](https://github.com/ofseed/neovim/blob/e2a24c75c34a0c3adb6caf318d7a289f0c27c874/runtime/lua/vim/lsp/folding_range.lua#L172-L189) not enough?\r\n\r\nDetaching the buffer should be unnecessary, because if this buffer has already been setup, then even if all clients detach at a certain moment (or any client has not yet attached), it is possible that it will be attached by new clients in the future.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:11:23Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855218877",
            "id": 1855218877,
            "in_reply_to_id": 1855215145,
            "line": 161,
            "node_id": "PRRC_kwDOAPphoM5ulGS9",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 161,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 161,
            "pull_request_review_id": 2456428954,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855218877/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:11:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855218877",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855219243"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855219243"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "It has already become part of the current specification. In [3.17](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#version_3_17_0). It's just that the server I commonly use does not support this feature.\r\n\r\nOf course, I wouldn't be particularly keen on exposing a feature that I wouldn't even use myself 😆.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:13:50Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855219243",
            "id": 1855219243,
            "in_reply_to_id": 1855209433,
            "line": 367,
            "node_id": "PRRC_kwDOAPphoM5ulGYr",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 367,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 367,
            "pull_request_review_id": 2456429314,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855219243/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:15:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855219243",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855220017"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855220017"
                }
            },
            "author_association": "MEMBER",
            "body": "Supporting multiple providers is valuable as it opens the door for plugins to implement custom folding via the LSP interface.\n\nSupporting multiple servers is something we've put a lot of effort into recently and want to support it for every method.\n\nLooking for intersections would be a problem, but this implementation just needs to make sure they are handled gracefully, and not necessarily correctly. I think the fold backend will already do something graceful so you may not need to do anything here, we just need to make sure the plumping is in place.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:17:40Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855220017",
            "id": 1855220017,
            "in_reply_to_id": 1855210172,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulGkx",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 62,
            "original_position": 62,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456429882,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855220017/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:17:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855220017",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855220757"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855220757"
                }
            },
            "author_association": "MEMBER",
            "body": "So you basically want to defer this code until all lines in a redraw have been calculated?",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:21:29Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855220757",
            "id": 1855220757,
            "in_reply_to_id": 1855214424,
            "line": 348,
            "node_id": "PRRC_kwDOAPphoM5ulGwV",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 348,
            "original_position": 275,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 348,
            "pull_request_review_id": 2456430386,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855220757/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:21:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855220757",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855221077"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855221077"
                }
            },
            "author_association": "MEMBER",
            "body": "If there are no clients, then the buf attach callbacks should not be invoked.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:23:07Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855221077",
            "id": 1855221077,
            "in_reply_to_id": 1855215145,
            "line": 161,
            "node_id": "PRRC_kwDOAPphoM5ulG1V",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 161,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 161,
            "pull_request_review_id": 2456430596,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855221077/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:23:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855221077",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855221730"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855221730"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "It is not for redrawing, but to wait for the `foldingRange` request to get a result.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:26:38Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855221730",
            "id": 1855221730,
            "in_reply_to_id": 1855214424,
            "line": 348,
            "node_id": "PRRC_kwDOAPphoM5ulG_i",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 348,
            "original_position": 275,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 348,
            "pull_request_review_id": 2456431050,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855221730/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:26:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855221730",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855222229"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855222229"
                }
            },
            "author_association": "MEMBER",
            "body": "The fact it doesn't provide highlighting already makes it behind other foldtexts, so I'd omit this for now.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:30:40Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855222229",
            "id": 1855222229,
            "in_reply_to_id": 1855209433,
            "line": 367,
            "node_id": "PRRC_kwDOAPphoM5ulHHV",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 367,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 367,
            "pull_request_review_id": 2456431574,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855222229/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:30:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855222229",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855222599"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855222599"
                }
            },
            "author_association": "MEMBER",
            "body": "Oh, because `LspRequest` is triggered on the handler. Ok can you just add some comments explaining this. I'd probably want to re-implement this in the future when some other things have been added.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:33:14Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855222599",
            "id": 1855222599,
            "in_reply_to_id": 1855214424,
            "line": 348,
            "node_id": "PRRC_kwDOAPphoM5ulHNH",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 348,
            "original_position": 275,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 348,
            "pull_request_review_id": 2456431854,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855222599/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:33:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855222599",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855223033"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223033"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "If you are referring to `on_bytes`, then it indeed will not be invoked, because when there are no clients, [here](https://github.com/ofseed/neovim/blob/e2a24c75c34a0c3adb6caf318d7a289f0c27c874/runtime/lua/vim/lsp/folding_range.lua#L172-L189) the row_levels will be cleared. This is intentional, because `row_level` being empty covers a wider range of possibilities.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:35:46Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855223033",
            "id": 1855223033,
            "in_reply_to_id": 1855215145,
            "line": 161,
            "node_id": "PRRC_kwDOAPphoM5ulHT5",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 161,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 161,
            "pull_request_review_id": 2456432152,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223033/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:35:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223033",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855223787"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223787"
                }
            },
            "author_association": "MEMBER",
            "body": "`collapsed_text` is often used for folding regions (delimited by `#region/#endregion`).\r\n\r\nExample from TypeScript:\r\n![image](https://github.com/user-attachments/assets/d4bf335f-2909-4ecc-99b3-1f9537cab3d4)\r\n\r\nI think that we can support it, I doubt that the spec will change a lot.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:40:41Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855223787",
            "id": 1855223787,
            "in_reply_to_id": 1855209433,
            "line": 367,
            "node_id": "PRRC_kwDOAPphoM5ulHfr",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 367,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 367,
            "pull_request_review_id": 2456432865,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223787/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:40:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223787",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855223897"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223897"
                }
            },
            "author_association": "MEMBER",
            "body": "Out of curiosity, is using `next` faster? Why do you personally prefer it? @lewis6991 ",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:41:24Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855223897",
            "id": 1855223897,
            "in_reply_to_id": 1855213282,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulHhZ",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 177,
            "original_position": 177,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456432949,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223897/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:41:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223897",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225320"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225320"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I can make some more attempts in this area, but I hope that will be in another PR. Currently (only supporting one server), it can handle most needs. Even implementing custom folding through the LSP interface often covers situations that LSP server does not support folding on a specific filetype. I anticipate that such functionality may bring a lot of complexity, and it would be better to make modifications when support for a single server is already mature, as this proves that providing LSP folding through `foldexpr` is feasible.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:48:13Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225320",
            "id": 1855225320,
            "in_reply_to_id": 1855210172,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulH3o",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 62,
            "original_position": 62,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456439811,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225320/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:48:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225320",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225509"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225509"
                }
            },
            "author_association": "MEMBER",
            "body": "Because it is standard Lua. No need to use a redundant wrapper.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:49:19Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225509",
            "id": 1855225509,
            "in_reply_to_id": 1855213282,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulH6l",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 177,
            "original_position": 177,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456439959,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225509/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:49:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225509",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225697"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225697"
                }
            },
            "author_association": "MEMBER",
            "body": "`on_bytes` will still be invoked until you detach from the buffer. ",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:50:47Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225697",
            "id": 1855225697,
            "in_reply_to_id": 1855215145,
            "line": 161,
            "node_id": "PRRC_kwDOAPphoM5ulH9h",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 161,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 161,
            "pull_request_review_id": 2456440129,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225697/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:50:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225697",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225804"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225804"
                }
            },
            "author_association": "MEMBER",
            "body": "(I just went by the \"(proposed)\" in the second comment. If it's already part of the spec, then that's different of course.)",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:51:49Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225804",
            "id": 1855225804,
            "in_reply_to_id": 1855209433,
            "line": 367,
            "node_id": "PRRC_kwDOAPphoM5ulH_M",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 367,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 367,
            "pull_request_review_id": 2456440237,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225804/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:51:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225804",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225999"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225999"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Looking back, I think `#client == 0` should be sufficient, and its meaning should be clearer.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:53:15Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225999",
            "id": 1855225999,
            "in_reply_to_id": 1855213282,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulICP",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 177,
            "original_position": 177,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456440434,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225999/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:53:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225999",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855226895"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855226895"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "This is also where I am confused, because it is also written as proposed in the LSP specification, and I am not sure if my understanding is incorrect as most LSP servers do not support it.\r\n![image](https://github.com/user-attachments/assets/e3cd97cc-64c1-4da0-95d6-92eba785157c)\r\n",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:57:08Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855226895",
            "id": 1855226895,
            "in_reply_to_id": 1855209433,
            "line": 367,
            "node_id": "PRRC_kwDOAPphoM5ulIQP",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 367,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 367,
            "pull_request_review_id": 2456440987,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855226895/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:57:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855226895",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855226970"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855226970"
                }
            },
            "author_association": "MEMBER",
            "body": "> (I just went by the \"(proposed)\" in the second comment. If it's already part of the spec, then that's different of course.)\r\n\r\nThat's fair! I just wanted to give an example of how it is used :)",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T16:57:49Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855226970",
            "id": 1855226970,
            "in_reply_to_id": 1855209433,
            "line": 367,
            "node_id": "PRRC_kwDOAPphoM5ulIRa",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 367,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 367,
            "pull_request_review_id": 2456441079,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855226970/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:57:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855226970",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855227850"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855227850"
                }
            },
            "author_association": "MEMBER",
            "body": "Then this PR at the very least needs to make sure that multiple clients are handled gracefully by not processing multiple responses and probably only make a request to a single server.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T17:02:33Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855227850",
            "id": 1855227850,
            "in_reply_to_id": 1855210172,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulIfK",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 62,
            "original_position": 62,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456441708,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855227850/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T17:02:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855227850",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855229326"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855229326"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Are you referring to directly removing the callback set by this buf attach? Then we would need to find a way to add it back, which would significantly increase complexity. I think it's sufficient to return after it finds the table is empty. Callbacks created by `buf_attach` will only be triggered on the buffer associated with a window whose `vim.wo.foldexpr = \"v:lua.vim.lsp.foldexpr\"`, so it makes sense in the vast majority of cases. I'm not quite sure what your suggested approach is.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T17:14:45Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855229326",
            "id": 1855229326,
            "in_reply_to_id": 1855215145,
            "line": 161,
            "node_id": "PRRC_kwDOAPphoM5ulI2O",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 161,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 161,
            "pull_request_review_id": 2456443260,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855229326/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T17:14:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855229326",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855234841"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855234841"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I tend to stick with the current approach. The simplicity lies in not having to consider the buffer. Ideally, if such an id exists, it should be stored in `bufstate`.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T17:44:36Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855234841",
            "id": 1855234841,
            "in_reply_to_id": 1855210582,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulKMZ",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 45,
            "original_position": 45,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456447992,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855234841/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T17:44:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855234841",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855244278"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855244278"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "After weighing the options, considering that this PR already includes some code for handling multiple clients, I plan to add preliminary support within this PR. This might be better than asking the user to choose which client to use when encountering multiple clients. However, this shouldn’t be the main goal, especially since I can’t find any use case in practical scenarios that would allow me to perform manual testing.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T18:19:43Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855244278",
            "id": 1855244278,
            "in_reply_to_id": 1855210172,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulMf2",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 62,
            "original_position": 62,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456457945,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855244278/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T18:19:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855244278",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855267731"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855267731"
                }
            },
            "author_association": "MEMBER",
            "body": "You reattach when you set up, so all you need to do is clear bufstates. You just need to return true in on_bytes to detach. It isn't that hard, it is just basic hygiene to clean up after all clients have detached.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-23T20:56:05Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855267731",
            "id": 1855267731,
            "in_reply_to_id": 1855215145,
            "line": 161,
            "node_id": "PRRC_kwDOAPphoM5ulSOT",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 161,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 161,
            "pull_request_review_id": 2456477847,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855267731/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T20:57:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855267731",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855343657"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855343657"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I think clearing bufstate is not an option. Because bufstate represents a buffer's window's `foldexpr` is `vim.lsp.foldexpr`, if it is cleared, next time `vim.lsp.foldexpr` is calculated, setup will be called again, and the callback will be created.\r\n\r\nThis is a design based on the callbacks and the bufstate has the same lifecycle. If the logic of the code is unclear, I can add more explanations later. However, it may be necessary to create an autocmd for `OptionSet` to clear bufstate and these callbacks when `foldexpr` is not `vim.lsp.foldexpr`.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T03:39:55Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855343657",
            "id": 1855343657,
            "in_reply_to_id": 1855215145,
            "line": 161,
            "node_id": "PRRC_kwDOAPphoM5ulkwp",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 161,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 161,
            "pull_request_review_id": 2456584711,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855343657/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T03:39:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855343657",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855350618"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855350618"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "According to my understanding, you mean that for a buffer with `foldexpr` set to `vim.lsp.foldexpr`, it can be attached by LSP before or after (it's a goal), but during the time it is not attached (even if `foldexpr` is still `vim.lsp.foldexpr`), all callback executions need to be stopped.\r\n\r\nThis can be done through `LspAttach` and `LspDetach`, but I don't think it brings any real benefits. Especially during this time period, these callbacks return almost immediately",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T04:07:52Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855350618",
            "id": 1855350618,
            "in_reply_to_id": 1855215145,
            "line": 161,
            "node_id": "PRRC_kwDOAPphoM5ulmda",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 161,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 161,
            "pull_request_review_id": 2456608767,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855350618/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T04:07:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855350618",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855420715"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420715"
                }
            },
            "author_association": "MEMBER",
            "body": "Can't you check for available clients here and return if there are none, this avoids setting up attaching to the buffer and setting up autocmds, and I think allows you to remove the OptionSet autocmd.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T10:52:06Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855420715",
            "id": 1855420715,
            "line": 149,
            "node_id": "PRRC_kwDOAPphoM5ul3kr",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 149,
            "original_position": 155,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 149,
            "pull_request_review_id": 2456681288,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420715/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T10:52:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420715",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855420832"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420832"
                }
            },
            "author_association": "MEMBER",
            "body": "I think you can remove the autocmds heres.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T10:52:38Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855420832",
            "id": 1855420832,
            "line": 196,
            "node_id": "PRRC_kwDOAPphoM5ul3mg",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 196,
            "original_position": 182,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 196,
            "pull_request_review_id": 2456681382,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420832/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T10:52:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420832",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855420962"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420962"
                }
            },
            "author_association": "MEMBER",
            "body": "I don't think you should be registering bufstate here.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T10:53:24Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855420962",
            "id": 1855420962,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul3oi",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 235,
            "original_position": 207,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456681519,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420962/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T10:53:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420962",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855421272"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855421272"
                }
            },
            "author_association": "MEMBER",
            "body": "This function is pretty hot and is only called internally by vim, so I think this `vim.validate` can be removed.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T10:55:18Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client)\n+  end\n+\n+  return bufstate\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+api.nvim_create_autocmd('OptionSet', {\n+  group = augroup_setup,\n+  pattern = 'foldexpr',\n+  callback = function()\n+    if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+      for bufnr in pairs(bufstates) do\n+        if\n+          ---@param winid integer\n+          vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+            return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+          end)\n+        then\n+          bufstates[bufnr] = nil\n+          api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+        end\n+      end\n+    end\n+  end,\n+})\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Schedule `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        callback = function(args)\n+          -- Do foldclose() if the `refresh()` request above is completed.\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()\n+  local lnum = vim.v.foldstart\n+  local row = lnum - 1\n+  local bufstate = bufstates[bufnr]\n+  if bufstate and bufstate.row_text[row] then\n+    return bufstate.row_text[row]\n+  end\n+  return vim.fn.getline(lnum)\n+end\n+\n+---@param lnum? integer\n+---@return string level\n+function M._foldexpr(lnum)\n+  vim.validate('lnum', lnum, 'number', true)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855421272",
            "id": 1855421272,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul3tY",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 355,
            "original_position": 355,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456681786,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855421272/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T10:55:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855421272",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855421589"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855421589"
                }
            },
            "author_association": "MEMBER",
            "body": "Is LuaLS not able to infer this?",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T10:57:24Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855421589",
            "id": 1855421589,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul3yV",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 85,
            "original_position": 85,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456682098,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855421589/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T10:57:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855421589",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855422221"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855422221"
                }
            },
            "author_association": "MEMBER",
            "body": "This won't work if #31280 gets merged.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T11:02:12Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client)\n+  end\n+\n+  return bufstate\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+api.nvim_create_autocmd('OptionSet', {\n+  group = augroup_setup,\n+  pattern = 'foldexpr',\n+  callback = function()\n+    if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+      for bufnr in pairs(bufstates) do\n+        if\n+          ---@param winid integer\n+          vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+            return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855422221",
            "id": 1855422221,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul38N",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 276,
            "original_position": 251,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456682866,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855422221/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T11:02:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855422221",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855429653"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855429653"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I remember it wasn't before, but I am about to change the data structure of `kind_ranges` (for multi-client support, and to ensure it collapses from the smallest place, this issue will not exist).",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T11:44:57Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855429653",
            "id": 1855429653,
            "in_reply_to_id": 1855421589,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul5wV",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 85,
            "original_position": 85,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456690626,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855429653/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T11:44:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855429653",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855430304"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855430304"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "This is not registering but resetting bufstate. The assignment `bufstates[bufnr] = bufstate` needs to be done because `bufstates[bufnr]` still points to the previously constructed `bufstate`, not the new one.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T11:48:36Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855430304",
            "id": 1855430304,
            "in_reply_to_id": 1855420962,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul56g",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 235,
            "original_position": 207,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456691262,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855430304/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T11:48:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855430304",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855431023"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855431023"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "If garbage collection is needed, `OptionSet` is necessary. Because the user may have changed `foldexpr` themselves, there is no way to know that the user has changed it other than using `OptionSet`. At the same time, LSP clients will not make any changes in this case.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T11:52:46Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855431023",
            "id": 1855431023,
            "in_reply_to_id": 1855420715,
            "line": 149,
            "node_id": "PRRC_kwDOAPphoM5ul6Fv",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 149,
            "original_position": 155,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 149,
            "pull_request_review_id": 2456692028,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855431023/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T11:52:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855431023",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855431289"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855431289"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I have already subscribed to this PR. If it is merged, this place will become more efficient because we can check if the expr functions are equal instead of checking strings.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T11:54:20Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client)\n+  end\n+\n+  return bufstate\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+api.nvim_create_autocmd('OptionSet', {\n+  group = augroup_setup,\n+  pattern = 'foldexpr',\n+  callback = function()\n+    if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+      for bufnr in pairs(bufstates) do\n+        if\n+          ---@param winid integer\n+          vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+            return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855431289",
            "id": 1855431289,
            "in_reply_to_id": 1855422221,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul6J5",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 276,
            "original_position": 251,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456692311,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855431289/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T11:54:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855431289",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855432393"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855432393"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "As I noted in the code above, the lifecycle of bufstate and these callbacks should be synchronized. So if we do not need to destroy bufstate here, then we also do not need to destroy the callback. However, callbacks of `nvim_buf_attach` can only be destroyed if it returns true, which is the reason for adding the branch here.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T12:00:22Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855432393",
            "id": 1855432393,
            "in_reply_to_id": 1855420832,
            "line": 196,
            "node_id": "PRRC_kwDOAPphoM5ul6bJ",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 196,
            "original_position": 182,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 196,
            "pull_request_review_id": 2456693471,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855432393/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T12:00:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855432393",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855471219"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855471219"
                }
            },
            "author_association": "MEMBER",
            "body": "The point is that there is no reliable way of checking this, nor do I think it is necessary.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T15:06:46Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client)\n+  end\n+\n+  return bufstate\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+api.nvim_create_autocmd('OptionSet', {\n+  group = augroup_setup,\n+  pattern = 'foldexpr',\n+  callback = function()\n+    if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+      for bufnr in pairs(bufstates) do\n+        if\n+          ---@param winid integer\n+          vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+            return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855471219",
            "id": 1855471219,
            "in_reply_to_id": 1855422221,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5umD5z",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 276,
            "original_position": 251,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456733556,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855471219/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T15:06:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855471219",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855476582"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855476582"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "It is indeed unnecessary, so I didn't add it at first, but considering your suggestion for more granular garbage collection, I included it because it makes sense in many cases. I'm fine to delete this.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T15:32:43Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client)\n+  end\n+\n+  return bufstate\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+api.nvim_create_autocmd('OptionSet', {\n+  group = augroup_setup,\n+  pattern = 'foldexpr',\n+  callback = function()\n+    if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+      for bufnr in pairs(bufstates) do\n+        if\n+          ---@param winid integer\n+          vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+            return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855476582",
            "id": 1855476582,
            "in_reply_to_id": 1855422221,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5umFNm",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 276,
            "original_position": 251,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456738559,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855476582/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T15:32:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855476582",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855489323"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855489323"
                }
            },
            "author_association": "MEMBER",
            "body": "Fine, revert everything back to the stage you are happy with and then someone else can review and merge this. If this gets merged I'll take a look at resolving the memory leaks in a follow up.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T16:39:54Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client)\n+  end\n+\n+  return bufstate\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+api.nvim_create_autocmd('OptionSet', {\n+  group = augroup_setup,\n+  pattern = 'foldexpr',\n+  callback = function()\n+    if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+      for bufnr in pairs(bufstates) do\n+        if\n+          ---@param winid integer\n+          vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+            return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855489323",
            "id": 1855489323,
            "in_reply_to_id": 1855422221,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5umIUr",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 276,
            "original_position": 251,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456750830,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855489323/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T16:39:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855489323",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855492014"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855492014"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Perhaps I'm overthinking it, and I hope that's the case. Later, I will add some test cases that I'm concerned about so that the code can be changed more safely.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-24T16:54:00Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client)\n+  end\n+\n+  return bufstate\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+api.nvim_create_autocmd('OptionSet', {\n+  group = augroup_setup,\n+  pattern = 'foldexpr',\n+  callback = function()\n+    if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+      for bufnr in pairs(bufstates) do\n+        if\n+          ---@param winid integer\n+          vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+            return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855492014",
            "id": 1855492014,
            "in_reply_to_id": 1855422221,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5umI-u",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 276,
            "original_position": 251,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456753321,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855492014/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T16:54:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855492014",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855858261"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855858261"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I have changed it to a method very similar to your suggestion, and now I will mark this thread as resolved.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-25T05:54:20Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855858261",
            "id": 1855858261,
            "in_reply_to_id": 1855210582,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5uniZV",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 45,
            "original_position": 45,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2457243877,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855858261/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-25T05:54:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855858261",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1856859913"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1856859913"
                }
            },
            "author_association": "MEMBER",
            "body": "Would this be better written as?\r\n\r\n```suggestion\r\n      bufstates[bufnr] = {\r\n        row_level = {},\r\n        row_kinds = {},\r\n        row_text = {},\r\n      }\r\n```\r\n\r\nAnd actually I think all these callbacks should refer directly to `bufstates[bufnr]` instead of `bufstate` to avoid any accidental aliasing.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-25T15:54:03Z",
            "diff_hunk": "@@ -0,0 +1,396 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Add `ranges` into the given `bufstate`.\n+---@param bufstate vim.lsp.folding_range.BufState\n+---@param ranges lsp.FoldingRange[]\n+local function rangeadd(bufstate, ranges)\n+  local row_level = bufstate.row_level\n+  local row_kinds = bufstate.row_kinds\n+  local row_text = bufstate.row_text\n+\n+  for _, range in ipairs(ranges) do\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Adding folds within a single line is not supported by Nvim.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+\n+      local kind = range.kind\n+      if kind then\n+        local kinds = row_kinds[start_row] or {}\n+        kinds[kind] = true\n+        row_kinds[start_row] = kinds\n+      end\n+\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+end\n+\n+--- Force `foldexpr()` to be re-evaluated, without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled[bufnr] then\n+    scheduled[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.row_level = {}\n+  bufstate.row_kinds = {}\n+  bufstate.row_text = {}\n+\n+  rangeadd(bufstate, result)\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- the strategy here is to ensure that their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Nothing more than setup `bufstate` and its event hooks then request folding ranges.\n+--- their lifecycle management should be done in this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = {\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  -- NOTE: If the table pointed to by `bufstate` or `bufstates[bufnr]` changes\n+  -- (for example, if either is reassigned), make sure they remain in sync,\n+  -- as they are free variables defined by the event hooks here.\n+  bufstates[bufnr] = bufstate\n+\n+  -- There is no way to remove event hooks created by `buf_attach` from the outside,\n+  -- but our strategy is based on keeping `bufstate` and event hooks in the same lifecycle,\n+  -- so each of them should check if `bufstate == nil` and then destroy themselves.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- Note that `on_detach` will also be triggered when `:e` is executed to reload,\n+    -- make sure `bufstate` and event hooks are cleaned up\n+    -- so that they don't exist on a unloaded buffer\n+    -- or be recreated when the buffer is reloaded.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstate = nil\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+      return true\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      if bufstate == nil then\n+        return true\n+      end\n+      bufstate = {\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      bufstates[bufnr] = bufstate",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1856859913",
            "id": 1856859913,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5urW8J",
            "original_commit_id": "3b01523c030cca19bea29a473d37352e45bff207",
            "original_line": 188,
            "original_position": 188,
            "original_start_line": 183,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2458847085,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1856859913/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-11-25T16:04:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1856859913",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1857536489"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1857536489"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Oh right, there’s no reason to use `bufstate` in `setup` instead of `bufstates[bufnr]`.",
            "commit_id": "ec2f70266129fa843a7228809ea2a5be50cd2335",
            "created_at": "2024-11-26T01:12:32Z",
            "diff_hunk": "@@ -0,0 +1,396 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Add `ranges` into the given `bufstate`.\n+---@param bufstate vim.lsp.folding_range.BufState\n+---@param ranges lsp.FoldingRange[]\n+local function rangeadd(bufstate, ranges)\n+  local row_level = bufstate.row_level\n+  local row_kinds = bufstate.row_kinds\n+  local row_text = bufstate.row_text\n+\n+  for _, range in ipairs(ranges) do\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Adding folds within a single line is not supported by Nvim.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+\n+      local kind = range.kind\n+      if kind then\n+        local kinds = row_kinds[start_row] or {}\n+        kinds[kind] = true\n+        row_kinds[start_row] = kinds\n+      end\n+\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+end\n+\n+--- Force `foldexpr()` to be re-evaluated, without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled[bufnr] then\n+    scheduled[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.row_level = {}\n+  bufstate.row_kinds = {}\n+  bufstate.row_text = {}\n+\n+  rangeadd(bufstate, result)\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- the strategy here is to ensure that their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Nothing more than setup `bufstate` and its event hooks then request folding ranges.\n+--- their lifecycle management should be done in this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = {\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  -- NOTE: If the table pointed to by `bufstate` or `bufstates[bufnr]` changes\n+  -- (for example, if either is reassigned), make sure they remain in sync,\n+  -- as they are free variables defined by the event hooks here.\n+  bufstates[bufnr] = bufstate\n+\n+  -- There is no way to remove event hooks created by `buf_attach` from the outside,\n+  -- but our strategy is based on keeping `bufstate` and event hooks in the same lifecycle,\n+  -- so each of them should check if `bufstate == nil` and then destroy themselves.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- Note that `on_detach` will also be triggered when `:e` is executed to reload,\n+    -- make sure `bufstate` and event hooks are cleaned up\n+    -- so that they don't exist on a unloaded buffer\n+    -- or be recreated when the buffer is reloaded.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstate = nil\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+      return true\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      if bufstate == nil then\n+        return true\n+      end\n+      bufstate = {\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      bufstates[bufnr] = bufstate",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1857536489",
            "id": 1857536489,
            "in_reply_to_id": 1856859913,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ut8Hp",
            "original_commit_id": "3b01523c030cca19bea29a473d37352e45bff207",
            "original_line": 188,
            "original_position": 188,
            "original_start_line": 183,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2459925459,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1857536489/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-11-26T01:12:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1857536489",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "Could we add some tests? 😸 ",
            "created_at": "2024-11-23T03:48:10Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2495280398",
            "id": 2495280398,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6UuvUO",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495280398/reactions"
            },
            "updated_at": "2024-11-23T03:48:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495280398",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I have added tests for all the new APIs in this PR. This PR is now ready to be merged (or reviewed, of course).",
            "created_at": "2024-11-23T10:04:57Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2495424681",
            "id": 2495424681,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6UvSip",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495424681/reactions"
            },
            "updated_at": "2024-11-23T10:04:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495424681",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "For the somewhat controversial bufstate and callback cleanup mentioned above, I pushed an update to try to control them more granularly, and I detailed the expected behavior in the comments.",
            "created_at": "2024-11-24T10:16:11Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2495920511",
            "id": 2495920511,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6UxLl_",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495920511/reactions"
            },
            "updated_at": "2024-11-24T10:16:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495920511",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I pushed a new update that, in addition to changing the code marked as `resolved` above, includes an additional change that adjusts the data structure required for `foldclose` to make it ready to support multiple clients while also ensuring that the smallest range is prioritized for closing. Prioritizing the closing of the smallest range makes sense because after closing a larger range, vim will not close the smaller ranges within it. This broadens the applicability of `foldclose`.\r\n\r\nThis change can easily allow `foldclose()` to gain support for range parameters, but I haven't seen a clear use for this functionality, so I haven't exposed it. If you need it, please let me know.",
            "created_at": "2024-11-24T12:06:21Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2495966555",
            "id": 2495966555,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6UxW1b",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495966555/reactions"
            },
            "updated_at": "2024-11-24T12:18:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495966555",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "The reason for having the same lifecycle for bufstate and its related callbacks is that they are interdependent. If their lifecycles are not the same, then any error on one side will lead to issues on the other side. If the code on one side is changed, it may cause errors in the code on the other side. In reality, this would result in an indirect recursion of continuously reporting errors; we might just happen to be at a certain moment, but new errors will arise in the future. I believe we should consider their lifecycle management based on ensuring that their lifecycles are the same, as finding a way that perfectly covers all situations is very risky.",
            "created_at": "2024-11-24T12:28:26Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2495974326",
            "id": 2495974326,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6UxYu2",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495974326/reactions"
            },
            "updated_at": "2024-11-24T17:13:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495974326",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "@lewis6991 Thank you so much for your patient review. I apologize if I’ve wasted your time. I’ve revisited the management of these lifecycles and added tests to cover them, ensuring that callbacks are destroyed when the buffer is unloaded and avoiding duplicate creation on the same buffer. I’d appreciate any suggestions if you have the time to review it again.\r\n\r\nI am currently working on implementing support for multiple clients. ",
            "created_at": "2024-11-25T15:22:27Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2498315835",
            "id": 2498315835,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6U6UY7",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 1,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2498315835/reactions"
            },
            "updated_at": "2024-11-25T15:22:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2498315835",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "It works in most cases, but there are still some edge cases. The main issue is that we cannot guarantee that `foldexpr()` will be executed after a new LSP attach. For example, when a newly started nvim opens its first buffer, `foldexpr()` will be executed immediately, but it has not been LSP attached yet, so bufstate will not be. After a very short time, the LSP attach completes, but at this point, `foldexpr()` is unlikely to be executed again, the folds in the buffer keep outdated unless modifying the buffer or using something like `zx` after that. This issue can be resolved with an additional `LspAttach` autocmd, but I'm not sure if there are other edge cases because if a new autocmd is created, we also need to consider how to destroy it.",
            "created_at": "2024-11-26T02:16:01Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2499497904",
            "id": 2499497904,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6U-0-w",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2499497904/reactions"
            },
            "updated_at": "2024-11-26T02:16:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2499497904",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/31311/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/31311/commits",
    "created_at": "2024-11-22T13:23:46Z",
    "diff_url": "https://github.com/neovim/neovim/pull/31311.diff",
    "draft": false,
    "head": {
        "label": "ofseed:lsp-fold",
        "ref": "lsp-fold",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/ofseed/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/ofseed/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/ofseed/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/ofseed/neovim/branches{/branch}",
            "clone_url": "https://github.com/ofseed/neovim.git",
            "collaborators_url": "https://api.github.com/repos/ofseed/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/ofseed/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/ofseed/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/ofseed/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/ofseed/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/ofseed/neovim/contributors",
            "created_at": "2021-11-30T18:13:03Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/ofseed/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/ofseed/neovim/downloads",
            "events_url": "https://api.github.com/repos/ofseed/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/ofseed/neovim/forks",
            "full_name": "ofseed/neovim",
            "git_commits_url": "https://api.github.com/repos/ofseed/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/ofseed/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/ofseed/neovim/git/tags{/sha}",
            "git_url": "git://github.com/ofseed/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/ofseed/neovim/hooks",
            "html_url": "https://github.com/ofseed/neovim",
            "id": 433537354,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/ofseed/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/ofseed/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/ofseed/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/ofseed/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/ofseed/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/ofseed/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/ofseed/neovim/merges",
            "milestones_url": "https://api.github.com/repos/ofseed/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOGddBSg",
            "notifications_url": "https://api.github.com/repos/ofseed/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/ofseed/neovim/pulls{/number}",
            "pushed_at": "2024-11-26T02:14:55Z",
            "releases_url": "https://api.github.com/repos/ofseed/neovim/releases{/id}",
            "size": 289465,
            "ssh_url": "git@github.com:ofseed/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/ofseed/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/ofseed/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/ofseed/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/ofseed/neovim/subscription",
            "svn_url": "https://github.com/ofseed/neovim",
            "tags_url": "https://api.github.com/repos/ofseed/neovim/tags",
            "teams_url": "https://api.github.com/repos/ofseed/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/ofseed/neovim/git/trees{/sha}",
            "updated_at": "2024-11-22T04:12:21Z",
            "url": "https://api.github.com/repos/ofseed/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "ec2f70266129fa843a7228809ea2a5be50cd2335",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
            "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
            "followers_url": "https://api.github.com/users/ofseed/followers",
            "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
            "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/ofseed",
            "id": 61115159,
            "login": "ofseed",
            "node_id": "MDQ6VXNlcjYxMTE1MTU5",
            "organizations_url": "https://api.github.com/users/ofseed/orgs",
            "received_events_url": "https://api.github.com/users/ofseed/received_events",
            "repos_url": "https://api.github.com/users/ofseed/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/ofseed",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/31311",
    "id": 2194715647,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": null,
            "id": 662566370,
            "name": "lsp",
            "node_id": "MDU6TGFiZWw2NjI1NjYzNzA=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lsp"
        }
    ],
    "locked": false,
    "merge_commit_sha": "5dea3d836adfe6dbc5f8b9902e2af050557002cb",
    "merged_at": null,
    "milestone": null,
    "node_id": "PR_kwDOAPphoM6C0LP_",
    "number": 31311,
    "patch_url": "https://github.com/neovim/neovim/pull/31311.patch",
    "requested_reviewers": [
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/1363104?v=4",
            "events_url": "https://api.github.com/users/bfredl/events{/privacy}",
            "followers_url": "https://api.github.com/users/bfredl/followers",
            "following_url": "https://api.github.com/users/bfredl/following{/other_user}",
            "gists_url": "https://api.github.com/users/bfredl/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/bfredl",
            "id": 1363104,
            "login": "bfredl",
            "node_id": "MDQ6VXNlcjEzNjMxMDQ=",
            "organizations_url": "https://api.github.com/users/bfredl/orgs",
            "received_events_url": "https://api.github.com/users/bfredl/received_events",
            "repos_url": "https://api.github.com/users/bfredl/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/bfredl/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bfredl/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/bfredl",
            "user_view_type": "public"
        },
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
            "events_url": "https://api.github.com/users/clason/events{/privacy}",
            "followers_url": "https://api.github.com/users/clason/followers",
            "following_url": "https://api.github.com/users/clason/following{/other_user}",
            "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/clason",
            "id": 2361214,
            "login": "clason",
            "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
            "organizations_url": "https://api.github.com/users/clason/orgs",
            "received_events_url": "https://api.github.com/users/clason/received_events",
            "repos_url": "https://api.github.com/users/clason/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/clason",
            "user_view_type": "public"
        },
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
            "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
            "followers_url": "https://api.github.com/users/mfussenegger/followers",
            "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
            "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/mfussenegger",
            "id": 38700,
            "login": "mfussenegger",
            "node_id": "MDQ6VXNlcjM4NzAw",
            "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
            "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
            "repos_url": "https://api.github.com/users/mfussenegger/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/mfussenegger",
            "user_view_type": "public"
        },
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
            "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
            "followers_url": "https://api.github.com/users/wookayin/followers",
            "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
            "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/wookayin",
            "id": 1009873,
            "login": "wookayin",
            "node_id": "MDQ6VXNlcjEwMDk4NzM=",
            "organizations_url": "https://api.github.com/users/wookayin/orgs",
            "received_events_url": "https://api.github.com/users/wookayin/received_events",
            "repos_url": "https://api.github.com/users/wookayin/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/wookayin",
            "user_view_type": "public"
        },
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
            "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
            "followers_url": "https://api.github.com/users/MariaSolOs/followers",
            "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
            "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/MariaSolOs",
            "id": 62502207,
            "login": "MariaSolOs",
            "node_id": "MDQ6VXNlcjYyNTAyMjA3",
            "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
            "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
            "repos_url": "https://api.github.com/users/MariaSolOs/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/MariaSolOs",
            "user_view_type": "public"
        }
    ],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/31311/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/ec2f70266129fa843a7228809ea2a5be50cd2335",
    "title": "feat(lsp): support `textDocument/foldingRange`",
    "updated_at": "2024-11-26T02:16:02Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
        "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
        "followers_url": "https://api.github.com/users/ofseed/followers",
        "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
        "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/ofseed",
        "id": 61115159,
        "login": "ofseed",
        "node_id": "MDQ6VXNlcjYxMTE1MTU5",
        "organizations_url": "https://api.github.com/users/ofseed/orgs",
        "received_events_url": "https://api.github.com/users/ofseed/received_events",
        "repos_url": "https://api.github.com/users/ofseed/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/ofseed",
        "user_view_type": "public"
    }
}