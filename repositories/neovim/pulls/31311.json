{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/31311/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/31311/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/31311"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/31311"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/31311/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/9c7db37d316703e4fee0e6c0619c055f76614a3a"
        }
    },
    "active_lock_reason": "resolved",
    "assignee": null,
    "assignees": [],
    "author_association": "CONTRIBUTOR",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 5726,
            "forks_count": 5726,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1842,
            "open_issues_count": 1842,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2024-12-03T00:32:23Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 296843,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 83804,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2024-12-03T02:31:16Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 83804,
            "watchers_count": 83804,
            "web_commit_signoff_required": false
        },
        "sha": "c867a4f5e335a1e62e699c01056f9553c0ce151a",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "Closes https://github.com/neovim/neovim/issues/12836.\r\n\r\nImplemented the [`textDocument/foldingRange`](https://microsoft.github.io/language-server-protocol/specification/#textDocument_foldingRange) of LSP.\r\n\r\n* Provides `vim.lsp.foldexpr()` which can be used to enable LSP folding.\r\n* Provides `vim.lsp.foldtext()` which can be used to display the `collapsedText` returned by LSP servers.\r\n* Provides `vim.lsp.foldclose(kind, winid)`, which can be used to fold a certain kind, and it can be used to fold imports automatically.",
    "closed_at": "2024-11-29T12:40:32Z",
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1853921125"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853921125"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\r\n    Efficiently remove items from middle of a list.\r\n```",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-22T13:32:36Z",
            "diff_hunk": "@@ -2138,6 +2138,37 @@ vim.list_extend({dst}, {src}, {start}, {finish})           *vim.list_extend()*\n     See also: ~\n       • |vim.tbl_extend()|\n \n+vim.list_insert({t}, {first}, {last}, {v})                 *vim.list_insert()*\n+    Efficiently insert items into the middle of a list.\n+\n+    Calling table.insert() in a loop will re-index the tail of the table on\n+    every iteration, instead this function will re-index the table exactly\n+    once.\n+\n+    Based on\n+    https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+\n+    Parameters: ~\n+      • {t}      (`any[]`)\n+      • {first}  (`integer`)\n+      • {last}   (`integer`)\n+      • {v}      (`any`)\n+\n+vim.list_remove({t}, {first}, {last})                      *vim.list_remove()*\n+    Efficiently remove items from middle of a list a list.",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1853921125",
            "id": 1853921125,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ugJdl",
            "original_commit_id": "d0b3fdadecf5088e77c043239fad3c1357c11151",
            "original_line": 2158,
            "original_position": 21,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 2454463370,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853921125/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T13:32:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853921125",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/329822?v=4",
                "events_url": "https://api.github.com/users/Julian/events{/privacy}",
                "followers_url": "https://api.github.com/users/Julian/followers",
                "following_url": "https://api.github.com/users/Julian/following{/other_user}",
                "gists_url": "https://api.github.com/users/Julian/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Julian",
                "id": 329822,
                "login": "Julian",
                "node_id": "MDQ6VXNlcjMyOTgyMg==",
                "organizations_url": "https://api.github.com/users/Julian/orgs",
                "received_events_url": "https://api.github.com/users/Julian/received_events",
                "repos_url": "https://api.github.com/users/Julian/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Julian/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Julian/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Julian",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1853921653"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853921653"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\r\n  insert/remove items from middle of a list.\r\n```",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-22T13:32:57Z",
            "diff_hunk": "@@ -230,6 +232,8 @@ LUA\n   is more performant and easier to read.\n • |vim.str_byteindex()| and |vim.str_utfindex()| gained overload signatures\n   supporting two new parameters, `encoding` and `strict_indexing`.\n+• |vim.list_insert()| and |vim.list_remove()| were added to efficiently\n+  insert/remove items from middle of a list a list.",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1853921653",
            "id": 1853921653,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ugJl1",
            "original_commit_id": "d0b3fdadecf5088e77c043239fad3c1357c11151",
            "original_line": 236,
            "original_position": 14,
            "original_start_line": null,
            "path": "runtime/doc/news.txt",
            "position": null,
            "pull_request_review_id": 2454464679,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853921653/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T13:32:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853921653",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/329822?v=4",
                "events_url": "https://api.github.com/users/Julian/events{/privacy}",
                "followers_url": "https://api.github.com/users/Julian/followers",
                "following_url": "https://api.github.com/users/Julian/following{/other_user}",
                "gists_url": "https://api.github.com/users/Julian/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Julian",
                "id": 329822,
                "login": "Julian",
                "node_id": "MDQ6VXNlcjMyOTgyMg==",
                "organizations_url": "https://api.github.com/users/Julian/orgs",
                "received_events_url": "https://api.github.com/users/Julian/received_events",
                "repos_url": "https://api.github.com/users/Julian/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Julian/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Julian/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Julian",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1853922956"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853922956"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "```suggestion\r\n• Implemented LSP folding ranges: |vim.lsp.foldexpr()|\r\n```",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-22T13:33:33Z",
            "diff_hunk": "@@ -222,6 +222,8 @@ LSP\n • |vim.lsp.buf.hover()| now highlights hover ranges using the\n   |hl-LspReferenceTarget| highlight group.\n • Functions in |vim.lsp.Client| can now be called as methods.\n+• Implemented LSP inlay hints: |vim.lsp.foldexpr()|",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1853922956",
            "id": 1853922956,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ugJ6M",
            "original_commit_id": "d0b3fdadecf5088e77c043239fad3c1357c11151",
            "original_line": 225,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/doc/news.txt",
            "position": null,
            "pull_request_review_id": 2454465862,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853922956/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T13:33:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853922956",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/329822?v=4",
                "events_url": "https://api.github.com/users/Julian/events{/privacy}",
                "followers_url": "https://api.github.com/users/Julian/followers",
                "following_url": "https://api.github.com/users/Julian/following{/other_user}",
                "gists_url": "https://api.github.com/users/Julian/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/Julian",
                "id": 329822,
                "login": "Julian",
                "node_id": "MDQ6VXNlcjMyOTgyMg==",
                "organizations_url": "https://api.github.com/users/Julian/orgs",
                "received_events_url": "https://api.github.com/users/Julian/received_events",
                "repos_url": "https://api.github.com/users/Julian/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/Julian/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/Julian/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/Julian",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1853965396"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853965396"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Thanks.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-22T14:03:53Z",
            "diff_hunk": "@@ -222,6 +222,8 @@ LSP\n • |vim.lsp.buf.hover()| now highlights hover ranges using the\n   |hl-LspReferenceTarget| highlight group.\n • Functions in |vim.lsp.Client| can now be called as methods.\n+• Implemented LSP inlay hints: |vim.lsp.foldexpr()|",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1853965396",
            "id": 1853965396,
            "in_reply_to_id": 1853922956,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ugURU",
            "original_commit_id": "d0b3fdadecf5088e77c043239fad3c1357c11151",
            "original_line": 225,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/doc/news.txt",
            "position": null,
            "pull_request_review_id": 2454536052,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853965396/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T14:03:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1853965396",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1854573205"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854573205"
                }
            },
            "author_association": "MEMBER",
            "body": "Can you not expose this by prefixing it with an `_`.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-22T19:52:21Z",
            "diff_hunk": "@@ -737,6 +737,51 @@ function vim.list_slice(list, start, finish)\n   return new_list\n end\n \n+--- Efficiently insert items into the middle of a list.\n+---\n+--- Calling table.insert() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+---@param v any\n+function vim.list_insert(t, first, last, v)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1854573205",
            "id": 1854573205,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5uioqV",
            "original_commit_id": "7edd6718f050815fe399ed630cd7c69ab8cd9835",
            "original_line": 752,
            "original_position": 16,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2455516400,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854573205/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T19:53:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854573205",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1854573606"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854573606"
                }
            },
            "author_association": "MEMBER",
            "body": "Same here.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-22T19:52:47Z",
            "diff_hunk": "@@ -737,6 +737,51 @@ function vim.list_slice(list, start, finish)\n   return new_list\n end\n \n+--- Efficiently insert items into the middle of a list.\n+---\n+--- Calling table.insert() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+---@param v any\n+function vim.list_insert(t, first, last, v)\n+  local n = #t\n+\n+  -- Shift table forward\n+  for i = n - first, 0, -1 do\n+    t[last + 1 + i] = t[first + i]\n+  end\n+\n+  -- Fill in new values\n+  for i = first, last do\n+    t[i] = v\n+  end\n+end\n+\n+--- Efficiently remove items from middle of a list.\n+---\n+--- Calling table.remove() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+function vim.list_remove(t, first, last)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1854573606",
            "id": 1854573606,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5uiowm",
            "original_commit_id": "7edd6718f050815fe399ed630cd7c69ab8cd9835",
            "original_line": 777,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2455516400,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854573606/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T19:53:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854573606",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1854601238"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854601238"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Do you mean to consider it as an internal API? Then I will also remove it from the commit messages.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-22T20:16:41Z",
            "diff_hunk": "@@ -737,6 +737,51 @@ function vim.list_slice(list, start, finish)\n   return new_list\n end\n \n+--- Efficiently insert items into the middle of a list.\n+---\n+--- Calling table.insert() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+---@param v any\n+function vim.list_insert(t, first, last, v)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1854601238",
            "id": 1854601238,
            "in_reply_to_id": 1854573205,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5uivgW",
            "original_commit_id": "7edd6718f050815fe399ed630cd7c69ab8cd9835",
            "original_line": 752,
            "original_position": 16,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2455559068,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854601238/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T20:16:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854601238",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1854762776"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854762776"
                }
            },
            "author_association": "MEMBER",
            "body": "Yes please.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-22T21:47:41Z",
            "diff_hunk": "@@ -737,6 +737,51 @@ function vim.list_slice(list, start, finish)\n   return new_list\n end\n \n+--- Efficiently insert items into the middle of a list.\n+---\n+--- Calling table.insert() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+---@param v any\n+function vim.list_insert(t, first, last, v)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1854762776",
            "id": 1854762776,
            "in_reply_to_id": 1854573205,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ujW8Y",
            "original_commit_id": "7edd6718f050815fe399ed630cd7c69ab8cd9835",
            "original_line": 752,
            "original_position": 16,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": null,
            "pull_request_review_id": 2455793000,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854762776/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-22T21:47:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1854762776",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855056877"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855056877"
                }
            },
            "author_association": "MEMBER",
            "body": "Nit, but let's put this above `textDocument/formatting` to keep the alphabetical order.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T03:35:53Z",
            "diff_hunk": "@@ -205,6 +205,7 @@ won't run if your server doesn't support them.\n - `'textDocument/documentHighlight'`\n - `'textDocument/documentSymbol'`\n - `'textDocument/formatting'`\n+- `'textDocument/foldingRange'`",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855056877",
            "id": 1855056877,
            "line": 207,
            "node_id": "PRRC_kwDOAPphoM5ukevt",
            "original_commit_id": "1f90bbe7ffd3e76f0976d349143b657911aa2479",
            "original_line": 207,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": 4,
            "pull_request_review_id": 2456244920,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855056877/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T03:48:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855056877",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855056904"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855056904"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    Provides a `foldtext` function that shows the `collapsedText` retrieved,\r\n```",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T03:36:20Z",
            "diff_hunk": "@@ -697,6 +698,17 @@ commands                                                    *vim.lsp.commands*\n \n     The second argument is the `ctx` of |lsp-handler|\n \n+foldexpr({lnum})                                          *vim.lsp.foldexpr()*\n+    Provides an interface between the built-in client and a `foldexpr`\n+    function.\n+\n+    Parameters: ~\n+      • {lnum}  (`integer`) line number\n+\n+foldtext()                                                *vim.lsp.foldtext()*\n+    Provides a `foldtext` function that shows `collapsedText` retrieved,",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855056904",
            "id": 1855056904,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ukewI",
            "original_commit_id": "1f90bbe7ffd3e76f0976d349143b657911aa2479",
            "original_line": 709,
            "original_position": 20,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2456244920,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855056904/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T03:48:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855056904",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855057011"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855057011"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    defaults to the first folded line if `collapsedText` is not provided.\r\n```",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T03:37:12Z",
            "diff_hunk": "@@ -697,6 +698,17 @@ commands                                                    *vim.lsp.commands*\n \n     The second argument is the `ctx` of |lsp-handler|\n \n+foldexpr({lnum})                                          *vim.lsp.foldexpr()*\n+    Provides an interface between the built-in client and a `foldexpr`\n+    function.\n+\n+    Parameters: ~\n+      • {lnum}  (`integer`) line number\n+\n+foldtext()                                                *vim.lsp.foldtext()*\n+    Provides a `foldtext` function that shows `collapsedText` retrieved,\n+    default to the first folded line if `collapsedText` is not available.",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855057011",
            "id": 1855057011,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ukexz",
            "original_commit_id": "1f90bbe7ffd3e76f0976d349143b657911aa2479",
            "original_line": 710,
            "original_position": 21,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2456244920,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855057011/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T03:48:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855057011",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855057477"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855057477"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    To automatically fold imports when opening a file, you can use an autocommand: >lua\r\n```",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T03:37:55Z",
            "diff_hunk": "@@ -1644,6 +1656,27 @@ trigger()                                       *vim.lsp.completion.trigger()*\n     Trigger LSP completion in the current buffer.\n \n \n+==============================================================================\n+Lua module: vim.lsp.folding_range                          *lsp-folding_range*\n+\n+foldclose({kind}, {winid})                 *vim.lsp.folding_range.foldclose()*\n+    Close all {kind} of folds in the the window with {winid}.\n+\n+    To automatically fold imports, use an autocmd: >lua",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855057477",
            "id": 1855057477,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5uke5F",
            "original_commit_id": "1f90bbe7ffd3e76f0976d349143b657911aa2479",
            "original_line": 1665,
            "original_position": 36,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2456244920,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855057477/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T03:48:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855057477",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855060413"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855060413"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        client:supports_method(ms.textDocument_foldingRange)\r\n```",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T03:45:57Z",
            "diff_hunk": "@@ -0,0 +1,297 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRangeProvider`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client.server_capabilities.foldingRangeProvider",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855060413",
            "id": 1855060413,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ukfm9",
            "original_commit_id": "1f90bbe7ffd3e76f0976d349143b657911aa2479",
            "original_line": 142,
            "original_position": 142,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456244920,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855060413/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T03:48:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855060413",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855060525"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855060525"
                }
            },
            "author_association": "MEMBER",
            "body": "See previous suggestion about using `supports_method`",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T03:46:39Z",
            "diff_hunk": "@@ -0,0 +1,297 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRangeProvider`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client.server_capabilities.foldingRangeProvider\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        if client.server_capabilities.foldingRangeProvider then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855060525",
            "id": 1855060525,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ukfot",
            "original_commit_id": "1f90bbe7ffd3e76f0976d349143b657911aa2479",
            "original_line": 167,
            "original_position": 167,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456244920,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855060525/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T03:48:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855060525",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855063066"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855063066"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Oh, I know the reason now, `foldingRange` was not added to the supported methods of `client:supports_method` 😆. These checks should not be necessary because there is `get_clients()`",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T03:56:53Z",
            "diff_hunk": "@@ -0,0 +1,297 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRangeProvider`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client.server_capabilities.foldingRangeProvider\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        if client.server_capabilities.foldingRangeProvider then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855063066",
            "id": 1855063066,
            "in_reply_to_id": 1855060525,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ukgQa",
            "original_commit_id": "1f90bbe7ffd3e76f0976d349143b657911aa2479",
            "original_line": 167,
            "original_position": 167,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456253222,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855063066/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T03:56:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855063066",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855209433"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855209433"
                }
            },
            "author_association": "MEMBER",
            "body": "Is this really doing anything useful? It just seems to be returning the text of the top of the folded region?",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:08:13Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855209433",
            "id": 1855209433,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulD_Z",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 394,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456420959,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855209433/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:11:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855209433",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855209886"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855209886"
                }
            },
            "author_association": "MEMBER",
            "body": "We don't add handlers here anymore. Instead this should be inlined into the fold module.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:11:09Z",
            "diff_hunk": "@@ -217,6 +217,11 @@ RCS[ms.textDocument_diagnostic] = function(...)\n   return vim.lsp.diagnostic.on_diagnostic(...)\n end\n \n+--- @private\n+RCS[ms.textDocument_foldingRange] = function(...)\n+  return vim.lsp.folding_range.on_folding_range(...)\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855209886",
            "id": 1855209886,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulEGe",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 223,
            "original_position": 7,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/handlers.lua",
            "position": null,
            "pull_request_review_id": 2456420959,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855209886/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:11:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855209886",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855210172"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210172"
                }
            },
            "author_association": "MEMBER",
            "body": "Should this collect the results of all servers and process them in one loop so we then only schedule one update at the end?",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:13:07Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855210172",
            "id": 1855210172,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulEK8",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 62,
            "original_position": 62,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456421602,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210172/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:14:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210172",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855210341"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210341"
                }
            },
            "author_association": "MEMBER",
            "body": "Is this condition really necessary, especially since the expr could be something different anyway?",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:14:37Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855210341",
            "id": 1855210341,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulENl",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 81,
            "original_position": 30,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456421602,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210341/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:14:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210341",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855210582"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210582"
                }
            },
            "author_association": "MEMBER",
            "body": "Instead of collecting autocmds, would it be better to send an id and check for that instead?",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:16:15Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855210582",
            "id": 1855210582,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulERW",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 45,
            "original_position": 45,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456422000,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210582/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:16:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855210582",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213282"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213282"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n      if next(clients) then\n```\n",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:35:43Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213282",
            "id": 1855213282,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulE7i",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 177,
            "original_position": 177,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213282/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213282",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213349"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213349"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n```\n",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:36:30Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213349",
            "id": 1855213349,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulE8l",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 122,
            "original_position": 122,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213349/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213349",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213399"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213399"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n        refresh(bufnr, client)\n```\n",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:37:06Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213399",
            "id": 1855213399,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulE9X",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 202,
            "original_position": 202,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213399/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213399",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213406"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213406"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n          refresh(bufnr, client)\n```\n",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:37:20Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213406",
            "id": 1855213406,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulE9e",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 179,
            "original_position": 179,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213406/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213406",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213414"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213414"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n        refresh(bufnr, client)\n```\n",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:37:30Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213414",
            "id": 1855213414,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulE9m",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 150,
            "original_position": 150,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213414/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213414",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213451"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213451"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\nlocal function refresh(bufnr, client)\n```\n",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:37:45Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213451",
            "id": 1855213451,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulE-L",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 124,
            "original_position": 124,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213451/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213451",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213479"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213479"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n```\n",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:38:07Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213479",
            "id": 1855213479,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulE-n",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 127,
            "original_position": 127,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213479/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213479",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213591"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213591"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n    refresh(bufnr, client)\n```\n",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:38:37Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213591",
            "id": 1855213591,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulFAX",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 210,
            "original_position": 210,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213591/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213591",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213632"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213632"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\n      local request_id = refresh(bufnr, client)\n```\n",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:38:57Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213632",
            "id": 1855213632,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulFBA",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 274,
            "original_position": 274,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213632/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213632",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213683"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213683"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "It is to support `collapsedText` in `lsp.foldingRange` (proposed). To be honest, I haven't found a server that supports it, but I have a friend who is trying to implement LSP for Verilog and said this feature is somewhat useful. Considering it is very simple, I added it.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:39:14Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855213683",
            "id": 1855213683,
            "in_reply_to_id": 1855209433,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulFBz",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 394,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424703,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213683/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:39:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855213683",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855214424"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855214424"
                }
            },
            "author_association": "MEMBER",
            "body": "This autocmd seems a bit redundant, isn't the callback unconditional?",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:41:46Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855214424",
            "id": 1855214424,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulFNY",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 348,
            "original_position": 275,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855214424/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855214424",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855214803"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855214803"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I am currently not considering support for multiple servers. This is because such functionality is generally provided by a single server, and I feel that vim's own fold feature is unlikely to support this (correct me if I'm wrong), as multiple sources of `foldingRange` may have intersections, making it impossible to calculate the `foldlevel` in that case.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:43:41Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855214803",
            "id": 1855214803,
            "in_reply_to_id": 1855210172,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulFTT",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 62,
            "original_position": 62,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456425310,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855214803/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:43:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855214803",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855215145"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855215145"
                }
            },
            "author_association": "MEMBER",
            "body": "Need to also detach the buffer when all clients detach too.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:45:35Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855215145",
            "id": 1855215145,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulFYp",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 176,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456424270,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855215145/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:45:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855215145",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855215750"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855215750"
                }
            },
            "author_association": "MEMBER",
            "body": "Let's wait until it's actually part of the spec then; things might change too much until then.\r\n\r\n(It's better to leave something as a follow-up than to risk adding an API we have to do the deprecation dance around.)",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:49:18Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855215750",
            "id": 1855215750,
            "in_reply_to_id": 1855209433,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulFiG",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 394,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456426043,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855215750/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:49:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855215750",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855216166"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855216166"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "`foldupdate` to be called is possible only after the `vim.lsp.foldexpr` setup, which means that when it is called, `foldexpr` has already been ensured to be `vim.lsp.foldexpr`. This is to prevent the situation where `expr` is set but `foldmethod` is not set.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T15:52:07Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855216166",
            "id": 1855216166,
            "in_reply_to_id": 1855210341,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulFom",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 81,
            "original_position": 30,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456426458,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855216166/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T15:52:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855216166",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855218106"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855218106"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "This is to avoid executing `foldclose` when the buffer has already been modified, but the bufstate has not yet been updated. This ensures that the result of `foldclose` corresponds to the modified buffer.\r\n\r\nMore specifically, there is a situation where `foldclose` is executed immediately when opening a file (common in autocmd, such as the automatic folding import example given above). At this point, the bufstate is likely not updated yet, but what you actually want is the result after it has been updated, corresponding to the content you see in the buffer.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:06:43Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855218106",
            "id": 1855218106,
            "in_reply_to_id": 1855214424,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulGG6",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 348,
            "original_position": 275,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456428272,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855218106/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:06:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855218106",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855218877"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855218877"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Is [this](https://github.com/ofseed/neovim/blob/e2a24c75c34a0c3adb6caf318d7a289f0c27c874/runtime/lua/vim/lsp/folding_range.lua#L172-L189) not enough?\r\n\r\nDetaching the buffer should be unnecessary, because if this buffer has already been setup, then even if all clients detach at a certain moment (or any client has not yet attached), it is possible that it will be attached by new clients in the future.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:11:23Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855218877",
            "id": 1855218877,
            "in_reply_to_id": 1855215145,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulGS9",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 176,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456428954,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855218877/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:11:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855218877",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855219243"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855219243"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "It has already become part of the current specification. In [3.17](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#version_3_17_0). It's just that the server I commonly use does not support this feature.\r\n\r\nOf course, I wouldn't be particularly keen on exposing a feature that I wouldn't even use myself 😆.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:13:50Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855219243",
            "id": 1855219243,
            "in_reply_to_id": 1855209433,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulGYr",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 394,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456429314,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855219243/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:15:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855219243",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855220017"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855220017"
                }
            },
            "author_association": "MEMBER",
            "body": "Supporting multiple providers is valuable as it opens the door for plugins to implement custom folding via the LSP interface.\n\nSupporting multiple servers is something we've put a lot of effort into recently and want to support it for every method.\n\nLooking for intersections would be a problem, but this implementation just needs to make sure they are handled gracefully, and not necessarily correctly. I think the fold backend will already do something graceful so you may not need to do anything here, we just need to make sure the plumping is in place.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:17:40Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855220017",
            "id": 1855220017,
            "in_reply_to_id": 1855210172,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulGkx",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 62,
            "original_position": 62,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456429882,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855220017/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:17:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855220017",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855220757"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855220757"
                }
            },
            "author_association": "MEMBER",
            "body": "So you basically want to defer this code until all lines in a redraw have been calculated?",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:21:29Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855220757",
            "id": 1855220757,
            "in_reply_to_id": 1855214424,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulGwV",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 348,
            "original_position": 275,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456430386,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855220757/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:21:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855220757",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855221077"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855221077"
                }
            },
            "author_association": "MEMBER",
            "body": "If there are no clients, then the buf attach callbacks should not be invoked.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:23:07Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855221077",
            "id": 1855221077,
            "in_reply_to_id": 1855215145,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulG1V",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 176,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456430596,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855221077/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:23:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855221077",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855221730"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855221730"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "It is not for redrawing, but to wait for the `foldingRange` request to get a result.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:26:38Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855221730",
            "id": 1855221730,
            "in_reply_to_id": 1855214424,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulG_i",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 348,
            "original_position": 275,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456431050,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855221730/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:26:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855221730",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855222229"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855222229"
                }
            },
            "author_association": "MEMBER",
            "body": "The fact it doesn't provide highlighting already makes it behind other foldtexts, so I'd omit this for now.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:30:40Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855222229",
            "id": 1855222229,
            "in_reply_to_id": 1855209433,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulHHV",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 394,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456431574,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855222229/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:30:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855222229",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855222599"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855222599"
                }
            },
            "author_association": "MEMBER",
            "body": "Oh, because `LspRequest` is triggered on the handler. Ok can you just add some comments explaining this. I'd probably want to re-implement this in the future when some other things have been added.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:33:14Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855222599",
            "id": 1855222599,
            "in_reply_to_id": 1855214424,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulHNH",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 348,
            "original_position": 275,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456431854,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855222599/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:33:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855222599",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855223033"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223033"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "If you are referring to `on_bytes`, then it indeed will not be invoked, because when there are no clients, [here](https://github.com/ofseed/neovim/blob/e2a24c75c34a0c3adb6caf318d7a289f0c27c874/runtime/lua/vim/lsp/folding_range.lua#L172-L189) the row_levels will be cleared. This is intentional, because `row_level` being empty covers a wider range of possibilities.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:35:46Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855223033",
            "id": 1855223033,
            "in_reply_to_id": 1855215145,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulHT5",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 176,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456432152,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223033/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:35:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223033",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855223787"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223787"
                }
            },
            "author_association": "MEMBER",
            "body": "`collapsed_text` is often used for folding regions (delimited by `#region/#endregion`).\r\n\r\nExample from TypeScript:\r\n![image](https://github.com/user-attachments/assets/d4bf335f-2909-4ecc-99b3-1f9537cab3d4)\r\n\r\nI think that we can support it, I doubt that the spec will change a lot.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:40:41Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855223787",
            "id": 1855223787,
            "in_reply_to_id": 1855209433,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulHfr",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 394,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456432865,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223787/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:40:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223787",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855223897"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223897"
                }
            },
            "author_association": "MEMBER",
            "body": "Out of curiosity, is using `next` faster? Why do you personally prefer it? @lewis6991 ",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:41:24Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855223897",
            "id": 1855223897,
            "in_reply_to_id": 1855213282,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulHhZ",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 177,
            "original_position": 177,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456432949,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223897/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:41:25Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855223897",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225320"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225320"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I can make some more attempts in this area, but I hope that will be in another PR. Currently (only supporting one server), it can handle most needs. Even implementing custom folding through the LSP interface often covers situations that LSP server does not support folding on a specific filetype. I anticipate that such functionality may bring a lot of complexity, and it would be better to make modifications when support for a single server is already mature, as this proves that providing LSP folding through `foldexpr` is feasible.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:48:13Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225320",
            "id": 1855225320,
            "in_reply_to_id": 1855210172,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulH3o",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 62,
            "original_position": 62,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456439811,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225320/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:48:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225320",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225509"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225509"
                }
            },
            "author_association": "MEMBER",
            "body": "Because it is standard Lua. No need to use a redundant wrapper.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:49:19Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225509",
            "id": 1855225509,
            "in_reply_to_id": 1855213282,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulH6l",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 177,
            "original_position": 177,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456439959,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225509/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:49:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225509",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225697"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225697"
                }
            },
            "author_association": "MEMBER",
            "body": "`on_bytes` will still be invoked until you detach from the buffer. ",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:50:47Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225697",
            "id": 1855225697,
            "in_reply_to_id": 1855215145,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulH9h",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 176,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456440129,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225697/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:50:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225697",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225804"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225804"
                }
            },
            "author_association": "MEMBER",
            "body": "(I just went by the \"(proposed)\" in the second comment. If it's already part of the spec, then that's different of course.)",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:51:49Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225804",
            "id": 1855225804,
            "in_reply_to_id": 1855209433,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulH_M",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 394,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456440237,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225804/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:51:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225804",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225999"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225999"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Looking back, I think `#client == 0` should be sufficient, and its meaning should be clearer.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:53:15Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855225999",
            "id": 1855225999,
            "in_reply_to_id": 1855213282,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulICP",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 177,
            "original_position": 177,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456440434,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225999/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:53:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855225999",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855226895"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855226895"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "This is also where I am confused, because it is also written as proposed in the LSP specification, and I am not sure if my understanding is incorrect as most LSP servers do not support it.\r\n![image](https://github.com/user-attachments/assets/e3cd97cc-64c1-4da0-95d6-92eba785157c)\r\n",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:57:08Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855226895",
            "id": 1855226895,
            "in_reply_to_id": 1855209433,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulIQP",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 394,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456440987,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855226895/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:57:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855226895",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855226970"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855226970"
                }
            },
            "author_association": "MEMBER",
            "body": "> (I just went by the \"(proposed)\" in the second comment. If it's already part of the spec, then that's different of course.)\r\n\r\nThat's fair! I just wanted to give an example of how it is used :)",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T16:57:49Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client.id)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if vim.tbl_isempty(clients) then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client.id)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_refresh,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, args.data.client_id)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client.id)\n+  end\n+\n+  return bufstate\n+end\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Defer `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client.id)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        group = augroup_refresh,\n+        callback = function(args)\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855226970",
            "id": 1855226970,
            "in_reply_to_id": 1855209433,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulIRa",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 394,
            "original_position": 296,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456441079,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855226970/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T16:57:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855226970",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855227850"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855227850"
                }
            },
            "author_association": "MEMBER",
            "body": "Then this PR at the very least needs to make sure that multiple clients are handled gracefully by not processing multiple responses and probably only make a request to a single server.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T17:02:33Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855227850",
            "id": 1855227850,
            "in_reply_to_id": 1855210172,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulIfK",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 62,
            "original_position": 62,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456441708,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855227850/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T17:02:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855227850",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855229326"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855229326"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Are you referring to directly removing the callback set by this buf attach? Then we would need to find a way to add it back, which would significantly increase complexity. I think it's sufficient to return after it finds the table is empty. Callbacks created by `buf_attach` will only be triggered on the buffer associated with a window whose `vim.wo.foldexpr = \"v:lua.vim.lsp.foldexpr\"`, so it makes sense in the vast majority of cases. I'm not quite sure what your suggested approach is.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T17:14:45Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855229326",
            "id": 1855229326,
            "in_reply_to_id": 1855215145,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulI2O",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 176,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456443260,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855229326/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T17:14:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855229326",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855234841"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855234841"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I tend to stick with the current approach. The simplicity lies in not having to consider the buffer. Ideally, if such an id exists, it should be stored in `bufstate`.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T17:44:36Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855234841",
            "id": 1855234841,
            "in_reply_to_id": 1855210582,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulKMZ",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 45,
            "original_position": 45,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456447992,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855234841/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T17:44:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855234841",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855244278"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855244278"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "After weighing the options, considering that this PR already includes some code for handling multiple clients, I plan to add preliminary support within this PR. This might be better than asking the user to choose which client to use when encountering multiple clients. However, this shouldn’t be the main goal, especially since I can’t find any use case in practical scenarios that would allow me to perform manual testing.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T18:19:43Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855244278",
            "id": 1855244278,
            "in_reply_to_id": 1855210172,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulMf2",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 62,
            "original_position": 62,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456457945,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855244278/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T18:19:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855244278",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855267731"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855267731"
                }
            },
            "author_association": "MEMBER",
            "body": "You reattach when you set up, so all you need to do is clear bufstates. You just need to return true in on_bytes to detach. It isn't that hard, it is just basic hygiene to clean up after all clients have detached.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-23T20:56:05Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855267731",
            "id": 1855267731,
            "in_reply_to_id": 1855215145,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulSOT",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 176,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456477847,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855267731/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-23T20:57:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855267731",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855343657"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855343657"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I think clearing bufstate is not an option. Because bufstate represents a buffer's window's `foldexpr` is `vim.lsp.foldexpr`, if it is cleared, next time `vim.lsp.foldexpr` is calculated, setup will be called again, and the callback will be created.\r\n\r\nThis is a design based on the callbacks and the bufstate has the same lifecycle. If the logic of the code is unclear, I can add more explanations later. However, it may be necessary to create an autocmd for `OptionSet` to clear bufstate and these callbacks when `foldexpr` is not `vim.lsp.foldexpr`.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T03:39:55Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855343657",
            "id": 1855343657,
            "in_reply_to_id": 1855215145,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulkwp",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 176,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456584711,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855343657/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T03:39:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855343657",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855350618"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855350618"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "According to my understanding, you mean that for a buffer with `foldexpr` set to `vim.lsp.foldexpr`, it can be attached by LSP before or after (it's a goal), but during the time it is not attached (even if `foldexpr` is still `vim.lsp.foldexpr`), all callback executions need to be stopped.\r\n\r\nThis can be done through `LspAttach` and `LspDetach`, but I don't think it brings any real benefits. Especially during this time period, these callbacks return almost immediately",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T04:07:52Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+function M.on_folding_range(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, nil | \">\" | \"<\"]>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+local augroup_refresh = vim.api.nvim_create_augroup('vim_lsp_folding_range/refresh', {})\n+\n+---@param bufnr integer\n+---@param client_id integer The ID of the client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client_id)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local client = assert(vim.lsp.get_client_by_id(client_id))\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, nil, bufnr)\n+  return request_id\n+end\n+\n+--- Setup event hooks for folding range.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  bufstates[bufnr] = bufstate\n+\n+  api.nvim_buf_attach(bufnr, false, {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855350618",
            "id": 1855350618,
            "in_reply_to_id": 1855215145,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ulmda",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 176,
            "original_position": 140,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456608767,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855350618/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T04:07:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855350618",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855420715"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420715"
                }
            },
            "author_association": "MEMBER",
            "body": "Can't you check for available clients here and return if there are none, this avoids setting up attaching to the buffer and setting up autocmds, and I think allows you to remove the OptionSet autocmd.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T10:52:06Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855420715",
            "id": 1855420715,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul3kr",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 163,
            "original_position": 155,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456681288,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420715/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T10:52:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420715",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855420832"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420832"
                }
            },
            "author_association": "MEMBER",
            "body": "I think you can remove the autocmds heres.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T10:52:38Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855420832",
            "id": 1855420832,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul3mg",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 200,
            "original_position": 182,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456681382,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420832/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T10:52:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420832",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855420962"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420962"
                }
            },
            "author_association": "MEMBER",
            "body": "I don't think you should be registering bufstate here.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T10:53:24Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855420962",
            "id": 1855420962,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul3oi",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 235,
            "original_position": 207,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456681519,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420962/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T10:53:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855420962",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855421272"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855421272"
                }
            },
            "author_association": "MEMBER",
            "body": "This function is pretty hot and is only called internally by vim, so I think this `vim.validate` can be removed.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T10:55:18Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client)\n+  end\n+\n+  return bufstate\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+api.nvim_create_autocmd('OptionSet', {\n+  group = augroup_setup,\n+  pattern = 'foldexpr',\n+  callback = function()\n+    if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+      for bufnr in pairs(bufstates) do\n+        if\n+          ---@param winid integer\n+          vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+            return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+          end)\n+        then\n+          bufstates[bufnr] = nil\n+          api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+        end\n+      end\n+    end\n+  end,\n+})\n+\n+---@param winid integer\n+---@param ranges lsp.FoldingRange[]\n+local function foldclose(winid, ranges)\n+  vim._with({ win = winid }, function()\n+    -- Ensuring folding the smallest ranges first is not explicitly supported,\n+    -- but since LSP servers often return the largest ranges first,\n+    -- we traverse the ranges in reverse order here.\n+    --\n+    -- If sorting needs to be implemented,\n+    -- the most suitable algorithm here is\n+    -- [Timesort](https://wikipedia.org/wiki/Timsort).\n+    --\n+    -- \"Hanc marginis exiguitas non caperet.\"\n+    for i = #ranges, 1, -1 do\n+      local range = ranges[i]\n+      local start_lnum = range.startLine + 1\n+      local end_lnum = range.endLine + 1\n+      -- Folding a single line is not supported.\n+      if start_lnum ~= end_lnum then\n+        vim.cmd(start_lnum .. ',' .. end_lnum .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate vim.lsp.folding_range.BufState\n+\n+  -- Schedule `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = refresh(bufnr, client)\n+      api.nvim_create_autocmd('LspRequest', {\n+        buffer = bufnr,\n+        callback = function(args)\n+          -- Do foldclose() if the `refresh()` request above is completed.\n+          if args.data.request_id == request_id and args.data.request.type == 'complete' then\n+            local ranges = bufstate.kind_ranges[kind] or {}\n+            foldclose(winid, ranges)\n+            return true\n+          end\n+        end,\n+      })\n+    end\n+    return\n+  end\n+\n+  local ranges = bufstate.kind_ranges[kind] or {}\n+  foldclose(winid, ranges)\n+end\n+\n+---@return string\n+function M._foldtext()\n+  local bufnr = api.nvim_get_current_buf()\n+  local lnum = vim.v.foldstart\n+  local row = lnum - 1\n+  local bufstate = bufstates[bufnr]\n+  if bufstate and bufstate.row_text[row] then\n+    return bufstate.row_text[row]\n+  end\n+  return vim.fn.getline(lnum)\n+end\n+\n+---@param lnum? integer\n+---@return string level\n+function M._foldexpr(lnum)\n+  vim.validate('lnum', lnum, 'number', true)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855421272",
            "id": 1855421272,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul3tY",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 355,
            "original_position": 355,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456681786,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855421272/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T10:55:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855421272",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855421589"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855421589"
                }
            },
            "author_association": "MEMBER",
            "body": "Is LuaLS not able to infer this?",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T10:57:24Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855421589",
            "id": 1855421589,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul3yV",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 85,
            "original_position": 85,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456682098,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855421589/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T10:57:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855421589",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855422221"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855422221"
                }
            },
            "author_association": "MEMBER",
            "body": "This won't work if #31280 gets merged.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T11:02:12Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client)\n+  end\n+\n+  return bufstate\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+api.nvim_create_autocmd('OptionSet', {\n+  group = augroup_setup,\n+  pattern = 'foldexpr',\n+  callback = function()\n+    if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+      for bufnr in pairs(bufstates) do\n+        if\n+          ---@param winid integer\n+          vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+            return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855422221",
            "id": 1855422221,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul38N",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 276,
            "original_position": 251,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456682866,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855422221/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T11:02:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855422221",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855429653"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855429653"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I remember it wasn't before, but I am about to change the data structure of `kind_ranges` (for multi-client support, and to ensure it collapses from the smallest place, this issue will not exist).",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T11:44:57Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855429653",
            "id": 1855429653,
            "in_reply_to_id": 1855421589,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul5wV",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 85,
            "original_position": 85,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456690626,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855429653/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T11:44:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855429653",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855430304"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855430304"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "This is not registering but resetting bufstate. The assignment `bufstates[bufnr] = bufstate` needs to be done because `bufstates[bufnr]` still points to the previously constructed `bufstate`, not the new one.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T11:48:36Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855430304",
            "id": 1855430304,
            "in_reply_to_id": 1855420962,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul56g",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 235,
            "original_position": 207,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456691262,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855430304/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T11:48:37Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855430304",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855431023"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855431023"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "If garbage collection is needed, `OptionSet` is necessary. Because the user may have changed `foldexpr` themselves, there is no way to know that the user has changed it other than using `OptionSet`. At the same time, LSP clients will not make any changes in this case.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T11:52:46Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855431023",
            "id": 1855431023,
            "in_reply_to_id": 1855420715,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul6Fv",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 163,
            "original_position": 155,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456692028,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855431023/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T11:52:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855431023",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855431289"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855431289"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I have already subscribed to this PR. If it is merged, this place will become more efficient because we can check if the expr functions are equal instead of checking strings.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T11:54:20Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client)\n+  end\n+\n+  return bufstate\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+api.nvim_create_autocmd('OptionSet', {\n+  group = augroup_setup,\n+  pattern = 'foldexpr',\n+  callback = function()\n+    if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+      for bufnr in pairs(bufstates) do\n+        if\n+          ---@param winid integer\n+          vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+            return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855431289",
            "id": 1855431289,
            "in_reply_to_id": 1855422221,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul6J5",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 276,
            "original_position": 251,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456692311,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855431289/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T11:54:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855431289",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855432393"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855432393"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "As I noted in the code above, the lifecycle of bufstate and these callbacks should be synchronized. So if we do not need to destroy bufstate here, then we also do not need to destroy the callback. However, callbacks of `nvim_buf_attach` can only be destroyed if it returns true, which is the reason for adding the branch here.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T12:00:22Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855432393",
            "id": 1855432393,
            "in_reply_to_id": 1855420832,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ul6bJ",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 200,
            "original_position": 182,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456693471,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855432393/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T12:00:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855432393",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855471219"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855471219"
                }
            },
            "author_association": "MEMBER",
            "body": "The point is that there is no reliable way of checking this, nor do I think it is necessary.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T15:06:46Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client)\n+  end\n+\n+  return bufstate\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+api.nvim_create_autocmd('OptionSet', {\n+  group = augroup_setup,\n+  pattern = 'foldexpr',\n+  callback = function()\n+    if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+      for bufnr in pairs(bufstates) do\n+        if\n+          ---@param winid integer\n+          vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+            return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855471219",
            "id": 1855471219,
            "in_reply_to_id": 1855422221,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5umD5z",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 276,
            "original_position": 251,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456733556,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855471219/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T15:06:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855471219",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855476582"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855476582"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "It is indeed unnecessary, so I didn't add it at first, but considering your suggestion for more granular garbage collection, I included it because it makes sense in many cases. I'm fine to delete this.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T15:32:43Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client)\n+  end\n+\n+  return bufstate\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+api.nvim_create_autocmd('OptionSet', {\n+  group = augroup_setup,\n+  pattern = 'foldexpr',\n+  callback = function()\n+    if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+      for bufnr in pairs(bufstates) do\n+        if\n+          ---@param winid integer\n+          vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+            return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855476582",
            "id": 1855476582,
            "in_reply_to_id": 1855422221,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5umFNm",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 276,
            "original_position": 251,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456738559,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855476582/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T15:32:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855476582",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855489323"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855489323"
                }
            },
            "author_association": "MEMBER",
            "body": "Fine, revert everything back to the stage you are happy with and then someone else can review and merge this. If this gets merged I'll take a look at resolving the memory leaks in a follow up.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T16:39:54Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client)\n+  end\n+\n+  return bufstate\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+api.nvim_create_autocmd('OptionSet', {\n+  group = augroup_setup,\n+  pattern = 'foldexpr',\n+  callback = function()\n+    if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+      for bufnr in pairs(bufstates) do\n+        if\n+          ---@param winid integer\n+          vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+            return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855489323",
            "id": 1855489323,
            "in_reply_to_id": 1855422221,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5umIUr",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 276,
            "original_position": 251,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456750830,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855489323/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T16:39:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855489323",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855492014"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855492014"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Perhaps I'm overthinking it, and I hope that's the case. Later, I will add some test cases that I'm concerned about so that the code can be changed more safely.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-24T16:54:00Z",
            "diff_hunk": "@@ -0,0 +1,365 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then\n+    api.nvim_create_autocmd('InsertLeave', {\n+      group = augroup_update,\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+      end,\n+    })\n+  end\n+end\n+\n+--- |lsp-handler| for the method `textDocument/foldingRange`\n+--- Store folding range then update folds for a specific buffer.\n+---@private\n+---@param result lsp.FoldingRange[]?\n+---@param ctx lsp.HandlerContext\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, string>\n+  local row_text = {}\n+  ---@type table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+  local kind_ranges = {}\n+\n+  for _, range in ipairs(result) do\n+    local kind = range.kind\n+    if kind then\n+      ---@cast kind lsp.FoldingRangeKind\n+      local ranges = kind_ranges[kind] or {}\n+      ranges[#ranges + 1] = range\n+      kind_ranges[kind] = ranges\n+    end\n+\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Fold a single line is not supported.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_text = row_text\n+  bufstate.kind_ranges = kind_ranges\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function refresh(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- MAINTENANCE NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- our strategy is to ensure that their lifecycles are always synchronized.\n+--\n+-- As they are only meaningful for buffers associated with\n+-- at least one window that have `foldexpr()` set,\n+-- the following three elements are guaranteed\n+-- to exist or not exist simultaneously:\n+--\n+-- * A buffer associated with at least one window where `foldexpr()` is set.\n+-- * Its `bufstate`.\n+-- * Its event hooks.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Setup `bufstate` and its event hooks.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  bufstates[bufnr] = bufstate\n+\n+  -- Setup event hooks.\n+  api.nvim_buf_attach(bufnr, false, {\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+    end,\n+    on_reload = function()\n+      bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+      bufstates[bufnr] = bufstate\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        refresh(bufnr, client)\n+      end\n+    end,\n+    --- When modifying the buffer, new foldinfo is scheduled to be updated,\n+    --- synchronize the changed rows with their previous foldlevels as possible,\n+    --- before new foldlevels is updated.\n+    ---@param start_row integer\n+    ---@param old_row integer\n+    ---@param new_row integer\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstate == nil then\n+        return true\n+      end\n+      local row = new_row - old_row\n+      local row_level = bufstate.row_level\n+      if vim.tbl_isempty(row_level) then\n+        return\n+      end\n+      if row > 0 then\n+        vim._list_insert(bufstate.row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+      elseif row < 0 then\n+        vim._list_remove(bufstate.row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function()\n+      local clients = vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange })\n+      if #clients == 0 then\n+        for _, client in ipairs(clients) do\n+          refresh(bufnr, client)\n+        end\n+      else\n+        bufstate = { row_level = {}, row_text = {}, kind_ranges = {} }\n+        bufstates[bufnr] = bufstate\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          foldupdate(bufnr)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        refresh(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    refresh(bufnr, client)\n+  end\n+\n+  return bufstate\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+api.nvim_create_autocmd('OptionSet', {\n+  group = augroup_setup,\n+  pattern = 'foldexpr',\n+  callback = function()\n+    if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+      for bufnr in pairs(bufstates) do\n+        if\n+          ---@param winid integer\n+          vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+            return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855492014",
            "id": 1855492014,
            "in_reply_to_id": 1855422221,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5umI-u",
            "original_commit_id": "e141e0a4107876aab69e65a6b3e8edcf2ed966b1",
            "original_line": 276,
            "original_position": 251,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2456753321,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855492014/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-24T16:54:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855492014",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1855858261"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855858261"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I have changed it to a method very similar to your suggestion, and now I will mark this thread as resolved.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-25T05:54:20Z",
            "diff_hunk": "@@ -0,0 +1,320 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, nil | \">\" | \"<\"]>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string>\n+---\n+--- Index in the form of kind -> range\n+---@field kind_ranges table<lsp.FoldingRangeKind, lsp.FoldingRange[]?>>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Update visible folds in the buffer.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+local augroup_update = api.nvim_create_augroup('vim_lsp_folding_range/update', {})\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if #(api.nvim_get_autocmds({\n+    group = augroup_update,\n+    buffer = bufnr,\n+  })) == 0 then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1855858261",
            "id": 1855858261,
            "in_reply_to_id": 1855210582,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5uniZV",
            "original_commit_id": "e2a24c75c34a0c3adb6caf318d7a289f0c27c874",
            "original_line": 45,
            "original_position": 45,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2457243877,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855858261/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-25T05:54:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1855858261",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1856859913"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1856859913"
                }
            },
            "author_association": "MEMBER",
            "body": "Would this be better written as?\r\n\r\n```suggestion\r\n      bufstates[bufnr] = {\r\n        row_level = {},\r\n        row_kinds = {},\r\n        row_text = {},\r\n      }\r\n```\r\n\r\nAnd actually I think all these callbacks should refer directly to `bufstates[bufnr]` instead of `bufstate` to avoid any accidental aliasing.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-25T15:54:03Z",
            "diff_hunk": "@@ -0,0 +1,396 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Add `ranges` into the given `bufstate`.\n+---@param bufstate vim.lsp.folding_range.BufState\n+---@param ranges lsp.FoldingRange[]\n+local function rangeadd(bufstate, ranges)\n+  local row_level = bufstate.row_level\n+  local row_kinds = bufstate.row_kinds\n+  local row_text = bufstate.row_text\n+\n+  for _, range in ipairs(ranges) do\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Adding folds within a single line is not supported by Nvim.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+\n+      local kind = range.kind\n+      if kind then\n+        local kinds = row_kinds[start_row] or {}\n+        kinds[kind] = true\n+        row_kinds[start_row] = kinds\n+      end\n+\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+end\n+\n+--- Force `foldexpr()` to be re-evaluated, without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled[bufnr] then\n+    scheduled[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.row_level = {}\n+  bufstate.row_kinds = {}\n+  bufstate.row_text = {}\n+\n+  rangeadd(bufstate, result)\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- the strategy here is to ensure that their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Nothing more than setup `bufstate` and its event hooks then request folding ranges.\n+--- their lifecycle management should be done in this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = {\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  -- NOTE: If the table pointed to by `bufstate` or `bufstates[bufnr]` changes\n+  -- (for example, if either is reassigned), make sure they remain in sync,\n+  -- as they are free variables defined by the event hooks here.\n+  bufstates[bufnr] = bufstate\n+\n+  -- There is no way to remove event hooks created by `buf_attach` from the outside,\n+  -- but our strategy is based on keeping `bufstate` and event hooks in the same lifecycle,\n+  -- so each of them should check if `bufstate == nil` and then destroy themselves.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- Note that `on_detach` will also be triggered when `:e` is executed to reload,\n+    -- make sure `bufstate` and event hooks are cleaned up\n+    -- so that they don't exist on a unloaded buffer\n+    -- or be recreated when the buffer is reloaded.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstate = nil\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+      return true\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      if bufstate == nil then\n+        return true\n+      end\n+      bufstate = {\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      bufstates[bufnr] = bufstate",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1856859913",
            "id": 1856859913,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5urW8J",
            "original_commit_id": "3b01523c030cca19bea29a473d37352e45bff207",
            "original_line": 188,
            "original_position": 188,
            "original_start_line": 183,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2458847085,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1856859913/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-11-25T16:04:18Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1856859913",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1857536489"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1857536489"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Oh right, there’s no reason to use `bufstate` in `setup` instead of `bufstates[bufnr]`.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-26T01:12:32Z",
            "diff_hunk": "@@ -0,0 +1,396 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Add `ranges` into the given `bufstate`.\n+---@param bufstate vim.lsp.folding_range.BufState\n+---@param ranges lsp.FoldingRange[]\n+local function rangeadd(bufstate, ranges)\n+  local row_level = bufstate.row_level\n+  local row_kinds = bufstate.row_kinds\n+  local row_text = bufstate.row_text\n+\n+  for _, range in ipairs(ranges) do\n+    local start_row = range.startLine\n+    local end_row = range.endLine\n+    -- Adding folds within a single line is not supported by Nvim.\n+    if start_row ~= end_row then\n+      row_text[start_row] = range.collapsedText\n+\n+      local kind = range.kind\n+      if kind then\n+        local kinds = row_kinds[start_row] or {}\n+        kinds[kind] = true\n+        row_kinds[start_row] = kinds\n+      end\n+\n+      for row = start_row, end_row do\n+        local level = row_level[row] or { 0 }\n+        level[1] = level[1] + 1\n+        row_level[row] = level\n+      end\n+      row_level[start_row][2] = '>'\n+      row_level[end_row][2] = '<'\n+    end\n+  end\n+end\n+\n+--- Force `foldexpr()` to be re-evaluated, without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled[bufnr] then\n+    scheduled[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  if not result then\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.row_level = {}\n+  bufstate.row_kinds = {}\n+  bufstate.row_text = {}\n+\n+  rangeadd(bufstate, result)\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- * `bufstate` requires event hooks to ensure correctness.\n+-- * event hooks requires the previous `bufstate` for updates.\n+--\n+-- In other words, they are interdependent.\n+-- Since their creation and destruction are handled manually,\n+-- the strategy here is to ensure that their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Nothing more than setup `bufstate` and its event hooks then request folding ranges.\n+--- their lifecycle management should be done in this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState\n+local function setup(bufnr)\n+  ---@type vim.lsp.folding_range.BufState\n+  local bufstate = {\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return bufstate\n+  end\n+\n+  -- Register `bufstate`.\n+  -- NOTE: If the table pointed to by `bufstate` or `bufstates[bufnr]` changes\n+  -- (for example, if either is reassigned), make sure they remain in sync,\n+  -- as they are free variables defined by the event hooks here.\n+  bufstates[bufnr] = bufstate\n+\n+  -- There is no way to remove event hooks created by `buf_attach` from the outside,\n+  -- but our strategy is based on keeping `bufstate` and event hooks in the same lifecycle,\n+  -- so each of them should check if `bufstate == nil` and then destroy themselves.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- Note that `on_detach` will also be triggered when `:e` is executed to reload,\n+    -- make sure `bufstate` and event hooks are cleaned up\n+    -- so that they don't exist on a unloaded buffer\n+    -- or be recreated when the buffer is reloaded.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstate = nil\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+      return true\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      if bufstate == nil then\n+        return true\n+      end\n+      bufstate = {\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      bufstates[bufnr] = bufstate",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1857536489",
            "id": 1857536489,
            "in_reply_to_id": 1856859913,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5ut8Hp",
            "original_commit_id": "3b01523c030cca19bea29a473d37352e45bff207",
            "original_line": 188,
            "original_position": 188,
            "original_start_line": 183,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2459925459,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1857536489/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-11-26T01:12:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1857536489",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1858771769"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858771769"
                }
            },
            "author_association": "MEMBER",
            "body": "The logic is maybe complex enough to live in its own module, but we probably don't need to expose it as such? Should this live at `vim.lsp.foldclose`, or do we plan to have many more fold-related functions in the future? E.g. `folding_range.enable()`, `folding_range.is_enabled`, etc.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-26T15:37:14Z",
            "diff_hunk": "@@ -1647,6 +1659,27 @@ trigger()                                       *vim.lsp.completion.trigger()*\n     Trigger LSP completion in the current buffer.\n \n \n+==============================================================================\n+Lua module: vim.lsp.folding_range                          *lsp-folding_range*\n+\n+foldclose({kind}, {winid})                 *vim.lsp.folding_range.foldclose()*",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1858771769",
            "id": 1858771769,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5uyps5",
            "original_commit_id": "d2718e442c01d22c292866cca8668b1be57cdce5",
            "original_line": 1665,
            "original_position": 33,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2461924712,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858771769/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-26T15:37:14Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858771769",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1858776272"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858776272"
                }
            },
            "author_association": "MEMBER",
            "body": "`:help dev-naming` \r\n\r\n```suggestion\r\nfunction vim._list_del(t, first, last)\r\n```",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-26T15:39:54Z",
            "diff_hunk": "@@ -737,6 +737,51 @@ function vim.list_slice(list, start, finish)\n   return new_list\n end\n \n+--- Efficiently insert items into the middle of a list.\n+---\n+--- Calling table.insert() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+---@param v any\n+function vim._list_insert(t, first, last, v)\n+  local n = #t\n+\n+  -- Shift table forward\n+  for i = n - first, 0, -1 do\n+    t[last + 1 + i] = t[first + i]\n+  end\n+\n+  -- Fill in new values\n+  for i = first, last do\n+    t[i] = v\n+  end\n+end\n+\n+--- Efficiently remove items from middle of a list.\n+---\n+--- Calling table.remove() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+function vim._list_remove(t, first, last)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1858776272",
            "id": 1858776272,
            "line": 777,
            "node_id": "PRRC_kwDOAPphoM5uyqzQ",
            "original_commit_id": "d2718e442c01d22c292866cca8668b1be57cdce5",
            "original_line": 777,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": 41,
            "pull_request_review_id": 2461932025,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858776272/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-26T15:39:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858776272",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1858780478"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858780478"
                }
            },
            "author_association": "MEMBER",
            "body": "Just for reference: this is yet another case of a pattern I think we discussed generalizing, right? (can't find the PR/issue ...)",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-26T15:42:21Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1858780478",
            "id": 1858780478,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5uyr0-",
            "original_commit_id": "d2718e442c01d22c292866cca8668b1be57cdce5",
            "original_line": 28,
            "original_position": 28,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2461938416,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858780478/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-26T15:42:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858780478",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1858816805"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858816805"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "This is mainly about naming convention. I found that the functions under `vim.lsp.<name>`, apart from those directly related to LSP (such as `vim.lsp.buf_request`), only have functions related to specific methods when there are concrete interfaces in nvim. For example, `vim.lsp.tagfunc`, `vim.lsp.formatexpr`. The others are either in `vim.lsp.buf` or have their own module.\r\n\r\nIt is also possible to add additional functions. I hope to provide as few interfaces as possible initially to cover the functionality that LSP can offer. However, for convenience, it may also be possible to add a `foldopen()` in the future to correspond with `foldclose()`, or to add a function/hook to get `foldlevel` corresponding to vim's `set foldlevel`.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-26T16:01:10Z",
            "diff_hunk": "@@ -1647,6 +1659,27 @@ trigger()                                       *vim.lsp.completion.trigger()*\n     Trigger LSP completion in the current buffer.\n \n \n+==============================================================================\n+Lua module: vim.lsp.folding_range                          *lsp-folding_range*\n+\n+foldclose({kind}, {winid})                 *vim.lsp.folding_range.foldclose()*",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1858816805",
            "id": 1858816805,
            "in_reply_to_id": 1858771769,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5uy0sl",
            "original_commit_id": "d2718e442c01d22c292866cca8668b1be57cdce5",
            "original_line": 1665,
            "original_position": 33,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2461998849,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858816805/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-26T16:01:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858816805",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1858817245"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858817245"
                }
            },
            "author_association": "MEMBER",
            "body": "`remove` was initially chosen as this function is supposed to be a replacement for `table.remove`. Same for `vim.list_insert` and `table.insert`.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-26T16:01:28Z",
            "diff_hunk": "@@ -737,6 +737,51 @@ function vim.list_slice(list, start, finish)\n   return new_list\n end\n \n+--- Efficiently insert items into the middle of a list.\n+---\n+--- Calling table.insert() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+---@param v any\n+function vim._list_insert(t, first, last, v)\n+  local n = #t\n+\n+  -- Shift table forward\n+  for i = n - first, 0, -1 do\n+    t[last + 1 + i] = t[first + i]\n+  end\n+\n+  -- Fill in new values\n+  for i = first, last do\n+    t[i] = v\n+  end\n+end\n+\n+--- Efficiently remove items from middle of a list.\n+---\n+--- Calling table.remove() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+function vim._list_remove(t, first, last)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1858817245",
            "id": 1858817245,
            "in_reply_to_id": 1858776272,
            "line": 777,
            "node_id": "PRRC_kwDOAPphoM5uy0zd",
            "original_commit_id": "d2718e442c01d22c292866cca8668b1be57cdce5",
            "original_line": 777,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": 41,
            "pull_request_review_id": 2461999638,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858817245/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-26T16:01:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858817245",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1858835616"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858835616"
                }
            },
            "author_association": "MEMBER",
            "body": "If more functions are planned then I guess this is fine.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-26T16:12:46Z",
            "diff_hunk": "@@ -1647,6 +1659,27 @@ trigger()                                       *vim.lsp.completion.trigger()*\n     Trigger LSP completion in the current buffer.\n \n \n+==============================================================================\n+Lua module: vim.lsp.folding_range                          *lsp-folding_range*\n+\n+foldclose({kind}, {winid})                 *vim.lsp.folding_range.foldclose()*",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1858835616",
            "id": 1858835616,
            "in_reply_to_id": 1858771769,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5uy5Sg",
            "original_commit_id": "d2718e442c01d22c292866cca8668b1be57cdce5",
            "original_line": 1665,
            "original_position": 33,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2462028472,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858835616/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-26T16:12:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858835616",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1858837099"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858837099"
                }
            },
            "author_association": "MEMBER",
            "body": "Not a blocker for now",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-26T16:13:16Z",
            "diff_hunk": "@@ -737,6 +737,51 @@ function vim.list_slice(list, start, finish)\n   return new_list\n end\n \n+--- Efficiently insert items into the middle of a list.\n+---\n+--- Calling table.insert() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+---@param v any\n+function vim._list_insert(t, first, last, v)\n+  local n = #t\n+\n+  -- Shift table forward\n+  for i = n - first, 0, -1 do\n+    t[last + 1 + i] = t[first + i]\n+  end\n+\n+  -- Fill in new values\n+  for i = first, last do\n+    t[i] = v\n+  end\n+end\n+\n+--- Efficiently remove items from middle of a list.\n+---\n+--- Calling table.remove() in a loop will re-index the tail of the table on\n+--- every iteration, instead this function will re-index  the table exactly\n+--- once.\n+---\n+--- Based on https://stackoverflow.com/questions/12394841/safely-remove-items-from-an-array-table-while-iterating/53038524#53038524\n+---\n+---@param t any[]\n+---@param first integer\n+---@param last integer\n+function vim._list_remove(t, first, last)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1858837099",
            "id": 1858837099,
            "in_reply_to_id": 1858776272,
            "line": 777,
            "node_id": "PRRC_kwDOAPphoM5uy5pr",
            "original_commit_id": "d2718e442c01d22c292866cca8668b1be57cdce5",
            "original_line": 777,
            "original_position": 41,
            "original_start_line": null,
            "path": "runtime/lua/vim/shared.lua",
            "position": 41,
            "pull_request_review_id": 2462030569,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858837099/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-26T16:13:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858837099",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1858838301"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858838301"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Yes, there was [a draft PR](https://github.com/neovim/neovim/pull/30841) before. Many of lewis's earlier reviews focused on ensuring that these bufstates can be correctly destroyed to avoid potential memory leaks.\r\n\r\nI still haven't given up on this idea, so I kept the code related to managing bufstates in a single `setup` function there so that it can truly generalize to other modules in the future. Currently, it should ensure that nothing remains on the unloaded buffer. It would be better if we could delete it when there is no corresponding method supported on the buffer, as lewis suggested. Still, for now, the actual effect is not very significant, and the risk is relatively high.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-26T16:13:46Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> foldlevel\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1858838301",
            "id": 1858838301,
            "in_reply_to_id": 1858780478,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5uy58d",
            "original_commit_id": "d2718e442c01d22c292866cca8668b1be57cdce5",
            "original_line": 28,
            "original_position": 28,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2462032578,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 1,
                "total_count": 2,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858838301/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-26T16:13:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1858838301",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860339009"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860339009"
                }
            },
            "author_association": "MEMBER",
            "body": "For consistency with other docs:\r\n\r\n```suggestion\r\n---@param kind lsp.FoldingRangeKind 'comment'|'imports'|'region'\r\n```",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-27T09:48:14Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860339009",
            "id": 1860339009,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u4oVB",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 345,
            "original_position": 345,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2464504054,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860339009/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-27T09:57:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860339009",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860339918"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860339918"
                }
            },
            "author_association": "MEMBER",
            "body": "I'm pretty sure LuaLS correctly infers this already.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-27T09:48:47Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate -nil",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860339918",
            "id": 1860339918,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u4ojO",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 357,
            "original_position": 357,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2464504054,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860339918/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-27T09:57:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860339918",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860341814"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860341814"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  if bufstate.version == util.buf_versions[bufnr] then\r\n    foldclose(kind, winid)\r\n    return\r\n  end\r\n```\r\n\r\nTo reduce code nesting.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-27T09:49:54Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate -nil\n+\n+  -- Schedule `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860341814",
            "id": 1860341814,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u4pA2",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 360,
            "original_position": 360,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2464504054,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860341814/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-27T09:57:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860341814",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860344187"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860344187"
                }
            },
            "author_association": "MEMBER",
            "body": "Can this be flattened into one autocmd?",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-27T09:51:18Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate -nil\n+\n+  -- Schedule `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    --- Index in the form of request_id -> true?\n+    ---@type table<integer, true?>\n+    local scheduled_request = {}\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = request(bufnr, client)\n+      if request_id then\n+        scheduled_request[request_id] = true\n+        api.nvim_create_autocmd('LspRequest', {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860344187",
            "id": 1860344187,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u4pl7",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 370,
            "original_position": 370,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2464504054,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860344187/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-27T09:57:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860344187",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860347156"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860347156"
                }
            },
            "author_association": "MEMBER",
            "body": "This looks quite costly. Doesn't `vim.cmd.normal('zM')` do this?",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-27T09:53:17Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860347156",
            "id": 1860347156,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u4qUU",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 325,
            "original_position": 326,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2464504054,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860347156/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-27T09:57:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860347156",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860351480"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860351480"
                }
            },
            "author_association": "MEMBER",
            "body": "What's this doing?",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-27T09:55:13Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860351480",
            "id": 1860351480,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u4rX4",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 180,
            "original_position": 180,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2464504054,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860351480/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-27T09:57:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860351480",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860422150"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860422150"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Thanks, I didn't know there were performance differences in this. But I think it is still necessary to use `:foldclose`, because `zc` affects `foldenable` and `'zm'` affects `'foldlevel'`, we should choose one that has no side effects.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-27T10:38:05Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860422150",
            "id": 1860422150,
            "in_reply_to_id": 1860347156,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u48oG",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 325,
            "original_position": 326,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2464638874,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860422150/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-27T10:38:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860422150",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860427429"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860427429"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Right, I may have left unnecessary code during the rebase process.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-27T10:41:20Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate -nil",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860427429",
            "id": 1860427429,
            "in_reply_to_id": 1860339918,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u496l",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 357,
            "original_position": 357,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2464647059,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860427429/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-27T10:41:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860427429",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860455849"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860455849"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I've deleted it now.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-27T11:00:06Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860455849",
            "id": 1860455849,
            "in_reply_to_id": 1860351480,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u5E2p",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 180,
            "original_position": 180,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2464690059,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860455849/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-27T11:00:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860455849",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860456245"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860456245"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Done",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-27T11:00:21Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+  ---@cast bufstate -nil\n+\n+  -- Schedule `foldclose()` if the buffer is not up-to-date.\n+  if bufstate.version ~= util.buf_versions[bufnr] then\n+    --- Index in the form of request_id -> true?\n+    ---@type table<integer, true?>\n+    local scheduled_request = {}\n+    for _, client in\n+      ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+    do\n+      local request_id = request(bufnr, client)\n+      if request_id then\n+        scheduled_request[request_id] = true\n+        api.nvim_create_autocmd('LspRequest', {",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860456245",
            "id": 1860456245,
            "in_reply_to_id": 1860344187,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u5E81",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 370,
            "original_position": 370,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2464690645,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860456245/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-27T11:00:21Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860456245",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860472299"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860472299"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "It seems that changing it to the form of `'` will cause lintdoc to error, possibly because it is confused with type unions.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-27T11:12:08Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860472299",
            "id": 1860472299,
            "in_reply_to_id": 1860339009,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u5I3r",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 345,
            "original_position": 345,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2464716744,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860472299/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-27T11:12:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860472299",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860476855"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860476855"
                }
            },
            "author_association": "MEMBER",
            "body": "Oh the type is `lsp.FoldRangeKind`. These can be fully omitted.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-27T11:15:06Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860476855",
            "id": 1860476855,
            "in_reply_to_id": 1860339009,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u5J-3",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 345,
            "original_position": 345,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2464723761,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860476855/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-27T11:15:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860476855",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860483303"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860483303"
                }
            },
            "author_association": "MEMBER",
            "body": "Running a command on every single line in the buffer will exhibit issues on large files.\r\n\r\nI thought I saw `foldclose` called in other places in the `foldexpr` path, but I can't see any now, so `foldclose` looks like it can only be triggered directly by the user, so will be ok for now.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-27T11:19:40Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860483303",
            "id": 1860483303,
            "in_reply_to_id": 1860347156,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u5Ljn",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 325,
            "original_position": 326,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2464733655,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860483303/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-27T11:19:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860483303",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860484824"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860484824"
                }
            },
            "author_association": "MEMBER",
            "body": "I feel like this module should be called `fold.lua`. `folding_range` is just the name of the current method the spec provides, but more methods may be added in the future.",
            "commit_id": "dbc14c44105d2b85afc8cdfacd5b78ff4e628ce7",
            "created_at": "2024-11-27T11:20:53Z",
            "diff_hunk": "",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860484824",
            "id": 1860484824,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM5u5L7Y",
            "original_commit_id": "dbc14c44105d2b85afc8cdfacd5b78ff4e628ce7",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 1,
            "pull_request_review_id": 2464736185,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860484824/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "file",
            "updated_at": "2024-11-27T11:20:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860484824",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860490835"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860490835"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Will it be unrelated to this method? Actually, I thought about using semantic tokens to provide foldtext, but this doesn't have much impact since foldtext is already under `vim.lsp`.",
            "commit_id": "dbc14c44105d2b85afc8cdfacd5b78ff4e628ce7",
            "created_at": "2024-11-27T11:25:19Z",
            "diff_hunk": "",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860490835",
            "id": 1860490835,
            "in_reply_to_id": 1860484824,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM5u5NZT",
            "original_commit_id": "dbc14c44105d2b85afc8cdfacd5b78ff4e628ce7",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 1,
            "pull_request_review_id": 2464745606,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860490835/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "file",
            "updated_at": "2024-11-27T11:31:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860490835",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860491873"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860491873"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I slightly added content, but single quotes cannot be used still, as they will be treated as tags.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-27T11:26:12Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860491873",
            "id": 1860491873,
            "in_reply_to_id": 1860339009,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u5Nph",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 345,
            "original_position": 345,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2464747320,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860491873/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-27T11:28:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860491873",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1860502800"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860502800"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "> Oh the type is `lsp.FoldRangeKind`. These can be fully omitted.\r\n\r\nThe purpose of this comment is to generate documentation, as `lsp.FoldingRangeKind` will not be automatically generated, so I mentioned their possible values.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-27T11:34:16Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+--- Close all {kind} of folds in the the window with {winid}.\n+---\n+--- To automatically fold imports when opening a file, you can use an autocmd:\n+---\n+--- ```lua\n+--- vim.api.nvim_create_autocmd('LspNotify', {\n+---   callback = function(args)\n+---     if args.data.method == 'textDocument/didOpen' then\n+---       vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))\n+---     end\n+---   end,\n+--- })\n+--- ```\n+---\n+---@param kind lsp.FoldingRangeKind \"comment\" | \"imports\" | \"region\"",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1860502800",
            "id": 1860502800,
            "in_reply_to_id": 1860339009,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u5QUQ",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 345,
            "original_position": 345,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2464764573,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860502800/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-27T11:34:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1860502800",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1861457223"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1861457223"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I have precautions regarding this. `:foldclose` will not be called on every line, but rather at the beginning of a certain `kind`. If it is folding imports, it will only be called once; if it is folding comments, it will also only be called on the first line so even if a file has 100 functions, each with a docstring, it will only be called 100 times. This should already be quite large.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-28T03:16:28Z",
            "diff_hunk": "@@ -0,0 +1,417 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      ---@diagnostic disable-next-line: cast-local-type\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1861457223",
            "id": 1861457223,
            "in_reply_to_id": 1860347156,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5u85VH",
            "original_commit_id": "9082faefc484d276b758ad34d011ad760dfe793b",
            "original_line": 325,
            "original_position": 326,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": null,
            "pull_request_review_id": 2466251849,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1861457223/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-28T03:16:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1861457223",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1861705288"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1861705288"
                }
            },
            "author_association": "MEMBER",
            "body": "Folding is a general concept. I don't think it's a good idea to name modules directly from method names. Can we rename this to `fold.lua`. Preferably I would keep this module hidden and expose everything at the `vim.lsp.*` or `vim.lsp.buf.*` level.",
            "commit_id": "dbc14c44105d2b85afc8cdfacd5b78ff4e628ce7",
            "created_at": "2024-11-28T08:15:54Z",
            "diff_hunk": "",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1861705288",
            "id": 1861705288,
            "in_reply_to_id": 1860484824,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM5u915I",
            "original_commit_id": "dbc14c44105d2b85afc8cdfacd5b78ff4e628ce7",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 1,
            "pull_request_review_id": 2467061615,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1861705288/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "file",
            "updated_at": "2024-11-28T08:15:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1861705288",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1861826744"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1861826744"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "I don't have strong opinions about this name; I just noticed that there seems to be a naming convention when I first saw it. I'm okay with any name.\r\n\r\nIt can indeed be considered to turn it into an internal module, exposing interfaces only through `vim.lsp.*` (since folding in vim is a window-level option, I think `vim.lsp.buf.*` is not very meaningful). This module only has one `vim.lsp.folding_range.foldclose`, and the reason for using `foldclose` instead of `close` is that it corresponds to the native command `:foldclose`. For convenience, calling it `vim.lsp.foldclose` seems better and won't confuse.\r\n\r\nTherefore, if renaming is necessary, my personal suggestion is to rename it to `_folding_range.lua` and then expose the last reserved function as `vim.lsp.foldclose`.",
            "commit_id": "dbc14c44105d2b85afc8cdfacd5b78ff4e628ce7",
            "created_at": "2024-11-28T09:37:28Z",
            "diff_hunk": "",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1861826744",
            "id": 1861826744,
            "in_reply_to_id": 1860484824,
            "line": 1,
            "node_id": "PRRC_kwDOAPphoM5u-Ti4",
            "original_commit_id": "dbc14c44105d2b85afc8cdfacd5b78ff4e628ce7",
            "original_line": 1,
            "original_position": 1,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/folding_range.lua",
            "position": 1,
            "pull_request_review_id": 2467371810,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1861826744/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "file",
            "updated_at": "2024-11-28T09:37:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1861826744",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1862436647"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862436647"
                }
            },
            "author_association": "MEMBER",
            "body": "Is there any reason for the `?` suffixes for the table values? It's kinda implicit that entries can be missing and that you get a `nil` so I'm wondering if I'm missing some aspect to this.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-28T16:04:27Z",
            "diff_hunk": "@@ -0,0 +1,404 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1862436647",
            "id": 1862436647,
            "line": 27,
            "node_id": "PRRC_kwDOAPphoM5vAocn",
            "original_commit_id": "98fd2d6b0ea04a196f638aa17071a80f6260e312",
            "original_line": 27,
            "original_position": 27,
            "original_start_line": 16,
            "path": "runtime/lua/vim/lsp/_folding_range.lua",
            "position": 27,
            "pull_request_review_id": 2468517158,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862436647/reactions"
            },
            "side": "RIGHT",
            "start_line": 16,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-11-28T16:23:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862436647",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1862445820"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862445820"
                }
            },
            "author_association": "MEMBER",
            "body": "I don't quite understand why it's necessary to re-request the fold information for other clients if one client detaches from the buffer. The state should still be up to date, no?\r\n\r\nShouldn't this instead only clear out the `bufstate.client_ranges` for the given client id?\r\n",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-28T16:11:44Z",
            "diff_hunk": "@@ -0,0 +1,404 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1862445820",
            "id": 1862445820,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vAqr8",
            "original_commit_id": "98fd2d6b0ea04a196f638aa17071a80f6260e312",
            "original_line": 250,
            "original_position": 250,
            "original_start_line": 248,
            "path": "runtime/lua/vim/lsp/_folding_range.lua",
            "position": null,
            "pull_request_review_id": 2468517158,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862445820/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-11-28T16:23:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862445820",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1862458699"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862458699"
                }
            },
            "author_association": "MEMBER",
            "body": "A bit an unusual pattern to use `LspRequest` for a countdown latch to react once all responses were received.\r\nTypical pattern is to use a counter like in `buf_request_all` or in some of the methods in lsp.buf.\r\n\r\nBut no strong opinion on this.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-28T16:22:39Z",
            "diff_hunk": "@@ -0,0 +1,404 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+---@param kind lsp.FoldingRangeKind Kind to close, one of \"comment\", \"imports\" or \"region\".\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+\n+  if bufstate.version == util.buf_versions[bufnr] then\n+    foldclose(kind, winid)\n+    return\n+  end\n+  -- Schedule `foldclose()` if the buffer is not up-to-date.\n+\n+  --- Index in the form of request_id -> true?\n+  ---@type table<integer, true?>\n+  local scheduled_request = {}\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    local request_id = request(bufnr, client)\n+    if request_id then\n+      scheduled_request[request_id] = true\n+    end\n+  end\n+\n+  api.nvim_create_autocmd('LspRequest', {\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local request_id = args.data.request_id\n+      if scheduled_request[request_id] and args.data.request.type == 'complete' then\n+        scheduled_request[request_id] = nil\n+      end\n+      -- Do `foldclose()` if all the requests is completed.\n+      if next(scheduled_request) == nil then\n+        foldclose(kind, winid)\n+        return true\n+      end\n+    end,\n+  })",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1862458699",
            "id": 1862458699,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vAt1L",
            "original_commit_id": "98fd2d6b0ea04a196f638aa17071a80f6260e312",
            "original_line": 375,
            "original_position": 375,
            "original_start_line": 349,
            "path": "runtime/lua/vim/lsp/_folding_range.lua",
            "position": null,
            "pull_request_review_id": 2468517158,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862458699/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-11-28T16:23:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862458699",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1862516138"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862516138"
                }
            },
            "author_association": "MEMBER",
            "body": "Nah, they are not implicit, though they should be. Adding them gives you more strict type checking.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-28T17:14:39Z",
            "diff_hunk": "@@ -0,0 +1,404 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1862516138",
            "id": 1862516138,
            "in_reply_to_id": 1862436647,
            "line": 27,
            "node_id": "PRRC_kwDOAPphoM5vA72q",
            "original_commit_id": "98fd2d6b0ea04a196f638aa17071a80f6260e312",
            "original_line": 27,
            "original_position": 27,
            "original_start_line": 16,
            "path": "runtime/lua/vim/lsp/_folding_range.lua",
            "position": 27,
            "pull_request_review_id": 2468617166,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862516138/reactions"
            },
            "side": "RIGHT",
            "start_line": 16,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-11-28T17:14:39Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862516138",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1862517230"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862517230"
                }
            },
            "author_association": "MEMBER",
            "body": "Hmm, yeah I think that might be better.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-28T17:15:53Z",
            "diff_hunk": "@@ -0,0 +1,404 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+---@param kind lsp.FoldingRangeKind Kind to close, one of \"comment\", \"imports\" or \"region\".\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+\n+  if bufstate.version == util.buf_versions[bufnr] then\n+    foldclose(kind, winid)\n+    return\n+  end\n+  -- Schedule `foldclose()` if the buffer is not up-to-date.\n+\n+  --- Index in the form of request_id -> true?\n+  ---@type table<integer, true?>\n+  local scheduled_request = {}\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    local request_id = request(bufnr, client)\n+    if request_id then\n+      scheduled_request[request_id] = true\n+    end\n+  end\n+\n+  api.nvim_create_autocmd('LspRequest', {\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local request_id = args.data.request_id\n+      if scheduled_request[request_id] and args.data.request.type == 'complete' then\n+        scheduled_request[request_id] = nil\n+      end\n+      -- Do `foldclose()` if all the requests is completed.\n+      if next(scheduled_request) == nil then\n+        foldclose(kind, winid)\n+        return true\n+      end\n+    end,\n+  })",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1862517230",
            "id": 1862517230,
            "in_reply_to_id": 1862458699,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vA8Hu",
            "original_commit_id": "98fd2d6b0ea04a196f638aa17071a80f6260e312",
            "original_line": 375,
            "original_position": 375,
            "original_start_line": 349,
            "path": "runtime/lua/vim/lsp/_folding_range.lua",
            "position": null,
            "pull_request_review_id": 2468618460,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862517230/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-11-28T17:15:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862517230",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1862530713"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862530713"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Yes, this can be done; I didn't add `client_ranges` to handle multiple clients before.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-28T17:30:32Z",
            "diff_hunk": "@@ -0,0 +1,404 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1862530713",
            "id": 1862530713,
            "in_reply_to_id": 1862445820,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vA_aZ",
            "original_commit_id": "98fd2d6b0ea04a196f638aa17071a80f6260e312",
            "original_line": 250,
            "original_position": 250,
            "original_start_line": 248,
            "path": "runtime/lua/vim/lsp/_folding_range.lua",
            "position": null,
            "pull_request_review_id": 2468634235,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862530713/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-11-28T17:30:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862530713",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1862531364"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862531364"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Okay, I will add another `lsp.MultiHandler` and reduce the number of calls to `foldupdate`.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-28T17:31:17Z",
            "diff_hunk": "@@ -0,0 +1,404 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      for _, client in\n+        ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+      do\n+        request(bufnr, client)\n+      end\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 then\n+        if api.nvim_buf_is_loaded(bufnr) then\n+          bufstates[bufnr] = {\n+            client_ranges = {},\n+            row_level = {},\n+            row_kinds = {},\n+            row_text = {},\n+          }\n+          foldupdate(bufnr)\n+        end\n+      else\n+        for _, client in ipairs(clients) do\n+          request(bufnr, client)\n+        end\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    request(bufnr, client)\n+  end\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })\n+\n+---@param kind lsp.FoldingRangeKind\n+---@param winid integer\n+local function foldclose(kind, winid)\n+  vim._with({ win = winid }, function()\n+    local bufnr = api.nvim_win_get_buf(winid)\n+    local row_kinds = bufstates[bufnr].row_kinds\n+    -- Reverse traverse to ensure that the smallest ranges are closed first.\n+    for row = api.nvim_buf_line_count(bufnr) - 1, 0, -1 do\n+      local kinds = row_kinds[row]\n+      if kinds and kinds[kind] then\n+        vim.cmd(row + 1 .. 'foldclose')\n+      end\n+    end\n+  end)\n+end\n+\n+---@param kind lsp.FoldingRangeKind Kind to close, one of \"comment\", \"imports\" or \"region\".\n+---@param winid? integer Defaults to the current window.\n+function M.foldclose(kind, winid)\n+  vim.validate('kind', kind, 'string')\n+  vim.validate('winid', winid, 'number', true)\n+\n+  winid = winid or api.nvim_get_current_win()\n+  local bufnr = api.nvim_win_get_buf(winid)\n+  local bufstate = bufstates[bufnr]\n+  if not bufstate then\n+    return\n+  end\n+\n+  if bufstate.version == util.buf_versions[bufnr] then\n+    foldclose(kind, winid)\n+    return\n+  end\n+  -- Schedule `foldclose()` if the buffer is not up-to-date.\n+\n+  --- Index in the form of request_id -> true?\n+  ---@type table<integer, true?>\n+  local scheduled_request = {}\n+  for _, client in\n+    ipairs(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+  do\n+    local request_id = request(bufnr, client)\n+    if request_id then\n+      scheduled_request[request_id] = true\n+    end\n+  end\n+\n+  api.nvim_create_autocmd('LspRequest', {\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local request_id = args.data.request_id\n+      if scheduled_request[request_id] and args.data.request.type == 'complete' then\n+        scheduled_request[request_id] = nil\n+      end\n+      -- Do `foldclose()` if all the requests is completed.\n+      if next(scheduled_request) == nil then\n+        foldclose(kind, winid)\n+        return true\n+      end\n+    end,\n+  })",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1862531364",
            "id": 1862531364,
            "in_reply_to_id": 1862458699,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vA_kk",
            "original_commit_id": "98fd2d6b0ea04a196f638aa17071a80f6260e312",
            "original_line": 375,
            "original_position": 375,
            "original_start_line": 349,
            "path": "runtime/lua/vim/lsp/_folding_range.lua",
            "position": null,
            "pull_request_review_id": 2468635064,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862531364/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-11-28T17:31:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862531364",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1862534602"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862534602"
                }
            },
            "author_association": "MEMBER",
            "body": "Oh, I didn't realize luals doesn't do that by default.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-28T17:34:58Z",
            "diff_hunk": "@@ -0,0 +1,404 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1862534602",
            "id": 1862534602,
            "in_reply_to_id": 1862436647,
            "line": 27,
            "node_id": "PRRC_kwDOAPphoM5vBAXK",
            "original_commit_id": "98fd2d6b0ea04a196f638aa17071a80f6260e312",
            "original_line": 27,
            "original_position": 27,
            "original_start_line": 16,
            "path": "runtime/lua/vim/lsp/_folding_range.lua",
            "position": 27,
            "pull_request_review_id": 2468638783,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862534602/reactions"
            },
            "side": "RIGHT",
            "start_line": 16,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2024-11-28T17:34:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862534602",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1862707452"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862707452"
                }
            },
            "author_association": "MEMBER",
            "body": "Needs updating.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-28T21:43:32Z",
            "diff_hunk": "@@ -697,6 +698,35 @@ commands                                                    *vim.lsp.commands*\n \n     The second argument is the `ctx` of |lsp-handler|\n \n+foldclose({kind}, {winid})                               *vim.lsp.foldclose()*\n+    Close all {kind} of folds in the the window with {winid}.\n+\n+    To automatically fold imports when opening a file, you can use an autocmd: >lua\n+        vim.api.nvim_create_autocmd('LspNotify', {\n+          callback = function(args)\n+            if args.data.method == 'textDocument/didOpen' then\n+              vim.lsp.folding_range.foldclose('imports', vim.fn.bufwinid(args.buf))",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1862707452",
            "id": 1862707452,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vBqj8",
            "original_commit_id": "97b50efeda0a44a40b95d8347bfe4e836ebc5b78",
            "original_line": 708,
            "original_position": 19,
            "original_start_line": null,
            "path": "runtime/doc/lsp.txt",
            "position": null,
            "pull_request_review_id": 2468834161,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862707452/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-28T21:50:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862707452",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1862709163"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862709163"
                }
            },
            "author_association": "MEMBER",
            "body": "Can you implement this so it calls `multi_handler` to eliminate the code duplication? In fact you could probably inline that directly since it should only be a few lines.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-28T21:46:47Z",
            "diff_hunk": "@@ -0,0 +1,400 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1862709163",
            "id": 1862709163,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vBq-r",
            "original_commit_id": "97b50efeda0a44a40b95d8347bfe4e836ebc5b78",
            "original_line": 112,
            "original_position": 112,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/_folding_range.lua",
            "position": null,
            "pull_request_review_id": 2468834161,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862709163/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-28T21:50:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862709163",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1862710663"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862710663"
                }
            },
            "author_association": "MEMBER",
            "body": "This block can be removed for now. If we add it then it shouldn't try and compare the value of foldexpr.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-28T21:49:34Z",
            "diff_hunk": "@@ -0,0 +1,400 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)\n+  if err then\n+    log.error(err)\n+    return\n+  end\n+\n+  local bufnr = assert(ctx.bufnr)\n+  -- Handling responses from outdated buffer only causes performance overhead.\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  bufstate.client_ranges[ctx.client_id] = result\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+---@param results table<integer,{err: lsp.ResponseError?, result: lsp.FoldingRange[]?}>\n+---@type lsp.MultiHandler\n+local function multi_handler(results, ctx)\n+  local bufnr = assert(ctx.bufnr)\n+  if util.buf_versions[bufnr] ~= ctx.version then\n+    return\n+  end\n+\n+  local bufstate = assert(bufstates[bufnr])\n+  for client_id, result in ipairs(results) do\n+    if result.err then\n+      log.error(result.err)\n+    else\n+      bufstate.client_ranges[client_id] = result.result\n+    end\n+  end\n+  bufstate.version = ctx.version\n+\n+  if api.nvim_get_mode().mode:match('^i') then\n+    -- `foldUpdate()` is guarded in insert mode.\n+    schedule_foldupdate(bufnr)\n+  else\n+    foldupdate(bufnr)\n+  end\n+end\n+\n+--- Request `textDocument/foldingRange` from the server.\n+--- `foldupdate()` is scheduled once after the request is completed.\n+---@param bufnr integer\n+---@param client? vim.lsp.Client The client whose server supports `foldingRange`.\n+---@return integer? request_id\n+local function request(bufnr, client)\n+  ---@type lsp.FoldingRangeParams\n+  local params = { textDocument = util.make_text_document_params(bufnr) }\n+  if not client then\n+    vim.lsp.buf_request_all(bufnr, ms.textDocument_foldingRange, params, multi_handler)\n+    return\n+  end\n+  local _, request_id = client:request(ms.textDocument_foldingRange, params, handler, bufnr)\n+  return request_id\n+end\n+\n+-- NOTE:\n+-- `bufstate` and event hooks are interdependent:\n+-- * `bufstate` needs event hooks for correctness.\n+-- * event hooks require the previous `bufstate` for updates.\n+-- Since they are manually created and destroyed,\n+-- we ensure their lifecycles are always synchronized.\n+local augroup_setup = api.nvim_create_augroup('vim_lsp_folding_range/setup', {})\n+\n+--- Initialize `bufstate` and event hooks, then request folding ranges.\n+--- Manage their lifecycle within this function.\n+---@param bufnr integer\n+---@return vim.lsp.folding_range.BufState?\n+local function setup(bufnr)\n+  if not api.nvim_buf_is_loaded(bufnr) then\n+    return\n+  end\n+\n+  -- Register the new `bufstate`.\n+  bufstates[bufnr] = {\n+    client_ranges = {},\n+    row_level = {},\n+    row_kinds = {},\n+    row_text = {},\n+  }\n+\n+  -- Event hooks from `buf_attach` can't be removed externally.\n+  -- Hooks and `bufstate` share the same lifecycle;\n+  -- they should self-destroy if `bufstate == nil`.\n+  api.nvim_buf_attach(bufnr, false, {\n+    -- `on_detach` also runs on buffer reload (`:e`).\n+    -- Ensure `bufstate` and hooks are cleared to avoid duplication or leftover states.\n+    on_detach = function()\n+      bufstates[bufnr] = nil\n+      api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+    end,\n+    -- Reset `bufstate` and request folding ranges.\n+    on_reload = function()\n+      bufstates[bufnr] = {\n+        client_ranges = {},\n+        row_level = {},\n+        row_kinds = {},\n+        row_text = {},\n+      }\n+      request(bufnr)\n+    end,\n+    --- Sync changed rows with their previous foldlevels before applying new ones.\n+    on_bytes = function(_, _, _, start_row, _, _, old_row, _, _, new_row, _, _)\n+      if bufstates[bufnr] == nil then\n+        return true\n+      end\n+      local row_level = bufstates[bufnr].row_level\n+      if next(row_level) == nil then\n+        return\n+      end\n+      local row = new_row - old_row\n+      if row > 0 then\n+        vim._list_insert(row_level, start_row, start_row + math.abs(row) - 1, { -1 })\n+        -- If the previous row ends a fold,\n+        -- Nvim treats the first row after consecutive `-1`s as a new fold start,\n+        -- which is not the desired behavior.\n+        local prev_level = row_level[start_row - 1]\n+        if prev_level and prev_level[2] == '<' then\n+          row_level[start_row] = { prev_level[1] - 1 }\n+        end\n+      elseif row < 0 then\n+        vim._list_remove(row_level, start_row, start_row + math.abs(row) - 1)\n+      end\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspDetach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      ---@type integer\n+      local client_id = args.data.client_id\n+      bufstates[bufnr].client_ranges[client_id] = nil\n+\n+      ---@type vim.lsp.Client[]\n+      local clients = vim\n+        .iter(vim.lsp.get_clients({ bufnr = bufnr, method = ms.textDocument_foldingRange }))\n+        ---@param client vim.lsp.Client\n+        :filter(function(client)\n+          return client.id ~= client_id\n+        end)\n+        :totable()\n+      if #clients == 0 and api.nvim_buf_is_loaded(bufnr) then\n+        bufstates[bufnr] = {\n+          client_ranges = {},\n+          row_level = {},\n+          row_kinds = {},\n+          row_text = {},\n+        }\n+      end\n+\n+      foldupdate(bufnr)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspAttach', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      request(bufnr, client)\n+    end,\n+  })\n+  api.nvim_create_autocmd('LspNotify', {\n+    group = augroup_setup,\n+    buffer = bufnr,\n+    callback = function(args)\n+      local client = assert(vim.lsp.get_client_by_id(args.data.client_id))\n+      if\n+        client:supports_method(ms.textDocument_foldingRange, bufnr)\n+        and (\n+          args.data.method == ms.textDocument_didChange\n+          or args.data.method == ms.textDocument_didOpen\n+        )\n+      then\n+        request(bufnr, client)\n+      end\n+    end,\n+  })\n+\n+  request(bufnr)\n+\n+  return bufstates[bufnr]\n+end\n+\n+-- The \"garbage collector\" for `bufstate` and its associated event hooks.\n+-- See the comment above `augroup_setup` function for more details.\n+--\n+-- It will be fine without this, as the bufstate and event hooks will also\n+-- be cleared when the buffer is unloaded.\n+-- api.nvim_create_autocmd('OptionSet', {\n+--   group = augroup_setup,\n+--   pattern = 'foldexpr',\n+--   callback = function()\n+--     -- Sould find a more reliable way to detect changes in `foldexpr`.\n+--     if vim.v.option_old == 'v:lua.vim.lsp.foldexpr()' then\n+--       for bufnr in pairs(bufstates) do\n+--         if\n+--           ---@param winid integer\n+--           vim.iter(vim.fn.win_findbuf(bufnr)):all(function(winid)\n+--             return vim.wo[winid].foldexpr ~= 'v:lua.vim.lsp.foldexpr()'\n+--           end)\n+--         then\n+--           bufstates[bufnr] = nil\n+--           api.nvim_clear_autocmds({ buffer = bufnr, group = augroup_setup })\n+--         end\n+--       end\n+--     end\n+--   end,\n+-- })",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1862710663",
            "id": 1862710663,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vBrWH",
            "original_commit_id": "97b50efeda0a44a40b95d8347bfe4e836ebc5b78",
            "original_line": 329,
            "original_position": 329,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/_folding_range.lua",
            "position": null,
            "pull_request_review_id": 2468834161,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862710663/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-28T21:50:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862710663",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1862867709"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862867709"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Indeed, code redundancy should be reduced. It is for a general purpose so I did not inline it.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-29T02:51:50Z",
            "diff_hunk": "@@ -0,0 +1,400 @@\n+local util = require('vim.lsp.util')\n+local log = require('vim.lsp.log')\n+local ms = require('vim.lsp.protocol').Methods\n+local api = vim.api\n+\n+local M = {}\n+\n+---@class (private) vim.lsp.folding_range.BufState\n+---\n+---@field version? integer\n+---\n+--- Never use this directly, `renew()` the cached foldinfo\n+--- then use on demand via `row_*` fields.\n+---\n+--- Index In the form of client_id -> ranges\n+---@field client_ranges table<integer, lsp.FoldingRange[]?>\n+---\n+--- Index in the form of row -> [foldlevel, mark]\n+---@field row_level table<integer, [integer, \">\" | \"<\"?]?>\n+---\n+--- Index in the form of start_row -> kinds\n+---@field row_kinds table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+---\n+--- Index in the form of start_row -> collapsed_text\n+---@field row_text table<integer, string?>\n+\n+---@type table<integer, vim.lsp.folding_range.BufState?>\n+local bufstates = {}\n+\n+--- Renew the cached foldinfo in the buffer.\n+---@param bufnr integer\n+local function renew(bufnr)\n+  local bufstate = assert(bufstates[bufnr])\n+\n+  ---@type table<integer, [integer, \">\" | \"<\"?]?>\n+  local row_level = {}\n+  ---@type table<integer, table<lsp.FoldingRangeKind, true?>?>>\n+  local row_kinds = {}\n+  ---@type table<integer, string?>\n+  local row_text = {}\n+\n+  for _, ranges in pairs(bufstate.client_ranges) do\n+    for _, range in ipairs(ranges) do\n+      local start_row = range.startLine\n+      local end_row = range.endLine\n+      -- Adding folds within a single line is not supported by Nvim.\n+      if start_row ~= end_row then\n+        row_text[start_row] = range.collapsedText\n+\n+        local kind = range.kind\n+        if kind then\n+          local kinds = row_kinds[start_row] or {}\n+          kinds[kind] = true\n+          row_kinds[start_row] = kinds\n+        end\n+\n+        for row = start_row, end_row do\n+          local level = row_level[row] or { 0 }\n+          level[1] = level[1] + 1\n+          row_level[row] = level\n+        end\n+        row_level[start_row][2] = '>'\n+        row_level[end_row][2] = '<'\n+      end\n+    end\n+  end\n+\n+  bufstate.row_level = row_level\n+  bufstate.row_kinds = row_kinds\n+  bufstate.row_text = row_text\n+end\n+\n+--- Renew the cached foldinfo then force `foldexpr()` to be re-evaluated,\n+--- without opening folds.\n+---@param bufnr integer\n+local function foldupdate(bufnr)\n+  renew(bufnr)\n+  for _, winid in ipairs(vim.fn.win_findbuf(bufnr)) do\n+    local wininfo = vim.fn.getwininfo(winid)[1]\n+    if wininfo and wininfo.tabnr == vim.fn.tabpagenr() then\n+      if vim.wo[winid].foldmethod == 'expr' then\n+        vim._foldupdate(winid, 0, api.nvim_buf_line_count(bufnr))\n+      end\n+    end\n+  end\n+end\n+\n+--- Whether `foldupdate()` is scheduled for the buffer with `bufnr`.\n+---\n+--- Index in the form of bufnr -> true?\n+---@type table<integer, true?>\n+local scheduled_foldupdate = {}\n+\n+--- Schedule `foldupdate()` after leaving insert mode.\n+---@param bufnr integer\n+local function schedule_foldupdate(bufnr)\n+  if not scheduled_foldupdate[bufnr] then\n+    scheduled_foldupdate[bufnr] = true\n+    api.nvim_create_autocmd('InsertLeave', {\n+      buffer = bufnr,\n+      once = true,\n+      callback = function()\n+        foldupdate(bufnr)\n+        scheduled_foldupdate[bufnr] = nil\n+      end,\n+    })\n+  end\n+end\n+\n+---@param result lsp.FoldingRange[]?\n+---@type lsp.Handler\n+local function handler(err, result, ctx)",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1862867709",
            "id": 1862867709,
            "in_reply_to_id": 1862709163,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vCRr9",
            "original_commit_id": "97b50efeda0a44a40b95d8347bfe4e836ebc5b78",
            "original_line": 112,
            "original_position": 112,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/_folding_range.lua",
            "position": null,
            "pull_request_review_id": 2468998084,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862867709/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-29T02:51:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1862867709",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1863311880"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1863311880"
                }
            },
            "author_association": "MEMBER",
            "body": "Can we avoid doing this and just use `get_clients` to check for unsupported before calling `buf_request_all`?",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-29T10:32:22Z",
            "diff_hunk": "@@ -928,10 +930,13 @@ end\n ---               Can also be passed as a function that returns the params table for cases where\n ---               parameters are specific to the client.\n ---@param handler lsp.MultiHandler (function)\n---- Handler called after all requests are completed. Server results are passed as\n---- a `client_id:result` map.\n+---       Handler called after all requests are completed. Server results are passed as\n+---       a `client_id:result` map.\n+---@param on_unsupported? fun()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1863311880",
            "id": 1863311880,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vD-II",
            "original_commit_id": "3ca63d4ed2dbe2096bb1c0710fc7e5e60d99b0e5",
            "original_line": 935,
            "original_position": 24,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp.lua",
            "position": null,
            "pull_request_review_id": 2469606594,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1863311880/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-29T10:32:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1863311880",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1863318104"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1863318104"
                }
            },
            "author_association": "MEMBER",
            "body": "Also note, many of the functions in `lsp/buf.lua` don't use `buf_request_all` and simply call all the clients manually:\r\n\r\n```lua\r\nfunction M.references(context, opts)\r\n  validate('context', context, 'table', true)\r\n  local bufnr = api.nvim_get_current_buf()\r\n  local clients = lsp.get_clients({ method = ms.textDocument_references, bufnr = bufnr })\r\n  if not next(clients) then\r\n    return\r\n  end\r\n  local win = api.nvim_get_current_win()\r\n\r\n  local all_items = {}\r\n\r\n  local function on_done()\r\n    if not next(all_items) then\r\n      vim.notify('No references found')\r\n    else\r\n      ...\r\n    end\r\n  end\r\n\r\n  local remaining = #clients\r\n  for _, client in ipairs(clients) do\r\n    local params = ...\r\n    client:request(ms.textDocument_references, params, function(_, result)\r\n      local items = util.locations_to_items(result or {}, client.offset_encoding)\r\n      vim.list_extend(all_items, items)\r\n      remaining = remaining - 1\r\n      if remaining == 0 then\r\n        on_done()\r\n      end\r\n    end)\r\n  end\r\nend\r\n```\r\n\r\nSo pick your poison. Eventually I plan to refactor this pattern out anyway,  so don't overthink it, just avoid extending any API.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-29T10:36:56Z",
            "diff_hunk": "@@ -928,10 +930,13 @@ end\n ---               Can also be passed as a function that returns the params table for cases where\n ---               parameters are specific to the client.\n ---@param handler lsp.MultiHandler (function)\n---- Handler called after all requests are completed. Server results are passed as\n---- a `client_id:result` map.\n+---       Handler called after all requests are completed. Server results are passed as\n+---       a `client_id:result` map.\n+---@param on_unsupported? fun()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1863318104",
            "id": 1863318104,
            "in_reply_to_id": 1863311880,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vD_pY",
            "original_commit_id": "3ca63d4ed2dbe2096bb1c0710fc7e5e60d99b0e5",
            "original_line": 935,
            "original_position": 24,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp.lua",
            "position": null,
            "pull_request_review_id": 2469615582,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1863318104/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-29T10:36:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1863318104",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1863379922"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1863379922"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "Okay, sorry I don't know about these plans. Will `lsp.MultiHandler` be retained? `vim.lsp.buf_request_all` seems to be its only usage.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-29T11:25:13Z",
            "diff_hunk": "@@ -928,10 +930,13 @@ end\n ---               Can also be passed as a function that returns the params table for cases where\n ---               parameters are specific to the client.\n ---@param handler lsp.MultiHandler (function)\n---- Handler called after all requests are completed. Server results are passed as\n---- a `client_id:result` map.\n+---       Handler called after all requests are completed. Server results are passed as\n+---       a `client_id:result` map.\n+---@param on_unsupported? fun()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1863379922",
            "id": 1863379922,
            "in_reply_to_id": 1863311880,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vEOvS",
            "original_commit_id": "3ca63d4ed2dbe2096bb1c0710fc7e5e60d99b0e5",
            "original_line": 935,
            "original_position": 24,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp.lua",
            "position": null,
            "pull_request_review_id": 2469704767,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1863379922/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-29T11:43:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1863379922",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/31311#discussion_r1863403769"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/31311"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1863403769"
                }
            },
            "author_association": "MEMBER",
            "body": "Yes `vim.lsp.buf_request_all` and `lsp.MultiHandler` will remain, but any changes to them is TBD.",
            "commit_id": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
            "created_at": "2024-11-29T11:46:22Z",
            "diff_hunk": "@@ -928,10 +930,13 @@ end\n ---               Can also be passed as a function that returns the params table for cases where\n ---               parameters are specific to the client.\n ---@param handler lsp.MultiHandler (function)\n---- Handler called after all requests are completed. Server results are passed as\n---- a `client_id:result` map.\n+---       Handler called after all requests are completed. Server results are passed as\n+---       a `client_id:result` map.\n+---@param on_unsupported? fun()",
            "html_url": "https://github.com/neovim/neovim/pull/31311#discussion_r1863403769",
            "id": 1863403769,
            "in_reply_to_id": 1863311880,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5vEUj5",
            "original_commit_id": "3ca63d4ed2dbe2096bb1c0710fc7e5e60d99b0e5",
            "original_line": 935,
            "original_position": 24,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp.lua",
            "position": null,
            "pull_request_review_id": 2469739169,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1863403769/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-11-29T11:46:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1863403769",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "Could we add some tests? 😸 ",
            "created_at": "2024-11-23T03:48:10Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2495280398",
            "id": 2495280398,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6UuvUO",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495280398/reactions"
            },
            "updated_at": "2024-11-23T03:48:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495280398",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I have added tests for all the new APIs in this PR. This PR is now ready to be merged (or reviewed, of course).",
            "created_at": "2024-11-23T10:04:57Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2495424681",
            "id": 2495424681,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6UvSip",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495424681/reactions"
            },
            "updated_at": "2024-11-23T10:04:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495424681",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "For the somewhat controversial bufstate and callback cleanup mentioned above, I pushed an update to try to control them more granularly, and I detailed the expected behavior in the comments.",
            "created_at": "2024-11-24T10:16:11Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2495920511",
            "id": 2495920511,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6UxLl_",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495920511/reactions"
            },
            "updated_at": "2024-11-24T10:16:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495920511",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I pushed a new update that, in addition to changing the code marked as `resolved` above, includes an additional change that adjusts the data structure required for `foldclose` to make it ready to support multiple clients while also ensuring that the smallest range is prioritized for closing. Prioritizing the closing of the smallest range makes sense because after closing a larger range, vim will not close the smaller ranges within it. This broadens the applicability of `foldclose`.\r\n\r\nThis change can easily allow `foldclose()` to gain support for range parameters, but I haven't seen a clear use for this functionality, so I haven't exposed it. If you need it, please let me know.",
            "created_at": "2024-11-24T12:06:21Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2495966555",
            "id": 2495966555,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6UxW1b",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495966555/reactions"
            },
            "updated_at": "2024-11-24T12:18:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495966555",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "The reason for having the same lifecycle for bufstate and its related callbacks is that they are interdependent. If their lifecycles are not the same, then any error on one side will lead to issues on the other side. If the code on one side is changed, it may cause errors in the code on the other side. In reality, this would result in an indirect recursion of continuously reporting errors; we might just happen to be at a certain moment, but new errors will arise in the future. I believe we should consider their lifecycle management based on ensuring that their lifecycles are the same, as finding a way that perfectly covers all situations is very risky.",
            "created_at": "2024-11-24T12:28:26Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2495974326",
            "id": 2495974326,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6UxYu2",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495974326/reactions"
            },
            "updated_at": "2024-11-24T17:13:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2495974326",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "@lewis6991 Thank you so much for your patient review. I apologize if I’ve wasted your time. I’ve revisited the management of these lifecycles and added tests to cover them, ensuring that callbacks are destroyed when the buffer is unloaded and avoiding duplicate creation on the same buffer. I’d appreciate any suggestions if you have the time to review it again.\r\n\r\nI am currently working on implementing support for multiple clients. ",
            "created_at": "2024-11-25T15:22:27Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2498315835",
            "id": 2498315835,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6U6UY7",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 3,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2498315835/reactions"
            },
            "updated_at": "2024-11-25T15:22:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2498315835",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "> Would it make sense for `setup()` to early return when there are no supported clients, and additionally set `bufstate=nil` in `LspDetach` so we detach from the buffer on the next `on_bytes` call. Then every subsequent call to `foldexpr()` will early return until a supported client becomes available which we then we re-attach to the buffer?\r\n\r\nIt works in most cases, but there are still some edge cases. The main issue is that we cannot guarantee that `foldexpr()` will be executed after a new LSP attach. For example, when a newly started nvim opens its first buffer, `foldexpr()` will be executed immediately, but it has not been LSP attached yet, so bufstate will not be. After a very short time, the LSP attach completes, but at this point, `foldexpr()` is unlikely to be executed again, the folds in the buffer keep outdated unless modifying the buffer or using something like `zx` after that. This issue can be resolved with an additional `LspAttach` autocmd, but I'm not sure because if a new autocmd is created, we also need to consider how to destroy it unless it is global, and if there are other edge cases.\r\n\r\nHowever, I really hope to find a reliable way to achieve this, as it almost implements the `vim.lsp._state` I suggested in https://github.com/neovim/neovim/pull/30841#issuecomment-2421066482. As long as the buffer is enabled and contains a client that supports the corresponding method, it will have the corresponding `bufstate` and callback function; otherwise, everything will be cleaned up.",
            "created_at": "2024-11-26T02:16:01Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2499497904",
            "id": 2499497904,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6U-0-w",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2499497904/reactions"
            },
            "updated_at": "2024-11-26T07:16:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2499497904",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I pushed support for multiple clients, so I marked the related reviews above as resolved.\r\n\r\nRebased to the master branch, now ready to be merged or reviewed again.",
            "created_at": "2024-11-26T09:25:27Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2500091148",
            "id": 2500091148,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6VBF0M",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2500091148/reactions"
            },
            "updated_at": "2024-11-26T15:29:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2500091148",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I pushed the changes for the comments above. I also changed a test because it depends on the behavior that `LspRequest` will not be triggered in the test environment.",
            "created_at": "2024-11-28T18:31:39Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2506630007",
            "id": 2506630007,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6VaCN3",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2506630007/reactions"
            },
            "updated_at": "2024-11-28T18:46:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2506630007",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "I revisited the code and found that `vim.lsp.buf_request_all` notifies an error when there are no supported clients in the buffer, which is not the behavior we expect. Therefore, I exposed the `on_unsupported` parameter for `vim.lsp.buf_request_all`, partly to keep it in sync with the parameters of `vim.lsp.buf_request`. I kept this change in a separate commit, so please note if the commits in this PR need to be squashed.",
            "created_at": "2024-11-29T04:04:40Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2507053872",
            "id": 2507053872,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6Vbpsw",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2507053872/reactions"
            },
            "updated_at": "2024-11-29T04:04:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2507053872",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "Feel free to ping me if there are any issue related!",
            "created_at": "2024-11-30T11:30:51Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2508930288",
            "id": 2508930288,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6Vizzw",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 4,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2508930288/reactions"
            },
            "updated_at": "2024-11-30T11:30:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2508930288",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "NONE",
            "body": "```\r\nError executing vim.schedule lua callback: ...7841_1/share/nvim/runtime/lua/vim/lsp/_folding_range.lua:119: assertion failed!\r\nstack traceback:\r\n        [C]: in function 'assert'\r\n        ...7841_1/share/nvim/runtime/lua/vim/lsp/_folding_range.lua:119: in function 'multi_handler'\r\n        ...7841_1/share/nvim/runtime/lua/vim/lsp/_folding_range.lua:140: in function 'handler'\r\n        ...HEAD-c137841_1/share/nvim/runtime/lua/vim/lsp/client.lua:669: in function ''\r\n        vim/_editor.lua: in function <vim/_editor.lua:0>\r\n\r\n```",
            "created_at": "2024-12-02T09:38:08Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2511024970",
            "id": 2511024970,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6VqzNK",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2511024970/reactions"
            },
            "updated_at": "2024-12-02T10:01:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2511024970",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/50194671?v=4",
                "events_url": "https://api.github.com/users/edte/events{/privacy}",
                "followers_url": "https://api.github.com/users/edte/followers",
                "following_url": "https://api.github.com/users/edte/following{/other_user}",
                "gists_url": "https://api.github.com/users/edte/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/edte",
                "id": 50194671,
                "login": "edte",
                "node_id": "MDQ6VXNlcjUwMTk0Njcx",
                "organizations_url": "https://api.github.com/users/edte/orgs",
                "received_events_url": "https://api.github.com/users/edte/received_events",
                "repos_url": "https://api.github.com/users/edte/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/edte/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/edte/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/edte",
                "user_view_type": "public"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Please open a  new issue with minimal reproducing steps.",
            "created_at": "2024-12-02T09:54:47Z",
            "html_url": "https://github.com/neovim/neovim/pull/31311#issuecomment-2511063858",
            "id": 2511063858,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
            "node_id": "IC_kwDOAPphoM6Vq8sy",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2511063858/reactions"
            },
            "updated_at": "2024-12-02T09:54:47Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/2511063858",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason",
                "user_view_type": "public"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/31311/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/31311/commits",
    "created_at": "2024-11-22T13:23:46Z",
    "diff_url": "https://github.com/neovim/neovim/pull/31311.diff",
    "draft": false,
    "head": {
        "label": "ofseed:lsp-fold",
        "ref": "lsp-fold",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/ofseed/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/ofseed/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/ofseed/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/ofseed/neovim/branches{/branch}",
            "clone_url": "https://github.com/ofseed/neovim.git",
            "collaborators_url": "https://api.github.com/repos/ofseed/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/ofseed/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/ofseed/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/ofseed/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/ofseed/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/ofseed/neovim/contributors",
            "created_at": "2021-11-30T18:13:03Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/ofseed/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/ofseed/neovim/downloads",
            "events_url": "https://api.github.com/repos/ofseed/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/ofseed/neovim/forks",
            "full_name": "ofseed/neovim",
            "git_commits_url": "https://api.github.com/repos/ofseed/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/ofseed/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/ofseed/neovim/git/tags{/sha}",
            "git_url": "git://github.com/ofseed/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/ofseed/neovim/hooks",
            "html_url": "https://github.com/ofseed/neovim",
            "id": 433537354,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/ofseed/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/ofseed/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/ofseed/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/ofseed/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/ofseed/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/ofseed/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/ofseed/neovim/merges",
            "milestones_url": "https://api.github.com/repos/ofseed/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOGddBSg",
            "notifications_url": "https://api.github.com/repos/ofseed/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
                "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
                "followers_url": "https://api.github.com/users/ofseed/followers",
                "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
                "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/ofseed",
                "id": 61115159,
                "login": "ofseed",
                "node_id": "MDQ6VXNlcjYxMTE1MTU5",
                "organizations_url": "https://api.github.com/users/ofseed/orgs",
                "received_events_url": "https://api.github.com/users/ofseed/received_events",
                "repos_url": "https://api.github.com/users/ofseed/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/ofseed",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/ofseed/neovim/pulls{/number}",
            "pushed_at": "2024-12-01T17:00:25Z",
            "releases_url": "https://api.github.com/repos/ofseed/neovim/releases{/id}",
            "size": 290398,
            "ssh_url": "git@github.com:ofseed/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/ofseed/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/ofseed/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/ofseed/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/ofseed/neovim/subscription",
            "svn_url": "https://github.com/ofseed/neovim",
            "tags_url": "https://api.github.com/repos/ofseed/neovim/tags",
            "teams_url": "https://api.github.com/repos/ofseed/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/ofseed/neovim/git/trees{/sha}",
            "updated_at": "2024-11-29T12:50:17Z",
            "url": "https://api.github.com/repos/ofseed/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "9c7db37d316703e4fee0e6c0619c055f76614a3a",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
            "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
            "followers_url": "https://api.github.com/users/ofseed/followers",
            "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
            "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/ofseed",
            "id": 61115159,
            "login": "ofseed",
            "node_id": "MDQ6VXNlcjYxMTE1MTU5",
            "organizations_url": "https://api.github.com/users/ofseed/orgs",
            "received_events_url": "https://api.github.com/users/ofseed/received_events",
            "repos_url": "https://api.github.com/users/ofseed/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/ofseed",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/31311",
    "id": 2194715647,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/31311",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": null,
            "id": 662566370,
            "name": "lsp",
            "node_id": "MDU6TGFiZWw2NjI1NjYzNzA=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lsp"
        }
    ],
    "locked": true,
    "merge_commit_sha": "a1e313ded6e4c46c58012639e5c0c6d0b009d52a",
    "merged_at": "2024-11-29T12:40:32Z",
    "milestone": null,
    "node_id": "PR_kwDOAPphoM6C0LP_",
    "number": 31311,
    "patch_url": "https://github.com/neovim/neovim/pull/31311.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/31311/comments",
    "state": "closed",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/9c7db37d316703e4fee0e6c0619c055f76614a3a",
    "title": "feat(lsp): support `textDocument/foldingRange`",
    "updated_at": "2024-12-02T10:01:38Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/31311",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/61115159?v=4",
        "events_url": "https://api.github.com/users/ofseed/events{/privacy}",
        "followers_url": "https://api.github.com/users/ofseed/followers",
        "following_url": "https://api.github.com/users/ofseed/following{/other_user}",
        "gists_url": "https://api.github.com/users/ofseed/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/ofseed",
        "id": 61115159,
        "login": "ofseed",
        "node_id": "MDQ6VXNlcjYxMTE1MTU5",
        "organizations_url": "https://api.github.com/users/ofseed/orgs",
        "received_events_url": "https://api.github.com/users/ofseed/received_events",
        "repos_url": "https://api.github.com/users/ofseed/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/ofseed/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/ofseed/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/ofseed",
        "user_view_type": "public"
    }
}