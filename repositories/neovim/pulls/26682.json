{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/26682/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/26682/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/26682"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/26682"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/26682/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/85954ac9959d3166f5ae6f81ea0cf43138d26d2c"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 5077,
            "forks_count": 5077,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1697,
            "open_issues_count": 1697,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2023-12-26T01:26:05Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 247838,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 72074,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2023-12-26T01:14:58Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 72074,
            "watchers_count": 72074,
            "web_commit_signoff_required": false
        },
        "sha": "d431a4d410f02af2039d7c98e4e33136fd1e4849",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim"
        }
    },
    "body": "- doc: move vim-variables to separate file\n- feat: generate types and docs for v variables\n",
    "closed_at": "2023-12-21T14:19:11Z",
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26682#discussion_r1432985320"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1432985320"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        \"setlocal\"   |:setlocal| or `:let l:xxx`\r\n        \"setglobal\"  |:setglobal| or `:let g:xxx`\r\n```",
            "commit_id": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
            "created_at": "2023-12-20T17:17:37Z",
            "diff_hunk": "@@ -0,0 +1,869 @@\n+local M = {}\n+\n+M.vars = {\n+  argv = {\n+    type = 'string[]',\n+    desc = [=[\n+      The command line arguments Vim was invoked with.  This is a\n+      list of strings.  The first item is the Vim command.\n+      See |v:progpath| for the command with full path.\n+    ]=],\n+  },\n+  char = {\n+    desc = [=[\n+      Argument for evaluating 'formatexpr' and used for the typed\n+      character when using <expr> in an abbreviation |:map-<expr>|.\n+      It is also used by the |InsertCharPre| and |InsertEnter| events.\n+    ]=],\n+  },\n+  charconvert_from = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file to be converted.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  charconvert_to = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file after conversion.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  cmdarg = {\n+    type = 'string[]',\n+    desc = [=[\n+      The extra arguments (\"++p\", \"++enc=\", \"++ff=\") given to a file\n+      read/write command.  This is set before an autocommand event\n+      for a file read/write command is triggered.  There is a\n+      leading space to make it possible to append this variable\n+      directly after the read/write command. Note: \"+cmd\" isn't\n+      included here, because it will be executed anyway.\n+    ]=],\n+  },\n+  collate = {\n+    type = 'string',\n+    desc = [=[\n+      The current locale setting for collation order of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current locale encoding.  Technical: it's the value of\n+      LC_COLLATE.  When not using a locale the value is \"C\".\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      See |multi-lang|.\n+    ]=],\n+  },\n+  cmdbang = {\n+    desc = [=[\n+      Set like v:cmdarg for a file read/write command.  When a \"!\"\n+      was used the value is 1, otherwise it is 0.  Note that this\n+      can only be used in autocommands.  For user commands |<bang>|\n+      can be used.\n+    ]=],\n+  },\n+  completed_item = {\n+    desc = [=[\n+      Dictionary containing the most recent |complete-items| after\n+      |CompleteDone|.  Empty if the completion failed, or after\n+      leaving and re-entering insert mode.\n+      Note: Plugins can modify the value to emulate the builtin\n+      |CompleteDone| event behavior.\n+    ]=],\n+  },\n+  count = {\n+    type = 'integer',\n+    desc = [=[\n+      The count given for the last Normal mode command.  Can be used\n+      to get the count before a mapping.  Read-only.  Example: >vim\n+        :map _x :<C-U>echo \"the count is \" .. v:count<CR>\n+      <\n+      Note: The <C-U> is required to remove the line range that you\n+      get when typing ':' after a count.\n+      When there are two counts, as in \"3d2w\", they are multiplied,\n+      just like what happens in the command, \"d6w\" for the example.\n+      Also used for evaluating the 'formatexpr' option.\n+    ]=],\n+  },\n+  count1 = {\n+    type = 'integer',\n+    desc = [=[\n+      Just like \"v:count\", but defaults to one when no count is\n+      used.\n+    ]=],\n+  },\n+  ctype = {\n+    desc = [=[\n+      The current locale setting for characters of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current locale encoding.  Technical: it's the value of\n+      LC_CTYPE.  When not using a locale the value is \"C\".\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      See |multi-lang|.\n+    ]=],\n+  },\n+  dying = {\n+    type = 'integer',\n+    desc = [=[\n+      Normally zero.  When a deadly signal is caught it's set to\n+      one.  When multiple signals are caught the number increases.\n+      Can be used in an autocommand to check if Vim didn't\n+      terminate normally.\n+      Example: >vim\n+        :au VimLeave * if v:dying | echo \"\\nAAAAaaaarrrggghhhh!!!\\n\" | endif\n+      <\n+      Note: if another deadly signal is caught when v:dying is one,\n+      VimLeave autocommands will not be executed.\n+    ]=],\n+  },\n+  exiting = {\n+    desc = [=[\n+      Exit code, or |v:null| before invoking the |VimLeavePre|\n+      and |VimLeave| autocmds.  See |:q|, |:x| and |:cquit|.\n+      Example: >vim\n+        :au VimLeave * echo \"Exit value is \" .. v:exiting\n+      <\n+    ]=],\n+  },\n+  echospace = {\n+    type = 'integer',\n+    desc = [=[\n+      Number of screen cells that can be used for an `:echo` message\n+      in the last screen line before causing the |hit-enter-prompt|.\n+      Depends on 'showcmd', 'ruler' and 'columns'.  You need to\n+      check 'cmdheight' for whether there are full-width lines\n+      available above the last line.\n+    ]=],\n+  },\n+  errmsg = {\n+    type = 'string',\n+    desc = [=[\n+      Last given error message.\n+      Modifiable (can be set).\n+      Example: >vim\n+        let v:errmsg = \"\"\n+        silent! next\n+        if v:errmsg != \"\"\n+          ... handle error\n+      <\n+\n+    ]=],\n+  },\n+  errors = {\n+    tags = { 'assert-return' },\n+    desc = [=[\n+      Errors found by assert functions, such as |assert_true()|.\n+      This is a list of strings.\n+      The assert functions append an item when an assert fails.\n+      The return value indicates this: a one is returned if an item\n+      was added to v:errors, otherwise zero is returned.\n+      To remove old results make it empty: >vim\n+        :let v:errors = []\n+      <\n+      If v:errors is set to anything but a list it is made an empty\n+      list by the assert function.\n+    ]=],\n+  },\n+  event = {\n+    desc = [=[\n+      Dictionary of event data for the current |autocommand|.  Valid\n+      only during the event lifetime; storing or passing v:event is\n+      invalid!  Copy it instead: >vim\n+        au TextYankPost * let g:foo = deepcopy(v:event)\n+      <\n+      Keys vary by event; see the documentation for the specific\n+      event, e.g. |DirChanged| or |TextYankPost|.\n+        KEY              DESCRIPTION ~\n+        abort            Whether the event triggered during\n+                         an aborting condition (e.g. |c_Esc| or\n+                         |c_CTRL-C| for |CmdlineLeave|).\n+        chan             |channel-id|\n+        cmdlevel         Level of cmdline.\n+        cmdtype          Type of cmdline, |cmdline-char|.\n+        cwd              Current working directory.\n+        inclusive        Motion is |inclusive|, else exclusive.\n+        scope            Event-specific scope name.\n+        operator         Current |operator|.  Also set for Ex\n+        commands         (unlike |v:operator|). For\n+                         example if |TextYankPost| is triggered\n+                         by the |:yank| Ex command then\n+                         `v:event.operator` is \"y\".\n+        regcontents      Text stored in the register as a\n+                         |readfile()|-style list of lines.\n+        regname          Requested register (e.g \"x\" for \"xyy)\n+                         or the empty string for an unnamed\n+                         operation.\n+        regtype          Type of register as returned by\n+                         |getregtype()|.\n+        visual           Selection is visual (as opposed to,\n+                         e.g., via motion).\n+        completed_item   Current selected complete item on\n+                         |CompleteChanged|, Is `{}` when no complete\n+                         item selected.\n+        height           Height of popup menu on |CompleteChanged|\n+        width            Width of popup menu on |CompleteChanged|\n+        row              Row count of popup menu on |CompleteChanged|,\n+                         relative to screen.\n+        col              Col count of popup menu on |CompleteChanged|,\n+                         relative to screen.\n+        size             Total number of completion items on\n+                         |CompleteChanged|.\n+        scrollbar        Is |v:true| if popup menu have scrollbar, or\n+                         |v:false| if not.\n+        changed_window   Is |v:true| if the event fired while\n+        changing window  (or tab) on |DirChanged|.\n+        status           Job status or exit code, -1 means \"unknown\". |TermClose|\n+    ]=],\n+  },\n+  exception = {\n+    desc = [=[\n+      The value of the exception most recently caught and not\n+      finished.  See also |v:throwpoint| and |throw-variables|.\n+      Example: >vim\n+        try\n+          throw \"oops\"\n+        catch /.*/\n+          echo \"caught \" .. v:exception\n+        endtry\n+      <\n+      Output: \"caught oops\".\n+    ]=],\n+  },\n+  ['false'] = {\n+    desc = [=[\n+      Special value used to put \"false\" in JSON and msgpack.  See\n+      |json_encode()|.  This value is converted to \"v:false\" when used\n+      as a String (e.g. in |expr5| with string concatenation\n+      operator) and to zero when used as a Number (e.g. in |expr5|\n+      or |expr7| when used with numeric operators). Read-only.\n+    ]=],\n+  },\n+  fcs_reason = {\n+    type = 'string',\n+    desc = [=[\n+      The reason why the |FileChangedShell| event was triggered.\n+      Can be used in an autocommand to decide what to do and/or what\n+      to set v:fcs_choice to.  Possible values:\n+        deleted   file no longer exists\n+        conflict  file contents, mode or timestamp was\n+                  changed and buffer is modified\n+        changed   file contents has changed\n+        mode      mode of file changed\n+        time      only file timestamp changed\n+    ]=],\n+  },\n+  fcs_choice = {\n+    type = 'string',\n+    desc = [=[\n+      What should happen after a |FileChangedShell| event was\n+      triggered.  Can be used in an autocommand to tell Vim what to\n+      do with the affected buffer:\n+        reload  Reload the buffer (does not work if\n+                the file was deleted).\n+        edit    Reload the buffer and detect the\n+                values for options such as\n+                'fileformat', 'fileencoding', 'binary'\n+                (does not work if the file was\n+                deleted).\n+        ask     Ask the user what to do, as if there\n+                was no autocommand.  Except that when\n+                only the timestamp changed nothing\n+                will happen.\n+        <empty> Nothing, the autocommand should do\n+                everything that needs to be done.\n+      The default is empty.  If another (invalid) value is used then\n+      Vim behaves like it is empty, there is no warning message.\n+    ]=],\n+  },\n+  fname = {\n+    type = 'string',\n+    desc = [=[\n+      When evaluating 'includeexpr': the file name that was\n+      detected.  Empty otherwise.\n+    ]=],\n+  },\n+  fname_in = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the input file.  Valid while evaluating:\n+        option         used for ~\n+        'charconvert'  file to be converted\n+        'diffexpr'     original file\n+        'patchexpr'    original file\n+      And set to the swap file name for |SwapExists|.\n+    ]=],\n+  },\n+  fname_out = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the output file.  Only valid while\n+      evaluating:\n+        option           used for ~\n+        'charconvert'    resulting converted file [1]\n+        'diffexpr'       output of diff\n+        'patchexpr'      resulting patched file\n+      [1] When doing conversion for a write command (e.g., \":w\n+      file\") it will be equal to v:fname_in.  When doing conversion\n+      for a read command (e.g., \":e file\") it will be a temporary\n+      file and different from v:fname_in.\n+    ]=],\n+  },\n+  fname_new = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the new version of the file.  Only valid while\n+      evaluating 'diffexpr'.\n+    ]=],\n+  },\n+  fname_diff = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the diff (patch) file.  Only valid while\n+      evaluating 'patchexpr'.\n+    ]=],\n+  },\n+  folddashes = {\n+    type = 'string',\n+    desc = [=[\n+      Used for 'foldtext': dashes representing foldlevel of a closed\n+      fold.\n+      Read-only in the |sandbox|. |fold-foldtext|\n+    ]=],\n+  },\n+  foldlevel = {\n+    type = 'integer',\n+    desc = [=[\n+      Used for 'foldtext': foldlevel of closed fold.\n+      Read-only in the |sandbox|. |fold-foldtext|\n+    ]=],\n+  },\n+  foldend = {\n+    type = 'integer',\n+    desc = [=[\n+      Used for 'foldtext': last line of closed fold.\n+      Read-only in the |sandbox|. |fold-foldtext|\n+    ]=],\n+  },\n+  foldstart = {\n+    type = 'integer',\n+    desc = [=[\n+      Used for 'foldtext': first line of closed fold.\n+      Read-only in the |sandbox|. |fold-foldtext|\n+    ]=],\n+  },\n+  hlsearch = {\n+    type = 'integer',\n+    desc = [=[\n+      Variable that indicates whether search highlighting is on.\n+      Setting it makes sense only if 'hlsearch' is enabled. Setting\n+      this variable to zero acts like the |:nohlsearch| command,\n+      setting it to one acts like\n+      let &hlsearch = &hlsearch\n+      Note that the value is restored when returning from a\n+      function. |function-search-undo|.\n+    ]=],\n+  },\n+  insertmode = {\n+    type = 'string',\n+    desc = [=[\n+      Used for the |InsertEnter| and |InsertChange| autocommand\n+      events.  Values:\n+        i    Insert mode\n+        r    Replace mode\n+        v    Virtual Replace mode\n+    ]=],\n+  },\n+  key = {\n+    type = 'string',\n+    desc = [=[\n+      Key of the current item of a |Dictionary|.  Only valid while\n+      evaluating the expression used with |map()| and |filter()|.\n+      Read-only.\n+    ]=],\n+  },\n+  lang = {\n+    type = 'string',\n+    desc = [=[\n+      The current locale setting for messages of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current language.  Technical: it's the value of LC_MESSAGES.\n+      The value is system dependent.\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      It can be different from |v:ctype| when messages are desired\n+      in a different language than what is used for character\n+      encoding.  See |multi-lang|.\n+    ]=],\n+  },\n+  lc_time = {\n+    type = 'string',\n+    desc = [=[\n+      The current locale setting for time messages of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current language.  Technical: it's the value of LC_TIME.\n+      This variable can not be set directly, use the |:language|\n+      command.  See |multi-lang|.\n+    ]=],\n+  },\n+  lnum = {\n+    type = 'integer',\n+    desc = [=[\n+      Line number for the 'foldexpr' |fold-expr|, 'formatexpr',\n+      'indentexpr' and 'statuscolumn' expressions, tab page number\n+      for 'guitablabel' and 'guitabtooltip'.  Only valid while one of\n+      these expressions is being evaluated.  Read-only when in the\n+      |sandbox|.\n+    ]=],\n+  },\n+  lua = {\n+    desc = [=[\n+      Prefix for calling Lua functions from expressions.\n+      See |v:lua-call| for more information.\n+    ]=],\n+  },\n+  maxcol = {\n+    type = 'integer',\n+    desc = [=[\n+      Maximum line length.  Depending on where it is used it can be\n+      screen columns, characters or bytes.  The value currently is\n+      2147483647 on all systems.\n+    ]=],\n+  },\n+  mouse_win = {\n+    type = 'integer',\n+    desc = [=[\n+      Window number for a mouse click obtained with |getchar()|.\n+      First window has number 1, like with |winnr()|.  The value is\n+      zero when there was no mouse button click.\n+    ]=],\n+  },\n+  mouse_winid = {\n+    type = 'integer',\n+    desc = [=[\n+      |window-ID| for a mouse click obtained with |getchar()|.\n+      The value is zero when there was no mouse button click.\n+    ]=],\n+  },\n+  mouse_lnum = {\n+    type = 'integer',\n+    desc = [=[\n+      Line number for a mouse click obtained with |getchar()|.\n+      This is the text line number, not the screen line number.  The\n+      value is zero when there was no mouse button click.\n+    ]=],\n+  },\n+  mouse_col = {\n+    type = 'integer',\n+    desc = [=[\n+      Column number for a mouse click obtained with |getchar()|.\n+      This is the screen column number, like with |virtcol()|.  The\n+      value is zero when there was no mouse button click.\n+    ]=],\n+  },\n+  msgpack_types = {\n+    desc = [=[\n+      Dictionary containing msgpack types used by |msgpackparse()|\n+      and |msgpackdump()|. All types inside dictionary are fixed\n+      (not editable) empty lists. To check whether some list is one\n+      of msgpack types, use |is| operator.\n+    ]=],\n+  },\n+  null = {\n+    desc = [=[\n+      Special value used to put \"null\" in JSON and NIL in msgpack.\n+      See |json_encode()|.  This value is converted to \"v:null\" when\n+      used as a String (e.g. in |expr5| with string concatenation\n+      operator) and to zero when used as a Number (e.g. in |expr5|\n+      or |expr7| when used with numeric operators). Read-only.\n+      In some places `v:null` can be used for a List, Dict, etc.\n+      that is not set.  That is slightly different than an empty\n+      List, Dict, etc.\n+    ]=],\n+  },\n+  numbermax = {\n+    type = 'integer',\n+    desc = 'Maximum value of a number.',\n+  },\n+  numbermin = {\n+    type = 'integer',\n+    desc = 'Minimum value of a number (negative).',\n+  },\n+  numbersize = {\n+    type = 'integer',\n+    desc = [=[\n+      Number of bits in a Number.  This is normally 64, but on some\n+      systems it may be 32.\n+    ]=],\n+  },\n+  oldfiles = {\n+    type = 'string[]',\n+    desc = [=[\n+      List of file names that is loaded from the |shada| file on\n+      startup.  These are the files that Vim remembers marks for.\n+      The length of the List is limited by the ' argument of the\n+      'shada' option (default is 100).\n+      When the |shada| file is not used the List is empty.\n+      Also see |:oldfiles| and |c_#<|.\n+      The List can be modified, but this has no effect on what is\n+      stored in the |shada| file later.  If you use values other\n+      than String this will cause trouble.\n+    ]=],\n+  },\n+  option_new = {\n+    desc = [=[\n+      New value of the option. Valid while executing an |OptionSet|\n+      autocommand.\n+    ]=],\n+  },\n+  option_old = {\n+    desc = [=[\n+      Old value of the option. Valid while executing an |OptionSet|\n+      autocommand. Depending on the command used for setting and the\n+      kind of option this is either the local old value or the\n+      global old value.\n+    ]=],\n+  },\n+  option_oldlocal = {\n+    desc = [=[\n+      Old local value of the option. Valid while executing an\n+      |OptionSet| autocommand.\n+    ]=],\n+  },\n+  option_oldglobal = {\n+    desc = [=[\n+      Old global value of the option. Valid while executing an\n+      |OptionSet| autocommand.\n+    ]=],\n+  },\n+  option_type = {\n+    type = 'string',\n+    desc = [=[\n+      Scope of the set command. Valid while executing an\n+      |OptionSet| autocommand. Can be either \"global\" or \"local\"\n+    ]=],\n+  },\n+  option_command = {\n+    type = 'string',\n+    desc = [=[\n+      Command used to set the option. Valid while executing an\n+      |OptionSet| autocommand.\n+        value        option was set via ~\n+        \"setlocal\"   |:setlocal| or \":let l:xxx\"\n+        \"setglobal\"  |:setglobal| or \":let g:xxx\"",
            "html_url": "https://github.com/neovim/neovim/pull/26682#discussion_r1432985320",
            "id": 1432985320,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5VaZ7o",
            "original_commit_id": "f098bb5fea6f6ae5b21d0ab3ddac1e7c84713a12",
            "original_line": 552,
            "original_position": 552,
            "original_start_line": 551,
            "path": "src/nvim/vvars.lua",
            "position": null,
            "pull_request_review_id": 1791348945,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1432985320/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-12-20T17:17:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1432985320",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26682#discussion_r1432986617"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1432986617"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "This looks a bit confusing",
            "commit_id": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
            "created_at": "2023-12-20T17:18:58Z",
            "diff_hunk": "@@ -1,23 +1,758 @@\n --- @meta _\n-\n--- TODO(lewis6991): generate this and `:help vim-variable`\n+-- THIS FILE IS GENERATED\n+-- DO NOT EDIT\n+error('Cannot require a meta file')\n \n --- @class vim.v\n+vim.v = ...\n+\n+--- The command line arguments Vim was invoked with.  This is a\n+--- list of strings.  The first item is the Vim command.\n+--- See `v:progpath` for the command with full path.\n+--- @type string[]\n+vim.v.argv = ...\n+\n+--- Argument for evaluating 'formatexpr' and used for the typed\n+--- character when using <expr> in an abbreviation `:map-<expr>`.\n+--- It is also used by the `InsertCharPre` and `InsertEnter` events.\n+--- @type any\n+vim.v.char = ...\n+\n+--- The name of the character encoding of a file to be converted.\n+--- Only valid while evaluating the 'charconvert' option.\n+--- @type string\n+vim.v.charconvert_from = ...\n+\n+--- The name of the character encoding of a file after conversion.\n+--- Only valid while evaluating the 'charconvert' option.\n+--- @type string\n+vim.v.charconvert_to = ...\n+\n+--- The extra arguments (\"++p\", \"++enc=\", \"++ff=\") given to a file\n+--- read/write command.  This is set before an autocommand event\n+--- for a file read/write command is triggered.  There is a\n+--- leading space to make it possible to append this variable\n+--- directly after the read/write command. Note: \"+cmd\" isn't\n+--- included here, because it will be executed anyway.\n+--- @type string[]\n+vim.v.cmdarg = ...\n+\n+--- Set like v:cmdarg for a file read/write command.  When a \"!\"\n+--- was used the value is 1, otherwise it is 0.  Note that this\n+--- can only be used in autocommands.  For user commands `<bang>`\n+--- can be used.\n+--- @type any\n+vim.v.cmdbang = ...\n+\n+--- The current locale setting for collation order of the runtime\n+--- environment.  This allows Vim scripts to be aware of the\n+--- current locale encoding.  Technical: it's the value of\n+--- LC_COLLATE.  When not using a locale the value is \"C\".\n+--- This variable can not be set directly, use the `:language`\n+--- command.\n+--- See `multi-lang`.\n+--- @type string\n+vim.v.collate = ...\n+\n+--- Dictionary containing the most recent `complete-items` after\n+--- `CompleteDone`.  Empty if the completion failed, or after\n+--- leaving and re-entering insert mode.\n+--- Note: Plugins can modify the value to emulate the builtin\n+--- `CompleteDone` event behavior.\n+--- @type any\n+vim.v.completed_item = ...\n+\n --- The count given for the last Normal mode command.  Can be used\n --- to get the count before a mapping.  Read-only.  Example:\n+---\n --- ```vim\n---- :map _x :<C-U>echo \"the count is \" .. v:count<CR>\n---- ```\n+---   :map _x :<C-U>echo \"the count is \" .. v:count<CR>\n+--- <",
            "html_url": "https://github.com/neovim/neovim/pull/26682#discussion_r1432986617",
            "id": 1432986617,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5VaaP5",
            "original_commit_id": "f098bb5fea6f6ae5b21d0ab3ddac1e7c84713a12",
            "original_line": 70,
            "original_position": 74,
            "original_start_line": 68,
            "path": "runtime/lua/vim/_meta/vvars.lua",
            "position": null,
            "pull_request_review_id": 1791350920,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1432986617/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-12-20T17:18:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1432986617",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/29790821?v=4",
                "events_url": "https://api.github.com/users/lucario387/events{/privacy}",
                "followers_url": "https://api.github.com/users/lucario387/followers",
                "following_url": "https://api.github.com/users/lucario387/following{/other_user}",
                "gists_url": "https://api.github.com/users/lucario387/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lucario387",
                "id": 29790821,
                "login": "lucario387",
                "node_id": "MDQ6VXNlcjI5NzkwODIx",
                "organizations_url": "https://api.github.com/users/lucario387/orgs",
                "received_events_url": "https://api.github.com/users/lucario387/received_events",
                "repos_url": "https://api.github.com/users/lucario387/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lucario387/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lucario387/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lucario387"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26682#discussion_r1432990438"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1432990438"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n      get when typing `:` after a count.\r\n```\r\n(or \":\", but not single quotes)",
            "commit_id": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
            "created_at": "2023-12-20T17:22:51Z",
            "diff_hunk": "@@ -0,0 +1,869 @@\n+local M = {}\n+\n+M.vars = {\n+  argv = {\n+    type = 'string[]',\n+    desc = [=[\n+      The command line arguments Vim was invoked with.  This is a\n+      list of strings.  The first item is the Vim command.\n+      See |v:progpath| for the command with full path.\n+    ]=],\n+  },\n+  char = {\n+    desc = [=[\n+      Argument for evaluating 'formatexpr' and used for the typed\n+      character when using <expr> in an abbreviation |:map-<expr>|.\n+      It is also used by the |InsertCharPre| and |InsertEnter| events.\n+    ]=],\n+  },\n+  charconvert_from = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file to be converted.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  charconvert_to = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file after conversion.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  cmdarg = {\n+    type = 'string[]',\n+    desc = [=[\n+      The extra arguments (\"++p\", \"++enc=\", \"++ff=\") given to a file\n+      read/write command.  This is set before an autocommand event\n+      for a file read/write command is triggered.  There is a\n+      leading space to make it possible to append this variable\n+      directly after the read/write command. Note: \"+cmd\" isn't\n+      included here, because it will be executed anyway.\n+    ]=],\n+  },\n+  collate = {\n+    type = 'string',\n+    desc = [=[\n+      The current locale setting for collation order of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current locale encoding.  Technical: it's the value of\n+      LC_COLLATE.  When not using a locale the value is \"C\".\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      See |multi-lang|.\n+    ]=],\n+  },\n+  cmdbang = {\n+    desc = [=[\n+      Set like v:cmdarg for a file read/write command.  When a \"!\"\n+      was used the value is 1, otherwise it is 0.  Note that this\n+      can only be used in autocommands.  For user commands |<bang>|\n+      can be used.\n+    ]=],\n+  },\n+  completed_item = {\n+    desc = [=[\n+      Dictionary containing the most recent |complete-items| after\n+      |CompleteDone|.  Empty if the completion failed, or after\n+      leaving and re-entering insert mode.\n+      Note: Plugins can modify the value to emulate the builtin\n+      |CompleteDone| event behavior.\n+    ]=],\n+  },\n+  count = {\n+    type = 'integer',\n+    desc = [=[\n+      The count given for the last Normal mode command.  Can be used\n+      to get the count before a mapping.  Read-only.  Example: >vim\n+        :map _x :<C-U>echo \"the count is \" .. v:count<CR>\n+      <\n+      Note: The <C-U> is required to remove the line range that you\n+      get when typing ':' after a count.",
            "html_url": "https://github.com/neovim/neovim/pull/26682#discussion_r1432990438",
            "id": 1432990438,
            "line": 81,
            "node_id": "PRRC_kwDOAPphoM5VabLm",
            "original_commit_id": "f098bb5fea6f6ae5b21d0ab3ddac1e7c84713a12",
            "original_line": 81,
            "original_position": 81,
            "original_start_line": null,
            "path": "src/nvim/vvars.lua",
            "position": 81,
            "pull_request_review_id": 1791356848,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1432990438/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-12-20T17:22:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1432990438",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26682#discussion_r1433281605"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433281605"
                }
            },
            "author_association": "MEMBER",
            "body": "This should be moved to `t_blob` now.",
            "commit_id": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
            "created_at": "2023-12-20T23:41:38Z",
            "diff_hunk": "@@ -0,0 +1,869 @@\n+local M = {}\n+\n+M.vars = {\n+  argv = {\n+    type = 'string[]',\n+    desc = [=[\n+      The command line arguments Vim was invoked with.  This is a\n+      list of strings.  The first item is the Vim command.\n+      See |v:progpath| for the command with full path.\n+    ]=],\n+  },\n+  char = {\n+    desc = [=[\n+      Argument for evaluating 'formatexpr' and used for the typed\n+      character when using <expr> in an abbreviation |:map-<expr>|.\n+      It is also used by the |InsertCharPre| and |InsertEnter| events.\n+    ]=],\n+  },\n+  charconvert_from = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file to be converted.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  charconvert_to = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file after conversion.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  cmdarg = {\n+    type = 'string[]',\n+    desc = [=[\n+      The extra arguments (\"++p\", \"++enc=\", \"++ff=\") given to a file\n+      read/write command.  This is set before an autocommand event\n+      for a file read/write command is triggered.  There is a\n+      leading space to make it possible to append this variable\n+      directly after the read/write command. Note: \"+cmd\" isn't\n+      included here, because it will be executed anyway.\n+    ]=],\n+  },\n+  collate = {\n+    type = 'string',\n+    desc = [=[\n+      The current locale setting for collation order of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current locale encoding.  Technical: it's the value of\n+      LC_COLLATE.  When not using a locale the value is \"C\".\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      See |multi-lang|.\n+    ]=],\n+  },\n+  cmdbang = {\n+    desc = [=[\n+      Set like v:cmdarg for a file read/write command.  When a \"!\"\n+      was used the value is 1, otherwise it is 0.  Note that this\n+      can only be used in autocommands.  For user commands |<bang>|\n+      can be used.\n+    ]=],\n+  },\n+  completed_item = {\n+    desc = [=[\n+      Dictionary containing the most recent |complete-items| after\n+      |CompleteDone|.  Empty if the completion failed, or after\n+      leaving and re-entering insert mode.\n+      Note: Plugins can modify the value to emulate the builtin\n+      |CompleteDone| event behavior.\n+    ]=],\n+  },\n+  count = {\n+    type = 'integer',\n+    desc = [=[\n+      The count given for the last Normal mode command.  Can be used\n+      to get the count before a mapping.  Read-only.  Example: >vim\n+        :map _x :<C-U>echo \"the count is \" .. v:count<CR>\n+      <\n+      Note: The <C-U> is required to remove the line range that you\n+      get when typing ':' after a count.\n+      When there are two counts, as in \"3d2w\", they are multiplied,\n+      just like what happens in the command, \"d6w\" for the example.\n+      Also used for evaluating the 'formatexpr' option.\n+    ]=],\n+  },\n+  count1 = {\n+    type = 'integer',\n+    desc = [=[\n+      Just like \"v:count\", but defaults to one when no count is\n+      used.\n+    ]=],\n+  },\n+  ctype = {\n+    desc = [=[\n+      The current locale setting for characters of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current locale encoding.  Technical: it's the value of\n+      LC_CTYPE.  When not using a locale the value is \"C\".\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      See |multi-lang|.\n+    ]=],\n+  },\n+  dying = {\n+    type = 'integer',\n+    desc = [=[\n+      Normally zero.  When a deadly signal is caught it's set to\n+      one.  When multiple signals are caught the number increases.\n+      Can be used in an autocommand to check if Vim didn't\n+      terminate normally.\n+      Example: >vim\n+        :au VimLeave * if v:dying | echo \"\\nAAAAaaaarrrggghhhh!!!\\n\" | endif\n+      <\n+      Note: if another deadly signal is caught when v:dying is one,\n+      VimLeave autocommands will not be executed.\n+    ]=],\n+  },\n+  exiting = {\n+    desc = [=[\n+      Exit code, or |v:null| before invoking the |VimLeavePre|\n+      and |VimLeave| autocmds.  See |:q|, |:x| and |:cquit|.\n+      Example: >vim\n+        :au VimLeave * echo \"Exit value is \" .. v:exiting\n+      <\n+    ]=],\n+  },\n+  echospace = {\n+    type = 'integer',\n+    desc = [=[\n+      Number of screen cells that can be used for an `:echo` message\n+      in the last screen line before causing the |hit-enter-prompt|.\n+      Depends on 'showcmd', 'ruler' and 'columns'.  You need to\n+      check 'cmdheight' for whether there are full-width lines\n+      available above the last line.\n+    ]=],\n+  },\n+  errmsg = {\n+    type = 'string',\n+    desc = [=[\n+      Last given error message.\n+      Modifiable (can be set).\n+      Example: >vim\n+        let v:errmsg = \"\"\n+        silent! next\n+        if v:errmsg != \"\"\n+          ... handle error\n+      <\n+\n+    ]=],\n+  },\n+  errors = {\n+    tags = { 'assert-return' },\n+    desc = [=[\n+      Errors found by assert functions, such as |assert_true()|.\n+      This is a list of strings.\n+      The assert functions append an item when an assert fails.\n+      The return value indicates this: a one is returned if an item\n+      was added to v:errors, otherwise zero is returned.\n+      To remove old results make it empty: >vim\n+        :let v:errors = []\n+      <\n+      If v:errors is set to anything but a list it is made an empty\n+      list by the assert function.\n+    ]=],\n+  },\n+  event = {\n+    desc = [=[\n+      Dictionary of event data for the current |autocommand|.  Valid\n+      only during the event lifetime; storing or passing v:event is\n+      invalid!  Copy it instead: >vim\n+        au TextYankPost * let g:foo = deepcopy(v:event)\n+      <\n+      Keys vary by event; see the documentation for the specific\n+      event, e.g. |DirChanged| or |TextYankPost|.\n+        KEY              DESCRIPTION ~\n+        abort            Whether the event triggered during\n+                         an aborting condition (e.g. |c_Esc| or\n+                         |c_CTRL-C| for |CmdlineLeave|).\n+        chan             |channel-id|\n+        cmdlevel         Level of cmdline.\n+        cmdtype          Type of cmdline, |cmdline-char|.\n+        cwd              Current working directory.\n+        inclusive        Motion is |inclusive|, else exclusive.\n+        scope            Event-specific scope name.\n+        operator         Current |operator|.  Also set for Ex\n+        commands         (unlike |v:operator|). For\n+                         example if |TextYankPost| is triggered\n+                         by the |:yank| Ex command then\n+                         `v:event.operator` is \"y\".\n+        regcontents      Text stored in the register as a\n+                         |readfile()|-style list of lines.\n+        regname          Requested register (e.g \"x\" for \"xyy)\n+                         or the empty string for an unnamed\n+                         operation.\n+        regtype          Type of register as returned by\n+                         |getregtype()|.\n+        visual           Selection is visual (as opposed to,\n+                         e.g., via motion).\n+        completed_item   Current selected complete item on\n+                         |CompleteChanged|, Is `{}` when no complete\n+                         item selected.\n+        height           Height of popup menu on |CompleteChanged|\n+        width            Width of popup menu on |CompleteChanged|\n+        row              Row count of popup menu on |CompleteChanged|,\n+                         relative to screen.\n+        col              Col count of popup menu on |CompleteChanged|,\n+                         relative to screen.\n+        size             Total number of completion items on\n+                         |CompleteChanged|.\n+        scrollbar        Is |v:true| if popup menu have scrollbar, or\n+                         |v:false| if not.\n+        changed_window   Is |v:true| if the event fired while\n+        changing window  (or tab) on |DirChanged|.\n+        status           Job status or exit code, -1 means \"unknown\". |TermClose|\n+    ]=],\n+  },\n+  exception = {\n+    desc = [=[\n+      The value of the exception most recently caught and not\n+      finished.  See also |v:throwpoint| and |throw-variables|.\n+      Example: >vim\n+        try\n+          throw \"oops\"\n+        catch /.*/\n+          echo \"caught \" .. v:exception\n+        endtry\n+      <\n+      Output: \"caught oops\".\n+    ]=],\n+  },\n+  ['false'] = {\n+    desc = [=[\n+      Special value used to put \"false\" in JSON and msgpack.  See\n+      |json_encode()|.  This value is converted to \"v:false\" when used\n+      as a String (e.g. in |expr5| with string concatenation\n+      operator) and to zero when used as a Number (e.g. in |expr5|\n+      or |expr7| when used with numeric operators). Read-only.\n+    ]=],\n+  },\n+  fcs_reason = {\n+    type = 'string',\n+    desc = [=[\n+      The reason why the |FileChangedShell| event was triggered.\n+      Can be used in an autocommand to decide what to do and/or what\n+      to set v:fcs_choice to.  Possible values:\n+        deleted   file no longer exists\n+        conflict  file contents, mode or timestamp was\n+                  changed and buffer is modified\n+        changed   file contents has changed\n+        mode      mode of file changed\n+        time      only file timestamp changed\n+    ]=],\n+  },\n+  fcs_choice = {\n+    type = 'string',\n+    desc = [=[\n+      What should happen after a |FileChangedShell| event was\n+      triggered.  Can be used in an autocommand to tell Vim what to\n+      do with the affected buffer:\n+        reload  Reload the buffer (does not work if\n+                the file was deleted).\n+        edit    Reload the buffer and detect the\n+                values for options such as\n+                'fileformat', 'fileencoding', 'binary'\n+                (does not work if the file was\n+                deleted).\n+        ask     Ask the user what to do, as if there\n+                was no autocommand.  Except that when\n+                only the timestamp changed nothing\n+                will happen.\n+        <empty> Nothing, the autocommand should do\n+                everything that needs to be done.\n+      The default is empty.  If another (invalid) value is used then\n+      Vim behaves like it is empty, there is no warning message.\n+    ]=],\n+  },\n+  fname = {\n+    type = 'string',\n+    desc = [=[\n+      When evaluating 'includeexpr': the file name that was\n+      detected.  Empty otherwise.\n+    ]=],\n+  },\n+  fname_in = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the input file.  Valid while evaluating:\n+        option         used for ~\n+        'charconvert'  file to be converted\n+        'diffexpr'     original file\n+        'patchexpr'    original file\n+      And set to the swap file name for |SwapExists|.\n+    ]=],\n+  },\n+  fname_out = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the output file.  Only valid while\n+      evaluating:\n+        option           used for ~\n+        'charconvert'    resulting converted file [1]\n+        'diffexpr'       output of diff\n+        'patchexpr'      resulting patched file\n+      [1] When doing conversion for a write command (e.g., \":w\n+      file\") it will be equal to v:fname_in.  When doing conversion\n+      for a read command (e.g., \":e file\") it will be a temporary\n+      file and different from v:fname_in.\n+    ]=],\n+  },\n+  fname_new = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the new version of the file.  Only valid while\n+      evaluating 'diffexpr'.\n+    ]=],\n+  },\n+  fname_diff = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the diff (patch) file.  Only valid while\n+      evaluating 'patchexpr'.\n+    ]=],\n+  },\n+  folddashes = {\n+    type = 'string',\n+    desc = [=[\n+      Used for 'foldtext': dashes representing foldlevel of a closed\n+      fold.\n+      Read-only in the |sandbox|. |fold-foldtext|\n+    ]=],\n+  },\n+  foldlevel = {\n+    type = 'integer',\n+    desc = [=[\n+      Used for 'foldtext': foldlevel of closed fold.\n+      Read-only in the |sandbox|. |fold-foldtext|\n+    ]=],\n+  },\n+  foldend = {\n+    type = 'integer',\n+    desc = [=[\n+      Used for 'foldtext': last line of closed fold.\n+      Read-only in the |sandbox|. |fold-foldtext|\n+    ]=],\n+  },\n+  foldstart = {\n+    type = 'integer',\n+    desc = [=[\n+      Used for 'foldtext': first line of closed fold.\n+      Read-only in the |sandbox|. |fold-foldtext|\n+    ]=],\n+  },\n+  hlsearch = {\n+    type = 'integer',\n+    desc = [=[\n+      Variable that indicates whether search highlighting is on.\n+      Setting it makes sense only if 'hlsearch' is enabled. Setting\n+      this variable to zero acts like the |:nohlsearch| command,\n+      setting it to one acts like\n+      let &hlsearch = &hlsearch\n+      Note that the value is restored when returning from a\n+      function. |function-search-undo|.\n+    ]=],\n+  },\n+  insertmode = {\n+    type = 'string',\n+    desc = [=[\n+      Used for the |InsertEnter| and |InsertChange| autocommand\n+      events.  Values:\n+        i    Insert mode\n+        r    Replace mode\n+        v    Virtual Replace mode\n+    ]=],\n+  },\n+  key = {\n+    type = 'string',\n+    desc = [=[\n+      Key of the current item of a |Dictionary|.  Only valid while\n+      evaluating the expression used with |map()| and |filter()|.\n+      Read-only.\n+    ]=],\n+  },\n+  lang = {\n+    type = 'string',\n+    desc = [=[\n+      The current locale setting for messages of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current language.  Technical: it's the value of LC_MESSAGES.\n+      The value is system dependent.\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      It can be different from |v:ctype| when messages are desired\n+      in a different language than what is used for character\n+      encoding.  See |multi-lang|.\n+    ]=],\n+  },\n+  lc_time = {\n+    type = 'string',\n+    desc = [=[\n+      The current locale setting for time messages of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current language.  Technical: it's the value of LC_TIME.\n+      This variable can not be set directly, use the |:language|\n+      command.  See |multi-lang|.\n+    ]=],\n+  },\n+  lnum = {\n+    type = 'integer',\n+    desc = [=[\n+      Line number for the 'foldexpr' |fold-expr|, 'formatexpr',\n+      'indentexpr' and 'statuscolumn' expressions, tab page number\n+      for 'guitablabel' and 'guitabtooltip'.  Only valid while one of\n+      these expressions is being evaluated.  Read-only when in the\n+      |sandbox|.\n+    ]=],\n+  },\n+  lua = {\n+    desc = [=[\n+      Prefix for calling Lua functions from expressions.\n+      See |v:lua-call| for more information.\n+    ]=],\n+  },\n+  maxcol = {\n+    type = 'integer',\n+    desc = [=[\n+      Maximum line length.  Depending on where it is used it can be\n+      screen columns, characters or bytes.  The value currently is\n+      2147483647 on all systems.\n+    ]=],\n+  },\n+  mouse_win = {\n+    type = 'integer',\n+    desc = [=[\n+      Window number for a mouse click obtained with |getchar()|.\n+      First window has number 1, like with |winnr()|.  The value is\n+      zero when there was no mouse button click.\n+    ]=],\n+  },\n+  mouse_winid = {\n+    type = 'integer',\n+    desc = [=[\n+      |window-ID| for a mouse click obtained with |getchar()|.\n+      The value is zero when there was no mouse button click.\n+    ]=],\n+  },\n+  mouse_lnum = {\n+    type = 'integer',\n+    desc = [=[\n+      Line number for a mouse click obtained with |getchar()|.\n+      This is the text line number, not the screen line number.  The\n+      value is zero when there was no mouse button click.\n+    ]=],\n+  },\n+  mouse_col = {\n+    type = 'integer',\n+    desc = [=[\n+      Column number for a mouse click obtained with |getchar()|.\n+      This is the screen column number, like with |virtcol()|.  The\n+      value is zero when there was no mouse button click.\n+    ]=],\n+  },\n+  msgpack_types = {\n+    desc = [=[\n+      Dictionary containing msgpack types used by |msgpackparse()|\n+      and |msgpackdump()|. All types inside dictionary are fixed\n+      (not editable) empty lists. To check whether some list is one\n+      of msgpack types, use |is| operator.\n+    ]=],\n+  },\n+  null = {\n+    desc = [=[\n+      Special value used to put \"null\" in JSON and NIL in msgpack.\n+      See |json_encode()|.  This value is converted to \"v:null\" when\n+      used as a String (e.g. in |expr5| with string concatenation\n+      operator) and to zero when used as a Number (e.g. in |expr5|\n+      or |expr7| when used with numeric operators). Read-only.\n+      In some places `v:null` can be used for a List, Dict, etc.\n+      that is not set.  That is slightly different than an empty\n+      List, Dict, etc.\n+    ]=],\n+  },\n+  numbermax = {\n+    type = 'integer',\n+    desc = 'Maximum value of a number.',\n+  },\n+  numbermin = {\n+    type = 'integer',\n+    desc = 'Minimum value of a number (negative).',\n+  },\n+  numbersize = {\n+    type = 'integer',\n+    desc = [=[\n+      Number of bits in a Number.  This is normally 64, but on some\n+      systems it may be 32.\n+    ]=],\n+  },\n+  oldfiles = {\n+    type = 'string[]',\n+    desc = [=[\n+      List of file names that is loaded from the |shada| file on\n+      startup.  These are the files that Vim remembers marks for.\n+      The length of the List is limited by the ' argument of the\n+      'shada' option (default is 100).\n+      When the |shada| file is not used the List is empty.\n+      Also see |:oldfiles| and |c_#<|.\n+      The List can be modified, but this has no effect on what is\n+      stored in the |shada| file later.  If you use values other\n+      than String this will cause trouble.\n+    ]=],\n+  },\n+  option_new = {\n+    desc = [=[\n+      New value of the option. Valid while executing an |OptionSet|\n+      autocommand.\n+    ]=],\n+  },\n+  option_old = {\n+    desc = [=[\n+      Old value of the option. Valid while executing an |OptionSet|\n+      autocommand. Depending on the command used for setting and the\n+      kind of option this is either the local old value or the\n+      global old value.\n+    ]=],\n+  },\n+  option_oldlocal = {\n+    desc = [=[\n+      Old local value of the option. Valid while executing an\n+      |OptionSet| autocommand.\n+    ]=],\n+  },\n+  option_oldglobal = {\n+    desc = [=[\n+      Old global value of the option. Valid while executing an\n+      |OptionSet| autocommand.\n+    ]=],\n+  },\n+  option_type = {\n+    type = 'string',\n+    desc = [=[\n+      Scope of the set command. Valid while executing an\n+      |OptionSet| autocommand. Can be either \"global\" or \"local\"\n+    ]=],\n+  },\n+  option_command = {\n+    type = 'string',\n+    desc = [=[\n+      Command used to set the option. Valid while executing an\n+      |OptionSet| autocommand.\n+        value        option was set via ~\n+        \"setlocal\"   |:setlocal| or \":let l:xxx\"\n+        \"setglobal\"  |:setglobal| or \":let g:xxx\"\n+        \"set\"        |:set| or |:let|\n+        \"modeline\"   |modeline|\n+            --\n+    ]=],\n+  },\n+  operator = {\n+    type = 'string',\n+    desc = [=[\n+      The last operator given in Normal mode.  This is a single\n+      character except for commands starting with <g> or <z>,\n+      in which case it is two characters.  Best used alongside\n+      |v:prevcount| and |v:register|.  Useful if you want to cancel\n+      Operator-pending mode and then use the operator, e.g.: >vim\n+        :omap O <Esc>:call MyMotion(v:operator)<CR>\n+      <\n+      The value remains set until another operator is entered, thus\n+      don't expect it to be empty.\n+      v:operator is not set for |:delete|, |:yank| or other Ex\n+      commands.\n+      Read-only.\n+    ]=],\n+  },\n+  prevcount = {\n+    type = 'integer',\n+    desc = [=[\n+      The count given for the last but one Normal mode command.\n+      This is the v:count value of the previous command.  Useful if\n+      you want to cancel Visual or Operator-pending mode and then\n+      use the count, e.g.: >vim\n+        :vmap % <Esc>:call MyFilter(v:prevcount)<CR>\n+      <\n+      Read-only.\n+    ]=],\n+  },\n+  profiling = {\n+    type = 'integer',\n+    desc = [=[\n+      Normally zero.  Set to one after using \":profile start\".\n+      See |profiling|.\n+    ]=],\n+  },\n+  progname = {\n+    type = 'string',\n+    desc = [=[\n+      The name by which Nvim was invoked (with path removed).\n+      Read-only.\n+    ]=],\n+  },\n+  progpath = {\n+    type = 'string',\n+    desc = [=[\n+      Absolute path to the current running Nvim.\n+      Read-only.\n+    ]=],\n+  },\n+  register = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the register in effect for the current normal mode\n+      command (regardless of whether that command actually used a\n+      register).  Or for the currently executing normal mode mapping\n+      (use this in custom commands that take a register).\n+      If none is supplied it is the default register '\"', unless\n+      'clipboard' contains \"unnamed\" or \"unnamedplus\", then it is\n+      \"*\" or '+'.\n+      Also see |getreg()| and |setreg()|\n+    ]=],\n+  },\n+  relnum = {\n+    type = 'integer',\n+    desc = [=[\n+      Relative line number for the 'statuscolumn' expression.\n+      Read-only.\n+    ]=],\n+  },\n+  scrollstart = {\n+    desc = [=[\n+      String describing the script or function that caused the\n+      screen to scroll up.  It's only set when it is empty, thus the\n+      first reason is remembered.  It is set to \"Unknown\" for a\n+      typed command.\n+      This can be used to find out why your script causes the\n+      hit-enter prompt.\n+    ]=],\n+  },\n+  servername = {\n+    type = 'string',\n+    desc = [=[\n+      Primary listen-address of Nvim, the first item returned by\n+      |serverlist()|. Usually this is the named pipe created by Nvim\n+      at |startup| or given by |--listen| (or the deprecated\n+      |$NVIM_LISTEN_ADDRESS| env var).\n+\n+      See also |serverstart()| |serverstop()|.\n+      Read-only.\n+\n+                         *$NVIM*\n+      $NVIM is set by |terminal| and |jobstart()|, and is thus\n+      a hint that the current environment is a subprocess of Nvim.\n+      Example: >vim\n+        if $NVIM\n+          echo nvim_get_chan_info(v:parent)\n+        endif\n+      <\n+\n+      Note the contents of $NVIM may change in the future.\n+    ]=],\n+  },\n+  searchforward = {\n+    type = 'integer',\n+    desc = [=[\n+      Search direction:  1 after a forward search, 0 after a\n+      backward search.  It is reset to forward when directly setting\n+      the last search pattern, see |quote/|.\n+      Note that the value is restored when returning from a\n+      function. |function-search-undo|.\n+      Read-write.\n+    ]=],\n+  },\n+  shell_error = {\n+    type = 'string',\n+    desc = [=[\n+      Result of the last shell command.  When non-zero, the last\n+      shell command had an error.  When zero, there was no problem.\n+      This only works when the shell returns the error code to Vim.\n+      The value -1 is often used when the command could not be\n+      executed.  Read-only.\n+      Example: >vim\n+        !mv foo bar\n+        if v:shell_error\n+          echo 'could not rename \"foo\" to \"bar\"!'\n+        endif\n+      <\n+    ]=],\n+  },\n+  statusmsg = {\n+    type = 'string',\n+    desc = [=[\n+      Last given status message.\n+      Modifiable (can be set).\n+    ]=],\n+  },\n+  stderr = {\n+    type = 'string',\n+    desc = [=[\n+      |channel-id| corresponding to stderr. The value is always 2;\n+      use this variable to make your code more descriptive.\n+      Unlike stdin and stdout (see |stdioopen()|), stderr is always\n+      open for writing. Example:\n+      :call chansend(v:stderr, \"error: toaster empty\\n\")\n+    ]=],\n+  },\n+  swapname = {\n+    type = 'string',\n+    desc = [=[\n+      Name of the swapfile found.\n+      Only valid during |SwapExists| event.\n+      Read-only.\n+    ]=],\n+  },\n+  swapchoice = {\n+    type = 'string',\n+    desc = [=[\n+      |SwapExists| autocommands can set this to the selected choice\n+      for handling an existing swapfile:\n+        'o'    Open read-only\n+        'e'    Edit anyway\n+        'r'    Recover\n+        'd'    Delete swapfile\n+        'q'    Quit\n+        'a'    Abort\n+      The value should be a single-character string.  An empty value\n+      results in the user being asked, as would happen when there is\n+      no SwapExists autocommand.  The default is empty.\n+    ]=],\n+  },\n+  swapcommand = {\n+    type = 'string',\n+    desc = [=[\n+      Normal mode command to be executed after a file has been\n+      opened.  Can be used for a |SwapExists| autocommand to have\n+      another Vim open the file and jump to the right place.  For\n+      example, when jumping to a tag the value is \":tag tagname\\r\".\n+      For \":edit +cmd file\" the value is \":cmd\\r\".\n+    ]=],\n+  },\n+  t_bool = {\n+    type = 'integer',\n+    tags = { 'v:t_TYPE' },",
            "html_url": "https://github.com/neovim/neovim/pull/26682#discussion_r1433281605",
            "id": 1433281605,
            "line": 741,
            "node_id": "PRRC_kwDOAPphoM5VbiRF",
            "original_commit_id": "f098bb5fea6f6ae5b21d0ab3ddac1e7c84713a12",
            "original_line": 741,
            "original_position": 741,
            "original_start_line": null,
            "path": "src/nvim/vvars.lua",
            "position": 741,
            "pull_request_review_id": 1791869931,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433281605/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-12-20T23:41:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433281605",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26682#discussion_r1433281909"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433281909"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n          \" ... handle error\r\n```",
            "commit_id": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
            "created_at": "2023-12-20T23:42:23Z",
            "diff_hunk": "@@ -0,0 +1,869 @@\n+local M = {}\n+\n+M.vars = {\n+  argv = {\n+    type = 'string[]',\n+    desc = [=[\n+      The command line arguments Vim was invoked with.  This is a\n+      list of strings.  The first item is the Vim command.\n+      See |v:progpath| for the command with full path.\n+    ]=],\n+  },\n+  char = {\n+    desc = [=[\n+      Argument for evaluating 'formatexpr' and used for the typed\n+      character when using <expr> in an abbreviation |:map-<expr>|.\n+      It is also used by the |InsertCharPre| and |InsertEnter| events.\n+    ]=],\n+  },\n+  charconvert_from = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file to be converted.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  charconvert_to = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file after conversion.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  cmdarg = {\n+    type = 'string[]',\n+    desc = [=[\n+      The extra arguments (\"++p\", \"++enc=\", \"++ff=\") given to a file\n+      read/write command.  This is set before an autocommand event\n+      for a file read/write command is triggered.  There is a\n+      leading space to make it possible to append this variable\n+      directly after the read/write command. Note: \"+cmd\" isn't\n+      included here, because it will be executed anyway.\n+    ]=],\n+  },\n+  collate = {\n+    type = 'string',\n+    desc = [=[\n+      The current locale setting for collation order of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current locale encoding.  Technical: it's the value of\n+      LC_COLLATE.  When not using a locale the value is \"C\".\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      See |multi-lang|.\n+    ]=],\n+  },\n+  cmdbang = {\n+    desc = [=[\n+      Set like v:cmdarg for a file read/write command.  When a \"!\"\n+      was used the value is 1, otherwise it is 0.  Note that this\n+      can only be used in autocommands.  For user commands |<bang>|\n+      can be used.\n+    ]=],\n+  },\n+  completed_item = {\n+    desc = [=[\n+      Dictionary containing the most recent |complete-items| after\n+      |CompleteDone|.  Empty if the completion failed, or after\n+      leaving and re-entering insert mode.\n+      Note: Plugins can modify the value to emulate the builtin\n+      |CompleteDone| event behavior.\n+    ]=],\n+  },\n+  count = {\n+    type = 'integer',\n+    desc = [=[\n+      The count given for the last Normal mode command.  Can be used\n+      to get the count before a mapping.  Read-only.  Example: >vim\n+        :map _x :<C-U>echo \"the count is \" .. v:count<CR>\n+      <\n+      Note: The <C-U> is required to remove the line range that you\n+      get when typing ':' after a count.\n+      When there are two counts, as in \"3d2w\", they are multiplied,\n+      just like what happens in the command, \"d6w\" for the example.\n+      Also used for evaluating the 'formatexpr' option.\n+    ]=],\n+  },\n+  count1 = {\n+    type = 'integer',\n+    desc = [=[\n+      Just like \"v:count\", but defaults to one when no count is\n+      used.\n+    ]=],\n+  },\n+  ctype = {\n+    desc = [=[\n+      The current locale setting for characters of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current locale encoding.  Technical: it's the value of\n+      LC_CTYPE.  When not using a locale the value is \"C\".\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      See |multi-lang|.\n+    ]=],\n+  },\n+  dying = {\n+    type = 'integer',\n+    desc = [=[\n+      Normally zero.  When a deadly signal is caught it's set to\n+      one.  When multiple signals are caught the number increases.\n+      Can be used in an autocommand to check if Vim didn't\n+      terminate normally.\n+      Example: >vim\n+        :au VimLeave * if v:dying | echo \"\\nAAAAaaaarrrggghhhh!!!\\n\" | endif\n+      <\n+      Note: if another deadly signal is caught when v:dying is one,\n+      VimLeave autocommands will not be executed.\n+    ]=],\n+  },\n+  exiting = {\n+    desc = [=[\n+      Exit code, or |v:null| before invoking the |VimLeavePre|\n+      and |VimLeave| autocmds.  See |:q|, |:x| and |:cquit|.\n+      Example: >vim\n+        :au VimLeave * echo \"Exit value is \" .. v:exiting\n+      <\n+    ]=],\n+  },\n+  echospace = {\n+    type = 'integer',\n+    desc = [=[\n+      Number of screen cells that can be used for an `:echo` message\n+      in the last screen line before causing the |hit-enter-prompt|.\n+      Depends on 'showcmd', 'ruler' and 'columns'.  You need to\n+      check 'cmdheight' for whether there are full-width lines\n+      available above the last line.\n+    ]=],\n+  },\n+  errmsg = {\n+    type = 'string',\n+    desc = [=[\n+      Last given error message.\n+      Modifiable (can be set).\n+      Example: >vim\n+        let v:errmsg = \"\"\n+        silent! next\n+        if v:errmsg != \"\"\n+          ... handle error",
            "html_url": "https://github.com/neovim/neovim/pull/26682#discussion_r1433281909",
            "id": 1433281909,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5VbiV1",
            "original_commit_id": "f098bb5fea6f6ae5b21d0ab3ddac1e7c84713a12",
            "original_line": 147,
            "original_position": 147,
            "original_start_line": null,
            "path": "src/nvim/vvars.lua",
            "position": null,
            "pull_request_review_id": 1791871354,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433281909/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-12-20T23:42:23Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433281909",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26682#discussion_r1433283971"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433283971"
                }
            },
            "author_association": "MEMBER",
            "body": "Isn't single quotes fine for a single char?",
            "commit_id": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
            "created_at": "2023-12-20T23:47:24Z",
            "diff_hunk": "@@ -0,0 +1,869 @@\n+local M = {}\n+\n+M.vars = {\n+  argv = {\n+    type = 'string[]',\n+    desc = [=[\n+      The command line arguments Vim was invoked with.  This is a\n+      list of strings.  The first item is the Vim command.\n+      See |v:progpath| for the command with full path.\n+    ]=],\n+  },\n+  char = {\n+    desc = [=[\n+      Argument for evaluating 'formatexpr' and used for the typed\n+      character when using <expr> in an abbreviation |:map-<expr>|.\n+      It is also used by the |InsertCharPre| and |InsertEnter| events.\n+    ]=],\n+  },\n+  charconvert_from = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file to be converted.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  charconvert_to = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file after conversion.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  cmdarg = {\n+    type = 'string[]',\n+    desc = [=[\n+      The extra arguments (\"++p\", \"++enc=\", \"++ff=\") given to a file\n+      read/write command.  This is set before an autocommand event\n+      for a file read/write command is triggered.  There is a\n+      leading space to make it possible to append this variable\n+      directly after the read/write command. Note: \"+cmd\" isn't\n+      included here, because it will be executed anyway.\n+    ]=],\n+  },\n+  collate = {\n+    type = 'string',\n+    desc = [=[\n+      The current locale setting for collation order of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current locale encoding.  Technical: it's the value of\n+      LC_COLLATE.  When not using a locale the value is \"C\".\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      See |multi-lang|.\n+    ]=],\n+  },\n+  cmdbang = {\n+    desc = [=[\n+      Set like v:cmdarg for a file read/write command.  When a \"!\"\n+      was used the value is 1, otherwise it is 0.  Note that this\n+      can only be used in autocommands.  For user commands |<bang>|\n+      can be used.\n+    ]=],\n+  },\n+  completed_item = {\n+    desc = [=[\n+      Dictionary containing the most recent |complete-items| after\n+      |CompleteDone|.  Empty if the completion failed, or after\n+      leaving and re-entering insert mode.\n+      Note: Plugins can modify the value to emulate the builtin\n+      |CompleteDone| event behavior.\n+    ]=],\n+  },\n+  count = {\n+    type = 'integer',\n+    desc = [=[\n+      The count given for the last Normal mode command.  Can be used\n+      to get the count before a mapping.  Read-only.  Example: >vim\n+        :map _x :<C-U>echo \"the count is \" .. v:count<CR>\n+      <\n+      Note: The <C-U> is required to remove the line range that you\n+      get when typing ':' after a count.",
            "html_url": "https://github.com/neovim/neovim/pull/26682#discussion_r1433283971",
            "id": 1433283971,
            "in_reply_to_id": 1432990438,
            "line": 81,
            "node_id": "PRRC_kwDOAPphoM5Vbi2D",
            "original_commit_id": "f098bb5fea6f6ae5b21d0ab3ddac1e7c84713a12",
            "original_line": 81,
            "original_position": 81,
            "original_start_line": null,
            "path": "src/nvim/vvars.lua",
            "position": 81,
            "pull_request_review_id": 1791880913,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433283971/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-12-20T23:47:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433283971",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26682#discussion_r1433289819"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433289819"
                }
            },
            "author_association": "MEMBER",
            "body": "`norm_text()` should be called after removing leading spaces.",
            "commit_id": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
            "created_at": "2023-12-21T00:01:10Z",
            "diff_hunk": "@@ -534,6 +546,31 @@ local function render_option_meta(_f, opt, write)\n   end\n end\n \n+--- @param _f string\n+--- @param opt vim.option_meta\n+--- @param write fun(line: string)\n+local function render_vvar_meta(_f, opt, write)\n+  write('')\n+\n+  local desc = split(norm_text(opt.desc))",
            "html_url": "https://github.com/neovim/neovim/pull/26682#discussion_r1433289819",
            "id": 1433289819,
            "line": 555,
            "node_id": "PRRC_kwDOAPphoM5VbkRb",
            "original_commit_id": "f098bb5fea6f6ae5b21d0ab3ddac1e7c84713a12",
            "original_line": 555,
            "original_position": 36,
            "original_start_line": null,
            "path": "scripts/gen_eval_files.lua",
            "position": 36,
            "pull_request_review_id": 1791906639,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433289819/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-12-21T00:01:10Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433289819",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26682#discussion_r1433290141"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433290141"
                }
            },
            "author_association": "MEMBER",
            "body": "`norm_text()` should be called after removing leading spaces.",
            "commit_id": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
            "created_at": "2023-12-21T00:01:57Z",
            "diff_hunk": "@@ -1,23 +1,758 @@\n --- @meta _\n-\n--- TODO(lewis6991): generate this and `:help vim-variable`\n+-- THIS FILE IS GENERATED\n+-- DO NOT EDIT\n+error('Cannot require a meta file')\n \n --- @class vim.v\n+vim.v = ...\n+\n+--- The command line arguments Vim was invoked with.  This is a\n+--- list of strings.  The first item is the Vim command.\n+--- See `v:progpath` for the command with full path.\n+--- @type string[]\n+vim.v.argv = ...\n+\n+--- Argument for evaluating 'formatexpr' and used for the typed\n+--- character when using <expr> in an abbreviation `:map-<expr>`.\n+--- It is also used by the `InsertCharPre` and `InsertEnter` events.\n+--- @type any\n+vim.v.char = ...\n+\n+--- The name of the character encoding of a file to be converted.\n+--- Only valid while evaluating the 'charconvert' option.\n+--- @type string\n+vim.v.charconvert_from = ...\n+\n+--- The name of the character encoding of a file after conversion.\n+--- Only valid while evaluating the 'charconvert' option.\n+--- @type string\n+vim.v.charconvert_to = ...\n+\n+--- The extra arguments (\"++p\", \"++enc=\", \"++ff=\") given to a file\n+--- read/write command.  This is set before an autocommand event\n+--- for a file read/write command is triggered.  There is a\n+--- leading space to make it possible to append this variable\n+--- directly after the read/write command. Note: \"+cmd\" isn't\n+--- included here, because it will be executed anyway.\n+--- @type string[]\n+vim.v.cmdarg = ...\n+\n+--- Set like v:cmdarg for a file read/write command.  When a \"!\"\n+--- was used the value is 1, otherwise it is 0.  Note that this\n+--- can only be used in autocommands.  For user commands `<bang>`\n+--- can be used.\n+--- @type any\n+vim.v.cmdbang = ...\n+\n+--- The current locale setting for collation order of the runtime\n+--- environment.  This allows Vim scripts to be aware of the\n+--- current locale encoding.  Technical: it's the value of\n+--- LC_COLLATE.  When not using a locale the value is \"C\".\n+--- This variable can not be set directly, use the `:language`\n+--- command.\n+--- See `multi-lang`.\n+--- @type string\n+vim.v.collate = ...\n+\n+--- Dictionary containing the most recent `complete-items` after\n+--- `CompleteDone`.  Empty if the completion failed, or after\n+--- leaving and re-entering insert mode.\n+--- Note: Plugins can modify the value to emulate the builtin\n+--- `CompleteDone` event behavior.\n+--- @type any\n+vim.v.completed_item = ...\n+\n --- The count given for the last Normal mode command.  Can be used\n --- to get the count before a mapping.  Read-only.  Example:\n+---\n --- ```vim\n---- :map _x :<C-U>echo \"the count is \" .. v:count<CR>\n---- ```\n+---   :map _x :<C-U>echo \"the count is \" .. v:count<CR>\n+--- <",
            "html_url": "https://github.com/neovim/neovim/pull/26682#discussion_r1433290141",
            "id": 1433290141,
            "in_reply_to_id": 1432986617,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5VbkWd",
            "original_commit_id": "f098bb5fea6f6ae5b21d0ab3ddac1e7c84713a12",
            "original_line": 70,
            "original_position": 74,
            "original_start_line": 68,
            "path": "runtime/lua/vim/_meta/vvars.lua",
            "position": null,
            "pull_request_review_id": 1791908052,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433290141/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-12-21T00:02:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433290141",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26682#discussion_r1433775863"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433775863"
                }
            },
            "author_association": "MEMBER",
            "body": "> Isn't single quotes fine for a **single** char?\r\n\r\nAh, you're right, I missed that (also for non-alphanumeric chars); I was worried that the vimdoc parser is not as lenient, but I just tested that it is.\r\n\r\n(Have I mentioned how much I hate vimdoc and it's Pirate Code of a \"specification\"?) ",
            "commit_id": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
            "created_at": "2023-12-21T09:12:01Z",
            "diff_hunk": "@@ -0,0 +1,869 @@\n+local M = {}\n+\n+M.vars = {\n+  argv = {\n+    type = 'string[]',\n+    desc = [=[\n+      The command line arguments Vim was invoked with.  This is a\n+      list of strings.  The first item is the Vim command.\n+      See |v:progpath| for the command with full path.\n+    ]=],\n+  },\n+  char = {\n+    desc = [=[\n+      Argument for evaluating 'formatexpr' and used for the typed\n+      character when using <expr> in an abbreviation |:map-<expr>|.\n+      It is also used by the |InsertCharPre| and |InsertEnter| events.\n+    ]=],\n+  },\n+  charconvert_from = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file to be converted.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  charconvert_to = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file after conversion.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  cmdarg = {\n+    type = 'string[]',\n+    desc = [=[\n+      The extra arguments (\"++p\", \"++enc=\", \"++ff=\") given to a file\n+      read/write command.  This is set before an autocommand event\n+      for a file read/write command is triggered.  There is a\n+      leading space to make it possible to append this variable\n+      directly after the read/write command. Note: \"+cmd\" isn't\n+      included here, because it will be executed anyway.\n+    ]=],\n+  },\n+  collate = {\n+    type = 'string',\n+    desc = [=[\n+      The current locale setting for collation order of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current locale encoding.  Technical: it's the value of\n+      LC_COLLATE.  When not using a locale the value is \"C\".\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      See |multi-lang|.\n+    ]=],\n+  },\n+  cmdbang = {\n+    desc = [=[\n+      Set like v:cmdarg for a file read/write command.  When a \"!\"\n+      was used the value is 1, otherwise it is 0.  Note that this\n+      can only be used in autocommands.  For user commands |<bang>|\n+      can be used.\n+    ]=],\n+  },\n+  completed_item = {\n+    desc = [=[\n+      Dictionary containing the most recent |complete-items| after\n+      |CompleteDone|.  Empty if the completion failed, or after\n+      leaving and re-entering insert mode.\n+      Note: Plugins can modify the value to emulate the builtin\n+      |CompleteDone| event behavior.\n+    ]=],\n+  },\n+  count = {\n+    type = 'integer',\n+    desc = [=[\n+      The count given for the last Normal mode command.  Can be used\n+      to get the count before a mapping.  Read-only.  Example: >vim\n+        :map _x :<C-U>echo \"the count is \" .. v:count<CR>\n+      <\n+      Note: The <C-U> is required to remove the line range that you\n+      get when typing ':' after a count.",
            "html_url": "https://github.com/neovim/neovim/pull/26682#discussion_r1433775863",
            "id": 1433775863,
            "in_reply_to_id": 1432990438,
            "line": 81,
            "node_id": "PRRC_kwDOAPphoM5Vda73",
            "original_commit_id": "f098bb5fea6f6ae5b21d0ab3ddac1e7c84713a12",
            "original_line": 81,
            "original_position": 81,
            "original_start_line": null,
            "path": "src/nvim/vvars.lua",
            "position": 81,
            "pull_request_review_id": 1792535729,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 1,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433775863/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-12-21T09:12:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433775863",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26682#discussion_r1433958020"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433958020"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n                         changing window  (or tab) on |DirChanged|.\r\n```",
            "commit_id": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
            "created_at": "2023-12-21T11:39:49Z",
            "diff_hunk": "@@ -0,0 +1,868 @@\n+local M = {}\n+\n+M.vars = {\n+  argv = {\n+    type = 'string[]',\n+    desc = [=[\n+      The command line arguments Vim was invoked with.  This is a\n+      list of strings.  The first item is the Vim command.\n+      See |v:progpath| for the command with full path.\n+    ]=],\n+  },\n+  char = {\n+    desc = [=[\n+      Argument for evaluating 'formatexpr' and used for the typed\n+      character when using <expr> in an abbreviation |:map-<expr>|.\n+      It is also used by the |InsertCharPre| and |InsertEnter| events.\n+    ]=],\n+  },\n+  charconvert_from = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file to be converted.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  charconvert_to = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file after conversion.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  cmdarg = {\n+    type = 'string[]',\n+    desc = [=[\n+      The extra arguments (\"++p\", \"++enc=\", \"++ff=\") given to a file\n+      read/write command.  This is set before an autocommand event\n+      for a file read/write command is triggered.  There is a\n+      leading space to make it possible to append this variable\n+      directly after the read/write command. Note: \"+cmd\" isn't\n+      included here, because it will be executed anyway.\n+    ]=],\n+  },\n+  collate = {\n+    type = 'string',\n+    desc = [=[\n+      The current locale setting for collation order of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current locale encoding.  Technical: it's the value of\n+      LC_COLLATE.  When not using a locale the value is \"C\".\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      See |multi-lang|.\n+    ]=],\n+  },\n+  cmdbang = {\n+    desc = [=[\n+      Set like v:cmdarg for a file read/write command.  When a \"!\"\n+      was used the value is 1, otherwise it is 0.  Note that this\n+      can only be used in autocommands.  For user commands |<bang>|\n+      can be used.\n+    ]=],\n+  },\n+  completed_item = {\n+    desc = [=[\n+      Dictionary containing the most recent |complete-items| after\n+      |CompleteDone|.  Empty if the completion failed, or after\n+      leaving and re-entering insert mode.\n+      Note: Plugins can modify the value to emulate the builtin\n+      |CompleteDone| event behavior.\n+    ]=],\n+  },\n+  count = {\n+    type = 'integer',\n+    desc = [=[\n+      The count given for the last Normal mode command.  Can be used\n+      to get the count before a mapping.  Read-only.  Example: >vim\n+        :map _x :<C-U>echo \"the count is \" .. v:count<CR>\n+      <\n+      Note: The <C-U> is required to remove the line range that you\n+      get when typing ':' after a count.\n+      When there are two counts, as in \"3d2w\", they are multiplied,\n+      just like what happens in the command, \"d6w\" for the example.\n+      Also used for evaluating the 'formatexpr' option.\n+    ]=],\n+  },\n+  count1 = {\n+    type = 'integer',\n+    desc = [=[\n+      Just like \"v:count\", but defaults to one when no count is\n+      used.\n+    ]=],\n+  },\n+  ctype = {\n+    desc = [=[\n+      The current locale setting for characters of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current locale encoding.  Technical: it's the value of\n+      LC_CTYPE.  When not using a locale the value is \"C\".\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      See |multi-lang|.\n+    ]=],\n+  },\n+  dying = {\n+    type = 'integer',\n+    desc = [=[\n+      Normally zero.  When a deadly signal is caught it's set to\n+      one.  When multiple signals are caught the number increases.\n+      Can be used in an autocommand to check if Vim didn't\n+      terminate normally.\n+      Example: >vim\n+        :au VimLeave * if v:dying | echo \"\\nAAAAaaaarrrggghhhh!!!\\n\" | endif\n+      <\n+      Note: if another deadly signal is caught when v:dying is one,\n+      VimLeave autocommands will not be executed.\n+    ]=],\n+  },\n+  exiting = {\n+    desc = [=[\n+      Exit code, or |v:null| before invoking the |VimLeavePre|\n+      and |VimLeave| autocmds.  See |:q|, |:x| and |:cquit|.\n+      Example: >vim\n+        :au VimLeave * echo \"Exit value is \" .. v:exiting\n+      <\n+    ]=],\n+  },\n+  echospace = {\n+    type = 'integer',\n+    desc = [=[\n+      Number of screen cells that can be used for an `:echo` message\n+      in the last screen line before causing the |hit-enter-prompt|.\n+      Depends on 'showcmd', 'ruler' and 'columns'.  You need to\n+      check 'cmdheight' for whether there are full-width lines\n+      available above the last line.\n+    ]=],\n+  },\n+  errmsg = {\n+    type = 'string',\n+    desc = [=[\n+      Last given error message.\n+      Modifiable (can be set).\n+      Example: >vim\n+        let v:errmsg = \"\"\n+        silent! next\n+        if v:errmsg != \"\"\n+          \" ... handle error\n+      <\n+\n+    ]=],\n+  },\n+  errors = {\n+    tags = { 'assert-return' },\n+    desc = [=[\n+      Errors found by assert functions, such as |assert_true()|.\n+      This is a list of strings.\n+      The assert functions append an item when an assert fails.\n+      The return value indicates this: a one is returned if an item\n+      was added to v:errors, otherwise zero is returned.\n+      To remove old results make it empty: >vim\n+        :let v:errors = []\n+      <\n+      If v:errors is set to anything but a list it is made an empty\n+      list by the assert function.\n+    ]=],\n+  },\n+  event = {\n+    desc = [=[\n+      Dictionary of event data for the current |autocommand|.  Valid\n+      only during the event lifetime; storing or passing v:event is\n+      invalid!  Copy it instead: >vim\n+        au TextYankPost * let g:foo = deepcopy(v:event)\n+      <\n+      Keys vary by event; see the documentation for the specific\n+      event, e.g. |DirChanged| or |TextYankPost|.\n+        KEY              DESCRIPTION ~\n+        abort            Whether the event triggered during\n+                         an aborting condition (e.g. |c_Esc| or\n+                         |c_CTRL-C| for |CmdlineLeave|).\n+        chan             |channel-id|\n+        cmdlevel         Level of cmdline.\n+        cmdtype          Type of cmdline, |cmdline-char|.\n+        cwd              Current working directory.\n+        inclusive        Motion is |inclusive|, else exclusive.\n+        scope            Event-specific scope name.\n+        operator         Current |operator|.  Also set for Ex\n+        commands         (unlike |v:operator|). For\n+                         example if |TextYankPost| is triggered\n+                         by the |:yank| Ex command then\n+                         `v:event.operator` is \"y\".\n+        regcontents      Text stored in the register as a\n+                         |readfile()|-style list of lines.\n+        regname          Requested register (e.g \"x\" for \"xyy)\n+                         or the empty string for an unnamed\n+                         operation.\n+        regtype          Type of register as returned by\n+                         |getregtype()|.\n+        visual           Selection is visual (as opposed to,\n+                         e.g., via motion).\n+        completed_item   Current selected complete item on\n+                         |CompleteChanged|, Is `{}` when no complete\n+                         item selected.\n+        height           Height of popup menu on |CompleteChanged|\n+        width            Width of popup menu on |CompleteChanged|\n+        row              Row count of popup menu on |CompleteChanged|,\n+                         relative to screen.\n+        col              Col count of popup menu on |CompleteChanged|,\n+                         relative to screen.\n+        size             Total number of completion items on\n+                         |CompleteChanged|.\n+        scrollbar        Is |v:true| if popup menu have scrollbar, or\n+                         |v:false| if not.\n+        changed_window   Is |v:true| if the event fired while\n+        changing window  (or tab) on |DirChanged|.",
            "html_url": "https://github.com/neovim/neovim/pull/26682#discussion_r1433958020",
            "id": 1433958020,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5VeHaE",
            "original_commit_id": "51615a2457917ee09a098f60cfabee2022df2957",
            "original_line": 214,
            "original_position": 214,
            "original_start_line": null,
            "path": "src/nvim/vvars.lua",
            "position": null,
            "pull_request_review_id": 1792796313,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433958020/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-12-21T11:39:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433958020",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26682#discussion_r1433959139"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433959139"
                }
            },
            "author_association": "MEMBER",
            "body": "Missing codeblock markers",
            "commit_id": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
            "created_at": "2023-12-21T11:40:54Z",
            "diff_hunk": "@@ -86,217 +94,247 @@ v:ctype\t\tThe current locale setting for characters of the runtime\n \t\tSee |multi-lang|.\n \n \t\t\t\t\t*v:dying* *dying-variable*\n-v:dying\t\tNormally zero.  When a deadly signal is caught it's set to\n+v:dying\n+\t\tNormally zero.  When a deadly signal is caught it's set to\n \t\tone.  When multiple signals are caught the number increases.\n \t\tCan be used in an autocommand to check if Vim didn't\n \t\tterminate normally.\n-\t\tExample: >\n-\t:au VimLeave * if v:dying | echo \"\\nAAAAaaaarrrggghhhh!!!\\n\" | endif\n-<\t\tNote: if another deadly signal is caught when v:dying is one,\n+\t\tExample: >vim\n+\t\t  :au VimLeave * if v:dying | echo \"\\nAAAAaaaarrrggghhhh!!!\\n\" | endif\n+<\n+\t\tNote: if another deadly signal is caught when v:dying is one,\n \t\tVimLeave autocommands will not be executed.\n \n-\t\t\t\t\t*v:exiting* *exiting-variable*\n-v:exiting\tExit code, or |v:null| before invoking the |VimLeavePre|\n-\t\tand |VimLeave| autocmds.  See |:q|, |:x| and |:cquit|.\n-\t\tExample: >\n-\t\t\t:au VimLeave * echo \"Exit value is \" .. v:exiting\n-<\n-\t\t\t\t\t*v:echospace* *echospace-variable*\n-v:echospace\tNumber of screen cells that can be used for an `:echo` message\n+\t\t\t\t*v:echospace* *echospace-variable*\n+v:echospace\n+\t\tNumber of screen cells that can be used for an `:echo` message\n \t\tin the last screen line before causing the |hit-enter-prompt|.\n \t\tDepends on 'showcmd', 'ruler' and 'columns'.  You need to\n \t\tcheck 'cmdheight' for whether there are full-width lines\n \t\tavailable above the last line.\n \n \t\t\t\t\t*v:errmsg* *errmsg-variable*\n-v:errmsg\tLast given error message.\n+v:errmsg\n+\t\tLast given error message.\n \t\tModifiable (can be set).\n-\t\tExample: >\n-\t:let v:errmsg = \"\"\n-\t:silent! next\n-\t:if v:errmsg != \"\"\n-\t:  ... handle error\n+\t\tExample: >vim\n+\t\t  let v:errmsg = \"\"\n+\t\t  silent! next\n+\t\t  if v:errmsg != \"\"\n+\t\t    ... handle error\n <\n-\t\t\t\t*v:errors* *errors-variable* *assert-return*\n-v:errors\tErrors found by assert functions, such as |assert_true()|.\n+\n+\n+\t\t\t*v:errors* *errors-variable* *assert-return*\n+v:errors\n+\t\tErrors found by assert functions, such as |assert_true()|.\n \t\tThis is a list of strings.\n \t\tThe assert functions append an item when an assert fails.\n \t\tThe return value indicates this: a one is returned if an item\n \t\twas added to v:errors, otherwise zero is returned.\n-\t\tTo remove old results make it empty: >\n-\t:let v:errors = []\n-<\t\tIf v:errors is set to anything but a list it is made an empty\n+\t\tTo remove old results make it empty: >vim\n+\t\t  :let v:errors = []\n+<\n+\t\tIf v:errors is set to anything but a list it is made an empty\n \t\tlist by the assert function.\n \n \t\t\t\t\t*v:event* *event-variable*\n-v:event\t\tDictionary of event data for the current |autocommand|.  Valid\n+v:event\n+\t\tDictionary of event data for the current |autocommand|.  Valid\n \t\tonly during the event lifetime; storing or passing v:event is\n-\t\tinvalid!  Copy it instead: >\n-\t\t\tau TextYankPost * let g:foo = deepcopy(v:event)\n-<\t\tKeys vary by event; see the documentation for the specific\n+\t\tinvalid!  Copy it instead: >vim\n+\t\t  au TextYankPost * let g:foo = deepcopy(v:event)\n+<\n+\t\tKeys vary by event; see the documentation for the specific\n \t\tevent, e.g. |DirChanged| or |TextYankPost|.\n-\t\t\tKEY\t\tDESCRIPTION ~\n-\t\t\tabort\t\tWhether the event triggered during\n-\t\t\t\t\tan aborting condition (e.g. |c_Esc| or\n-\t\t\t\t\t|c_CTRL-C| for |CmdlineLeave|).\n-\t\t\tchan\t\t|channel-id|\n-\t\t\tcmdlevel\tLevel of cmdline.\n-\t\t\tcmdtype\t\tType of cmdline, |cmdline-char|.\n-\t\t\tcwd\t\tCurrent working directory.\n-\t\t\tinclusive\tMotion is |inclusive|, else exclusive.\n-\t\t\tscope\t\tEvent-specific scope name.\n-\t\t\toperator\tCurrent |operator|.  Also set for Ex\n-\t\t\t\t\tcommands (unlike |v:operator|). For\n-\t\t\t\t\texample if |TextYankPost| is triggered\n-\t\t\t\t\tby the |:yank| Ex command then\n-\t\t\t\t\t`v:event.operator` is \"y\".\n-\t\t\tregcontents\tText stored in the register as a\n-\t\t\t\t\t|readfile()|-style list of lines.\n-\t\t\tregname\t\tRequested register (e.g \"x\" for \"xyy)\n-\t\t\t\t\tor the empty string for an unnamed\n-\t\t\t\t\toperation.\n-\t\t\tregtype\t\tType of register as returned by\n-\t\t\t\t\t|getregtype()|.\n-\t\t\tvisual\t\tSelection is visual (as opposed to,\n-\t\t\t\t\te.g., via motion).\n-\t\t\tcompleted_item    Current selected complete item on\n-\t\t\t\t\t|CompleteChanged|, Is `{}` when no complete\n-\t\t\t\t\titem selected.\n-\t\t\theight\t\tHeight of popup menu on |CompleteChanged|\n-\t\t\twidth\t\twidth of popup menu on |CompleteChanged|\n-\t\t\trow\t\tRow count of popup menu on |CompleteChanged|,\n-\t\t\t\t\trelative to screen.\n-\t\t\tcol\t\tCol count of popup menu on |CompleteChanged|,\n-\t\t\t\t\trelative to screen.\n-\t\t\tsize\t\tTotal number of completion items on\n-\t\t\t\t\t|CompleteChanged|.\n-\t\t\tscrollbar\tIs |v:true| if popup menu have scrollbar, or\n-\t\t\t\t\t|v:false| if not.\n-\t\t\tchanged_window\tIs |v:true| if the event fired while\n-\t\t\t\t\tchanging window (or tab) on |DirChanged|.\n-\t\t\tstatus\t\tJob status or exit code, -1 means \"unknown\". |TermClose|\n-\n-\t\t\t\t\t*v:exception* *exception-variable*\n-v:exception\tThe value of the exception most recently caught and not\n+\t\t  KEY              DESCRIPTION ~\n+\t\t  abort            Whether the event triggered during\n+\t\t                   an aborting condition (e.g. |c_Esc| or\n+\t\t                   |c_CTRL-C| for |CmdlineLeave|).\n+\t\t  chan             |channel-id|\n+\t\t  cmdlevel         Level of cmdline.\n+\t\t  cmdtype          Type of cmdline, |cmdline-char|.\n+\t\t  cwd              Current working directory.\n+\t\t  inclusive        Motion is |inclusive|, else exclusive.\n+\t\t  scope            Event-specific scope name.\n+\t\t  operator         Current |operator|.  Also set for Ex\n+\t\t  commands         (unlike |v:operator|). For\n+\t\t                   example if |TextYankPost| is triggered\n+\t\t                   by the |:yank| Ex command then\n+\t\t                   `v:event.operator` is \"y\".\n+\t\t  regcontents      Text stored in the register as a\n+\t\t                   |readfile()|-style list of lines.\n+\t\t  regname          Requested register (e.g \"x\" for \"xyy)\n+\t\t                   or the empty string for an unnamed\n+\t\t                   operation.\n+\t\t  regtype          Type of register as returned by\n+\t\t                   |getregtype()|.\n+\t\t  visual           Selection is visual (as opposed to,\n+\t\t                   e.g., via motion).\n+\t\t  completed_item   Current selected complete item on\n+\t\t                   |CompleteChanged|, Is `{}` when no complete\n+\t\t                   item selected.\n+\t\t  height           Height of popup menu on |CompleteChanged|\n+\t\t  width            Width of popup menu on |CompleteChanged|\n+\t\t  row              Row count of popup menu on |CompleteChanged|,\n+\t\t                   relative to screen.\n+\t\t  col              Col count of popup menu on |CompleteChanged|,\n+\t\t                   relative to screen.\n+\t\t  size             Total number of completion items on\n+\t\t                   |CompleteChanged|.\n+\t\t  scrollbar        Is |v:true| if popup menu have scrollbar, or\n+\t\t                   |v:false| if not.\n+\t\t  changed_window   Is |v:true| if the event fired while\n+\t\t  changing window  (or tab) on |DirChanged|.\n+\t\t  status           Job status or exit code, -1 means \"unknown\". |TermClose|\n+\n+\t\t\t\t*v:exception* *exception-variable*\n+v:exception\n+\t\tThe value of the exception most recently caught and not\n \t\tfinished.  See also |v:throwpoint| and |throw-variables|.\n-\t\tExample: >\n-\t:try\n-\t:  throw \"oops\"\n-\t:catch /.*/\n-\t:  echo \"caught \" .. v:exception\n-\t:endtry\n-<\t\tOutput: \"caught oops\".\n+\t\tExample: >vim\n+\t\t  try\n+\t\t    throw \"oops\"\n+\t\t  catch /.*/\n+\t\t    echo \"caught \" .. v:exception\n+\t\t  endtry\n+<\n+\t\tOutput: \"caught oops\".\n+\n+\t\t\t\t\t*v:exiting* *exiting-variable*\n+v:exiting\n+\t\tExit code, or |v:null| before invoking the |VimLeavePre|\n+\t\tand |VimLeave| autocmds.  See |:q|, |:x| and |:cquit|.\n+\t\tExample: >vim\n+\t\t  :au VimLeave * echo \"Exit value is \" .. v:exiting\n+<\n \n \t\t\t\t\t*v:false* *false-variable*\n-v:false\t\tSpecial value used to put \"false\" in JSON and msgpack.  See\n+v:false\n+\t\tSpecial value used to put \"false\" in JSON and msgpack.  See\n \t\t|json_encode()|.  This value is converted to \"v:false\" when used\n \t\tas a String (e.g. in |expr5| with string concatenation\n \t\toperator) and to zero when used as a Number (e.g. in |expr5|\n \t\tor |expr7| when used with numeric operators). Read-only.\n \n-\t\t\t\t\t*v:fcs_reason* *fcs_reason-variable*\n-v:fcs_reason\tThe reason why the |FileChangedShell| event was triggered.\n-\t\tCan be used in an autocommand to decide what to do and/or what\n-\t\tto set v:fcs_choice to.  Possible values:\n-\t\t\tdeleted\t\tfile no longer exists\n-\t\t\tconflict\tfile contents, mode or timestamp was\n-\t\t\t\t\tchanged and buffer is modified\n-\t\t\tchanged\t\tfile contents has changed\n-\t\t\tmode\t\tmode of file changed\n-\t\t\ttime\t\tonly file timestamp changed\n-\n-\t\t\t\t\t*v:fcs_choice* *fcs_choice-variable*\n-v:fcs_choice\tWhat should happen after a |FileChangedShell| event was\n+\t\t\t\t*v:fcs_choice* *fcs_choice-variable*\n+v:fcs_choice\n+\t\tWhat should happen after a |FileChangedShell| event was\n \t\ttriggered.  Can be used in an autocommand to tell Vim what to\n \t\tdo with the affected buffer:\n-\t\t\treload\t\tReload the buffer (does not work if\n-\t\t\t\t\tthe file was deleted).\n-\t\t\tedit\t\tReload the buffer and detect the\n-\t\t\t\t\tvalues for options such as\n-\t\t\t\t\t'fileformat', 'fileencoding', 'binary'\n-\t\t\t\t\t(does not work if the file was\n-\t\t\t\t\tdeleted).\n-\t\t\task\t\tAsk the user what to do, as if there\n-\t\t\t\t\twas no autocommand.  Except that when\n-\t\t\t\t\tonly the timestamp changed nothing\n-\t\t\t\t\twill happen.\n-\t\t\t<empty>\t\tNothing, the autocommand should do\n-\t\t\t\t\teverything that needs to be done.\n+\t\t  reload  Reload the buffer (does not work if\n+\t\t          the file was deleted).\n+\t\t  edit    Reload the buffer and detect the\n+\t\t          values for options such as\n+\t\t          'fileformat', 'fileencoding', 'binary'\n+\t\t          (does not work if the file was\n+\t\t          deleted).\n+\t\t  ask     Ask the user what to do, as if there\n+\t\t          was no autocommand.  Except that when\n+\t\t          only the timestamp changed nothing\n+\t\t          will happen.\n+\t\t  <empty> Nothing, the autocommand should do\n+\t\t          everything that needs to be done.\n \t\tThe default is empty.  If another (invalid) value is used then\n \t\tVim behaves like it is empty, there is no warning message.\n \n+\t\t\t\t*v:fcs_reason* *fcs_reason-variable*\n+v:fcs_reason\n+\t\tThe reason why the |FileChangedShell| event was triggered.\n+\t\tCan be used in an autocommand to decide what to do and/or what\n+\t\tto set v:fcs_choice to.  Possible values:\n+\t\t  deleted   file no longer exists\n+\t\t  conflict  file contents, mode or timestamp was\n+\t\t            changed and buffer is modified\n+\t\t  changed   file contents has changed\n+\t\t  mode      mode of file changed\n+\t\t  time      only file timestamp changed\n+\n \t\t\t\t\t*v:fname* *fname-variable*\n-v:fname\t\tWhen evaluating 'includeexpr': the file name that was\n+v:fname\n+\t\tWhen evaluating 'includeexpr': the file name that was\n \t\tdetected.  Empty otherwise.\n \n+\t\t\t\t*v:fname_diff* *fname_diff-variable*\n+v:fname_diff\n+\t\tThe name of the diff (patch) file.  Only valid while\n+\t\tevaluating 'patchexpr'.\n+\n \t\t\t\t\t*v:fname_in* *fname_in-variable*\n-v:fname_in\tThe name of the input file.  Valid while evaluating:\n-\t\t\toption\t\tused for ~\n-\t\t\t'charconvert'\tfile to be converted\n-\t\t\t'diffexpr'\toriginal file\n-\t\t\t'patchexpr'\toriginal file\n+v:fname_in\n+\t\tThe name of the input file.  Valid while evaluating:\n+\t\t  option         used for ~\n+\t\t  'charconvert'  file to be converted\n+\t\t  'diffexpr'     original file\n+\t\t  'patchexpr'    original file\n \t\tAnd set to the swap file name for |SwapExists|.\n \n-\t\t\t\t\t*v:fname_out* *fname_out-variable*\n-v:fname_out\tThe name of the output file.  Only valid while\n+\t\t\t\t*v:fname_new* *fname_new-variable*\n+v:fname_new\n+\t\tThe name of the new version of the file.  Only valid while\n+\t\tevaluating 'diffexpr'.\n+\n+\t\t\t\t*v:fname_out* *fname_out-variable*\n+v:fname_out\n+\t\tThe name of the output file.  Only valid while\n \t\tevaluating:\n-\t\t\toption\t\tused for ~\n-\t\t\t'charconvert'\tresulting converted file [1]\n-\t\t\t'diffexpr'\toutput of diff\n-\t\t\t'patchexpr'\tresulting patched file\n+\t\t  option           used for ~\n+\t\t  'charconvert'    resulting converted file [1]\n+\t\t  'diffexpr'       output of diff\n+\t\t  'patchexpr'      resulting patched file\n \t\t[1] When doing conversion for a write command (e.g., \":w\n \t\tfile\") it will be equal to v:fname_in.  When doing conversion\n \t\tfor a read command (e.g., \":e file\") it will be a temporary\n \t\tfile and different from v:fname_in.\n \n-\t\t\t\t\t*v:fname_new* *fname_new-variable*\n-v:fname_new\tThe name of the new version of the file.  Only valid while\n-\t\tevaluating 'diffexpr'.\n-\n-\t\t\t\t\t*v:fname_diff* *fname_diff-variable*\n-v:fname_diff\tThe name of the diff (patch) file.  Only valid while\n-\t\tevaluating 'patchexpr'.\n-\n-\t\t\t\t\t*v:folddashes* *folddashes-variable*\n-v:folddashes\tUsed for 'foldtext': dashes representing foldlevel of a closed\n+\t\t\t\t*v:folddashes* *folddashes-variable*\n+v:folddashes\n+\t\tUsed for 'foldtext': dashes representing foldlevel of a closed\n \t\tfold.\n \t\tRead-only in the |sandbox|. |fold-foldtext|\n \n-\t\t\t\t\t*v:foldlevel* *foldlevel-variable*\n-v:foldlevel\tUsed for 'foldtext': foldlevel of closed fold.\n+\t\t\t\t\t*v:foldend* *foldend-variable*\n+v:foldend\n+\t\tUsed for 'foldtext': last line of closed fold.\n \t\tRead-only in the |sandbox|. |fold-foldtext|\n \n-\t\t\t\t\t*v:foldend* *foldend-variable*\n-v:foldend\tUsed for 'foldtext': last line of closed fold.\n+\t\t\t\t*v:foldlevel* *foldlevel-variable*\n+v:foldlevel\n+\t\tUsed for 'foldtext': foldlevel of closed fold.\n \t\tRead-only in the |sandbox|. |fold-foldtext|\n \n-\t\t\t\t\t*v:foldstart* *foldstart-variable*\n-v:foldstart\tUsed for 'foldtext': first line of closed fold.\n+\t\t\t\t*v:foldstart* *foldstart-variable*\n+v:foldstart\n+\t\tUsed for 'foldtext': first line of closed fold.\n \t\tRead-only in the |sandbox|. |fold-foldtext|\n \n \t\t\t\t\t*v:hlsearch* *hlsearch-variable*\n-v:hlsearch\tVariable that indicates whether search highlighting is on.\n+v:hlsearch\n+\t\tVariable that indicates whether search highlighting is on.\n \t\tSetting it makes sense only if 'hlsearch' is enabled. Setting\n \t\tthis variable to zero acts like the |:nohlsearch| command,\n-\t\tsetting it to one acts like >\n-\t\t\tlet &hlsearch = &hlsearch\n-<\t\tNote that the value is restored when returning from a\n+\t\tsetting it to one acts like\n+\t\tlet &hlsearch = &hlsearch\n+\t\tNote that the value is restored when returning from a",
            "html_url": "https://github.com/neovim/neovim/pull/26682#discussion_r1433959139",
            "id": 1433959139,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5VeHrj",
            "original_commit_id": "f098bb5fea6f6ae5b21d0ab3ddac1e7c84713a12",
            "original_line": 318,
            "original_position": 448,
            "original_start_line": 316,
            "path": "runtime/doc/vvars.txt",
            "position": null,
            "pull_request_review_id": 1792797934,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433959139/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-12-21T11:40:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1433959139",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26682#discussion_r1434080470"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1434080470"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n```",
            "commit_id": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
            "created_at": "2023-12-21T13:29:16Z",
            "diff_hunk": "@@ -0,0 +1,869 @@\n+local M = {}\n+\n+M.vars = {\n+  argv = {\n+    type = 'string[]',\n+    desc = [=[\n+      The command line arguments Vim was invoked with.  This is a\n+      list of strings.  The first item is the Vim command.\n+      See |v:progpath| for the command with full path.\n+    ]=],\n+  },\n+  char = {\n+    desc = [=[\n+      Argument for evaluating 'formatexpr' and used for the typed\n+      character when using <expr> in an abbreviation |:map-<expr>|.\n+      It is also used by the |InsertCharPre| and |InsertEnter| events.\n+    ]=],\n+  },\n+  charconvert_from = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file to be converted.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  charconvert_to = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file after conversion.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  cmdarg = {\n+    type = 'string[]',\n+    desc = [=[\n+      The extra arguments (\"++p\", \"++enc=\", \"++ff=\") given to a file\n+      read/write command.  This is set before an autocommand event\n+      for a file read/write command is triggered.  There is a\n+      leading space to make it possible to append this variable\n+      directly after the read/write command. Note: \"+cmd\" isn't\n+      included here, because it will be executed anyway.\n+    ]=],\n+  },\n+  collate = {\n+    type = 'string',\n+    desc = [=[\n+      The current locale setting for collation order of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current locale encoding.  Technical: it's the value of\n+      LC_COLLATE.  When not using a locale the value is \"C\".\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      See |multi-lang|.\n+    ]=],\n+  },\n+  cmdbang = {\n+    desc = [=[\n+      Set like v:cmdarg for a file read/write command.  When a \"!\"\n+      was used the value is 1, otherwise it is 0.  Note that this\n+      can only be used in autocommands.  For user commands |<bang>|\n+      can be used.\n+    ]=],\n+  },\n+  completed_item = {\n+    desc = [=[\n+      Dictionary containing the most recent |complete-items| after\n+      |CompleteDone|.  Empty if the completion failed, or after\n+      leaving and re-entering insert mode.\n+      Note: Plugins can modify the value to emulate the builtin\n+      |CompleteDone| event behavior.\n+    ]=],\n+  },\n+  count = {\n+    type = 'integer',\n+    desc = [=[\n+      The count given for the last Normal mode command.  Can be used\n+      to get the count before a mapping.  Read-only.  Example: >vim\n+        :map _x :<C-U>echo \"the count is \" .. v:count<CR>\n+      <\n+      Note: The <C-U> is required to remove the line range that you\n+      get when typing ':' after a count.\n+      When there are two counts, as in \"3d2w\", they are multiplied,\n+      just like what happens in the command, \"d6w\" for the example.\n+      Also used for evaluating the 'formatexpr' option.\n+    ]=],\n+  },\n+  count1 = {\n+    type = 'integer',\n+    desc = [=[\n+      Just like \"v:count\", but defaults to one when no count is\n+      used.\n+    ]=],\n+  },\n+  ctype = {\n+    desc = [=[\n+      The current locale setting for characters of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current locale encoding.  Technical: it's the value of\n+      LC_CTYPE.  When not using a locale the value is \"C\".\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      See |multi-lang|.\n+    ]=],\n+  },\n+  dying = {\n+    type = 'integer',\n+    desc = [=[\n+      Normally zero.  When a deadly signal is caught it's set to\n+      one.  When multiple signals are caught the number increases.\n+      Can be used in an autocommand to check if Vim didn't\n+      terminate normally.\n+      Example: >vim\n+        :au VimLeave * if v:dying | echo \"\\nAAAAaaaarrrggghhhh!!!\\n\" | endif\n+      <\n+      Note: if another deadly signal is caught when v:dying is one,\n+      VimLeave autocommands will not be executed.\n+    ]=],\n+  },\n+  exiting = {\n+    desc = [=[\n+      Exit code, or |v:null| before invoking the |VimLeavePre|\n+      and |VimLeave| autocmds.  See |:q|, |:x| and |:cquit|.\n+      Example: >vim\n+        :au VimLeave * echo \"Exit value is \" .. v:exiting\n+      <\n+    ]=],\n+  },\n+  echospace = {\n+    type = 'integer',\n+    desc = [=[\n+      Number of screen cells that can be used for an `:echo` message\n+      in the last screen line before causing the |hit-enter-prompt|.\n+      Depends on 'showcmd', 'ruler' and 'columns'.  You need to\n+      check 'cmdheight' for whether there are full-width lines\n+      available above the last line.\n+    ]=],\n+  },\n+  errmsg = {\n+    type = 'string',\n+    desc = [=[\n+      Last given error message.\n+      Modifiable (can be set).\n+      Example: >vim\n+        let v:errmsg = \"\"\n+        silent! next\n+        if v:errmsg != \"\"\n+          \" ... handle error\n+      <\n+",
            "html_url": "https://github.com/neovim/neovim/pull/26682#discussion_r1434080470",
            "id": 1434080470,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5VelTW",
            "original_commit_id": "291f779f57cd21a16d180b667b3e875e16051b2e",
            "original_line": 149,
            "original_position": 149,
            "original_start_line": null,
            "path": "src/nvim/vvars.lua",
            "position": null,
            "pull_request_review_id": 1792975424,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1434080470/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-12-21T13:33:11Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1434080470",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26682#discussion_r1434084391"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1434084391"
                }
            },
            "author_association": "MEMBER",
            "body": "This tag's position is a bit strange.",
            "commit_id": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
            "created_at": "2023-12-21T13:33:17Z",
            "diff_hunk": "@@ -457,111 +525,131 @@ v:register\tThe name of the register in effect for the current normal mode\n \t\tAlso see |getreg()| and |setreg()|\n \n \t\t\t\t\t*v:relnum* *relnum-variable*\n-v:relnum\tRelative line number for the 'statuscolumn' expression.\n+v:relnum\n+\t\tRelative line number for the 'statuscolumn' expression.\n \t\tRead-only.\n \n-\t\t\t\t\t*v:scrollstart* *scrollstart-variable*\n-v:scrollstart\tString describing the script or function that caused the\n+\t\t\t\t*v:scrollstart* *scrollstart-variable*\n+v:scrollstart\n+\t\tString describing the script or function that caused the\n \t\tscreen to scroll up.  It's only set when it is empty, thus the\n \t\tfirst reason is remembered.  It is set to \"Unknown\" for a\n \t\ttyped command.\n \t\tThis can be used to find out why your script causes the\n \t\thit-enter prompt.\n \n-\t\t\t\t\t*v:servername* *servername-variable*\n-v:servername\tPrimary listen-address of Nvim, the first item returned by\n+\t\t\t*v:searchforward* *searchforward-variable*\n+v:searchforward\n+\t\tSearch direction:  1 after a forward search, 0 after a\n+\t\tbackward search.  It is reset to forward when directly setting\n+\t\tthe last search pattern, see |quote/|.\n+\t\tNote that the value is restored when returning from a\n+\t\tfunction. |function-search-undo|.\n+\t\tRead-write.\n+\n+\t\t\t\t*v:servername* *servername-variable*\n+v:servername\n+\t\tPrimary listen-address of Nvim, the first item returned by\n \t\t|serverlist()|. Usually this is the named pipe created by Nvim\n \t\tat |startup| or given by |--listen| (or the deprecated\n \t\t|$NVIM_LISTEN_ADDRESS| env var).\n \n \t\tSee also |serverstart()| |serverstop()|.\n \t\tRead-only.\n \n-\t\t\t\t\t\t\t\t       *$NVIM*\n+\t\t                   *$NVIM*",
            "html_url": "https://github.com/neovim/neovim/pull/26682#discussion_r1434084391",
            "id": 1434084391,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5VemQn",
            "original_commit_id": "f098bb5fea6f6ae5b21d0ab3ddac1e7c84713a12",
            "original_line": 560,
            "original_position": 767,
            "original_start_line": null,
            "path": "runtime/doc/vvars.txt",
            "position": null,
            "pull_request_review_id": 1792981673,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1434084391/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-12-21T13:33:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1434084391",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26682#discussion_r1434084906"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1434084906"
                }
            },
            "author_association": "MEMBER",
            "body": "Missing code block markers",
            "commit_id": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
            "created_at": "2023-12-21T13:33:45Z",
            "diff_hunk": "@@ -457,111 +525,131 @@ v:register\tThe name of the register in effect for the current normal mode\n \t\tAlso see |getreg()| and |setreg()|\n \n \t\t\t\t\t*v:relnum* *relnum-variable*\n-v:relnum\tRelative line number for the 'statuscolumn' expression.\n+v:relnum\n+\t\tRelative line number for the 'statuscolumn' expression.\n \t\tRead-only.\n \n-\t\t\t\t\t*v:scrollstart* *scrollstart-variable*\n-v:scrollstart\tString describing the script or function that caused the\n+\t\t\t\t*v:scrollstart* *scrollstart-variable*\n+v:scrollstart\n+\t\tString describing the script or function that caused the\n \t\tscreen to scroll up.  It's only set when it is empty, thus the\n \t\tfirst reason is remembered.  It is set to \"Unknown\" for a\n \t\ttyped command.\n \t\tThis can be used to find out why your script causes the\n \t\thit-enter prompt.\n \n-\t\t\t\t\t*v:servername* *servername-variable*\n-v:servername\tPrimary listen-address of Nvim, the first item returned by\n+\t\t\t*v:searchforward* *searchforward-variable*\n+v:searchforward\n+\t\tSearch direction:  1 after a forward search, 0 after a\n+\t\tbackward search.  It is reset to forward when directly setting\n+\t\tthe last search pattern, see |quote/|.\n+\t\tNote that the value is restored when returning from a\n+\t\tfunction. |function-search-undo|.\n+\t\tRead-write.\n+\n+\t\t\t\t*v:servername* *servername-variable*\n+v:servername\n+\t\tPrimary listen-address of Nvim, the first item returned by\n \t\t|serverlist()|. Usually this is the named pipe created by Nvim\n \t\tat |startup| or given by |--listen| (or the deprecated\n \t\t|$NVIM_LISTEN_ADDRESS| env var).\n \n \t\tSee also |serverstart()| |serverstop()|.\n \t\tRead-only.\n \n-\t\t\t\t\t\t\t\t       *$NVIM*\n+\t\t                   *$NVIM*\n \t\t$NVIM is set by |terminal| and |jobstart()|, and is thus\n \t\ta hint that the current environment is a subprocess of Nvim.\n-\t\tExample: >\n-\t\t    if $NVIM\n-\t\t      echo nvim_get_chan_info(v:parent)\n-\t\t    endif\n-\n-<\t\tNote the contents of $NVIM may change in the future.\n+\t\tExample: >vim\n+\t\t  if $NVIM\n+\t\t    echo nvim_get_chan_info(v:parent)\n+\t\t  endif\n+<\n \n-v:searchforward\t\t\t*v:searchforward* *searchforward-variable*\n-\t\tSearch direction:  1 after a forward search, 0 after a\n-\t\tbackward search.  It is reset to forward when directly setting\n-\t\tthe last search pattern, see |quote/|.\n-\t\tNote that the value is restored when returning from a\n-\t\tfunction. |function-search-undo|.\n-\t\tRead-write.\n+\t\tNote the contents of $NVIM may change in the future.\n \n-\t\t\t\t\t*v:shell_error* *shell_error-variable*\n-v:shell_error\tResult of the last shell command.  When non-zero, the last\n+\t\t\t\t*v:shell_error* *shell_error-variable*\n+v:shell_error\n+\t\tResult of the last shell command.  When non-zero, the last\n \t\tshell command had an error.  When zero, there was no problem.\n \t\tThis only works when the shell returns the error code to Vim.\n \t\tThe value -1 is often used when the command could not be\n \t\texecuted.  Read-only.\n-\t\tExample: >\n-\t:!mv foo bar\n-\t:if v:shell_error\n-\t:  echo 'could not rename \"foo\" to \"bar\"!'\n-\t:endif\n+\t\tExample: >vim\n+\t\t  !mv foo bar\n+\t\t  if v:shell_error\n+\t\t    echo 'could not rename \"foo\" to \"bar\"!'\n+\t\t  endif\n <\n-\t\t\t\t\t*v:statusmsg* *statusmsg-variable*\n-v:statusmsg\tLast given status message.\n+\n+\t\t\t\t*v:statusmsg* *statusmsg-variable*\n+v:statusmsg\n+\t\tLast given status message.\n \t\tModifiable (can be set).\n \n \t\t\t\t\t*v:stderr* *stderr-variable*\n-v:stderr\t|channel-id| corresponding to stderr. The value is always 2;\n+v:stderr\n+\t\t|channel-id| corresponding to stderr. The value is always 2;\n \t\tuse this variable to make your code more descriptive.\n \t\tUnlike stdin and stdout (see |stdioopen()|), stderr is always\n-\t\topen for writing. Example: >\n-\t\t\t:call chansend(v:stderr, \"error: toaster empty\\n\")\n-<\n-\t\t\t\t\t*v:swapname* *swapname-variable*\n-v:swapname\tName of the swapfile found.\n-\t\tOnly valid during |SwapExists| event.\n-\t\tRead-only.\n+\t\topen for writing. Example:\n+\t\t:call chansend(v:stderr, \"error: toaster empty\\n\")",
            "html_url": "https://github.com/neovim/neovim/pull/26682#discussion_r1434084906",
            "id": 1434084906,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5VemYq",
            "original_commit_id": "f098bb5fea6f6ae5b21d0ab3ddac1e7c84713a12",
            "original_line": 595,
            "original_position": 833,
            "original_start_line": 595,
            "path": "runtime/doc/vvars.txt",
            "position": null,
            "pull_request_review_id": 1792982747,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1434084906/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-12-21T13:33:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1434084906",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26682#discussion_r1434086419"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26682"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1434086419"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n        try\r\n          throw \"oops\"\r\n        catch /.*/\r\n          echo \"Exception from\" v:throwpoint\r\n        endtry\r\n```",
            "commit_id": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
            "created_at": "2023-12-21T13:35:16Z",
            "diff_hunk": "@@ -0,0 +1,869 @@\n+local M = {}\n+\n+M.vars = {\n+  argv = {\n+    type = 'string[]',\n+    desc = [=[\n+      The command line arguments Vim was invoked with.  This is a\n+      list of strings.  The first item is the Vim command.\n+      See |v:progpath| for the command with full path.\n+    ]=],\n+  },\n+  char = {\n+    desc = [=[\n+      Argument for evaluating 'formatexpr' and used for the typed\n+      character when using <expr> in an abbreviation |:map-<expr>|.\n+      It is also used by the |InsertCharPre| and |InsertEnter| events.\n+    ]=],\n+  },\n+  charconvert_from = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file to be converted.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  charconvert_to = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the character encoding of a file after conversion.\n+      Only valid while evaluating the 'charconvert' option.\n+    ]=],\n+  },\n+  cmdarg = {\n+    type = 'string[]',\n+    desc = [=[\n+      The extra arguments (\"++p\", \"++enc=\", \"++ff=\") given to a file\n+      read/write command.  This is set before an autocommand event\n+      for a file read/write command is triggered.  There is a\n+      leading space to make it possible to append this variable\n+      directly after the read/write command. Note: \"+cmd\" isn't\n+      included here, because it will be executed anyway.\n+    ]=],\n+  },\n+  collate = {\n+    type = 'string',\n+    desc = [=[\n+      The current locale setting for collation order of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current locale encoding.  Technical: it's the value of\n+      LC_COLLATE.  When not using a locale the value is \"C\".\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      See |multi-lang|.\n+    ]=],\n+  },\n+  cmdbang = {\n+    desc = [=[\n+      Set like v:cmdarg for a file read/write command.  When a \"!\"\n+      was used the value is 1, otherwise it is 0.  Note that this\n+      can only be used in autocommands.  For user commands |<bang>|\n+      can be used.\n+    ]=],\n+  },\n+  completed_item = {\n+    desc = [=[\n+      Dictionary containing the most recent |complete-items| after\n+      |CompleteDone|.  Empty if the completion failed, or after\n+      leaving and re-entering insert mode.\n+      Note: Plugins can modify the value to emulate the builtin\n+      |CompleteDone| event behavior.\n+    ]=],\n+  },\n+  count = {\n+    type = 'integer',\n+    desc = [=[\n+      The count given for the last Normal mode command.  Can be used\n+      to get the count before a mapping.  Read-only.  Example: >vim\n+        :map _x :<C-U>echo \"the count is \" .. v:count<CR>\n+      <\n+      Note: The <C-U> is required to remove the line range that you\n+      get when typing ':' after a count.\n+      When there are two counts, as in \"3d2w\", they are multiplied,\n+      just like what happens in the command, \"d6w\" for the example.\n+      Also used for evaluating the 'formatexpr' option.\n+    ]=],\n+  },\n+  count1 = {\n+    type = 'integer',\n+    desc = [=[\n+      Just like \"v:count\", but defaults to one when no count is\n+      used.\n+    ]=],\n+  },\n+  ctype = {\n+    desc = [=[\n+      The current locale setting for characters of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current locale encoding.  Technical: it's the value of\n+      LC_CTYPE.  When not using a locale the value is \"C\".\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      See |multi-lang|.\n+    ]=],\n+  },\n+  dying = {\n+    type = 'integer',\n+    desc = [=[\n+      Normally zero.  When a deadly signal is caught it's set to\n+      one.  When multiple signals are caught the number increases.\n+      Can be used in an autocommand to check if Vim didn't\n+      terminate normally.\n+      Example: >vim\n+        :au VimLeave * if v:dying | echo \"\\nAAAAaaaarrrggghhhh!!!\\n\" | endif\n+      <\n+      Note: if another deadly signal is caught when v:dying is one,\n+      VimLeave autocommands will not be executed.\n+    ]=],\n+  },\n+  exiting = {\n+    desc = [=[\n+      Exit code, or |v:null| before invoking the |VimLeavePre|\n+      and |VimLeave| autocmds.  See |:q|, |:x| and |:cquit|.\n+      Example: >vim\n+        :au VimLeave * echo \"Exit value is \" .. v:exiting\n+      <\n+    ]=],\n+  },\n+  echospace = {\n+    type = 'integer',\n+    desc = [=[\n+      Number of screen cells that can be used for an `:echo` message\n+      in the last screen line before causing the |hit-enter-prompt|.\n+      Depends on 'showcmd', 'ruler' and 'columns'.  You need to\n+      check 'cmdheight' for whether there are full-width lines\n+      available above the last line.\n+    ]=],\n+  },\n+  errmsg = {\n+    type = 'string',\n+    desc = [=[\n+      Last given error message.\n+      Modifiable (can be set).\n+      Example: >vim\n+        let v:errmsg = \"\"\n+        silent! next\n+        if v:errmsg != \"\"\n+          \" ... handle error\n+      <\n+\n+    ]=],\n+  },\n+  errors = {\n+    tags = { 'assert-return' },\n+    desc = [=[\n+      Errors found by assert functions, such as |assert_true()|.\n+      This is a list of strings.\n+      The assert functions append an item when an assert fails.\n+      The return value indicates this: a one is returned if an item\n+      was added to v:errors, otherwise zero is returned.\n+      To remove old results make it empty: >vim\n+        :let v:errors = []\n+      <\n+      If v:errors is set to anything but a list it is made an empty\n+      list by the assert function.\n+    ]=],\n+  },\n+  event = {\n+    desc = [=[\n+      Dictionary of event data for the current |autocommand|.  Valid\n+      only during the event lifetime; storing or passing v:event is\n+      invalid!  Copy it instead: >vim\n+        au TextYankPost * let g:foo = deepcopy(v:event)\n+      <\n+      Keys vary by event; see the documentation for the specific\n+      event, e.g. |DirChanged| or |TextYankPost|.\n+        KEY              DESCRIPTION ~\n+        abort            Whether the event triggered during\n+                         an aborting condition (e.g. |c_Esc| or\n+                         |c_CTRL-C| for |CmdlineLeave|).\n+        chan             |channel-id|\n+        cmdlevel         Level of cmdline.\n+        cmdtype          Type of cmdline, |cmdline-char|.\n+        cwd              Current working directory.\n+        inclusive        Motion is |inclusive|, else exclusive.\n+        scope            Event-specific scope name.\n+        operator         Current |operator|.  Also set for Ex\n+        commands         (unlike |v:operator|). For\n+                         example if |TextYankPost| is triggered\n+                         by the |:yank| Ex command then\n+                         `v:event.operator` is \"y\".\n+        regcontents      Text stored in the register as a\n+                         |readfile()|-style list of lines.\n+        regname          Requested register (e.g \"x\" for \"xyy)\n+                         or the empty string for an unnamed\n+                         operation.\n+        regtype          Type of register as returned by\n+                         |getregtype()|.\n+        visual           Selection is visual (as opposed to,\n+                         e.g., via motion).\n+        completed_item   Current selected complete item on\n+                         |CompleteChanged|, Is `{}` when no complete\n+                         item selected.\n+        height           Height of popup menu on |CompleteChanged|\n+        width            Width of popup menu on |CompleteChanged|\n+        row              Row count of popup menu on |CompleteChanged|,\n+                         relative to screen.\n+        col              Col count of popup menu on |CompleteChanged|,\n+                         relative to screen.\n+        size             Total number of completion items on\n+                         |CompleteChanged|.\n+        scrollbar        Is |v:true| if popup menu have scrollbar, or\n+                         |v:false| if not.\n+        changed_window   Is |v:true| if the event fired while\n+                         changing window  (or tab) on |DirChanged|.\n+        status           Job status or exit code, -1 means \"unknown\". |TermClose|\n+    ]=],\n+  },\n+  exception = {\n+    desc = [=[\n+      The value of the exception most recently caught and not\n+      finished.  See also |v:throwpoint| and |throw-variables|.\n+      Example: >vim\n+        try\n+          throw \"oops\"\n+        catch /.*/\n+          echo \"caught \" .. v:exception\n+        endtry\n+      <\n+      Output: \"caught oops\".\n+    ]=],\n+  },\n+  ['false'] = {\n+    desc = [=[\n+      Special value used to put \"false\" in JSON and msgpack.  See\n+      |json_encode()|.  This value is converted to \"v:false\" when used\n+      as a String (e.g. in |expr5| with string concatenation\n+      operator) and to zero when used as a Number (e.g. in |expr5|\n+      or |expr7| when used with numeric operators). Read-only.\n+    ]=],\n+  },\n+  fcs_reason = {\n+    type = 'string',\n+    desc = [=[\n+      The reason why the |FileChangedShell| event was triggered.\n+      Can be used in an autocommand to decide what to do and/or what\n+      to set v:fcs_choice to.  Possible values:\n+        deleted   file no longer exists\n+        conflict  file contents, mode or timestamp was\n+                  changed and buffer is modified\n+        changed   file contents has changed\n+        mode      mode of file changed\n+        time      only file timestamp changed\n+    ]=],\n+  },\n+  fcs_choice = {\n+    type = 'string',\n+    desc = [=[\n+      What should happen after a |FileChangedShell| event was\n+      triggered.  Can be used in an autocommand to tell Vim what to\n+      do with the affected buffer:\n+        reload  Reload the buffer (does not work if\n+                the file was deleted).\n+        edit    Reload the buffer and detect the\n+                values for options such as\n+                'fileformat', 'fileencoding', 'binary'\n+                (does not work if the file was\n+                deleted).\n+        ask     Ask the user what to do, as if there\n+                was no autocommand.  Except that when\n+                only the timestamp changed nothing\n+                will happen.\n+        <empty> Nothing, the autocommand should do\n+                everything that needs to be done.\n+      The default is empty.  If another (invalid) value is used then\n+      Vim behaves like it is empty, there is no warning message.\n+    ]=],\n+  },\n+  fname = {\n+    type = 'string',\n+    desc = [=[\n+      When evaluating 'includeexpr': the file name that was\n+      detected.  Empty otherwise.\n+    ]=],\n+  },\n+  fname_in = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the input file.  Valid while evaluating:\n+        option         used for ~\n+        'charconvert'  file to be converted\n+        'diffexpr'     original file\n+        'patchexpr'    original file\n+      And set to the swap file name for |SwapExists|.\n+    ]=],\n+  },\n+  fname_out = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the output file.  Only valid while\n+      evaluating:\n+        option           used for ~\n+        'charconvert'    resulting converted file [1]\n+        'diffexpr'       output of diff\n+        'patchexpr'      resulting patched file\n+      [1] When doing conversion for a write command (e.g., \":w\n+      file\") it will be equal to v:fname_in.  When doing conversion\n+      for a read command (e.g., \":e file\") it will be a temporary\n+      file and different from v:fname_in.\n+    ]=],\n+  },\n+  fname_new = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the new version of the file.  Only valid while\n+      evaluating 'diffexpr'.\n+    ]=],\n+  },\n+  fname_diff = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the diff (patch) file.  Only valid while\n+      evaluating 'patchexpr'.\n+    ]=],\n+  },\n+  folddashes = {\n+    type = 'string',\n+    desc = [=[\n+      Used for 'foldtext': dashes representing foldlevel of a closed\n+      fold.\n+      Read-only in the |sandbox|. |fold-foldtext|\n+    ]=],\n+  },\n+  foldlevel = {\n+    type = 'integer',\n+    desc = [=[\n+      Used for 'foldtext': foldlevel of closed fold.\n+      Read-only in the |sandbox|. |fold-foldtext|\n+    ]=],\n+  },\n+  foldend = {\n+    type = 'integer',\n+    desc = [=[\n+      Used for 'foldtext': last line of closed fold.\n+      Read-only in the |sandbox|. |fold-foldtext|\n+    ]=],\n+  },\n+  foldstart = {\n+    type = 'integer',\n+    desc = [=[\n+      Used for 'foldtext': first line of closed fold.\n+      Read-only in the |sandbox|. |fold-foldtext|\n+    ]=],\n+  },\n+  hlsearch = {\n+    type = 'integer',\n+    desc = [=[\n+      Variable that indicates whether search highlighting is on.\n+      Setting it makes sense only if 'hlsearch' is enabled. Setting\n+      this variable to zero acts like the |:nohlsearch| command,\n+      setting it to one acts like >vim\n+        let &hlsearch = &hlsearch\n+      <\n+      Note that the value is restored when returning from a\n+      function. |function-search-undo|.\n+    ]=],\n+  },\n+  insertmode = {\n+    type = 'string',\n+    desc = [=[\n+      Used for the |InsertEnter| and |InsertChange| autocommand\n+      events.  Values:\n+        i    Insert mode\n+        r    Replace mode\n+        v    Virtual Replace mode\n+    ]=],\n+  },\n+  key = {\n+    type = 'string',\n+    desc = [=[\n+      Key of the current item of a |Dictionary|.  Only valid while\n+      evaluating the expression used with |map()| and |filter()|.\n+      Read-only.\n+    ]=],\n+  },\n+  lang = {\n+    type = 'string',\n+    desc = [=[\n+      The current locale setting for messages of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current language.  Technical: it's the value of LC_MESSAGES.\n+      The value is system dependent.\n+      This variable can not be set directly, use the |:language|\n+      command.\n+      It can be different from |v:ctype| when messages are desired\n+      in a different language than what is used for character\n+      encoding.  See |multi-lang|.\n+    ]=],\n+  },\n+  lc_time = {\n+    type = 'string',\n+    desc = [=[\n+      The current locale setting for time messages of the runtime\n+      environment.  This allows Vim scripts to be aware of the\n+      current language.  Technical: it's the value of LC_TIME.\n+      This variable can not be set directly, use the |:language|\n+      command.  See |multi-lang|.\n+    ]=],\n+  },\n+  lnum = {\n+    type = 'integer',\n+    desc = [=[\n+      Line number for the 'foldexpr' |fold-expr|, 'formatexpr',\n+      'indentexpr' and 'statuscolumn' expressions, tab page number\n+      for 'guitablabel' and 'guitabtooltip'.  Only valid while one of\n+      these expressions is being evaluated.  Read-only when in the\n+      |sandbox|.\n+    ]=],\n+  },\n+  lua = {\n+    desc = [=[\n+      Prefix for calling Lua functions from expressions.\n+      See |v:lua-call| for more information.\n+    ]=],\n+  },\n+  maxcol = {\n+    type = 'integer',\n+    desc = [=[\n+      Maximum line length.  Depending on where it is used it can be\n+      screen columns, characters or bytes.  The value currently is\n+      2147483647 on all systems.\n+    ]=],\n+  },\n+  mouse_win = {\n+    type = 'integer',\n+    desc = [=[\n+      Window number for a mouse click obtained with |getchar()|.\n+      First window has number 1, like with |winnr()|.  The value is\n+      zero when there was no mouse button click.\n+    ]=],\n+  },\n+  mouse_winid = {\n+    type = 'integer',\n+    desc = [=[\n+      |window-ID| for a mouse click obtained with |getchar()|.\n+      The value is zero when there was no mouse button click.\n+    ]=],\n+  },\n+  mouse_lnum = {\n+    type = 'integer',\n+    desc = [=[\n+      Line number for a mouse click obtained with |getchar()|.\n+      This is the text line number, not the screen line number.  The\n+      value is zero when there was no mouse button click.\n+    ]=],\n+  },\n+  mouse_col = {\n+    type = 'integer',\n+    desc = [=[\n+      Column number for a mouse click obtained with |getchar()|.\n+      This is the screen column number, like with |virtcol()|.  The\n+      value is zero when there was no mouse button click.\n+    ]=],\n+  },\n+  msgpack_types = {\n+    desc = [=[\n+      Dictionary containing msgpack types used by |msgpackparse()|\n+      and |msgpackdump()|. All types inside dictionary are fixed\n+      (not editable) empty lists. To check whether some list is one\n+      of msgpack types, use |is| operator.\n+    ]=],\n+  },\n+  null = {\n+    desc = [=[\n+      Special value used to put \"null\" in JSON and NIL in msgpack.\n+      See |json_encode()|.  This value is converted to \"v:null\" when\n+      used as a String (e.g. in |expr5| with string concatenation\n+      operator) and to zero when used as a Number (e.g. in |expr5|\n+      or |expr7| when used with numeric operators). Read-only.\n+      In some places `v:null` can be used for a List, Dict, etc.\n+      that is not set.  That is slightly different than an empty\n+      List, Dict, etc.\n+    ]=],\n+  },\n+  numbermax = {\n+    type = 'integer',\n+    desc = 'Maximum value of a number.',\n+  },\n+  numbermin = {\n+    type = 'integer',\n+    desc = 'Minimum value of a number (negative).',\n+  },\n+  numbersize = {\n+    type = 'integer',\n+    desc = [=[\n+      Number of bits in a Number.  This is normally 64, but on some\n+      systems it may be 32.\n+    ]=],\n+  },\n+  oldfiles = {\n+    type = 'string[]',\n+    desc = [=[\n+      List of file names that is loaded from the |shada| file on\n+      startup.  These are the files that Vim remembers marks for.\n+      The length of the List is limited by the ' argument of the\n+      'shada' option (default is 100).\n+      When the |shada| file is not used the List is empty.\n+      Also see |:oldfiles| and |c_#<|.\n+      The List can be modified, but this has no effect on what is\n+      stored in the |shada| file later.  If you use values other\n+      than String this will cause trouble.\n+    ]=],\n+  },\n+  option_new = {\n+    desc = [=[\n+      New value of the option. Valid while executing an |OptionSet|\n+      autocommand.\n+    ]=],\n+  },\n+  option_old = {\n+    desc = [=[\n+      Old value of the option. Valid while executing an |OptionSet|\n+      autocommand. Depending on the command used for setting and the\n+      kind of option this is either the local old value or the\n+      global old value.\n+    ]=],\n+  },\n+  option_oldlocal = {\n+    desc = [=[\n+      Old local value of the option. Valid while executing an\n+      |OptionSet| autocommand.\n+    ]=],\n+  },\n+  option_oldglobal = {\n+    desc = [=[\n+      Old global value of the option. Valid while executing an\n+      |OptionSet| autocommand.\n+    ]=],\n+  },\n+  option_type = {\n+    type = 'string',\n+    desc = [=[\n+      Scope of the set command. Valid while executing an\n+      |OptionSet| autocommand. Can be either \"global\" or \"local\"\n+    ]=],\n+  },\n+  option_command = {\n+    type = 'string',\n+    desc = [=[\n+      Command used to set the option. Valid while executing an\n+      |OptionSet| autocommand.\n+        value        option was set via ~\n+        \"setlocal\"   |:setlocal| or `:let l:xxx`\n+        \"setglobal\"  |:setglobal| or `:let g:xxx`\n+        \"set\"        |:set| or |:let|\n+        \"modeline\"   |modeline|\n+    ]=],\n+  },\n+  operator = {\n+    type = 'string',\n+    desc = [=[\n+      The last operator given in Normal mode.  This is a single\n+      character except for commands starting with <g> or <z>,\n+      in which case it is two characters.  Best used alongside\n+      |v:prevcount| and |v:register|.  Useful if you want to cancel\n+      Operator-pending mode and then use the operator, e.g.: >vim\n+        :omap O <Esc>:call MyMotion(v:operator)<CR>\n+      <\n+      The value remains set until another operator is entered, thus\n+      don't expect it to be empty.\n+      v:operator is not set for |:delete|, |:yank| or other Ex\n+      commands.\n+      Read-only.\n+    ]=],\n+  },\n+  prevcount = {\n+    type = 'integer',\n+    desc = [=[\n+      The count given for the last but one Normal mode command.\n+      This is the v:count value of the previous command.  Useful if\n+      you want to cancel Visual or Operator-pending mode and then\n+      use the count, e.g.: >vim\n+        :vmap % <Esc>:call MyFilter(v:prevcount)<CR>\n+      <\n+      Read-only.\n+    ]=],\n+  },\n+  profiling = {\n+    type = 'integer',\n+    desc = [=[\n+      Normally zero.  Set to one after using \":profile start\".\n+      See |profiling|.\n+    ]=],\n+  },\n+  progname = {\n+    type = 'string',\n+    desc = [=[\n+      The name by which Nvim was invoked (with path removed).\n+      Read-only.\n+    ]=],\n+  },\n+  progpath = {\n+    type = 'string',\n+    desc = [=[\n+      Absolute path to the current running Nvim.\n+      Read-only.\n+    ]=],\n+  },\n+  register = {\n+    type = 'string',\n+    desc = [=[\n+      The name of the register in effect for the current normal mode\n+      command (regardless of whether that command actually used a\n+      register).  Or for the currently executing normal mode mapping\n+      (use this in custom commands that take a register).\n+      If none is supplied it is the default register '\"', unless\n+      'clipboard' contains \"unnamed\" or \"unnamedplus\", then it is\n+      \"*\" or '+'.\n+      Also see |getreg()| and |setreg()|\n+    ]=],\n+  },\n+  relnum = {\n+    type = 'integer',\n+    desc = [=[\n+      Relative line number for the 'statuscolumn' expression.\n+      Read-only.\n+    ]=],\n+  },\n+  scrollstart = {\n+    desc = [=[\n+      String describing the script or function that caused the\n+      screen to scroll up.  It's only set when it is empty, thus the\n+      first reason is remembered.  It is set to \"Unknown\" for a\n+      typed command.\n+      This can be used to find out why your script causes the\n+      hit-enter prompt.\n+    ]=],\n+  },\n+  servername = {\n+    type = 'string',\n+    desc = [=[\n+      Primary listen-address of Nvim, the first item returned by\n+      |serverlist()|. Usually this is the named pipe created by Nvim\n+      at |startup| or given by |--listen| (or the deprecated\n+      |$NVIM_LISTEN_ADDRESS| env var).\n+\n+      See also |serverstart()| |serverstop()|.\n+      Read-only.\n+\n+                         *$NVIM*\n+      $NVIM is set by |terminal| and |jobstart()|, and is thus\n+      a hint that the current environment is a subprocess of Nvim.\n+      Example: >vim\n+        if $NVIM\n+          echo nvim_get_chan_info(v:parent)\n+        endif\n+      <\n+\n+      Note the contents of $NVIM may change in the future.\n+    ]=],\n+  },\n+  searchforward = {\n+    type = 'integer',\n+    desc = [=[\n+      Search direction:  1 after a forward search, 0 after a\n+      backward search.  It is reset to forward when directly setting\n+      the last search pattern, see |quote/|.\n+      Note that the value is restored when returning from a\n+      function. |function-search-undo|.\n+      Read-write.\n+    ]=],\n+  },\n+  shell_error = {\n+    type = 'string',\n+    desc = [=[\n+      Result of the last shell command.  When non-zero, the last\n+      shell command had an error.  When zero, there was no problem.\n+      This only works when the shell returns the error code to Vim.\n+      The value -1 is often used when the command could not be\n+      executed.  Read-only.\n+      Example: >vim\n+        !mv foo bar\n+        if v:shell_error\n+          echo 'could not rename \"foo\" to \"bar\"!'\n+        endif\n+      <\n+    ]=],\n+  },\n+  statusmsg = {\n+    type = 'string',\n+    desc = [=[\n+      Last given status message.\n+      Modifiable (can be set).\n+    ]=],\n+  },\n+  stderr = {\n+    type = 'string',\n+    desc = [=[\n+      |channel-id| corresponding to stderr. The value is always 2;\n+      use this variable to make your code more descriptive.\n+      Unlike stdin and stdout (see |stdioopen()|), stderr is always\n+      open for writing. Example:\n+      :call chansend(v:stderr, \"error: toaster empty\\n\")\n+    ]=],\n+  },\n+  swapname = {\n+    type = 'string',\n+    desc = [=[\n+      Name of the swapfile found.\n+      Only valid during |SwapExists| event.\n+      Read-only.\n+    ]=],\n+  },\n+  swapchoice = {\n+    type = 'string',\n+    desc = [=[\n+      |SwapExists| autocommands can set this to the selected choice\n+      for handling an existing swapfile:\n+        'o'    Open read-only\n+        'e'    Edit anyway\n+        'r'    Recover\n+        'd'    Delete swapfile\n+        'q'    Quit\n+        'a'    Abort\n+      The value should be a single-character string.  An empty value\n+      results in the user being asked, as would happen when there is\n+      no SwapExists autocommand.  The default is empty.\n+    ]=],\n+  },\n+  swapcommand = {\n+    type = 'string',\n+    desc = [=[\n+      Normal mode command to be executed after a file has been\n+      opened.  Can be used for a |SwapExists| autocommand to have\n+      another Vim open the file and jump to the right place.  For\n+      example, when jumping to a tag the value is \":tag tagname\\r\".\n+      For \":edit +cmd file\" the value is \":cmd\\r\".\n+    ]=],\n+  },\n+  t_blob = {\n+    type = 'integer',\n+    tags = { 'v:t_TYPE' },\n+    desc = 'Value of |Blob| type.  Read-only.  See: |type()|',\n+  },\n+  t_bool = {\n+    type = 'integer',\n+    desc = 'Value of |Boolean| type.  Read-only.  See: |type()|',\n+  },\n+  t_dict = {\n+    type = 'integer',\n+    desc = 'Value of |Dictionary| type.  Read-only.  See: |type()|',\n+  },\n+  t_float = {\n+    type = 'integer',\n+    desc = 'Value of |Float| type.  Read-only.  See: |type()|',\n+  },\n+  t_func = {\n+    type = 'integer',\n+    desc = 'Value of |Funcref| type.  Read-only.  See: |type()|',\n+  },\n+  t_list = {\n+    type = 'integer',\n+    desc = 'Value of |List| type.  Read-only.  See: |type()|',\n+  },\n+  t_number = {\n+    type = 'integer',\n+    desc = 'Value of |Number| type.  Read-only.  See: |type()|',\n+  },\n+  t_string = {\n+    type = 'integer',\n+    desc = 'Value of |String| type.  Read-only.  See: |type()|',\n+  },\n+  termresponse = {\n+    desc = [=[\n+      The value of the most recent OSC or DCS escape sequence\n+      received by Nvim from the terminal. This can be read in a\n+      |TermResponse| event handler after querying the terminal using\n+      another escape sequence.\n+    ]=],\n+  },\n+  testing = {\n+    desc = [=[\n+      Must be set before using `test_garbagecollect_now()`.\n+    ]=],\n+  },\n+  this_session = {\n+    desc = [=[\n+      Full filename of the last loaded or saved session file.\n+      Empty when no session file has been saved.  See |:mksession|.\n+      Modifiable (can be set).\n+    ]=],\n+  },\n+  throwpoint = {\n+    desc = [=[\n+      The point where the exception most recently caught and not\n+      finished was thrown.  Not set when commands are typed.  See\n+      also |v:exception| and |throw-variables|.\n+      Example: >vim\n+       try\n+         throw \"oops\"\n+       catch /.*/\n+         echo \"Exception from\" v:throwpoint\n+       endtry",
            "html_url": "https://github.com/neovim/neovim/pull/26682#discussion_r1434086419",
            "id": 1434086419,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5VemwT",
            "original_commit_id": "291f779f57cd21a16d180b667b3e875e16051b2e",
            "original_line": 802,
            "original_position": 802,
            "original_start_line": 798,
            "path": "src/nvim/vvars.lua",
            "position": null,
            "pull_request_review_id": 1792985108,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1434086419/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-12-21T13:35:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1434086419",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "Note to self/others with too much time on their hands: `src/nvim/options.lua` could use some language annotations in the code blocks as well.",
            "created_at": "2023-12-20T17:24:54Z",
            "html_url": "https://github.com/neovim/neovim/pull/26682#issuecomment-1864860837",
            "id": 1864860837,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/26682",
            "node_id": "IC_kwDOAPphoM5vJ4Sl",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1864860837/reactions"
            },
            "updated_at": "2023-12-20T17:24:54Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1864860837",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/26682/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/26682/commits",
    "created_at": "2023-12-20T16:34:45Z",
    "diff_url": "https://github.com/neovim/neovim/pull/26682.diff",
    "draft": false,
    "head": {
        "label": "lewis6991:vvars",
        "ref": "vvars",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/lewis6991/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/lewis6991/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/lewis6991/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/lewis6991/neovim/branches{/branch}",
            "clone_url": "https://github.com/lewis6991/neovim.git",
            "collaborators_url": "https://api.github.com/repos/lewis6991/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/lewis6991/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/lewis6991/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/lewis6991/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/lewis6991/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/lewis6991/neovim/contributors",
            "created_at": "2020-11-24T21:47:43Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/lewis6991/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/lewis6991/neovim/downloads",
            "events_url": "https://api.github.com/repos/lewis6991/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/lewis6991/neovim/forks",
            "full_name": "lewis6991/neovim",
            "git_commits_url": "https://api.github.com/repos/lewis6991/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/lewis6991/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/lewis6991/neovim/git/tags{/sha}",
            "git_url": "git://github.com/lewis6991/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/lewis6991/neovim/hooks",
            "html_url": "https://github.com/lewis6991/neovim",
            "id": 315760150,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/lewis6991/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/lewis6991/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/lewis6991/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/lewis6991/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/lewis6991/neovim/labels{/name}",
            "language": "Vim script",
            "languages_url": "https://api.github.com/repos/lewis6991/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/lewis6991/neovim/merges",
            "milestones_url": "https://api.github.com/repos/lewis6991/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkzMTU3NjAxNTA=",
            "notifications_url": "https://api.github.com/repos/lewis6991/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/lewis6991/neovim/pulls{/number}",
            "pushed_at": "2023-12-22T16:31:48Z",
            "releases_url": "https://api.github.com/repos/lewis6991/neovim/releases{/id}",
            "size": 238434,
            "ssh_url": "git@github.com:lewis6991/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/lewis6991/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/lewis6991/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/lewis6991/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/lewis6991/neovim/subscription",
            "svn_url": "https://github.com/lewis6991/neovim",
            "tags_url": "https://api.github.com/repos/lewis6991/neovim/tags",
            "teams_url": "https://api.github.com/repos/lewis6991/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/lewis6991/neovim/git/trees{/sha}",
            "updated_at": "2023-01-31T18:36:52Z",
            "url": "https://api.github.com/repos/lewis6991/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
            "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
            "followers_url": "https://api.github.com/users/lewis6991/followers",
            "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
            "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/lewis6991",
            "id": 7904185,
            "login": "lewis6991",
            "node_id": "MDQ6VXNlcjc5MDQxODU=",
            "organizations_url": "https://api.github.com/users/lewis6991/orgs",
            "received_events_url": "https://api.github.com/users/lewis6991/received_events",
            "repos_url": "https://api.github.com/users/lewis6991/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/lewis6991"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/26682",
    "id": 1652397947,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/26682",
    "labels": [],
    "locked": false,
    "merge_commit_sha": "e8d3c4cccb9d362952a09216a5a114ee6d024c14",
    "merged_at": "2023-12-21T14:19:11Z",
    "milestone": null,
    "node_id": "PR_kwDOAPphoM5ifZd7",
    "number": 26682,
    "patch_url": "https://github.com/neovim/neovim/pull/26682.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/26682/comments",
    "state": "closed",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/85954ac9959d3166f5ae6f81ea0cf43138d26d2c",
    "title": "feat: generate types and docs for v: variables",
    "updated_at": "2023-12-21T14:19:29Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/26682",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
        "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
        "followers_url": "https://api.github.com/users/lewis6991/followers",
        "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
        "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/lewis6991",
        "id": 7904185,
        "login": "lewis6991",
        "node_id": "MDQ6VXNlcjc5MDQxODU=",
        "organizations_url": "https://api.github.com/users/lewis6991/orgs",
        "received_events_url": "https://api.github.com/users/lewis6991/received_events",
        "repos_url": "https://api.github.com/users/lewis6991/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/lewis6991"
    }
}