{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/25301/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/25301/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/25301"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/25301"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/25301/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/b7cd2c79d39981fe99ba771edf5e7541b8295410"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 4921,
            "forks_count": 4921,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1662,
            "open_issues_count": 1662,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2023-10-15T01:49:45Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 248656,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 70131,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2023-10-15T01:03:19Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 70131,
            "watchers_count": 70131,
            "web_commit_signoff_required": false
        },
        "sha": "28ef4a44925a1b1cbf291347aba43012ab038523",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim"
        }
    },
    "body": "Defines the minimal API for LSP snippet support. The initial design is:\r\n1. `vim.snippet.expand` receives the snippet text and parses it using the LPEG grammar.\r\n2. The snippet's children are transformed as follows:\r\n    - Known variables are replaced by their values (e.g. `$TM_FILENAME` becomes `foo.txt`), falling back to their defaults when provided.\r\n    - When a variable is unknown, the name of the variable is inserted and it is transformed into a placeholder _(haven't done this yet)_.\r\n    - Placeholders have their text[^1] inserted.\r\n    - With choice nodes, the first value is inserted (see below for future work).\r\n    - Text nodes are inserted as given.\r\n3. Based on `expandtab` and the indentation of the current line, the snippet is indented accordingly. \r\n4. The snippet text is set in the current buffer.\r\n5. To \"fill out\" the snippet, tabstops can be navigated using `vim.snippet.jump(direction)` (using `1` for jumping forward and `-1` for backwards). `vim.snippet.jumpable(direction)` can also be used before jumping to check if the jump in the given direction is valid.\r\n6. The snippet session is cancelled when reaching the final tabstop (`$0`) or when the cursor moves outside the snippet's tabstops.\r\n\r\nNote that the following features remain yet to be implemented in more mature versions of the snippet API:\r\n- Variable transformations via regexes.\r\n- Choice placeholders, in which the user can select from a given set of options to insert.\r\n- Nested placeholders. Right now the value of a placeholder is simply converted to a string and inserted.\r\n\r\nPending discussion items in this PR:\r\n- [X] _My use of `Range4` despite it being a \"Treesitter\" type_: Seems like we're fine with this given that [we plan on refactoring ranges/positions anyway](https://github.com/neovim/neovim/issues/25509).\r\n- [x] _Currently `vim.snippet.jump` uses `vim.snippet.jumpable` to check that the movement is valid. Do we want to instead ask the user to invoke `jumpable` first and remove the check?_ No harm in keeping the check.\r\n- [x] _I'm not 100% sure about the name of `vim.snippet.cancel`, since sometimes it does cancel the snippet session but it's also invoked when the snippet navigation is complete. Do we want to give it another name?_ Looks like we're all happy with `vim.snippet.exit`.\r\n\r\n[^1]: When I say that the text of a node is inserted, I don't mean the raw table string, but the output from [`Node:__tostring()`](https://github.com/neovim/neovim/blob/a041d8ac118f45b9e20d4975737f25a548cb6337/runtime/lua/vim/lsp/_snippet_grammar.lua#L85).",
    "closed_at": null,
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1334293206"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334293206"
                }
            },
            "author_association": "MEMBER",
            "body": "👍  say no to uppercase (spicy zero-likes tweet: https://twitter.com/justinmk/status/1669461598786711552 )",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-09-22T12:07:27Z",
            "diff_hunk": "@@ -173,32 +173,33 @@ P.seq = function(...)\n   end\n end\n \n-local Node = {}\n-\n-Node.Type = {\n-  SNIPPET = 0,",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1334293206",
            "id": 1334293206,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5Ph7LW",
            "original_commit_id": "98ac771c1b9497c38c6d59d49b9c1db5ed80c274",
            "original_line": 179,
            "original_position": 7,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/_snippet.lua",
            "position": null,
            "pull_request_review_id": 1639822849,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334293206/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-09-22T12:07:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334293206",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1334294741"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334294741"
                }
            },
            "author_association": "MEMBER",
            "body": "\"should\" is always redundant in test names\r\n```suggestion\r\n        it('disposes snippet if edit outside of range', function()\r\n```",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-09-22T12:09:03Z",
            "diff_hunk": "@@ -0,0 +1,336 @@\n+local helpers = require('test.functional.helpers')(after_each)\n+\n+local eq = helpers.eq\n+local clear = helpers.clear\n+local feed = helpers.feed\n+local exec_lua = helpers.exec_lua\n+\n+describe('vim.snippet', function()\n+  for _, selection in ipairs({ 'inclusive', 'exclusive' }) do\n+    for _, virtualedit in ipairs({ '', 'all', 'onemore' }) do\n+      describe(('selection=%s, virtualedit=%s'):format(selection, virtualedit), function()\n+        before_each(function()\n+          clear()\n+          exec_lua(([[\n+            vim.o.selection = '%s';\n+            vim.o.virtualedit = '%s';\n+            vim.snippet.dispose()\n+            vim.keymap.set({ 'n', 'i', 's' }, '<C-l>', '<Cmd>lua vim.snippet._sync()<CR>', { buffer = true })\n+            vim.keymap.set({ 'i', 's' }, '<Tab>', '<Cmd>lua vim.snippet.jump(vim.snippet.JumpDirection.Next)<CR>', { buffer = true })\n+            vim.keymap.set({ 'i', 's' }, '<S-Tab>', '<Cmd>lua vim.snippet.jump(vim.snippet.JumpDirection.Prev)<CR>', { buffer = true })\n+            vim.keymap.set({ 's' }, '<BS>', '\"\\\\<BS>\" .. (getcurpos()[2] == col(\"$\") - 1 ? \"a\" : \"i\")', { expr = true })\n+\n+            function get_state()\n+              local m = vim.api.nvim_get_mode().mode\n+              local select_s = vim.fn.getpos(\"'<\")\n+              local select_e = vim.fn.getpos(\"'>\")\n+              local cursor = vim.fn.getpos('.')\n+              local exclusive_offset = vim.o.selection == 'exclusive' and 1 or 0\n+              return {\n+                m = m,\n+                s = m ~= 's' and ({ cursor[2] - 1, cursor[3] - 1 }) or ({ select_s[2] - 1, select_s[3] - 1 }),\n+                e = m ~= 's' and ({ cursor[2] - 1, cursor[3] - 1 }) or ({ select_e[2] - 1, select_e[3] - exclusive_offset }),\n+              }\n+            end\n+          ]]):format(selection, virtualedit))\n+        end)\n+        after_each(function()\n+          clear()\n+        end)\n+\n+        it('should expand snippet with considering buffer indent setting', function()\n+          local snippet = table.concat({\n+            'class ${1:ClassName} {',\n+            '\\tpublic $1($2) {',\n+            '\\t\\t${3}',\n+            '\\t}',\n+            '}',\n+            ''\n+          }, '\\n')\n+\n+          for _, case in ipairs({\n+            {\n+              base_indent = [[  ]],\n+              indent_setting = [[\n+                vim.o.expandtab = true\n+                vim.o.shiftwidth = 2\n+              ]],\n+              expects = {\n+                '  class ClassName {',\n+                '    public ClassName() {',\n+                '      ',\n+                '    }',\n+                '  }',\n+                '  ',\n+              }\n+            }, {\n+            base_indent = [[  ]],\n+            indent_setting = [[\n+              vim.o.expandtab = true\n+              vim.o.shiftwidth = 0\n+              vim.o.tabstop = 2\n+            ]],\n+            expects = {\n+              '  class ClassName {',\n+              '    public ClassName() {',\n+              '      ',\n+              '    }',\n+              '  }',\n+              '  ',\n+            }\n+          }, {\n+            base_indent = [[<Tab>]],\n+            indent_setting = [[\n+              vim.o.expandtab = false\n+            ]],\n+            expects = {\n+              '\\tclass ClassName {',\n+              '\\t\\tpublic ClassName() {',\n+              '\\t\\t\\t',\n+              '\\t\\t}',\n+              '\\t}',\n+              '\\t',\n+            }\n+          }\n+          }) do\n+            clear()\n+            exec_lua(case.indent_setting)\n+            feed('i' .. case.base_indent)\n+            exec_lua('vim.snippet.expand(...)', snippet)\n+            eq(case.expects, helpers.buf_lines(0))\n+          end\n+        end)\n+\n+        it('should be able to jump through all placeholders', function()\n+          exec_lua('vim.snippet.expand(...)', table.concat({\n+            'class ${1:ClassName} {',\n+            '\\tpublic $1($2) {',\n+            '\\t\\t${3}',\n+            '\\t}',\n+            '}',\n+            ''\n+          }, '\\n'))\n+          local cases = {\n+            { m = 's', s = { 0, 6 },  e = { 0, 15 }, },\n+            { m = 'i', s = { 1, 18 }, e = { 1, 18 }, },\n+            { m = 'i', s = { 2, 2 },  e = { 2, 2 }, },\n+            { m = 'i', s = { 5, 0 },  e = { 5, 0 }, },\n+          }\n+          for i = 1, #cases do\n+            eq(cases[i], exec_lua([[return get_state()]]))\n+            eq(i ~= #cases, exec_lua([[return vim.snippet.jumpable(vim.snippet.JumpDirection.Next)]]))\n+            feed('<Tab>')\n+          end\n+          eq(cases[#cases], exec_lua([[return get_state()]]))\n+          for i = #cases, 1, -1 do\n+            eq(cases[i], exec_lua([[return get_state()]]))\n+            eq(i ~= 1, exec_lua([[return vim.snippet.jumpable(vim.snippet.JumpDirection.Prev)]]))\n+            feed('<S-Tab>')\n+          end\n+          eq(cases[1], exec_lua([[return get_state()]]))\n+        end)\n+\n+        it('should sync same tabstops', function()\n+          exec_lua('vim.snippet.expand(...)', table.concat({\n+            'class ${1:ClassName} {',\n+            '\\tpublic $1($2) {',\n+            '\\t\\t${3}',\n+            '\\t}',\n+            '}',\n+            ''\n+          }, '\\n'))\n+          feed('ModifiedClassName<C-l>')\n+          eq({\n+            'class ModifiedClassName {',\n+            '\\tpublic ModifiedClassName() {',\n+            '\\t\\t',\n+            '\\t}',\n+            '}',\n+            '',\n+          }, helpers.buf_lines(0))\n+        end)\n+\n+        -- We can't manage `complete(...)` in test.\n+        -- it('should insert selected choice', function()\n+        --   exec_lua('vim.snippet.expand(...)', table.concat({\n+        --     'console.${1|log,info,warn,error|}($2);',\n+        --   }, '\\n'))\n+        --   feed('<C-n><C-n><C-n><C-y>')\n+        --   eq({\n+        --     'console.warn();',\n+        --   }, helpers.buf_lines(0))\n+        -- end)\n+\n+        it('should dispose directly modified non-origin tabstop', function()\n+          exec_lua('vim.snippet.expand(...)', table.concat({\n+            'class ${1:ClassName} {',\n+            '\\tpublic $1($2) {',\n+            '\\t\\t${3}',\n+            '\\t}',\n+            '}',\n+            ''\n+          }, '\\n'))\n+          eq({\n+            'class ClassName {',\n+            '\\tpublic ClassName() {',\n+            '\\t\\t',\n+            '\\t}',\n+            '}',\n+            '',\n+          }, helpers.buf_lines(0))\n+          feed('<Esc><Cmd>call cursor(2, 9)<CR>ciwDirectlyModified<C-l>')\n+          eq({\n+            'class ClassName {',\n+            '\\tpublic DirectlyModified() {',\n+            '\\t\\t',\n+            '\\t}',\n+            '}',\n+            '',\n+          }, helpers.buf_lines(0))\n+        end)\n+\n+        it('should restore the state with undo', function()\n+          exec_lua('vim.snippet.expand(...)', table.concat({\n+            'class ${1:ClassName} {',\n+            '\\tpublic $1($2) {',\n+            '\\t\\t${3}',\n+            '\\t}',\n+            '}',\n+            ''\n+          }, '\\n'))\n+          feed('ModifiedClassName<C-l><Tab>argument<Esc>')\n+          eq({\n+            'class ModifiedClassName {',\n+            '\\tpublic ModifiedClassName(argument) {',\n+            '\\t\\t',\n+            '\\t}',\n+            '}',\n+            '',\n+          }, helpers.buf_lines(0))\n+\n+          feed('u<C-l>')\n+          eq({\n+            'class ClassName {',\n+            '\\tpublic ClassName() {',\n+            '\\t\\t',\n+            '\\t}',\n+            '}',\n+            '',\n+          }, helpers.buf_lines(0))\n+\n+          local to_insert = selection == 'exclusive' and 'i' or 'a'\n+          feed(('i<S-Tab><C-g>o<Esc>%sModified<C-l>'):format(to_insert))\n+          eq({\n+            'class ClassNameModified {',\n+            '\\tpublic ClassNameModified() {',\n+            '\\t\\t',\n+            '\\t}',\n+            '}',\n+            '',\n+          }, helpers.buf_lines(0))\n+        end)\n+\n+        it('should dispose snippet if edit outside of range', function()",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1334294741",
            "id": 1334294741,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5Ph7jV",
            "original_commit_id": "98ac771c1b9497c38c6d59d49b9c1db5ed80c274",
            "original_line": 233,
            "original_position": 233,
            "original_start_line": null,
            "path": "test/functional/lua/snippet_spec.lua",
            "position": null,
            "pull_request_review_id": 1639825180,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334294741/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-09-22T12:09:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334294741",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1334295676"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334295676"
                }
            },
            "author_association": "MEMBER",
            "body": "👀  https://github.com/neovim/neovim/pull/25154 @llllvvuu ",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-09-22T12:10:01Z",
            "diff_hunk": "@@ -0,0 +1,726 @@\n+local lsp_snippet = require('vim.lsp._snippet')\n+\n+---@alias vim.snippet.MarkId integer\n+---@alias vim.snippet.Tabstop integer\n+---@alias vim.snippet.Changenr integer\n+---@alias vim.snippet.Position { [1]: integer, [2]: integer } # The 0-origin utf8 byte index.\n+---@alias vim.snippet.Range { s: vim.snippet.Position, e: vim.snippet.Position } # The 0-origin utf8 byte index.\n+\n+---@class vim.snippet.TraverseContext\n+---@field depth integer\n+---@field range vim.snippet.Range\n+---@field replace fun(new_node: vim.lsp.snippet.Node): nil\n+\n+---Feed keys.\n+---NOTE: This always enables `virtualedit=onemore`\n+---@param keys string\n+local function feedkeys(keys)\n+  local k = {}\n+  table.insert(k, '<Cmd>set virtualedit=onemore<CR>')\n+  table.insert(k, keys)\n+  table.insert(k, ('<Cmd>set virtualedit=%s<CR>'):format(vim.o.virtualedit))\n+  vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes(table.concat(k), true, true, true), 'ni', true)\n+end\n+\n+---Return true if range contains position.\n+---@param range vim.snippet.Range\n+---@param position vim.snippet.Position\n+---@return boolean\n+local function within(range, position)\n+  -- Check the cursor is before the range start position.\n+  if position[1] < range.s[1] or (position[1] == range.s[1] and position[2] < range.s[2]) then\n+    return false\n+  end\n+\n+  -- Check the cursor is after the range end position.\n+  if range.e[1] < position[1] or (range.e[1] == position[1] and range.e[2] < position[2]) then\n+    return false\n+  end\n+\n+  return true\n+end\n+\n+---Return cursor position.\n+---@return vim.snippet.Position\n+local function cursor_position()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return { cursor[1] - 1, cursor[2] }\n+end\n+\n+---Return one indent string of current buffer.\n+---@return string\n+local function get_one_indent()\n+  local expandtab = vim.api.nvim_get_option('expandtab')\n+  if not expandtab then\n+    return '\\t'\n+  end\n+  local shiftwidth = vim.api.nvim_get_option('shiftwidth')\n+  if shiftwidth > 0 then\n+    return string.rep(' ', shiftwidth)\n+  end\n+  return string.rep(' ', vim.api.nvim_get_option('tabstop'))\n+end\n+\n+---Return base indent of current line.\n+---@return string\n+local function get_base_indent()\n+  return string.match(vim.api.nvim_get_current_line(), '^%s*') or ''\n+end\n+\n+---Adjust snippet indent\n+---@param snippet_text string\n+---@return string\n+local function adjust_indent(snippet_text)\n+  local one_indent = get_one_indent()\n+  local base_indent = get_base_indent()\n+\n+  local adjusted_snippet_text = {}\n+  local snippet_lines = vim.split(snippet_text, '\\n', { plain = true })\n+  for i, line in ipairs(snippet_lines) do\n+    if i == 1 then\n+      -- Use first line as-is.\n+      table.insert(adjusted_snippet_text, line)\n+    elseif i ~= #snippet_lines and string.match(line, '^%s*$') then\n+      -- Remove space only lines except the last line.\n+      table.insert(adjusted_snippet_text, '')\n+    else\n+      -- 1. Change \\t as one_indent.\n+      -- 2. Add base_indent.\n+      line = string.gsub(line, '^(\\t+)', function(indent)\n+        return string.gsub(indent, '\\t', one_indent)\n+      end)\n+      table.insert(adjusted_snippet_text, base_indent .. line)\n+    end\n+  end\n+  return table.concat(adjusted_snippet_text, '\\n')\n+end\n+\n+---Get range from extmark.\n+---@param ns integer\n+---@param mark_id vim.snippet.MarkId\n+---@return vim.snippet.Range\n+local function get_range_from_mark(ns, mark_id)\n+  local mark = vim.api.nvim_buf_get_extmark_by_id(0, ns, mark_id, { details = true })\n+  local s = { mark[1], mark[2] }\n+  local e = { mark[3].end_row, mark[3].end_col }\n+  if s[1] > e[1] or (s[1] == e[1] and s[2] > e[2]) then\n+    local t = s\n+    s = e\n+    e = t\n+  end\n+  return { s = s, e = e }\n+end\n+\n+---Get text from range.\n+---@param range vim.snippet.Range\n+---@return string\n+local function get_text_by_range(range)\n+  local lines = vim.api.nvim_buf_get_lines(0, range.s[1], range.e[1] + 1, false)\n+  if range.s[1] ~= range.e[1] then\n+    lines[1] = string.sub(lines[1], range.s[2] + 1)\n+    lines[#lines] = string.sub(lines[#lines], 1, range.e[2])\n+  else\n+    lines[1] = string.sub(lines[1], range.s[2] + 1, range.e[2])\n+  end\n+  return table.concat(lines, '\\n')\n+end\n+\n+---Traverse snippet ast.\n+---The `context.range` is calculated by `tostring(node)`, so it can be used only for processing before snippet insertion.\n+---@param snippet_node table\n+---@param callback fun(node: table, context: vim.snippet.TraverseContext): table|nil\n+local function traverse(snippet_node, callback)",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1334295676",
            "id": 1334295676,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5Ph7x8",
            "original_commit_id": "98ac771c1b9497c38c6d59d49b9c1db5ed80c274",
            "original_line": 136,
            "original_position": 132,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1639826656,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 1,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334295676/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-09-22T12:10:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334295676",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1334298996"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334298996"
                }
            },
            "author_association": "MEMBER",
            "body": "yet more cases for the Position/Range discussion https://github.com/neovim/neovim/issues/25509\r\n\r\nNot a blocker, just for reference.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-09-22T12:13:14Z",
            "diff_hunk": "@@ -0,0 +1,726 @@\n+local lsp_snippet = require('vim.lsp._snippet')\n+\n+---@alias vim.snippet.MarkId integer\n+---@alias vim.snippet.Tabstop integer\n+---@alias vim.snippet.Changenr integer\n+---@alias vim.snippet.Position { [1]: integer, [2]: integer } # The 0-origin utf8 byte index.\n+---@alias vim.snippet.Range { s: vim.snippet.Position, e: vim.snippet.Position } # The 0-origin utf8 byte index.\n+\n+---@class vim.snippet.TraverseContext\n+---@field depth integer\n+---@field range vim.snippet.Range\n+---@field replace fun(new_node: vim.lsp.snippet.Node): nil\n+\n+---Feed keys.\n+---NOTE: This always enables `virtualedit=onemore`\n+---@param keys string\n+local function feedkeys(keys)\n+  local k = {}\n+  table.insert(k, '<Cmd>set virtualedit=onemore<CR>')\n+  table.insert(k, keys)\n+  table.insert(k, ('<Cmd>set virtualedit=%s<CR>'):format(vim.o.virtualedit))\n+  vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes(table.concat(k), true, true, true), 'ni', true)\n+end\n+\n+---Return true if range contains position.\n+---@param range vim.snippet.Range\n+---@param position vim.snippet.Position\n+---@return boolean\n+local function within(range, position)\n+  -- Check the cursor is before the range start position.\n+  if position[1] < range.s[1] or (position[1] == range.s[1] and position[2] < range.s[2]) then\n+    return false\n+  end\n+\n+  -- Check the cursor is after the range end position.\n+  if range.e[1] < position[1] or (range.e[1] == position[1] and range.e[2] < position[2]) then\n+    return false\n+  end\n+\n+  return true\n+end\n+\n+---Return cursor position.\n+---@return vim.snippet.Position\n+local function cursor_position()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return { cursor[1] - 1, cursor[2] }\n+end\n+\n+---Return one indent string of current buffer.\n+---@return string\n+local function get_one_indent()\n+  local expandtab = vim.api.nvim_get_option('expandtab')\n+  if not expandtab then\n+    return '\\t'\n+  end\n+  local shiftwidth = vim.api.nvim_get_option('shiftwidth')\n+  if shiftwidth > 0 then\n+    return string.rep(' ', shiftwidth)\n+  end\n+  return string.rep(' ', vim.api.nvim_get_option('tabstop'))\n+end\n+\n+---Return base indent of current line.\n+---@return string\n+local function get_base_indent()\n+  return string.match(vim.api.nvim_get_current_line(), '^%s*') or ''\n+end\n+\n+---Adjust snippet indent\n+---@param snippet_text string\n+---@return string\n+local function adjust_indent(snippet_text)\n+  local one_indent = get_one_indent()\n+  local base_indent = get_base_indent()\n+\n+  local adjusted_snippet_text = {}\n+  local snippet_lines = vim.split(snippet_text, '\\n', { plain = true })\n+  for i, line in ipairs(snippet_lines) do\n+    if i == 1 then\n+      -- Use first line as-is.\n+      table.insert(adjusted_snippet_text, line)\n+    elseif i ~= #snippet_lines and string.match(line, '^%s*$') then\n+      -- Remove space only lines except the last line.\n+      table.insert(adjusted_snippet_text, '')\n+    else\n+      -- 1. Change \\t as one_indent.\n+      -- 2. Add base_indent.\n+      line = string.gsub(line, '^(\\t+)', function(indent)\n+        return string.gsub(indent, '\\t', one_indent)\n+      end)\n+      table.insert(adjusted_snippet_text, base_indent .. line)\n+    end\n+  end\n+  return table.concat(adjusted_snippet_text, '\\n')\n+end\n+\n+---Get range from extmark.\n+---@param ns integer\n+---@param mark_id vim.snippet.MarkId\n+---@return vim.snippet.Range\n+local function get_range_from_mark(ns, mark_id)",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1334298996",
            "id": 1334298996,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5Ph8l0",
            "original_commit_id": "98ac771c1b9497c38c6d59d49b9c1db5ed80c274",
            "original_line": 106,
            "original_position": 102,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1639831592,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334298996/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-05T09:44:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334298996",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1334310739"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334310739"
                }
            },
            "author_association": "MEMBER",
            "body": "I still don't understand what's so offensive about ASCII values 65-90. Does your font have particularly bad glyphs for this range or something?",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-09-22T12:24:51Z",
            "diff_hunk": "@@ -173,32 +173,33 @@ P.seq = function(...)\n   end\n end\n \n-local Node = {}\n-\n-Node.Type = {\n-  SNIPPET = 0,",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1334310739",
            "id": 1334310739,
            "in_reply_to_id": 1334293206,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5Ph_dT",
            "original_commit_id": "98ac771c1b9497c38c6d59d49b9c1db5ed80c274",
            "original_line": 179,
            "original_position": 7,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/_snippet.lua",
            "position": null,
            "pull_request_review_id": 1639849741,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 4,
                "rocket": 0,
                "total_count": 4,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334310739/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-09-22T12:24:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334310739",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1334337319"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334337319"
                }
            },
            "author_association": "MEMBER",
            "body": "I see it as a cargo-cult (a useless, mindless habit). I obviously don't agree that it reduces to being offended by a character range.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-09-22T12:49:36Z",
            "diff_hunk": "@@ -173,32 +173,33 @@ P.seq = function(...)\n   end\n end\n \n-local Node = {}\n-\n-Node.Type = {\n-  SNIPPET = 0,",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1334337319",
            "id": 1334337319,
            "in_reply_to_id": 1334293206,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5PiF8n",
            "original_commit_id": "98ac771c1b9497c38c6d59d49b9c1db5ed80c274",
            "original_line": 179,
            "original_position": 7,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/_snippet.lua",
            "position": null,
            "pull_request_review_id": 1639889718,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334337319/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-09-22T12:51:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334337319",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1334384246"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334384246"
                }
            },
            "author_association": "MEMBER",
            "body": "> I obviously don't agree that it reduces to being offended by a character range.\r\n\r\nOn that twitter thread you wrote:\r\n\r\n> Do prefer kOhShitHereComesAKonstant? \r\n>\r\n> sure, the k is less noisy than uppercase + underscores. \r\n>\r\n> why does this single property of a variable matter so much compared to all other possible dimensions ?\r\n\r\nI can only read this as a distaste for consecutive ASCII 65-90,95, whilst also suggesting that extra unrelated `k`'s are ok 🤔.\r\n\r\nI've explained this before....\r\n\r\nBeing able to easily determine whether something is state or not, statically, **is** a very important property in all programming domains. I hope that's something we can agree on. Using uppercase for this has simply become a popular convention. If there are other, better, ways to do it then I'm sure the cult is open to suggestions.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-09-22T13:29:41Z",
            "diff_hunk": "@@ -173,32 +173,33 @@ P.seq = function(...)\n   end\n end\n \n-local Node = {}\n-\n-Node.Type = {\n-  SNIPPET = 0,",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1334384246",
            "id": 1334384246,
            "in_reply_to_id": 1334293206,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5PiRZ2",
            "original_commit_id": "98ac771c1b9497c38c6d59d49b9c1db5ed80c274",
            "original_line": 179,
            "original_position": 7,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/_snippet.lua",
            "position": null,
            "pull_request_review_id": 1639963684,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334384246/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-09-22T13:29:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334384246",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1334408340"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334408340"
                }
            },
            "author_association": "MEMBER",
            "body": "> I can only read this as a distaste for consecutive ASCII 65-90,95, whilst also suggesting that extra unrelated `k`'s are ok 🤔.\r\n\r\nNo, it's a distaste for cargo cults. The \"k\" thing is a C workaround and totally irrelevant for other languages, which is where the vast majority of the cargo cult continues to practice.\r\n\r\n> Being able to easily determine whether something is state or not, statically, is a very important property in all programming domains.\r\n\r\nIn this case the symbols are part of a table. An enum is similar. Both are statically analyzable.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-09-22T13:48:32Z",
            "diff_hunk": "@@ -173,32 +173,33 @@ P.seq = function(...)\n   end\n end\n \n-local Node = {}\n-\n-Node.Type = {\n-  SNIPPET = 0,",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1334408340",
            "id": 1334408340,
            "in_reply_to_id": 1334293206,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5PiXSU",
            "original_commit_id": "98ac771c1b9497c38c6d59d49b9c1db5ed80c274",
            "original_line": 179,
            "original_position": 7,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/_snippet.lua",
            "position": null,
            "pull_request_review_id": 1640000624,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334408340/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-09-22T14:00:28Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334408340",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1334448482"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334448482"
                }
            },
            "author_association": "MEMBER",
            "body": "> No, it's a distaste for cargo cults.\r\n\r\nUp until now, I've not seen any evidence presented that this is one. I've only seen your opinion that you think const-ness isn't important when it comes to readability, which I deeply disagree with. I refactored enough code at this point to know this. Further repeating \"cargo cult\" (on its own) makes this increasingly frustrating.\r\n\r\n> Both are statically analyzable.\r\n\r\nWe have no tools other than `@enum` for that, and because of that we don't uppercase enums nor do we have a convention to indicate whether a symbol is a table or not. Inlay hints can do that for us, and even clangd now does a very good job with semantic tokens at differentiating const-ness without the need for a naming convention.\r\n\r\nIn this case it's unlikely `SNIPPET` is going to be used as a symbol by itself and is likely to be prefixed with `Node.type.`, so it's unlikely that convention is beneficial here. And as you suggest, this could be an `@enum`.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-09-22T14:19:45Z",
            "diff_hunk": "@@ -173,32 +173,33 @@ P.seq = function(...)\n   end\n end\n \n-local Node = {}\n-\n-Node.Type = {\n-  SNIPPET = 0,",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1334448482",
            "id": 1334448482,
            "in_reply_to_id": 1334293206,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5PihFi",
            "original_commit_id": "98ac771c1b9497c38c6d59d49b9c1db5ed80c274",
            "original_line": 179,
            "original_position": 7,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/_snippet.lua",
            "position": null,
            "pull_request_review_id": 1640065088,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334448482/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-09-22T14:19:46Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334448482",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1334463365"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334463365"
                }
            },
            "author_association": "MEMBER",
            "body": "> even clangd now does a very good job with semantic tokens at differentiating const-ness without the need for a naming convention.\r\n\r\nWe're in violent agreement? 😅 ",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-09-22T14:31:43Z",
            "diff_hunk": "@@ -173,32 +173,33 @@ P.seq = function(...)\n   end\n end\n \n-local Node = {}\n-\n-Node.Type = {\n-  SNIPPET = 0,",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1334463365",
            "id": 1334463365,
            "in_reply_to_id": 1334293206,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5PikuF",
            "original_commit_id": "98ac771c1b9497c38c6d59d49b9c1db5ed80c274",
            "original_line": 179,
            "original_position": 7,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/_snippet.lua",
            "position": null,
            "pull_request_review_id": 1640088700,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334463365/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-09-22T14:31:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334463365",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1334475288"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334475288"
                }
            },
            "author_association": "MEMBER",
            "body": "Lua 5.1, unlike C (or even Javascript) does not have language level attributes for const-ness, and LuaLS currently has no `@const` annotation. So.... our only choice to provide such a distinction to code readers is via naming convention. The same applies to python, bash, tcl, etc.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-09-22T14:40:31Z",
            "diff_hunk": "@@ -173,32 +173,33 @@ P.seq = function(...)\n   end\n end\n \n-local Node = {}\n-\n-Node.Type = {\n-  SNIPPET = 0,",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1334475288",
            "id": 1334475288,
            "in_reply_to_id": 1334293206,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5PinoY",
            "original_commit_id": "98ac771c1b9497c38c6d59d49b9c1db5ed80c274",
            "original_line": 179,
            "original_position": 7,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/_snippet.lua",
            "position": null,
            "pull_request_review_id": 1640108199,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334475288/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-09-22T14:40:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334475288",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1334490395"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334490395"
                }
            },
            "author_association": "MEMBER",
            "body": "Yet most javascript programmers follow the convention. Hence \"cargo cult\".\r\n\r\nRegarding Lua: it's not something I will insist on in our codebase, but the argument for it has a shelf-life that is expiring.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-09-22T14:52:48Z",
            "diff_hunk": "@@ -173,32 +173,33 @@ P.seq = function(...)\n   end\n end\n \n-local Node = {}\n-\n-Node.Type = {\n-  SNIPPET = 0,",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1334490395",
            "id": 1334490395,
            "in_reply_to_id": 1334293206,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5PirUb",
            "original_commit_id": "98ac771c1b9497c38c6d59d49b9c1db5ed80c274",
            "original_line": 179,
            "original_position": 7,
            "original_start_line": null,
            "path": "runtime/lua/vim/lsp/_snippet.lua",
            "position": null,
            "pull_request_review_id": 1640130799,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334490395/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-09-22T14:52:49Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334490395",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1334623207"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334623207"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "oh yay another use case! just left a status update on that PR",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-09-22T16:54:00Z",
            "diff_hunk": "@@ -0,0 +1,726 @@\n+local lsp_snippet = require('vim.lsp._snippet')\n+\n+---@alias vim.snippet.MarkId integer\n+---@alias vim.snippet.Tabstop integer\n+---@alias vim.snippet.Changenr integer\n+---@alias vim.snippet.Position { [1]: integer, [2]: integer } # The 0-origin utf8 byte index.\n+---@alias vim.snippet.Range { s: vim.snippet.Position, e: vim.snippet.Position } # The 0-origin utf8 byte index.\n+\n+---@class vim.snippet.TraverseContext\n+---@field depth integer\n+---@field range vim.snippet.Range\n+---@field replace fun(new_node: vim.lsp.snippet.Node): nil\n+\n+---Feed keys.\n+---NOTE: This always enables `virtualedit=onemore`\n+---@param keys string\n+local function feedkeys(keys)\n+  local k = {}\n+  table.insert(k, '<Cmd>set virtualedit=onemore<CR>')\n+  table.insert(k, keys)\n+  table.insert(k, ('<Cmd>set virtualedit=%s<CR>'):format(vim.o.virtualedit))\n+  vim.api.nvim_feedkeys(vim.api.nvim_replace_termcodes(table.concat(k), true, true, true), 'ni', true)\n+end\n+\n+---Return true if range contains position.\n+---@param range vim.snippet.Range\n+---@param position vim.snippet.Position\n+---@return boolean\n+local function within(range, position)\n+  -- Check the cursor is before the range start position.\n+  if position[1] < range.s[1] or (position[1] == range.s[1] and position[2] < range.s[2]) then\n+    return false\n+  end\n+\n+  -- Check the cursor is after the range end position.\n+  if range.e[1] < position[1] or (range.e[1] == position[1] and range.e[2] < position[2]) then\n+    return false\n+  end\n+\n+  return true\n+end\n+\n+---Return cursor position.\n+---@return vim.snippet.Position\n+local function cursor_position()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return { cursor[1] - 1, cursor[2] }\n+end\n+\n+---Return one indent string of current buffer.\n+---@return string\n+local function get_one_indent()\n+  local expandtab = vim.api.nvim_get_option('expandtab')\n+  if not expandtab then\n+    return '\\t'\n+  end\n+  local shiftwidth = vim.api.nvim_get_option('shiftwidth')\n+  if shiftwidth > 0 then\n+    return string.rep(' ', shiftwidth)\n+  end\n+  return string.rep(' ', vim.api.nvim_get_option('tabstop'))\n+end\n+\n+---Return base indent of current line.\n+---@return string\n+local function get_base_indent()\n+  return string.match(vim.api.nvim_get_current_line(), '^%s*') or ''\n+end\n+\n+---Adjust snippet indent\n+---@param snippet_text string\n+---@return string\n+local function adjust_indent(snippet_text)\n+  local one_indent = get_one_indent()\n+  local base_indent = get_base_indent()\n+\n+  local adjusted_snippet_text = {}\n+  local snippet_lines = vim.split(snippet_text, '\\n', { plain = true })\n+  for i, line in ipairs(snippet_lines) do\n+    if i == 1 then\n+      -- Use first line as-is.\n+      table.insert(adjusted_snippet_text, line)\n+    elseif i ~= #snippet_lines and string.match(line, '^%s*$') then\n+      -- Remove space only lines except the last line.\n+      table.insert(adjusted_snippet_text, '')\n+    else\n+      -- 1. Change \\t as one_indent.\n+      -- 2. Add base_indent.\n+      line = string.gsub(line, '^(\\t+)', function(indent)\n+        return string.gsub(indent, '\\t', one_indent)\n+      end)\n+      table.insert(adjusted_snippet_text, base_indent .. line)\n+    end\n+  end\n+  return table.concat(adjusted_snippet_text, '\\n')\n+end\n+\n+---Get range from extmark.\n+---@param ns integer\n+---@param mark_id vim.snippet.MarkId\n+---@return vim.snippet.Range\n+local function get_range_from_mark(ns, mark_id)\n+  local mark = vim.api.nvim_buf_get_extmark_by_id(0, ns, mark_id, { details = true })\n+  local s = { mark[1], mark[2] }\n+  local e = { mark[3].end_row, mark[3].end_col }\n+  if s[1] > e[1] or (s[1] == e[1] and s[2] > e[2]) then\n+    local t = s\n+    s = e\n+    e = t\n+  end\n+  return { s = s, e = e }\n+end\n+\n+---Get text from range.\n+---@param range vim.snippet.Range\n+---@return string\n+local function get_text_by_range(range)\n+  local lines = vim.api.nvim_buf_get_lines(0, range.s[1], range.e[1] + 1, false)\n+  if range.s[1] ~= range.e[1] then\n+    lines[1] = string.sub(lines[1], range.s[2] + 1)\n+    lines[#lines] = string.sub(lines[#lines], 1, range.e[2])\n+  else\n+    lines[1] = string.sub(lines[1], range.s[2] + 1, range.e[2])\n+  end\n+  return table.concat(lines, '\\n')\n+end\n+\n+---Traverse snippet ast.\n+---The `context.range` is calculated by `tostring(node)`, so it can be used only for processing before snippet insertion.\n+---@param snippet_node table\n+---@param callback fun(node: table, context: vim.snippet.TraverseContext): table|nil\n+local function traverse(snippet_node, callback)",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1334623207",
            "id": 1334623207,
            "in_reply_to_id": 1334295676,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5PjLvn",
            "original_commit_id": "98ac771c1b9497c38c6d59d49b9c1db5ed80c274",
            "original_line": 136,
            "original_position": 132,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1640338568,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334623207/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-09-22T16:54:01Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1334623207",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/5601392?v=4",
                "events_url": "https://api.github.com/users/llllvvuu/events{/privacy}",
                "followers_url": "https://api.github.com/users/llllvvuu/followers",
                "following_url": "https://api.github.com/users/llllvvuu/following{/other_user}",
                "gists_url": "https://api.github.com/users/llllvvuu/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/llllvvuu",
                "id": 5601392,
                "login": "llllvvuu",
                "node_id": "MDQ6VXNlcjU2MDEzOTI=",
                "organizations_url": "https://api.github.com/users/llllvvuu/orgs",
                "received_events_url": "https://api.github.com/users/llllvvuu/received_events",
                "repos_url": "https://api.github.com/users/llllvvuu/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/llllvvuu/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/llllvvuu/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/llllvvuu"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1348178743"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348178743"
                }
            },
            "author_association": "MEMBER",
            "body": "LSP defines this variable as the currently selected text or the empty string. However snippet expansion/insertion will always (?) happen in insert mode, so there won't be a visual selection, and I don't want to use `'<`/`'>` since it might not be intended for the last visual selection to be inserted here.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-06T02:28:35Z",
            "diff_hunk": "@@ -0,0 +1,66 @@\n+local grammar = require('_snippet_grammar')\n+\n+--- Returns the current cursor position (0-based).\n+--- @return { [1]: integer, [2]: integer }\n+local function cursor_position()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return { cursor[1] - 1, cursor[2] }\n+end\n+\n+--- Resolves variables.\n+--- @param var string\n+--- @return integer|string|nil\n+local function get_variable_value(var)\n+  if var == 'TM_SELECTED_TEXT' then\n+    return ''",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1348178743",
            "id": 1348178743,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5QW5M3",
            "original_commit_id": "37f8b93133d7e287631eb4f867d7cb1e2074d365",
            "original_line": 15,
            "original_position": 15,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1661022385,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348178743/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-06T02:28:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348178743",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1348374702"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348374702"
                }
            },
            "author_association": "MEMBER",
            "body": "If snippet expansion always happens in insert-mode, what is the intention of this case?\r\n\r\nNote that vim has `:help Select-mode` (as opposed to `:help Visual-mode`) which behaves more like selections in other text editors. Unfortunately It sets `'<`/`'>`, and `visualmode()` doesn't give a hint about whether the last mode was select-mode or visual-mode. But `mode()` does the right thing if we are currently in select-mode.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-06T07:55:50Z",
            "diff_hunk": "@@ -0,0 +1,66 @@\n+local grammar = require('_snippet_grammar')\n+\n+--- Returns the current cursor position (0-based).\n+--- @return { [1]: integer, [2]: integer }\n+local function cursor_position()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return { cursor[1] - 1, cursor[2] }\n+end\n+\n+--- Resolves variables.\n+--- @param var string\n+--- @return integer|string|nil\n+local function get_variable_value(var)\n+  if var == 'TM_SELECTED_TEXT' then\n+    return ''",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1348374702",
            "id": 1348374702,
            "in_reply_to_id": 1348178743,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5QXpCu",
            "original_commit_id": "37f8b93133d7e287631eb4f867d7cb1e2074d365",
            "original_line": 15,
            "original_position": 15,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1661316009,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348374702/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-06T07:55:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348374702",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1348377518"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348377518"
                }
            },
            "author_association": "MEMBER",
            "body": "The issue here is that the LSP spec describes (poorly) how variables should work with defaults, even if that combination doesn't make sense in the vast majority of cases; this is one of the \"nonsense\" combinations. Nevertheless, if we want to implement the spec, we need to handle them somehow.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-06T07:58:32Z",
            "diff_hunk": "@@ -0,0 +1,66 @@\n+local grammar = require('_snippet_grammar')\n+\n+--- Returns the current cursor position (0-based).\n+--- @return { [1]: integer, [2]: integer }\n+local function cursor_position()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return { cursor[1] - 1, cursor[2] }\n+end\n+\n+--- Resolves variables.\n+--- @param var string\n+--- @return integer|string|nil\n+local function get_variable_value(var)\n+  if var == 'TM_SELECTED_TEXT' then\n+    return ''",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1348377518",
            "id": 1348377518,
            "in_reply_to_id": 1348178743,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5QXpuu",
            "original_commit_id": "37f8b93133d7e287631eb4f867d7cb1e2074d365",
            "original_line": 15,
            "original_position": 15,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1661320360,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348377518/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-06T07:58:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348377518",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1348378929"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348378929"
                }
            },
            "author_association": "MEMBER",
            "body": "(This case is much more relevant for snippet _plugins_ that implement manual triggers; it's not relevant to expanding LSP snippets from completion items.)",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-06T07:59:55Z",
            "diff_hunk": "@@ -0,0 +1,66 @@\n+local grammar = require('_snippet_grammar')\n+\n+--- Returns the current cursor position (0-based).\n+--- @return { [1]: integer, [2]: integer }\n+local function cursor_position()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return { cursor[1] - 1, cursor[2] }\n+end\n+\n+--- Resolves variables.\n+--- @param var string\n+--- @return integer|string|nil\n+local function get_variable_value(var)\n+  if var == 'TM_SELECTED_TEXT' then\n+    return ''",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1348378929",
            "id": 1348378929,
            "in_reply_to_id": 1348178743,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5QXqEx",
            "original_commit_id": "37f8b93133d7e287631eb4f867d7cb1e2074d365",
            "original_line": 15,
            "original_position": 15,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1661322616,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348378929/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-06T07:59:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348378929",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1348941381"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348941381"
                }
            },
            "author_association": "MEMBER",
            "body": "Right. I also need to have this case because `TM_SELECTED_TEXT` is a defined variable, and so even if we noop for it we would insert its default if present.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-06T16:24:59Z",
            "diff_hunk": "@@ -0,0 +1,66 @@\n+local grammar = require('_snippet_grammar')\n+\n+--- Returns the current cursor position (0-based).\n+--- @return { [1]: integer, [2]: integer }\n+local function cursor_position()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return { cursor[1] - 1, cursor[2] }\n+end\n+\n+--- Resolves variables.\n+--- @param var string\n+--- @return integer|string|nil\n+local function get_variable_value(var)\n+  if var == 'TM_SELECTED_TEXT' then\n+    return ''",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1348941381",
            "id": 1348941381,
            "in_reply_to_id": 1348178743,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5QZzZF",
            "original_commit_id": "37f8b93133d7e287631eb4f867d7cb1e2074d365",
            "original_line": 15,
            "original_position": 15,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1662248615,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348941381/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-06T16:25:00Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348941381",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1348947069"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348947069"
                }
            },
            "author_association": "MEMBER",
            "body": "Sure, we need to handle whatever the spec demands; I'm just saying don't sweat it if it doesn't make sense ;)",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-06T16:27:19Z",
            "diff_hunk": "@@ -0,0 +1,66 @@\n+local grammar = require('_snippet_grammar')\n+\n+--- Returns the current cursor position (0-based).\n+--- @return { [1]: integer, [2]: integer }\n+local function cursor_position()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return { cursor[1] - 1, cursor[2] }\n+end\n+\n+--- Resolves variables.\n+--- @param var string\n+--- @return integer|string|nil\n+local function get_variable_value(var)\n+  if var == 'TM_SELECTED_TEXT' then\n+    return ''",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1348947069",
            "id": 1348947069,
            "in_reply_to_id": 1348178743,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5QZ0x9",
            "original_commit_id": "37f8b93133d7e287631eb4f867d7cb1e2074d365",
            "original_line": 15,
            "original_position": 15,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1662257323,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348947069/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-06T16:27:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1348947069",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1349177134"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1349177134"
                }
            },
            "author_association": "MEMBER",
            "body": "Note that the snippet grammar says that the variable's default can be any node, but here I'm just assuming that their string representation should be inserted and not doing any extra parsing.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-06T18:22:21Z",
            "diff_hunk": "@@ -0,0 +1,84 @@\n+local G = require('_snippet_grammar')\n+\n+--- Returns the current cursor position (0-based).\n+--- @return { line: integer, col: integer }\n+local function cursor_position()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return { line = cursor[1] - 1, col = cursor[2] }\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default? string\n+--- @return integer|string|nil\n+local function resolve_variable(var, default)\n+  if var == 'TM_SELECTED_TEXT' then\n+    return default or ''\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return vim.fn.expand('<cword>') --[[@as string]]\n+      or default\n+  elseif var == 'TM_LINE_INDEX' then\n+    return cursor_position().line\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return cursor_position().line + 1\n+  end\n+\n+  local bufname = vim.api.nvim_buf_get_name(0)\n+  if bufname == '' then\n+    return default\n+  end\n+  if var == 'TM_FILENAME' then\n+    return vim.fn.fnamemodify(bufname, ':p:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    local filename_base = vim.fn.fnamemodify(bufname, ':p:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return vim.fn.fnamemodify(bufname, ':p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return bufname\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- @alias vim.snippet.Direction\n+--- | -1 # Previous\n+--- | 1 # Next\n+\n+local M = {}\n+\n+--- @param direction vim.snippet.Direction\n+function M.jumpable(direction) end\n+\n+--- @param direction vim.snippet.Direction\n+function M.jump(direction) end\n+\n+--- Expands the given snippet text.\n+--- @param snippet_text string\n+function M.expand(snippet_text)\n+  local snippet = G.parse(snippet_text)\n+\n+  for _, child in ipairs(snippet.data.children) do\n+    local type, data = child.type, child.data\n+    if type == G.NodeType.Variable then\n+      --- @cast data vim.snippet.VariableData\n+      -- Try to get the variable's value.\n+      local value = resolve_variable(data.name, tostring(data.default))",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1349177134",
            "id": 1349177134,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5Qas8u",
            "original_commit_id": "34c1ba3cf3a1422146b522ca2acaccc12f316d11",
            "original_line": 75,
            "original_position": 75,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1662579417,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1349177134/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-08T05:41:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1349177134",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1349610621"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1349610621"
                }
            },
            "author_association": "MEMBER",
            "body": "Sorry for the unrelated change. When using this function I noticed the missing type annotations and decided to piggy-back the fix here.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-08T02:25:03Z",
            "diff_hunk": "@@ -8049,7 +8049,7 @@ function vim.fn.shellescape(string, special) end\n --- will be assumed.\n ---\n --- @param col? integer\n---- @return any\n+--- @return integer",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1349610621",
            "id": 1349610621,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5QcWx9",
            "original_commit_id": "68de01ff2e4c90e534d8c0ef55437e9d00c3e156",
            "original_line": 8058,
            "original_position": 5,
            "original_start_line": null,
            "path": "runtime/lua/vim/_meta/vimfn.lua",
            "position": null,
            "pull_request_review_id": 1663145505,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1349610621/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-08T02:25:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1349610621",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1349610930"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1349610930"
                }
            },
            "author_association": "MEMBER",
            "body": "I didn't want to define yet another range type and so I opted to use `Range4` here. It might be confusing given that the definition lives in the treesitter module, but it also seems like there's a spike in refactoring the entire position/range API (#25509) so I'm unsure of what would be the best action right now.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-08T02:28:33Z",
            "diff_hunk": "@@ -0,0 +1,286 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_ns = vim.api.nvim_create_namespace('vim/snippet')\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  end\n+\n+  if var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+--- @param cursor_row integer\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1349610930",
            "id": 1349610930,
            "line": 100,
            "node_id": "PRRC_kwDOAPphoM5QcW2y",
            "original_commit_id": "68de01ff2e4c90e534d8c0ef55437e9d00c3e156",
            "original_line": 100,
            "original_position": 92,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": 100,
            "pull_request_review_id": 1663145788,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1349610930/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-08T05:42:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1349610930",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1354293038"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1354293038"
                }
            },
            "author_association": "CONTRIBUTOR",
            "body": "LSP ranges are more annoying than Tree-sitter ranges due the string keys, but Tree-sitter is further conceptually from snippets. Tricky. It may depend on if the return value will be directly passed into other functions that do have a defined API, but if there's an impending refactor like you said, maybe don't need to think too much about this",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-11T07:12:03Z",
            "diff_hunk": "@@ -0,0 +1,286 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_ns = vim.api.nvim_create_namespace('vim/snippet')\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  end\n+\n+  if var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+--- @param cursor_row integer\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1354293038",
            "id": 1354293038,
            "in_reply_to_id": 1349610930,
            "line": 100,
            "node_id": "PRRC_kwDOAPphoM5QuN8u",
            "original_commit_id": "68de01ff2e4c90e534d8c0ef55437e9d00c3e156",
            "original_line": 100,
            "original_position": 92,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": 100,
            "pull_request_review_id": 1670204785,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1354293038/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-12T06:17:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1354293038",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/5601392?v=4",
                "events_url": "https://api.github.com/users/llllvvuu/events{/privacy}",
                "followers_url": "https://api.github.com/users/llllvvuu/followers",
                "following_url": "https://api.github.com/users/llllvvuu/following{/other_user}",
                "gists_url": "https://api.github.com/users/llllvvuu/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/llllvvuu",
                "id": 5601392,
                "login": "llllvvuu",
                "node_id": "MDQ6VXNlcjU2MDEzOTI=",
                "organizations_url": "https://api.github.com/users/llllvvuu/orgs",
                "received_events_url": "https://api.github.com/users/llllvvuu/received_events",
                "repos_url": "https://api.github.com/users/llllvvuu/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/llllvvuu/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/llllvvuu/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/llllvvuu"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1356097372"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1356097372"
                }
            },
            "author_association": "MEMBER",
            "body": "Stale comment. I ended up doing this in a separate PR.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-12T06:01:54Z",
            "diff_hunk": "@@ -8049,7 +8049,7 @@ function vim.fn.shellescape(string, special) end\n --- will be assumed.\n ---\n --- @param col? integer\n---- @return any\n+--- @return integer",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1356097372",
            "id": 1356097372,
            "in_reply_to_id": 1349610621,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5Q1Gdc",
            "original_commit_id": "68de01ff2e4c90e534d8c0ef55437e9d00c3e156",
            "original_line": 8058,
            "original_position": 5,
            "original_start_line": null,
            "path": "runtime/lua/vim/_meta/vimfn.lua",
            "position": null,
            "pull_request_review_id": 1673086416,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1356097372/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-12T06:01:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1356097372",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1356137714"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1356137714"
                }
            },
            "author_association": "MEMBER",
            "body": "Right, but here I'm not dealing with ranges as defined by the LSP spec (I'm not receiving or sending LSP objects from the client directly), this is just for me to be able to represent the range of a snippet tabstop in a less verbose way.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-12T06:34:07Z",
            "diff_hunk": "@@ -0,0 +1,286 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_ns = vim.api.nvim_create_namespace('vim/snippet')\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  end\n+\n+  if var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+--- @param cursor_row integer\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1356137714",
            "id": 1356137714,
            "in_reply_to_id": 1349610930,
            "line": 100,
            "node_id": "PRRC_kwDOAPphoM5Q1QTy",
            "original_commit_id": "68de01ff2e4c90e534d8c0ef55437e9d00c3e156",
            "original_line": 100,
            "original_position": 92,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": 100,
            "pull_request_review_id": 1673145994,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1356137714/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-12T06:34:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1356137714",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359068313"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359068313"
                }
            },
            "author_association": "MEMBER",
            "body": "@lewis6991 @clason @gpanders or anyone else that's familiar with the intricacies of the type generator: I just want to generate the documentation for the returned table in this module (`M`, which has the public snippet API). As noticed in this diff, `gen_vimdoc` is also including the other utility classes in this module (`Session` and `Tabstop`). I guess I can try just marking all of those methods with `@nodoc` to prevent them being included here, but that's cumbersome. Do you know of a better workaround with the existing doc infrastructure? ",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T02:28:29Z",
            "diff_hunk": "@@ -3670,4 +3670,87 @@ totable({f}, {...})                                       *vim.iter.totable()*\n     Return: ~\n         (table)\n \n+\n+==============================================================================\n+Lua module: vim.snippet                                          *vim.snippet*\n+\n+active()                                                    *snippet.active()*\n+    Returns `true` if there's an active snippet in the current buffer.\n+\n+    Return: ~\n+        (boolean)\n+\n+cancel()                                                    *snippet.cancel()*\n+    Cancels the current snippet.\n+\n+expand({input})                                             *snippet.expand()*\n+    Expands the given snippet text.\n+\n+    Parameters: ~\n+      • {input}  (string)\n+\n+jump({direction})                                             *snippet.jump()*\n+    Jumps (if possible) within the active snippet in the given direction.\n+\n+    Parameters: ~\n+      • {direction}  vim.snippet.Direction\n+\n+jumpable({direction})                                     *snippet.jumpable()*\n+    @alias vim.snippet.Direction | -1 # Previous | 1 # Next Returns `true` if\n+    there is an active snippet which can be jumped in the given direction.\n+\n+    Parameters: ~\n+      • {direction}  vim.snippet.Direction\n+\n+    Return: ~\n+        (boolean)\n+\n+new({index}, {bufnr}, {range})                                 *snippet.new()*",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359068313",
            "id": 1359068313,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RAbyZ",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 3708,
            "original_position": 39,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1677679555,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359068313/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-14T02:28:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359068313",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359180584"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359180584"
                }
            },
            "author_association": "MEMBER",
            "body": "Maybe worth linking to the grammar definition, so users know what kind of input is accepted.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T06:13:35Z",
            "diff_hunk": "@@ -3670,4 +3670,87 @@ totable({f}, {...})                                       *vim.iter.totable()*\n     Return: ~\n         (table)\n \n+\n+==============================================================================\n+Lua module: vim.snippet                                          *vim.snippet*\n+\n+active()                                                    *snippet.active()*\n+    Returns `true` if there's an active snippet in the current buffer.\n+\n+    Return: ~\n+        (boolean)\n+\n+cancel()                                                    *snippet.cancel()*\n+    Cancels the current snippet.\n+\n+expand({input})                                             *snippet.expand()*\n+    Expands the given snippet text.\n+",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359180584",
            "id": 1359180584,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RA3Mo",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 3688,
            "original_position": 19,
            "original_start_line": 3687,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1677820969,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359180584/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T06:40:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359180584",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359200714"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359200714"
                }
            },
            "author_association": "MEMBER",
            "body": "Is removing newlines part of the spec? If a snippet contains them, shouldn't they be preserved?\r\n\r\n---\r\n\r\nJust as info: I suspect using `vim.tbl_filter` would be more efficient as it avoids the concat/split work. Fine to keep as well given that this is not run in an inner loop or performance sensitive.\r\n",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T06:19:39Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359200714",
            "id": 1359200714,
            "line": 65,
            "node_id": "PRRC_kwDOAPphoM5RA8HK",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 65,
            "original_position": 65,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": 65,
            "pull_request_review_id": 1677820969,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359200714/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-14T06:40:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359200714",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359201179"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359201179"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n```\r\n\r\nI suspect this isn't needed?",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T06:24:29Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359201179",
            "id": 1359201179,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RA8Ob",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 126,
            "original_position": 126,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1677820969,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359201179/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-14T06:40:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359201179",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359201357"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359201357"
                }
            },
            "author_association": "MEMBER",
            "body": "Could using `nvim_buf_get_text` simplify this due to its column parameters?",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T06:26:06Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop\n+\n+--- Creates a new tabstop.\n+---\n+--- @param index integer\n+--- @param bufnr integer\n+--- @param range Range4\n+--- @return vim.snippet.Tabstop\n+function Tabstop.new(index, bufnr, range)\n+  local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, snippet_ns, range[1], range[2], {\n+    right_gravity = false,\n+    end_right_gravity = true,\n+    end_line = range[3],\n+    end_col = range[4],\n+  })\n+\n+  local self = setmetatable(\n+    { index = index, bufnr = bufnr, extmark_id = extmark_id },\n+    { __index = Tabstop }\n+  )\n+\n+  return self\n+end\n+\n+--- Returns the tabstop's range.\n+---\n+--- @return Range4\n+function Tabstop:get_range()\n+  local mark =\n+    vim.api.nvim_buf_get_extmark_by_id(self.bufnr, snippet_ns, self.extmark_id, { details = true })\n+\n+  --- @diagnostic disable-next-line: undefined-field\n+  return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n+end\n+\n+--- Returns the text spanned by the tabstop.\n+---\n+--- @return string\n+function Tabstop:get_text()\n+  local range = self:get_range()\n+  local lines = vim.api.nvim_buf_get_lines(self.bufnr, range[1], range[3] + 1, false)\n+  lines[#lines] = lines[#lines]:sub(1, range[4])\n+  lines[1] = lines[1]:sub(range[2] + 1)",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359201357",
            "id": 1359201357,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RA8RN",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 168,
            "original_position": 168,
            "original_start_line": 166,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1677820969,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359201357/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T06:40:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359201357",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359202067"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359202067"
                }
            },
            "author_association": "MEMBER",
            "body": "Is this intentionally mutating the `Session` object?\r\nIf not:\r\n\r\n\r\n```suggestion\r\nfunction Session.new()\r\n  local state = {\r\n    bufnr = vim.api.nvim_get_current_buf(),\r\n    tabstops = {},\r\n    current_tabstop = Tabstop.new(0, self.bufnr, { 0, 0, 0, 0 })\r\n  }\r\n  return setmetatable(state, __index = Session)\r\nend\r\n```\r\n\r\nIf it is intentional, I'd tend towards using a regular global table, without class style because class style usually involves different instances with encapsulated state.\r\n",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T06:32:58Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop\n+\n+--- Creates a new tabstop.\n+---\n+--- @param index integer\n+--- @param bufnr integer\n+--- @param range Range4\n+--- @return vim.snippet.Tabstop\n+function Tabstop.new(index, bufnr, range)\n+  local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, snippet_ns, range[1], range[2], {\n+    right_gravity = false,\n+    end_right_gravity = true,\n+    end_line = range[3],\n+    end_col = range[4],\n+  })\n+\n+  local self = setmetatable(\n+    { index = index, bufnr = bufnr, extmark_id = extmark_id },\n+    { __index = Tabstop }\n+  )\n+\n+  return self\n+end\n+\n+--- Returns the tabstop's range.\n+---\n+--- @return Range4\n+function Tabstop:get_range()\n+  local mark =\n+    vim.api.nvim_buf_get_extmark_by_id(self.bufnr, snippet_ns, self.extmark_id, { details = true })\n+\n+  --- @diagnostic disable-next-line: undefined-field\n+  return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n+end\n+\n+--- Returns the text spanned by the tabstop.\n+---\n+--- @return string\n+function Tabstop:get_text()\n+  local range = self:get_range()\n+  local lines = vim.api.nvim_buf_get_lines(self.bufnr, range[1], range[3] + 1, false)\n+  lines[#lines] = lines[#lines]:sub(1, range[4])\n+  lines[1] = lines[1]:sub(range[2] + 1)\n+\n+  return table.concat(lines, '\\n')\n+end\n+\n+--- Sets the tabstop's text.\n+---\n+--- @param text string\n+function Tabstop:set_text(text)\n+  local range = self:get_range()\n+  vim.api.nvim_buf_set_text(\n+    self.bufnr,\n+    range[1],\n+    range[2],\n+    range[3],\n+    range[4],\n+    remove_newlines(text)\n+  )\n+end\n+\n+--- @class vim.snippet.Session\n+--- @field bufnr integer\n+--- @field tabstops table<integer, vim.snippet.Tabstop[]>\n+--- @field current_tabstop vim.snippet.Tabstop\n+local Session = {}\n+\n+--- Initializes a new snippet session in the current buffer.\n+---\n+--- @return vim.snippet.Session\n+function Session:init()\n+  self.bufnr = vim.api.nvim_get_current_buf()\n+  self.tabstops = {}\n+  self.current_tabstop = Tabstop.new(0, self.bufnr, { 0, 0, 0, 0 })\n+\n+  return self\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359202067",
            "id": 1359202067,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RA8cT",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 202,
            "original_position": 203,
            "original_start_line": 197,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1677820969,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359202067/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T06:40:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359202067",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359202510"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359202510"
                }
            },
            "author_association": "MEMBER",
            "body": "Would `api.nvim_win_set_cursor` also work here? If not - maybe add a comment why it can't be used",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T06:34:31Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop\n+\n+--- Creates a new tabstop.\n+---\n+--- @param index integer\n+--- @param bufnr integer\n+--- @param range Range4\n+--- @return vim.snippet.Tabstop\n+function Tabstop.new(index, bufnr, range)\n+  local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, snippet_ns, range[1], range[2], {\n+    right_gravity = false,\n+    end_right_gravity = true,\n+    end_line = range[3],\n+    end_col = range[4],\n+  })\n+\n+  local self = setmetatable(\n+    { index = index, bufnr = bufnr, extmark_id = extmark_id },\n+    { __index = Tabstop }\n+  )\n+\n+  return self\n+end\n+\n+--- Returns the tabstop's range.\n+---\n+--- @return Range4\n+function Tabstop:get_range()\n+  local mark =\n+    vim.api.nvim_buf_get_extmark_by_id(self.bufnr, snippet_ns, self.extmark_id, { details = true })\n+\n+  --- @diagnostic disable-next-line: undefined-field\n+  return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n+end\n+\n+--- Returns the text spanned by the tabstop.\n+---\n+--- @return string\n+function Tabstop:get_text()\n+  local range = self:get_range()\n+  local lines = vim.api.nvim_buf_get_lines(self.bufnr, range[1], range[3] + 1, false)\n+  lines[#lines] = lines[#lines]:sub(1, range[4])\n+  lines[1] = lines[1]:sub(range[2] + 1)\n+\n+  return table.concat(lines, '\\n')\n+end\n+\n+--- Sets the tabstop's text.\n+---\n+--- @param text string\n+function Tabstop:set_text(text)\n+  local range = self:get_range()\n+  vim.api.nvim_buf_set_text(\n+    self.bufnr,\n+    range[1],\n+    range[2],\n+    range[3],\n+    range[4],\n+    remove_newlines(text)\n+  )\n+end\n+\n+--- @class vim.snippet.Session\n+--- @field bufnr integer\n+--- @field tabstops table<integer, vim.snippet.Tabstop[]>\n+--- @field current_tabstop vim.snippet.Tabstop\n+local Session = {}\n+\n+--- Initializes a new snippet session in the current buffer.\n+---\n+--- @return vim.snippet.Session\n+function Session:init()\n+  self.bufnr = vim.api.nvim_get_current_buf()\n+  self.tabstops = {}\n+  self.current_tabstop = Tabstop.new(0, self.bufnr, { 0, 0, 0, 0 })\n+\n+  return self\n+end\n+\n+--- Returns the number of tabstop indexes in the snippet session.\n+---\n+--- @return integer\n+function Session:get_num_tabstops()\n+  return #vim.tbl_keys(self.tabstops)\n+end\n+\n+--- Adds a tabstop at the given index and spanning `range`.\n+---\n+--- @param index integer\n+--- @param range Range4\n+function Session:add_tabstop(index, range)\n+  self.tabstops[index] = self.tabstops[index] or {}\n+  table.insert(self.tabstops[index], Tabstop.new(index, self.bufnr, range))\n+end\n+\n+--- @class vim.snippet.Snippet\n+--- @field private session? vim.snippet.Session\n+local M = { session = nil }\n+\n+--- Select the given tabstop range.\n+---\n+--- @private\n+--- @param tabstop vim.snippet.Tabstop\n+function M._select_stop(tabstop)\n+  --- @param keys string\n+  local function feedkeys(keys)\n+    keys = vim.api.nvim_replace_termcodes(keys, true, false, true)\n+    vim.api.nvim_feedkeys(keys, 'n', true)\n+  end\n+\n+  --- @param row integer\n+  --- @param col integer\n+  local function move_cursor_to(row, col)\n+    local line = vim.fn.getline(row) --[[ @as string ]]\n+    col = math.max(vim.fn.strchars(line:sub(1, col)) - 1, 0)\n+    feedkeys(string.format('%sG0%s', row, string.rep('<Right>', col)))\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359202510",
            "id": 1359202510,
            "line": 236,
            "node_id": "PRRC_kwDOAPphoM5RA8jO",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 236,
            "original_position": 242,
            "original_start_line": 238,
            "path": "runtime/lua/vim/snippet.lua",
            "position": 236,
            "pull_request_review_id": 1677820969,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359202510/reactions"
            },
            "side": "RIGHT",
            "start_line": 232,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T06:40:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359202510",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359202677"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359202677"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n  local mode = vim.fn.mode()\r\n  -- For empty and the final tabstop, start insert mode at the end of the range.\r\n  if tabstop.index == 0 or (range[1] == range[3] and range[2] == range[4]) then\r\n    if mode ~= 'i' then\r\n      if mode == 's' then\r\n        feedkeys('<Esc>')\r\n      end\r\n      vim.cmd({ cmd = 'startinsert', bang = range[4] >= #vim.api.nvim_get_current_line() })\r\n    end\r\n  else\r\n    -- Else, select the tabstop's text.\r\n    if mode ~= 'n' then\r\n      feedkeys('<Esc>')\r\n    end\r\n    move_cursor_to(range[1] + 1, range[2] + 1)\r\n    feedkeys('v')\r\n    move_cursor_to(range[3] + 1, range[4])\r\n    feedkeys('o<c-g>')\r\n  end\r\nend\r\n```\r\n",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T06:36:26Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop\n+\n+--- Creates a new tabstop.\n+---\n+--- @param index integer\n+--- @param bufnr integer\n+--- @param range Range4\n+--- @return vim.snippet.Tabstop\n+function Tabstop.new(index, bufnr, range)\n+  local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, snippet_ns, range[1], range[2], {\n+    right_gravity = false,\n+    end_right_gravity = true,\n+    end_line = range[3],\n+    end_col = range[4],\n+  })\n+\n+  local self = setmetatable(\n+    { index = index, bufnr = bufnr, extmark_id = extmark_id },\n+    { __index = Tabstop }\n+  )\n+\n+  return self\n+end\n+\n+--- Returns the tabstop's range.\n+---\n+--- @return Range4\n+function Tabstop:get_range()\n+  local mark =\n+    vim.api.nvim_buf_get_extmark_by_id(self.bufnr, snippet_ns, self.extmark_id, { details = true })\n+\n+  --- @diagnostic disable-next-line: undefined-field\n+  return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n+end\n+\n+--- Returns the text spanned by the tabstop.\n+---\n+--- @return string\n+function Tabstop:get_text()\n+  local range = self:get_range()\n+  local lines = vim.api.nvim_buf_get_lines(self.bufnr, range[1], range[3] + 1, false)\n+  lines[#lines] = lines[#lines]:sub(1, range[4])\n+  lines[1] = lines[1]:sub(range[2] + 1)\n+\n+  return table.concat(lines, '\\n')\n+end\n+\n+--- Sets the tabstop's text.\n+---\n+--- @param text string\n+function Tabstop:set_text(text)\n+  local range = self:get_range()\n+  vim.api.nvim_buf_set_text(\n+    self.bufnr,\n+    range[1],\n+    range[2],\n+    range[3],\n+    range[4],\n+    remove_newlines(text)\n+  )\n+end\n+\n+--- @class vim.snippet.Session\n+--- @field bufnr integer\n+--- @field tabstops table<integer, vim.snippet.Tabstop[]>\n+--- @field current_tabstop vim.snippet.Tabstop\n+local Session = {}\n+\n+--- Initializes a new snippet session in the current buffer.\n+---\n+--- @return vim.snippet.Session\n+function Session:init()\n+  self.bufnr = vim.api.nvim_get_current_buf()\n+  self.tabstops = {}\n+  self.current_tabstop = Tabstop.new(0, self.bufnr, { 0, 0, 0, 0 })\n+\n+  return self\n+end\n+\n+--- Returns the number of tabstop indexes in the snippet session.\n+---\n+--- @return integer\n+function Session:get_num_tabstops()\n+  return #vim.tbl_keys(self.tabstops)\n+end\n+\n+--- Adds a tabstop at the given index and spanning `range`.\n+---\n+--- @param index integer\n+--- @param range Range4\n+function Session:add_tabstop(index, range)\n+  self.tabstops[index] = self.tabstops[index] or {}\n+  table.insert(self.tabstops[index], Tabstop.new(index, self.bufnr, range))\n+end\n+\n+--- @class vim.snippet.Snippet\n+--- @field private session? vim.snippet.Session\n+local M = { session = nil }\n+\n+--- Select the given tabstop range.\n+---\n+--- @private\n+--- @param tabstop vim.snippet.Tabstop\n+function M._select_stop(tabstop)\n+  --- @param keys string\n+  local function feedkeys(keys)\n+    keys = vim.api.nvim_replace_termcodes(keys, true, false, true)\n+    vim.api.nvim_feedkeys(keys, 'n', true)\n+  end\n+\n+  --- @param row integer\n+  --- @param col integer\n+  local function move_cursor_to(row, col)\n+    local line = vim.fn.getline(row) --[[ @as string ]]\n+    col = math.max(vim.fn.strchars(line:sub(1, col)) - 1, 0)\n+    feedkeys(string.format('%sG0%s', row, string.rep('<Right>', col)))\n+  end\n+\n+  local range = tabstop:get_range()\n+\n+  -- Move the cursor to the start of the tabstop.\n+  vim.api.nvim_win_set_cursor(0, { range[1] + 1, range[2] })\n+\n+  -- For empty and the final tabstop, start insert mode at the end of the range.\n+  if tabstop.index == 0 or (range[1] == range[3] and range[2] == range[4]) then\n+    if vim.fn.mode() ~= 'i' then\n+      if vim.fn.mode() == 's' then\n+        feedkeys('<Esc>')\n+      end\n+      vim.cmd({ cmd = 'startinsert', bang = range[4] >= #vim.api.nvim_get_current_line() })\n+    end\n+  else\n+    -- Else, select the tabstop's text.\n+    if vim.fn.mode() ~= 'n' then\n+      feedkeys('<Esc>')\n+    end\n+    move_cursor_to(range[1] + 1, range[2] + 1)\n+    feedkeys('v')\n+    move_cursor_to(range[3] + 1, range[4])\n+    feedkeys('o<c-g>')\n+  end\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359202677",
            "id": 1359202677,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RA8l1",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 262,
            "original_position": 267,
            "original_start_line": 249,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1677820969,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359202677/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T06:40:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359202677",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359202827"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359202827"
                }
            },
            "author_association": "MEMBER",
            "body": "Is there any downside to having it?",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T06:38:25Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop\n+\n+--- Creates a new tabstop.\n+---\n+--- @param index integer\n+--- @param bufnr integer\n+--- @param range Range4\n+--- @return vim.snippet.Tabstop\n+function Tabstop.new(index, bufnr, range)\n+  local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, snippet_ns, range[1], range[2], {\n+    right_gravity = false,\n+    end_right_gravity = true,\n+    end_line = range[3],\n+    end_col = range[4],\n+  })\n+\n+  local self = setmetatable(\n+    { index = index, bufnr = bufnr, extmark_id = extmark_id },\n+    { __index = Tabstop }\n+  )\n+\n+  return self\n+end\n+\n+--- Returns the tabstop's range.\n+---\n+--- @return Range4\n+function Tabstop:get_range()\n+  local mark =\n+    vim.api.nvim_buf_get_extmark_by_id(self.bufnr, snippet_ns, self.extmark_id, { details = true })\n+\n+  --- @diagnostic disable-next-line: undefined-field\n+  return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n+end\n+\n+--- Returns the text spanned by the tabstop.\n+---\n+--- @return string\n+function Tabstop:get_text()\n+  local range = self:get_range()\n+  local lines = vim.api.nvim_buf_get_lines(self.bufnr, range[1], range[3] + 1, false)\n+  lines[#lines] = lines[#lines]:sub(1, range[4])\n+  lines[1] = lines[1]:sub(range[2] + 1)\n+\n+  return table.concat(lines, '\\n')\n+end\n+\n+--- Sets the tabstop's text.\n+---\n+--- @param text string\n+function Tabstop:set_text(text)\n+  local range = self:get_range()\n+  vim.api.nvim_buf_set_text(\n+    self.bufnr,\n+    range[1],\n+    range[2],\n+    range[3],\n+    range[4],\n+    remove_newlines(text)\n+  )\n+end\n+\n+--- @class vim.snippet.Session\n+--- @field bufnr integer\n+--- @field tabstops table<integer, vim.snippet.Tabstop[]>\n+--- @field current_tabstop vim.snippet.Tabstop\n+local Session = {}\n+\n+--- Initializes a new snippet session in the current buffer.\n+---\n+--- @return vim.snippet.Session\n+function Session:init()\n+  self.bufnr = vim.api.nvim_get_current_buf()\n+  self.tabstops = {}\n+  self.current_tabstop = Tabstop.new(0, self.bufnr, { 0, 0, 0, 0 })\n+\n+  return self\n+end\n+\n+--- Returns the number of tabstop indexes in the snippet session.\n+---\n+--- @return integer\n+function Session:get_num_tabstops()\n+  return #vim.tbl_keys(self.tabstops)\n+end\n+\n+--- Adds a tabstop at the given index and spanning `range`.\n+---\n+--- @param index integer\n+--- @param range Range4\n+function Session:add_tabstop(index, range)\n+  self.tabstops[index] = self.tabstops[index] or {}\n+  table.insert(self.tabstops[index], Tabstop.new(index, self.bufnr, range))\n+end\n+\n+--- @class vim.snippet.Snippet\n+--- @field private session? vim.snippet.Session\n+local M = { session = nil }\n+\n+--- Select the given tabstop range.\n+---\n+--- @private\n+--- @param tabstop vim.snippet.Tabstop\n+function M._select_stop(tabstop)\n+  --- @param keys string\n+  local function feedkeys(keys)\n+    keys = vim.api.nvim_replace_termcodes(keys, true, false, true)\n+    vim.api.nvim_feedkeys(keys, 'n', true)\n+  end\n+\n+  --- @param row integer\n+  --- @param col integer\n+  local function move_cursor_to(row, col)\n+    local line = vim.fn.getline(row) --[[ @as string ]]\n+    col = math.max(vim.fn.strchars(line:sub(1, col)) - 1, 0)\n+    feedkeys(string.format('%sG0%s', row, string.rep('<Right>', col)))\n+  end\n+\n+  local range = tabstop:get_range()\n+\n+  -- Move the cursor to the start of the tabstop.\n+  vim.api.nvim_win_set_cursor(0, { range[1] + 1, range[2] })\n+\n+  -- For empty and the final tabstop, start insert mode at the end of the range.\n+  if tabstop.index == 0 or (range[1] == range[3] and range[2] == range[4]) then\n+    if vim.fn.mode() ~= 'i' then\n+      if vim.fn.mode() == 's' then\n+        feedkeys('<Esc>')\n+      end\n+      vim.cmd({ cmd = 'startinsert', bang = range[4] >= #vim.api.nvim_get_current_line() })\n+    end\n+  else\n+    -- Else, select the tabstop's text.\n+    if vim.fn.mode() ~= 'n' then\n+      feedkeys('<Esc>')\n+    end\n+    move_cursor_to(range[1] + 1, range[2] + 1)\n+    feedkeys('v')\n+    move_cursor_to(range[3] + 1, range[4])\n+    feedkeys('o<c-g>')\n+  end\n+end\n+\n+--- Sets up the necessary autocommands for snippet expansion.\n+---\n+--- @private\n+function M._setup_autocmds()\n+  local group = vim.api.nvim_create_augroup(snippet_group, {})\n+\n+  vim.api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, {\n+    group = group,\n+    desc = 'Update snippet state when the cursor moves',\n+    buffer = M.session.bufnr,\n+    callback = function()\n+      -- Just update the tabstop in insert and select modes.\n+      if not vim.fn.mode():match('^[isS]') then\n+        return\n+      end\n+\n+      -- Update the current tabstop to be the one containing the cursor.\n+      local cursor_row, cursor_col = cursor_pos()\n+      for tabstop_index, tabstops in pairs(M.session.tabstops) do\n+        for _, tabstop in ipairs(tabstops) do\n+          local range = tabstop:get_range()\n+          if\n+            (cursor_row > range[1] or (cursor_row == range[1] and cursor_col >= range[2]))\n+            and (cursor_row < range[3] or (cursor_row == range[3] and cursor_col <= range[4]))\n+          then\n+            M.session.current_tabstop = tabstop\n+            if tabstop_index ~= 0 then\n+              return\n+            end\n+          end\n+        end\n+      end\n+\n+      -- The cursor is either not on a tabstop or we reached the end, so cancel the session.\n+      M.cancel()\n+    end,\n+  })\n+\n+  vim.api.nvim_create_autocmd({ 'TextChanged', 'TextChangedI' }, {\n+    group = group,\n+    desc = 'Update active tabstops when buffer text changes',\n+    buffer = M.session.bufnr,\n+    callback = function()\n+      -- Sync the tabstops in the current group.\n+      local current_tabstop = M.session.current_tabstop\n+      local current_text = current_tabstop:get_text()\n+      for _, tabstop in ipairs(M.session.tabstops[current_tabstop.index]) do\n+        if tabstop.extmark_id ~= current_tabstop.extmark_id then\n+          tabstop:set_text(current_text)\n+        end\n+      end\n+    end,\n+  })\n+end\n+\n+--- Clears the snippet autocommand group.\n+---\n+--- @private\n+function M._clear_autocmds()\n+  pcall(vim.api.nvim_clear_autocmds, { group = snippet_group, buffer = M.session.bufnr })\n+end\n+\n+--- Expands the given snippet text.\n+---\n+--- @param input string\n+function M.expand(input)\n+  local snippet = G.parse(input)\n+  local snippet_text = {}\n+\n+  M.session = Session:init()\n+\n+  -- Keep track of tabstop nodes during expansion.\n+  --- @type table<integer, Range4[]>\n+  local tabstop_ranges = {}\n+\n+  --- @param index integer\n+  --- @param placeholder string?\n+  local function add_tabstop(index, placeholder)\n+    tabstop_ranges[index] = tabstop_ranges[index] or {}\n+    table.insert(tabstop_ranges[index], compute_tabstop_range(snippet_text, placeholder))\n+  end\n+\n+  for _, child in ipairs(snippet.data.children) do\n+    local type, data = child.type, child.data\n+    if type == G.NodeType.Tabstop then\n+      --- @cast data vim.snippet.TabstopData\n+      add_tabstop(data.tabstop)\n+    elseif type == G.NodeType.Placeholder then\n+      --- @cast data vim.snippet.PlaceholderData\n+      local value = tostring(data.value)\n+      add_tabstop(data.tabstop, value)\n+      append_to_snippet(snippet_text, value)\n+    elseif type == G.NodeType.Choice then\n+      --- @cast data vim.snippet.ChoiceData\n+      append_to_snippet(snippet_text, data.values[1])\n+    elseif type == G.NodeType.Variable then\n+      --- @cast data vim.snippet.VariableData\n+      -- Try to get the variable's value.\n+      local value = resolve_variable(data.name, data.default and tostring(data.default) or '')\n+      if not value then\n+        -- Unknown variable, make this a tabstop and use the variable name as a placeholder.\n+        value = data.name\n+        local tabstop_indexes = vim.tbl_keys(tabstop_ranges)\n+        local index = math.max(unpack((#tabstop_indexes == 0 and { 0 }) or tabstop_indexes)) + 1\n+        add_tabstop(index, value)\n+      end\n+      append_to_snippet(snippet_text, value)\n+    elseif type == G.NodeType.Text then\n+      --- @cast data vim.snippet.TextData\n+      append_to_snippet(snippet_text, data.text)\n+    end\n+  end\n+\n+  -- $0, which defaults to the end of the snippet, defines the final cursor position.\n+  -- Make sure the snippet has exactly one of these.\n+  if vim.tbl_contains(vim.tbl_keys(tabstop_ranges), 0) then\n+    assert(#tabstop_ranges[0] == 1, 'Snippet has multiple $0 tabstops')\n+  else\n+    add_tabstop(0)\n+  end\n+\n+  -- Insert the snippet text.\n+  local cursor_row, cursor_col = cursor_pos()\n+  vim.api.nvim_buf_set_text(\n+    M.session.bufnr,\n+    cursor_row,\n+    cursor_col,\n+    cursor_row,\n+    cursor_col,\n+    remove_newlines(snippet_text)\n+  )\n+\n+  -- Create the tabstop extmarks.\n+  for index, ranges in pairs(tabstop_ranges) do\n+    for _, range in ipairs(ranges) do\n+      M.session:add_tabstop(index, range)\n+    end\n+  end\n+\n+  -- Jump to the first tabstop.\n+  M.jump(1)\n+end\n+\n+--- @alias vim.snippet.Direction\n+--- | -1 # Previous\n+--- | 1 # Next\n+\n+--- Returns `true` if there is an active snippet which can be jumped in the given direction.\n+---\n+--- @param direction vim.snippet.Direction\n+--- @return boolean\n+function M.jumpable(direction)\n+  if not M.active() or M.session:get_num_tabstops() == 0 then\n+    return false\n+  end\n+\n+  if direction == -1 then\n+    return M.session.current_tabstop.index > 1\n+  else\n+    return M.session.current_tabstop.index < M.session:get_num_tabstops()\n+  end\n+end\n+\n+--- Jumps (if possible) within the active snippet in the given direction.\n+---\n+--- @param direction vim.snippet.Direction\n+function M.jump(direction)\n+  -- TODO: Not sure if we want to have this check or insist on the user to check `jumpable` first.\n+  if not M.jumpable(direction) then\n+    return\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359202827",
            "id": 1359202827,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RA8oL",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 434,
            "original_position": 439,
            "original_start_line": 436,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1677820969,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359202827/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T06:40:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359202827",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359202974"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359202974"
                }
            },
            "author_association": "MEMBER",
            "body": "I think cancel is a good match, and it has the most uses across the codebase:\r\n\r\n```\r\n~/dev/neovim/neovim master\r\n↪  rg cancel | wc -l\r\n416\r\n\r\n~/dev/neovim/neovim master\r\n↪  rg discard | wc -l\r\n311\r\n\r\n~/dev/neovim/neovim master\r\n↪  rg unlink | wc -l\r\n39\r\n\r\n~/dev/neovim/neovim master\r\n↪  rg dispose | wc -l\r\n3\r\n```",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T06:39:39Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop\n+\n+--- Creates a new tabstop.\n+---\n+--- @param index integer\n+--- @param bufnr integer\n+--- @param range Range4\n+--- @return vim.snippet.Tabstop\n+function Tabstop.new(index, bufnr, range)\n+  local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, snippet_ns, range[1], range[2], {\n+    right_gravity = false,\n+    end_right_gravity = true,\n+    end_line = range[3],\n+    end_col = range[4],\n+  })\n+\n+  local self = setmetatable(\n+    { index = index, bufnr = bufnr, extmark_id = extmark_id },\n+    { __index = Tabstop }\n+  )\n+\n+  return self\n+end\n+\n+--- Returns the tabstop's range.\n+---\n+--- @return Range4\n+function Tabstop:get_range()\n+  local mark =\n+    vim.api.nvim_buf_get_extmark_by_id(self.bufnr, snippet_ns, self.extmark_id, { details = true })\n+\n+  --- @diagnostic disable-next-line: undefined-field\n+  return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n+end\n+\n+--- Returns the text spanned by the tabstop.\n+---\n+--- @return string\n+function Tabstop:get_text()\n+  local range = self:get_range()\n+  local lines = vim.api.nvim_buf_get_lines(self.bufnr, range[1], range[3] + 1, false)\n+  lines[#lines] = lines[#lines]:sub(1, range[4])\n+  lines[1] = lines[1]:sub(range[2] + 1)\n+\n+  return table.concat(lines, '\\n')\n+end\n+\n+--- Sets the tabstop's text.\n+---\n+--- @param text string\n+function Tabstop:set_text(text)\n+  local range = self:get_range()\n+  vim.api.nvim_buf_set_text(\n+    self.bufnr,\n+    range[1],\n+    range[2],\n+    range[3],\n+    range[4],\n+    remove_newlines(text)\n+  )\n+end\n+\n+--- @class vim.snippet.Session\n+--- @field bufnr integer\n+--- @field tabstops table<integer, vim.snippet.Tabstop[]>\n+--- @field current_tabstop vim.snippet.Tabstop\n+local Session = {}\n+\n+--- Initializes a new snippet session in the current buffer.\n+---\n+--- @return vim.snippet.Session\n+function Session:init()\n+  self.bufnr = vim.api.nvim_get_current_buf()\n+  self.tabstops = {}\n+  self.current_tabstop = Tabstop.new(0, self.bufnr, { 0, 0, 0, 0 })\n+\n+  return self\n+end\n+\n+--- Returns the number of tabstop indexes in the snippet session.\n+---\n+--- @return integer\n+function Session:get_num_tabstops()\n+  return #vim.tbl_keys(self.tabstops)\n+end\n+\n+--- Adds a tabstop at the given index and spanning `range`.\n+---\n+--- @param index integer\n+--- @param range Range4\n+function Session:add_tabstop(index, range)\n+  self.tabstops[index] = self.tabstops[index] or {}\n+  table.insert(self.tabstops[index], Tabstop.new(index, self.bufnr, range))\n+end\n+\n+--- @class vim.snippet.Snippet\n+--- @field private session? vim.snippet.Session\n+local M = { session = nil }\n+\n+--- Select the given tabstop range.\n+---\n+--- @private\n+--- @param tabstop vim.snippet.Tabstop\n+function M._select_stop(tabstop)\n+  --- @param keys string\n+  local function feedkeys(keys)\n+    keys = vim.api.nvim_replace_termcodes(keys, true, false, true)\n+    vim.api.nvim_feedkeys(keys, 'n', true)\n+  end\n+\n+  --- @param row integer\n+  --- @param col integer\n+  local function move_cursor_to(row, col)\n+    local line = vim.fn.getline(row) --[[ @as string ]]\n+    col = math.max(vim.fn.strchars(line:sub(1, col)) - 1, 0)\n+    feedkeys(string.format('%sG0%s', row, string.rep('<Right>', col)))\n+  end\n+\n+  local range = tabstop:get_range()\n+\n+  -- Move the cursor to the start of the tabstop.\n+  vim.api.nvim_win_set_cursor(0, { range[1] + 1, range[2] })\n+\n+  -- For empty and the final tabstop, start insert mode at the end of the range.\n+  if tabstop.index == 0 or (range[1] == range[3] and range[2] == range[4]) then\n+    if vim.fn.mode() ~= 'i' then\n+      if vim.fn.mode() == 's' then\n+        feedkeys('<Esc>')\n+      end\n+      vim.cmd({ cmd = 'startinsert', bang = range[4] >= #vim.api.nvim_get_current_line() })\n+    end\n+  else\n+    -- Else, select the tabstop's text.\n+    if vim.fn.mode() ~= 'n' then\n+      feedkeys('<Esc>')\n+    end\n+    move_cursor_to(range[1] + 1, range[2] + 1)\n+    feedkeys('v')\n+    move_cursor_to(range[3] + 1, range[4])\n+    feedkeys('o<c-g>')\n+  end\n+end\n+\n+--- Sets up the necessary autocommands for snippet expansion.\n+---\n+--- @private\n+function M._setup_autocmds()\n+  local group = vim.api.nvim_create_augroup(snippet_group, {})\n+\n+  vim.api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, {\n+    group = group,\n+    desc = 'Update snippet state when the cursor moves',\n+    buffer = M.session.bufnr,\n+    callback = function()\n+      -- Just update the tabstop in insert and select modes.\n+      if not vim.fn.mode():match('^[isS]') then\n+        return\n+      end\n+\n+      -- Update the current tabstop to be the one containing the cursor.\n+      local cursor_row, cursor_col = cursor_pos()\n+      for tabstop_index, tabstops in pairs(M.session.tabstops) do\n+        for _, tabstop in ipairs(tabstops) do\n+          local range = tabstop:get_range()\n+          if\n+            (cursor_row > range[1] or (cursor_row == range[1] and cursor_col >= range[2]))\n+            and (cursor_row < range[3] or (cursor_row == range[3] and cursor_col <= range[4]))\n+          then\n+            M.session.current_tabstop = tabstop\n+            if tabstop_index ~= 0 then\n+              return\n+            end\n+          end\n+        end\n+      end\n+\n+      -- The cursor is either not on a tabstop or we reached the end, so cancel the session.\n+      M.cancel()\n+    end,\n+  })\n+\n+  vim.api.nvim_create_autocmd({ 'TextChanged', 'TextChangedI' }, {\n+    group = group,\n+    desc = 'Update active tabstops when buffer text changes',\n+    buffer = M.session.bufnr,\n+    callback = function()\n+      -- Sync the tabstops in the current group.\n+      local current_tabstop = M.session.current_tabstop\n+      local current_text = current_tabstop:get_text()\n+      for _, tabstop in ipairs(M.session.tabstops[current_tabstop.index]) do\n+        if tabstop.extmark_id ~= current_tabstop.extmark_id then\n+          tabstop:set_text(current_text)\n+        end\n+      end\n+    end,\n+  })\n+end\n+\n+--- Clears the snippet autocommand group.\n+---\n+--- @private\n+function M._clear_autocmds()\n+  pcall(vim.api.nvim_clear_autocmds, { group = snippet_group, buffer = M.session.bufnr })\n+end\n+\n+--- Expands the given snippet text.\n+---\n+--- @param input string\n+function M.expand(input)\n+  local snippet = G.parse(input)\n+  local snippet_text = {}\n+\n+  M.session = Session:init()\n+\n+  -- Keep track of tabstop nodes during expansion.\n+  --- @type table<integer, Range4[]>\n+  local tabstop_ranges = {}\n+\n+  --- @param index integer\n+  --- @param placeholder string?\n+  local function add_tabstop(index, placeholder)\n+    tabstop_ranges[index] = tabstop_ranges[index] or {}\n+    table.insert(tabstop_ranges[index], compute_tabstop_range(snippet_text, placeholder))\n+  end\n+\n+  for _, child in ipairs(snippet.data.children) do\n+    local type, data = child.type, child.data\n+    if type == G.NodeType.Tabstop then\n+      --- @cast data vim.snippet.TabstopData\n+      add_tabstop(data.tabstop)\n+    elseif type == G.NodeType.Placeholder then\n+      --- @cast data vim.snippet.PlaceholderData\n+      local value = tostring(data.value)\n+      add_tabstop(data.tabstop, value)\n+      append_to_snippet(snippet_text, value)\n+    elseif type == G.NodeType.Choice then\n+      --- @cast data vim.snippet.ChoiceData\n+      append_to_snippet(snippet_text, data.values[1])\n+    elseif type == G.NodeType.Variable then\n+      --- @cast data vim.snippet.VariableData\n+      -- Try to get the variable's value.\n+      local value = resolve_variable(data.name, data.default and tostring(data.default) or '')\n+      if not value then\n+        -- Unknown variable, make this a tabstop and use the variable name as a placeholder.\n+        value = data.name\n+        local tabstop_indexes = vim.tbl_keys(tabstop_ranges)\n+        local index = math.max(unpack((#tabstop_indexes == 0 and { 0 }) or tabstop_indexes)) + 1\n+        add_tabstop(index, value)\n+      end\n+      append_to_snippet(snippet_text, value)\n+    elseif type == G.NodeType.Text then\n+      --- @cast data vim.snippet.TextData\n+      append_to_snippet(snippet_text, data.text)\n+    end\n+  end\n+\n+  -- $0, which defaults to the end of the snippet, defines the final cursor position.\n+  -- Make sure the snippet has exactly one of these.\n+  if vim.tbl_contains(vim.tbl_keys(tabstop_ranges), 0) then\n+    assert(#tabstop_ranges[0] == 1, 'Snippet has multiple $0 tabstops')\n+  else\n+    add_tabstop(0)\n+  end\n+\n+  -- Insert the snippet text.\n+  local cursor_row, cursor_col = cursor_pos()\n+  vim.api.nvim_buf_set_text(\n+    M.session.bufnr,\n+    cursor_row,\n+    cursor_col,\n+    cursor_row,\n+    cursor_col,\n+    remove_newlines(snippet_text)\n+  )\n+\n+  -- Create the tabstop extmarks.\n+  for index, ranges in pairs(tabstop_ranges) do\n+    for _, range in ipairs(ranges) do\n+      M.session:add_tabstop(index, range)\n+    end\n+  end\n+\n+  -- Jump to the first tabstop.\n+  M.jump(1)\n+end\n+\n+--- @alias vim.snippet.Direction\n+--- | -1 # Previous\n+--- | 1 # Next\n+\n+--- Returns `true` if there is an active snippet which can be jumped in the given direction.\n+---\n+--- @param direction vim.snippet.Direction\n+--- @return boolean\n+function M.jumpable(direction)\n+  if not M.active() or M.session:get_num_tabstops() == 0 then\n+    return false\n+  end\n+\n+  if direction == -1 then\n+    return M.session.current_tabstop.index > 1\n+  else\n+    return M.session.current_tabstop.index < M.session:get_num_tabstops()\n+  end\n+end\n+\n+--- Jumps (if possible) within the active snippet in the given direction.\n+---\n+--- @param direction vim.snippet.Direction\n+function M.jump(direction)\n+  -- TODO: Not sure if we want to have this check or insist on the user to check `jumpable` first.\n+  if not M.jumpable(direction) then\n+    return\n+  end\n+\n+  -- Find the tabstop with the lowest range.\n+  local tabstops =\n+    M.session.tabstops[(M.session.current_tabstop.index + direction) % M.session:get_num_tabstops()]\n+  local dest = tabstops[1]\n+  for _, tabstop in ipairs(tabstops) do\n+    local dest_range, range = dest:get_range(), tabstop:get_range()\n+    if (range[1] < dest_range[1]) or (range[1] == dest_range[1] and range[2] < dest_range[2]) then\n+      dest = tabstop\n+    end\n+  end\n+\n+  -- Clear the autocommands so that we can move the cursor freely while selecting the tabstop.\n+  M._clear_autocmds()\n+\n+  M.session.current_tabstop = dest\n+  M._select_stop(dest)\n+\n+  -- Restore the autocommands.\n+  M._setup_autocmds()\n+end\n+\n+--- Returns `true` if there's an active snippet in the current buffer.\n+---\n+--- @return boolean\n+function M.active()\n+  return M.session ~= nil and M.session.bufnr == vim.api.nvim_get_current_buf()\n+end\n+\n+-- TODO: Use another name? discard? dispose? unlink? assassinate?\n+--- Cancels the current snippet.\n+function M.cancel()",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359202974",
            "id": 1359202974,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RA8qe",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 471,
            "original_position": 471,
            "original_start_line": 469,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1677820969,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359202974/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T06:40:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359202974",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359203315"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359203315"
                }
            },
            "author_association": "MEMBER",
            "body": "Oh, I had missed this:\r\n\r\n> since sometimes it does cancel the snippet session but it's also invoked when the snippet navigation is complete. Do we want to give it another name?\r\n\r\nIn that case, maybe `reset` could work?\r\n\r\nIt's also used quite often:\r\n\r\n```\r\n↪  rg reset | wc -l\r\n1160\r\n```",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T06:42:24Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop\n+\n+--- Creates a new tabstop.\n+---\n+--- @param index integer\n+--- @param bufnr integer\n+--- @param range Range4\n+--- @return vim.snippet.Tabstop\n+function Tabstop.new(index, bufnr, range)\n+  local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, snippet_ns, range[1], range[2], {\n+    right_gravity = false,\n+    end_right_gravity = true,\n+    end_line = range[3],\n+    end_col = range[4],\n+  })\n+\n+  local self = setmetatable(\n+    { index = index, bufnr = bufnr, extmark_id = extmark_id },\n+    { __index = Tabstop }\n+  )\n+\n+  return self\n+end\n+\n+--- Returns the tabstop's range.\n+---\n+--- @return Range4\n+function Tabstop:get_range()\n+  local mark =\n+    vim.api.nvim_buf_get_extmark_by_id(self.bufnr, snippet_ns, self.extmark_id, { details = true })\n+\n+  --- @diagnostic disable-next-line: undefined-field\n+  return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n+end\n+\n+--- Returns the text spanned by the tabstop.\n+---\n+--- @return string\n+function Tabstop:get_text()\n+  local range = self:get_range()\n+  local lines = vim.api.nvim_buf_get_lines(self.bufnr, range[1], range[3] + 1, false)\n+  lines[#lines] = lines[#lines]:sub(1, range[4])\n+  lines[1] = lines[1]:sub(range[2] + 1)\n+\n+  return table.concat(lines, '\\n')\n+end\n+\n+--- Sets the tabstop's text.\n+---\n+--- @param text string\n+function Tabstop:set_text(text)\n+  local range = self:get_range()\n+  vim.api.nvim_buf_set_text(\n+    self.bufnr,\n+    range[1],\n+    range[2],\n+    range[3],\n+    range[4],\n+    remove_newlines(text)\n+  )\n+end\n+\n+--- @class vim.snippet.Session\n+--- @field bufnr integer\n+--- @field tabstops table<integer, vim.snippet.Tabstop[]>\n+--- @field current_tabstop vim.snippet.Tabstop\n+local Session = {}\n+\n+--- Initializes a new snippet session in the current buffer.\n+---\n+--- @return vim.snippet.Session\n+function Session:init()\n+  self.bufnr = vim.api.nvim_get_current_buf()\n+  self.tabstops = {}\n+  self.current_tabstop = Tabstop.new(0, self.bufnr, { 0, 0, 0, 0 })\n+\n+  return self\n+end\n+\n+--- Returns the number of tabstop indexes in the snippet session.\n+---\n+--- @return integer\n+function Session:get_num_tabstops()\n+  return #vim.tbl_keys(self.tabstops)\n+end\n+\n+--- Adds a tabstop at the given index and spanning `range`.\n+---\n+--- @param index integer\n+--- @param range Range4\n+function Session:add_tabstop(index, range)\n+  self.tabstops[index] = self.tabstops[index] or {}\n+  table.insert(self.tabstops[index], Tabstop.new(index, self.bufnr, range))\n+end\n+\n+--- @class vim.snippet.Snippet\n+--- @field private session? vim.snippet.Session\n+local M = { session = nil }\n+\n+--- Select the given tabstop range.\n+---\n+--- @private\n+--- @param tabstop vim.snippet.Tabstop\n+function M._select_stop(tabstop)\n+  --- @param keys string\n+  local function feedkeys(keys)\n+    keys = vim.api.nvim_replace_termcodes(keys, true, false, true)\n+    vim.api.nvim_feedkeys(keys, 'n', true)\n+  end\n+\n+  --- @param row integer\n+  --- @param col integer\n+  local function move_cursor_to(row, col)\n+    local line = vim.fn.getline(row) --[[ @as string ]]\n+    col = math.max(vim.fn.strchars(line:sub(1, col)) - 1, 0)\n+    feedkeys(string.format('%sG0%s', row, string.rep('<Right>', col)))\n+  end\n+\n+  local range = tabstop:get_range()\n+\n+  -- Move the cursor to the start of the tabstop.\n+  vim.api.nvim_win_set_cursor(0, { range[1] + 1, range[2] })\n+\n+  -- For empty and the final tabstop, start insert mode at the end of the range.\n+  if tabstop.index == 0 or (range[1] == range[3] and range[2] == range[4]) then\n+    if vim.fn.mode() ~= 'i' then\n+      if vim.fn.mode() == 's' then\n+        feedkeys('<Esc>')\n+      end\n+      vim.cmd({ cmd = 'startinsert', bang = range[4] >= #vim.api.nvim_get_current_line() })\n+    end\n+  else\n+    -- Else, select the tabstop's text.\n+    if vim.fn.mode() ~= 'n' then\n+      feedkeys('<Esc>')\n+    end\n+    move_cursor_to(range[1] + 1, range[2] + 1)\n+    feedkeys('v')\n+    move_cursor_to(range[3] + 1, range[4])\n+    feedkeys('o<c-g>')\n+  end\n+end\n+\n+--- Sets up the necessary autocommands for snippet expansion.\n+---\n+--- @private\n+function M._setup_autocmds()\n+  local group = vim.api.nvim_create_augroup(snippet_group, {})\n+\n+  vim.api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, {\n+    group = group,\n+    desc = 'Update snippet state when the cursor moves',\n+    buffer = M.session.bufnr,\n+    callback = function()\n+      -- Just update the tabstop in insert and select modes.\n+      if not vim.fn.mode():match('^[isS]') then\n+        return\n+      end\n+\n+      -- Update the current tabstop to be the one containing the cursor.\n+      local cursor_row, cursor_col = cursor_pos()\n+      for tabstop_index, tabstops in pairs(M.session.tabstops) do\n+        for _, tabstop in ipairs(tabstops) do\n+          local range = tabstop:get_range()\n+          if\n+            (cursor_row > range[1] or (cursor_row == range[1] and cursor_col >= range[2]))\n+            and (cursor_row < range[3] or (cursor_row == range[3] and cursor_col <= range[4]))\n+          then\n+            M.session.current_tabstop = tabstop\n+            if tabstop_index ~= 0 then\n+              return\n+            end\n+          end\n+        end\n+      end\n+\n+      -- The cursor is either not on a tabstop or we reached the end, so cancel the session.\n+      M.cancel()\n+    end,\n+  })\n+\n+  vim.api.nvim_create_autocmd({ 'TextChanged', 'TextChangedI' }, {\n+    group = group,\n+    desc = 'Update active tabstops when buffer text changes',\n+    buffer = M.session.bufnr,\n+    callback = function()\n+      -- Sync the tabstops in the current group.\n+      local current_tabstop = M.session.current_tabstop\n+      local current_text = current_tabstop:get_text()\n+      for _, tabstop in ipairs(M.session.tabstops[current_tabstop.index]) do\n+        if tabstop.extmark_id ~= current_tabstop.extmark_id then\n+          tabstop:set_text(current_text)\n+        end\n+      end\n+    end,\n+  })\n+end\n+\n+--- Clears the snippet autocommand group.\n+---\n+--- @private\n+function M._clear_autocmds()\n+  pcall(vim.api.nvim_clear_autocmds, { group = snippet_group, buffer = M.session.bufnr })\n+end\n+\n+--- Expands the given snippet text.\n+---\n+--- @param input string\n+function M.expand(input)\n+  local snippet = G.parse(input)\n+  local snippet_text = {}\n+\n+  M.session = Session:init()\n+\n+  -- Keep track of tabstop nodes during expansion.\n+  --- @type table<integer, Range4[]>\n+  local tabstop_ranges = {}\n+\n+  --- @param index integer\n+  --- @param placeholder string?\n+  local function add_tabstop(index, placeholder)\n+    tabstop_ranges[index] = tabstop_ranges[index] or {}\n+    table.insert(tabstop_ranges[index], compute_tabstop_range(snippet_text, placeholder))\n+  end\n+\n+  for _, child in ipairs(snippet.data.children) do\n+    local type, data = child.type, child.data\n+    if type == G.NodeType.Tabstop then\n+      --- @cast data vim.snippet.TabstopData\n+      add_tabstop(data.tabstop)\n+    elseif type == G.NodeType.Placeholder then\n+      --- @cast data vim.snippet.PlaceholderData\n+      local value = tostring(data.value)\n+      add_tabstop(data.tabstop, value)\n+      append_to_snippet(snippet_text, value)\n+    elseif type == G.NodeType.Choice then\n+      --- @cast data vim.snippet.ChoiceData\n+      append_to_snippet(snippet_text, data.values[1])\n+    elseif type == G.NodeType.Variable then\n+      --- @cast data vim.snippet.VariableData\n+      -- Try to get the variable's value.\n+      local value = resolve_variable(data.name, data.default and tostring(data.default) or '')\n+      if not value then\n+        -- Unknown variable, make this a tabstop and use the variable name as a placeholder.\n+        value = data.name\n+        local tabstop_indexes = vim.tbl_keys(tabstop_ranges)\n+        local index = math.max(unpack((#tabstop_indexes == 0 and { 0 }) or tabstop_indexes)) + 1\n+        add_tabstop(index, value)\n+      end\n+      append_to_snippet(snippet_text, value)\n+    elseif type == G.NodeType.Text then\n+      --- @cast data vim.snippet.TextData\n+      append_to_snippet(snippet_text, data.text)\n+    end\n+  end\n+\n+  -- $0, which defaults to the end of the snippet, defines the final cursor position.\n+  -- Make sure the snippet has exactly one of these.\n+  if vim.tbl_contains(vim.tbl_keys(tabstop_ranges), 0) then\n+    assert(#tabstop_ranges[0] == 1, 'Snippet has multiple $0 tabstops')\n+  else\n+    add_tabstop(0)\n+  end\n+\n+  -- Insert the snippet text.\n+  local cursor_row, cursor_col = cursor_pos()\n+  vim.api.nvim_buf_set_text(\n+    M.session.bufnr,\n+    cursor_row,\n+    cursor_col,\n+    cursor_row,\n+    cursor_col,\n+    remove_newlines(snippet_text)\n+  )\n+\n+  -- Create the tabstop extmarks.\n+  for index, ranges in pairs(tabstop_ranges) do\n+    for _, range in ipairs(ranges) do\n+      M.session:add_tabstop(index, range)\n+    end\n+  end\n+\n+  -- Jump to the first tabstop.\n+  M.jump(1)\n+end\n+\n+--- @alias vim.snippet.Direction\n+--- | -1 # Previous\n+--- | 1 # Next\n+\n+--- Returns `true` if there is an active snippet which can be jumped in the given direction.\n+---\n+--- @param direction vim.snippet.Direction\n+--- @return boolean\n+function M.jumpable(direction)\n+  if not M.active() or M.session:get_num_tabstops() == 0 then\n+    return false\n+  end\n+\n+  if direction == -1 then\n+    return M.session.current_tabstop.index > 1\n+  else\n+    return M.session.current_tabstop.index < M.session:get_num_tabstops()\n+  end\n+end\n+\n+--- Jumps (if possible) within the active snippet in the given direction.\n+---\n+--- @param direction vim.snippet.Direction\n+function M.jump(direction)\n+  -- TODO: Not sure if we want to have this check or insist on the user to check `jumpable` first.\n+  if not M.jumpable(direction) then\n+    return\n+  end\n+\n+  -- Find the tabstop with the lowest range.\n+  local tabstops =\n+    M.session.tabstops[(M.session.current_tabstop.index + direction) % M.session:get_num_tabstops()]\n+  local dest = tabstops[1]\n+  for _, tabstop in ipairs(tabstops) do\n+    local dest_range, range = dest:get_range(), tabstop:get_range()\n+    if (range[1] < dest_range[1]) or (range[1] == dest_range[1] and range[2] < dest_range[2]) then\n+      dest = tabstop\n+    end\n+  end\n+\n+  -- Clear the autocommands so that we can move the cursor freely while selecting the tabstop.\n+  M._clear_autocmds()\n+\n+  M.session.current_tabstop = dest\n+  M._select_stop(dest)\n+\n+  -- Restore the autocommands.\n+  M._setup_autocmds()\n+end\n+\n+--- Returns `true` if there's an active snippet in the current buffer.\n+---\n+--- @return boolean\n+function M.active()\n+  return M.session ~= nil and M.session.bufnr == vim.api.nvim_get_current_buf()\n+end\n+\n+-- TODO: Use another name? discard? dispose? unlink? assassinate?\n+--- Cancels the current snippet.\n+function M.cancel()",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359203315",
            "id": 1359203315,
            "in_reply_to_id": 1359202974,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RA8vz",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 471,
            "original_position": 471,
            "original_start_line": 469,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1677850035,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359203315/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T06:42:24Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359203315",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359233952"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359233952"
                }
            },
            "author_association": "MEMBER",
            "body": "I think `@nodoc` is The Way, at the moment.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T08:08:57Z",
            "diff_hunk": "@@ -3670,4 +3670,87 @@ totable({f}, {...})                                       *vim.iter.totable()*\n     Return: ~\n         (table)\n \n+\n+==============================================================================\n+Lua module: vim.snippet                                          *vim.snippet*\n+\n+active()                                                    *snippet.active()*\n+    Returns `true` if there's an active snippet in the current buffer.\n+\n+    Return: ~\n+        (boolean)\n+\n+cancel()                                                    *snippet.cancel()*\n+    Cancels the current snippet.\n+\n+expand({input})                                             *snippet.expand()*\n+    Expands the given snippet text.\n+\n+    Parameters: ~\n+      • {input}  (string)\n+\n+jump({direction})                                             *snippet.jump()*\n+    Jumps (if possible) within the active snippet in the given direction.\n+\n+    Parameters: ~\n+      • {direction}  vim.snippet.Direction\n+\n+jumpable({direction})                                     *snippet.jumpable()*\n+    @alias vim.snippet.Direction | -1 # Previous | 1 # Next Returns `true` if\n+    there is an active snippet which can be jumped in the given direction.\n+\n+    Parameters: ~\n+      • {direction}  vim.snippet.Direction\n+\n+    Return: ~\n+        (boolean)\n+\n+new({index}, {bufnr}, {range})                                 *snippet.new()*",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359233952",
            "id": 1359233952,
            "in_reply_to_id": 1359068313,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RBEOg",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 3708,
            "original_position": 39,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1677892705,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 1,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359233952/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-14T08:08:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359233952",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359481290"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359481290"
                }
            },
            "author_association": "MEMBER",
            "body": "Maybe `remove_newlines` isn't the best name. I use this utility function to transform input like `foo\\n\\nbar` to `{ 'foo', '', 'bar' }`, since I rely on the number of snippet lines to compute the tabstop positions and to clean the input for `nvim_buf_set_text`.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T16:59:50Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359481290",
            "id": 1359481290,
            "in_reply_to_id": 1359200714,
            "line": 65,
            "node_id": "PRRC_kwDOAPphoM5RCAnK",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 65,
            "original_position": 65,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": 65,
            "pull_request_review_id": 1678227892,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359481290/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-14T16:59:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359481290",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359486968"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359486968"
                }
            },
            "author_association": "MEMBER",
            "body": "Your suspicion is correct :)",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T17:02:32Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359486968",
            "id": 1359486968,
            "in_reply_to_id": 1359201179,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RCB_4",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 126,
            "original_position": 126,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1678234698,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359486968/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-14T17:02:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359486968",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359490121"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359490121"
                }
            },
            "author_association": "MEMBER",
            "body": "I still prefer @clason's suggestion of `exit`. I feel like `reset` doesn't imply that the snippet will be discarded entirely, instead of just reinitialized or something.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T17:03:59Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop\n+\n+--- Creates a new tabstop.\n+---\n+--- @param index integer\n+--- @param bufnr integer\n+--- @param range Range4\n+--- @return vim.snippet.Tabstop\n+function Tabstop.new(index, bufnr, range)\n+  local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, snippet_ns, range[1], range[2], {\n+    right_gravity = false,\n+    end_right_gravity = true,\n+    end_line = range[3],\n+    end_col = range[4],\n+  })\n+\n+  local self = setmetatable(\n+    { index = index, bufnr = bufnr, extmark_id = extmark_id },\n+    { __index = Tabstop }\n+  )\n+\n+  return self\n+end\n+\n+--- Returns the tabstop's range.\n+---\n+--- @return Range4\n+function Tabstop:get_range()\n+  local mark =\n+    vim.api.nvim_buf_get_extmark_by_id(self.bufnr, snippet_ns, self.extmark_id, { details = true })\n+\n+  --- @diagnostic disable-next-line: undefined-field\n+  return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n+end\n+\n+--- Returns the text spanned by the tabstop.\n+---\n+--- @return string\n+function Tabstop:get_text()\n+  local range = self:get_range()\n+  local lines = vim.api.nvim_buf_get_lines(self.bufnr, range[1], range[3] + 1, false)\n+  lines[#lines] = lines[#lines]:sub(1, range[4])\n+  lines[1] = lines[1]:sub(range[2] + 1)\n+\n+  return table.concat(lines, '\\n')\n+end\n+\n+--- Sets the tabstop's text.\n+---\n+--- @param text string\n+function Tabstop:set_text(text)\n+  local range = self:get_range()\n+  vim.api.nvim_buf_set_text(\n+    self.bufnr,\n+    range[1],\n+    range[2],\n+    range[3],\n+    range[4],\n+    remove_newlines(text)\n+  )\n+end\n+\n+--- @class vim.snippet.Session\n+--- @field bufnr integer\n+--- @field tabstops table<integer, vim.snippet.Tabstop[]>\n+--- @field current_tabstop vim.snippet.Tabstop\n+local Session = {}\n+\n+--- Initializes a new snippet session in the current buffer.\n+---\n+--- @return vim.snippet.Session\n+function Session:init()\n+  self.bufnr = vim.api.nvim_get_current_buf()\n+  self.tabstops = {}\n+  self.current_tabstop = Tabstop.new(0, self.bufnr, { 0, 0, 0, 0 })\n+\n+  return self\n+end\n+\n+--- Returns the number of tabstop indexes in the snippet session.\n+---\n+--- @return integer\n+function Session:get_num_tabstops()\n+  return #vim.tbl_keys(self.tabstops)\n+end\n+\n+--- Adds a tabstop at the given index and spanning `range`.\n+---\n+--- @param index integer\n+--- @param range Range4\n+function Session:add_tabstop(index, range)\n+  self.tabstops[index] = self.tabstops[index] or {}\n+  table.insert(self.tabstops[index], Tabstop.new(index, self.bufnr, range))\n+end\n+\n+--- @class vim.snippet.Snippet\n+--- @field private session? vim.snippet.Session\n+local M = { session = nil }\n+\n+--- Select the given tabstop range.\n+---\n+--- @private\n+--- @param tabstop vim.snippet.Tabstop\n+function M._select_stop(tabstop)\n+  --- @param keys string\n+  local function feedkeys(keys)\n+    keys = vim.api.nvim_replace_termcodes(keys, true, false, true)\n+    vim.api.nvim_feedkeys(keys, 'n', true)\n+  end\n+\n+  --- @param row integer\n+  --- @param col integer\n+  local function move_cursor_to(row, col)\n+    local line = vim.fn.getline(row) --[[ @as string ]]\n+    col = math.max(vim.fn.strchars(line:sub(1, col)) - 1, 0)\n+    feedkeys(string.format('%sG0%s', row, string.rep('<Right>', col)))\n+  end\n+\n+  local range = tabstop:get_range()\n+\n+  -- Move the cursor to the start of the tabstop.\n+  vim.api.nvim_win_set_cursor(0, { range[1] + 1, range[2] })\n+\n+  -- For empty and the final tabstop, start insert mode at the end of the range.\n+  if tabstop.index == 0 or (range[1] == range[3] and range[2] == range[4]) then\n+    if vim.fn.mode() ~= 'i' then\n+      if vim.fn.mode() == 's' then\n+        feedkeys('<Esc>')\n+      end\n+      vim.cmd({ cmd = 'startinsert', bang = range[4] >= #vim.api.nvim_get_current_line() })\n+    end\n+  else\n+    -- Else, select the tabstop's text.\n+    if vim.fn.mode() ~= 'n' then\n+      feedkeys('<Esc>')\n+    end\n+    move_cursor_to(range[1] + 1, range[2] + 1)\n+    feedkeys('v')\n+    move_cursor_to(range[3] + 1, range[4])\n+    feedkeys('o<c-g>')\n+  end\n+end\n+\n+--- Sets up the necessary autocommands for snippet expansion.\n+---\n+--- @private\n+function M._setup_autocmds()\n+  local group = vim.api.nvim_create_augroup(snippet_group, {})\n+\n+  vim.api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, {\n+    group = group,\n+    desc = 'Update snippet state when the cursor moves',\n+    buffer = M.session.bufnr,\n+    callback = function()\n+      -- Just update the tabstop in insert and select modes.\n+      if not vim.fn.mode():match('^[isS]') then\n+        return\n+      end\n+\n+      -- Update the current tabstop to be the one containing the cursor.\n+      local cursor_row, cursor_col = cursor_pos()\n+      for tabstop_index, tabstops in pairs(M.session.tabstops) do\n+        for _, tabstop in ipairs(tabstops) do\n+          local range = tabstop:get_range()\n+          if\n+            (cursor_row > range[1] or (cursor_row == range[1] and cursor_col >= range[2]))\n+            and (cursor_row < range[3] or (cursor_row == range[3] and cursor_col <= range[4]))\n+          then\n+            M.session.current_tabstop = tabstop\n+            if tabstop_index ~= 0 then\n+              return\n+            end\n+          end\n+        end\n+      end\n+\n+      -- The cursor is either not on a tabstop or we reached the end, so cancel the session.\n+      M.cancel()\n+    end,\n+  })\n+\n+  vim.api.nvim_create_autocmd({ 'TextChanged', 'TextChangedI' }, {\n+    group = group,\n+    desc = 'Update active tabstops when buffer text changes',\n+    buffer = M.session.bufnr,\n+    callback = function()\n+      -- Sync the tabstops in the current group.\n+      local current_tabstop = M.session.current_tabstop\n+      local current_text = current_tabstop:get_text()\n+      for _, tabstop in ipairs(M.session.tabstops[current_tabstop.index]) do\n+        if tabstop.extmark_id ~= current_tabstop.extmark_id then\n+          tabstop:set_text(current_text)\n+        end\n+      end\n+    end,\n+  })\n+end\n+\n+--- Clears the snippet autocommand group.\n+---\n+--- @private\n+function M._clear_autocmds()\n+  pcall(vim.api.nvim_clear_autocmds, { group = snippet_group, buffer = M.session.bufnr })\n+end\n+\n+--- Expands the given snippet text.\n+---\n+--- @param input string\n+function M.expand(input)\n+  local snippet = G.parse(input)\n+  local snippet_text = {}\n+\n+  M.session = Session:init()\n+\n+  -- Keep track of tabstop nodes during expansion.\n+  --- @type table<integer, Range4[]>\n+  local tabstop_ranges = {}\n+\n+  --- @param index integer\n+  --- @param placeholder string?\n+  local function add_tabstop(index, placeholder)\n+    tabstop_ranges[index] = tabstop_ranges[index] or {}\n+    table.insert(tabstop_ranges[index], compute_tabstop_range(snippet_text, placeholder))\n+  end\n+\n+  for _, child in ipairs(snippet.data.children) do\n+    local type, data = child.type, child.data\n+    if type == G.NodeType.Tabstop then\n+      --- @cast data vim.snippet.TabstopData\n+      add_tabstop(data.tabstop)\n+    elseif type == G.NodeType.Placeholder then\n+      --- @cast data vim.snippet.PlaceholderData\n+      local value = tostring(data.value)\n+      add_tabstop(data.tabstop, value)\n+      append_to_snippet(snippet_text, value)\n+    elseif type == G.NodeType.Choice then\n+      --- @cast data vim.snippet.ChoiceData\n+      append_to_snippet(snippet_text, data.values[1])\n+    elseif type == G.NodeType.Variable then\n+      --- @cast data vim.snippet.VariableData\n+      -- Try to get the variable's value.\n+      local value = resolve_variable(data.name, data.default and tostring(data.default) or '')\n+      if not value then\n+        -- Unknown variable, make this a tabstop and use the variable name as a placeholder.\n+        value = data.name\n+        local tabstop_indexes = vim.tbl_keys(tabstop_ranges)\n+        local index = math.max(unpack((#tabstop_indexes == 0 and { 0 }) or tabstop_indexes)) + 1\n+        add_tabstop(index, value)\n+      end\n+      append_to_snippet(snippet_text, value)\n+    elseif type == G.NodeType.Text then\n+      --- @cast data vim.snippet.TextData\n+      append_to_snippet(snippet_text, data.text)\n+    end\n+  end\n+\n+  -- $0, which defaults to the end of the snippet, defines the final cursor position.\n+  -- Make sure the snippet has exactly one of these.\n+  if vim.tbl_contains(vim.tbl_keys(tabstop_ranges), 0) then\n+    assert(#tabstop_ranges[0] == 1, 'Snippet has multiple $0 tabstops')\n+  else\n+    add_tabstop(0)\n+  end\n+\n+  -- Insert the snippet text.\n+  local cursor_row, cursor_col = cursor_pos()\n+  vim.api.nvim_buf_set_text(\n+    M.session.bufnr,\n+    cursor_row,\n+    cursor_col,\n+    cursor_row,\n+    cursor_col,\n+    remove_newlines(snippet_text)\n+  )\n+\n+  -- Create the tabstop extmarks.\n+  for index, ranges in pairs(tabstop_ranges) do\n+    for _, range in ipairs(ranges) do\n+      M.session:add_tabstop(index, range)\n+    end\n+  end\n+\n+  -- Jump to the first tabstop.\n+  M.jump(1)\n+end\n+\n+--- @alias vim.snippet.Direction\n+--- | -1 # Previous\n+--- | 1 # Next\n+\n+--- Returns `true` if there is an active snippet which can be jumped in the given direction.\n+---\n+--- @param direction vim.snippet.Direction\n+--- @return boolean\n+function M.jumpable(direction)\n+  if not M.active() or M.session:get_num_tabstops() == 0 then\n+    return false\n+  end\n+\n+  if direction == -1 then\n+    return M.session.current_tabstop.index > 1\n+  else\n+    return M.session.current_tabstop.index < M.session:get_num_tabstops()\n+  end\n+end\n+\n+--- Jumps (if possible) within the active snippet in the given direction.\n+---\n+--- @param direction vim.snippet.Direction\n+function M.jump(direction)\n+  -- TODO: Not sure if we want to have this check or insist on the user to check `jumpable` first.\n+  if not M.jumpable(direction) then\n+    return\n+  end\n+\n+  -- Find the tabstop with the lowest range.\n+  local tabstops =\n+    M.session.tabstops[(M.session.current_tabstop.index + direction) % M.session:get_num_tabstops()]\n+  local dest = tabstops[1]\n+  for _, tabstop in ipairs(tabstops) do\n+    local dest_range, range = dest:get_range(), tabstop:get_range()\n+    if (range[1] < dest_range[1]) or (range[1] == dest_range[1] and range[2] < dest_range[2]) then\n+      dest = tabstop\n+    end\n+  end\n+\n+  -- Clear the autocommands so that we can move the cursor freely while selecting the tabstop.\n+  M._clear_autocmds()\n+\n+  M.session.current_tabstop = dest\n+  M._select_stop(dest)\n+\n+  -- Restore the autocommands.\n+  M._setup_autocmds()\n+end\n+\n+--- Returns `true` if there's an active snippet in the current buffer.\n+---\n+--- @return boolean\n+function M.active()\n+  return M.session ~= nil and M.session.bufnr == vim.api.nvim_get_current_buf()\n+end\n+\n+-- TODO: Use another name? discard? dispose? unlink? assassinate?\n+--- Cancels the current snippet.\n+function M.cancel()",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359490121",
            "id": 1359490121,
            "in_reply_to_id": 1359202974,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RCCxJ",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 471,
            "original_position": 471,
            "original_start_line": 469,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1678239105,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359490121/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T17:03:59Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359490121",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359491392"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359491392"
                }
            },
            "author_association": "MEMBER",
            "body": "Neh. I think it makes sense to keep it.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T17:04:38Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop\n+\n+--- Creates a new tabstop.\n+---\n+--- @param index integer\n+--- @param bufnr integer\n+--- @param range Range4\n+--- @return vim.snippet.Tabstop\n+function Tabstop.new(index, bufnr, range)\n+  local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, snippet_ns, range[1], range[2], {\n+    right_gravity = false,\n+    end_right_gravity = true,\n+    end_line = range[3],\n+    end_col = range[4],\n+  })\n+\n+  local self = setmetatable(\n+    { index = index, bufnr = bufnr, extmark_id = extmark_id },\n+    { __index = Tabstop }\n+  )\n+\n+  return self\n+end\n+\n+--- Returns the tabstop's range.\n+---\n+--- @return Range4\n+function Tabstop:get_range()\n+  local mark =\n+    vim.api.nvim_buf_get_extmark_by_id(self.bufnr, snippet_ns, self.extmark_id, { details = true })\n+\n+  --- @diagnostic disable-next-line: undefined-field\n+  return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n+end\n+\n+--- Returns the text spanned by the tabstop.\n+---\n+--- @return string\n+function Tabstop:get_text()\n+  local range = self:get_range()\n+  local lines = vim.api.nvim_buf_get_lines(self.bufnr, range[1], range[3] + 1, false)\n+  lines[#lines] = lines[#lines]:sub(1, range[4])\n+  lines[1] = lines[1]:sub(range[2] + 1)\n+\n+  return table.concat(lines, '\\n')\n+end\n+\n+--- Sets the tabstop's text.\n+---\n+--- @param text string\n+function Tabstop:set_text(text)\n+  local range = self:get_range()\n+  vim.api.nvim_buf_set_text(\n+    self.bufnr,\n+    range[1],\n+    range[2],\n+    range[3],\n+    range[4],\n+    remove_newlines(text)\n+  )\n+end\n+\n+--- @class vim.snippet.Session\n+--- @field bufnr integer\n+--- @field tabstops table<integer, vim.snippet.Tabstop[]>\n+--- @field current_tabstop vim.snippet.Tabstop\n+local Session = {}\n+\n+--- Initializes a new snippet session in the current buffer.\n+---\n+--- @return vim.snippet.Session\n+function Session:init()\n+  self.bufnr = vim.api.nvim_get_current_buf()\n+  self.tabstops = {}\n+  self.current_tabstop = Tabstop.new(0, self.bufnr, { 0, 0, 0, 0 })\n+\n+  return self\n+end\n+\n+--- Returns the number of tabstop indexes in the snippet session.\n+---\n+--- @return integer\n+function Session:get_num_tabstops()\n+  return #vim.tbl_keys(self.tabstops)\n+end\n+\n+--- Adds a tabstop at the given index and spanning `range`.\n+---\n+--- @param index integer\n+--- @param range Range4\n+function Session:add_tabstop(index, range)\n+  self.tabstops[index] = self.tabstops[index] or {}\n+  table.insert(self.tabstops[index], Tabstop.new(index, self.bufnr, range))\n+end\n+\n+--- @class vim.snippet.Snippet\n+--- @field private session? vim.snippet.Session\n+local M = { session = nil }\n+\n+--- Select the given tabstop range.\n+---\n+--- @private\n+--- @param tabstop vim.snippet.Tabstop\n+function M._select_stop(tabstop)\n+  --- @param keys string\n+  local function feedkeys(keys)\n+    keys = vim.api.nvim_replace_termcodes(keys, true, false, true)\n+    vim.api.nvim_feedkeys(keys, 'n', true)\n+  end\n+\n+  --- @param row integer\n+  --- @param col integer\n+  local function move_cursor_to(row, col)\n+    local line = vim.fn.getline(row) --[[ @as string ]]\n+    col = math.max(vim.fn.strchars(line:sub(1, col)) - 1, 0)\n+    feedkeys(string.format('%sG0%s', row, string.rep('<Right>', col)))\n+  end\n+\n+  local range = tabstop:get_range()\n+\n+  -- Move the cursor to the start of the tabstop.\n+  vim.api.nvim_win_set_cursor(0, { range[1] + 1, range[2] })\n+\n+  -- For empty and the final tabstop, start insert mode at the end of the range.\n+  if tabstop.index == 0 or (range[1] == range[3] and range[2] == range[4]) then\n+    if vim.fn.mode() ~= 'i' then\n+      if vim.fn.mode() == 's' then\n+        feedkeys('<Esc>')\n+      end\n+      vim.cmd({ cmd = 'startinsert', bang = range[4] >= #vim.api.nvim_get_current_line() })\n+    end\n+  else\n+    -- Else, select the tabstop's text.\n+    if vim.fn.mode() ~= 'n' then\n+      feedkeys('<Esc>')\n+    end\n+    move_cursor_to(range[1] + 1, range[2] + 1)\n+    feedkeys('v')\n+    move_cursor_to(range[3] + 1, range[4])\n+    feedkeys('o<c-g>')\n+  end\n+end\n+\n+--- Sets up the necessary autocommands for snippet expansion.\n+---\n+--- @private\n+function M._setup_autocmds()\n+  local group = vim.api.nvim_create_augroup(snippet_group, {})\n+\n+  vim.api.nvim_create_autocmd({ 'CursorMoved', 'CursorMovedI' }, {\n+    group = group,\n+    desc = 'Update snippet state when the cursor moves',\n+    buffer = M.session.bufnr,\n+    callback = function()\n+      -- Just update the tabstop in insert and select modes.\n+      if not vim.fn.mode():match('^[isS]') then\n+        return\n+      end\n+\n+      -- Update the current tabstop to be the one containing the cursor.\n+      local cursor_row, cursor_col = cursor_pos()\n+      for tabstop_index, tabstops in pairs(M.session.tabstops) do\n+        for _, tabstop in ipairs(tabstops) do\n+          local range = tabstop:get_range()\n+          if\n+            (cursor_row > range[1] or (cursor_row == range[1] and cursor_col >= range[2]))\n+            and (cursor_row < range[3] or (cursor_row == range[3] and cursor_col <= range[4]))\n+          then\n+            M.session.current_tabstop = tabstop\n+            if tabstop_index ~= 0 then\n+              return\n+            end\n+          end\n+        end\n+      end\n+\n+      -- The cursor is either not on a tabstop or we reached the end, so cancel the session.\n+      M.cancel()\n+    end,\n+  })\n+\n+  vim.api.nvim_create_autocmd({ 'TextChanged', 'TextChangedI' }, {\n+    group = group,\n+    desc = 'Update active tabstops when buffer text changes',\n+    buffer = M.session.bufnr,\n+    callback = function()\n+      -- Sync the tabstops in the current group.\n+      local current_tabstop = M.session.current_tabstop\n+      local current_text = current_tabstop:get_text()\n+      for _, tabstop in ipairs(M.session.tabstops[current_tabstop.index]) do\n+        if tabstop.extmark_id ~= current_tabstop.extmark_id then\n+          tabstop:set_text(current_text)\n+        end\n+      end\n+    end,\n+  })\n+end\n+\n+--- Clears the snippet autocommand group.\n+---\n+--- @private\n+function M._clear_autocmds()\n+  pcall(vim.api.nvim_clear_autocmds, { group = snippet_group, buffer = M.session.bufnr })\n+end\n+\n+--- Expands the given snippet text.\n+---\n+--- @param input string\n+function M.expand(input)\n+  local snippet = G.parse(input)\n+  local snippet_text = {}\n+\n+  M.session = Session:init()\n+\n+  -- Keep track of tabstop nodes during expansion.\n+  --- @type table<integer, Range4[]>\n+  local tabstop_ranges = {}\n+\n+  --- @param index integer\n+  --- @param placeholder string?\n+  local function add_tabstop(index, placeholder)\n+    tabstop_ranges[index] = tabstop_ranges[index] or {}\n+    table.insert(tabstop_ranges[index], compute_tabstop_range(snippet_text, placeholder))\n+  end\n+\n+  for _, child in ipairs(snippet.data.children) do\n+    local type, data = child.type, child.data\n+    if type == G.NodeType.Tabstop then\n+      --- @cast data vim.snippet.TabstopData\n+      add_tabstop(data.tabstop)\n+    elseif type == G.NodeType.Placeholder then\n+      --- @cast data vim.snippet.PlaceholderData\n+      local value = tostring(data.value)\n+      add_tabstop(data.tabstop, value)\n+      append_to_snippet(snippet_text, value)\n+    elseif type == G.NodeType.Choice then\n+      --- @cast data vim.snippet.ChoiceData\n+      append_to_snippet(snippet_text, data.values[1])\n+    elseif type == G.NodeType.Variable then\n+      --- @cast data vim.snippet.VariableData\n+      -- Try to get the variable's value.\n+      local value = resolve_variable(data.name, data.default and tostring(data.default) or '')\n+      if not value then\n+        -- Unknown variable, make this a tabstop and use the variable name as a placeholder.\n+        value = data.name\n+        local tabstop_indexes = vim.tbl_keys(tabstop_ranges)\n+        local index = math.max(unpack((#tabstop_indexes == 0 and { 0 }) or tabstop_indexes)) + 1\n+        add_tabstop(index, value)\n+      end\n+      append_to_snippet(snippet_text, value)\n+    elseif type == G.NodeType.Text then\n+      --- @cast data vim.snippet.TextData\n+      append_to_snippet(snippet_text, data.text)\n+    end\n+  end\n+\n+  -- $0, which defaults to the end of the snippet, defines the final cursor position.\n+  -- Make sure the snippet has exactly one of these.\n+  if vim.tbl_contains(vim.tbl_keys(tabstop_ranges), 0) then\n+    assert(#tabstop_ranges[0] == 1, 'Snippet has multiple $0 tabstops')\n+  else\n+    add_tabstop(0)\n+  end\n+\n+  -- Insert the snippet text.\n+  local cursor_row, cursor_col = cursor_pos()\n+  vim.api.nvim_buf_set_text(\n+    M.session.bufnr,\n+    cursor_row,\n+    cursor_col,\n+    cursor_row,\n+    cursor_col,\n+    remove_newlines(snippet_text)\n+  )\n+\n+  -- Create the tabstop extmarks.\n+  for index, ranges in pairs(tabstop_ranges) do\n+    for _, range in ipairs(ranges) do\n+      M.session:add_tabstop(index, range)\n+    end\n+  end\n+\n+  -- Jump to the first tabstop.\n+  M.jump(1)\n+end\n+\n+--- @alias vim.snippet.Direction\n+--- | -1 # Previous\n+--- | 1 # Next\n+\n+--- Returns `true` if there is an active snippet which can be jumped in the given direction.\n+---\n+--- @param direction vim.snippet.Direction\n+--- @return boolean\n+function M.jumpable(direction)\n+  if not M.active() or M.session:get_num_tabstops() == 0 then\n+    return false\n+  end\n+\n+  if direction == -1 then\n+    return M.session.current_tabstop.index > 1\n+  else\n+    return M.session.current_tabstop.index < M.session:get_num_tabstops()\n+  end\n+end\n+\n+--- Jumps (if possible) within the active snippet in the given direction.\n+---\n+--- @param direction vim.snippet.Direction\n+function M.jump(direction)\n+  -- TODO: Not sure if we want to have this check or insist on the user to check `jumpable` first.\n+  if not M.jumpable(direction) then\n+    return\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359491392",
            "id": 1359491392,
            "in_reply_to_id": 1359202827,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RCDFA",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 434,
            "original_position": 439,
            "original_start_line": 436,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1678240821,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359491392/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T17:04:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359491392",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359493410"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359493410"
                }
            },
            "author_association": "MEMBER",
            "body": "It would.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T17:15:57Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop\n+\n+--- Creates a new tabstop.\n+---\n+--- @param index integer\n+--- @param bufnr integer\n+--- @param range Range4\n+--- @return vim.snippet.Tabstop\n+function Tabstop.new(index, bufnr, range)\n+  local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, snippet_ns, range[1], range[2], {\n+    right_gravity = false,\n+    end_right_gravity = true,\n+    end_line = range[3],\n+    end_col = range[4],\n+  })\n+\n+  local self = setmetatable(\n+    { index = index, bufnr = bufnr, extmark_id = extmark_id },\n+    { __index = Tabstop }\n+  )\n+\n+  return self\n+end\n+\n+--- Returns the tabstop's range.\n+---\n+--- @return Range4\n+function Tabstop:get_range()\n+  local mark =\n+    vim.api.nvim_buf_get_extmark_by_id(self.bufnr, snippet_ns, self.extmark_id, { details = true })\n+\n+  --- @diagnostic disable-next-line: undefined-field\n+  return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n+end\n+\n+--- Returns the text spanned by the tabstop.\n+---\n+--- @return string\n+function Tabstop:get_text()\n+  local range = self:get_range()\n+  local lines = vim.api.nvim_buf_get_lines(self.bufnr, range[1], range[3] + 1, false)\n+  lines[#lines] = lines[#lines]:sub(1, range[4])\n+  lines[1] = lines[1]:sub(range[2] + 1)",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359493410",
            "id": 1359493410,
            "in_reply_to_id": 1359201357,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RCDki",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 168,
            "original_position": 168,
            "original_start_line": 166,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1678243326,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359493410/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T17:15:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359493410",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359494255"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359494255"
                }
            },
            "author_association": "MEMBER",
            "body": "Yeah I think I'll just get rid of the `Session` class and move it's functionality to `M` as private bits.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T17:19:57Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop\n+\n+--- Creates a new tabstop.\n+---\n+--- @param index integer\n+--- @param bufnr integer\n+--- @param range Range4\n+--- @return vim.snippet.Tabstop\n+function Tabstop.new(index, bufnr, range)\n+  local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, snippet_ns, range[1], range[2], {\n+    right_gravity = false,\n+    end_right_gravity = true,\n+    end_line = range[3],\n+    end_col = range[4],\n+  })\n+\n+  local self = setmetatable(\n+    { index = index, bufnr = bufnr, extmark_id = extmark_id },\n+    { __index = Tabstop }\n+  )\n+\n+  return self\n+end\n+\n+--- Returns the tabstop's range.\n+---\n+--- @return Range4\n+function Tabstop:get_range()\n+  local mark =\n+    vim.api.nvim_buf_get_extmark_by_id(self.bufnr, snippet_ns, self.extmark_id, { details = true })\n+\n+  --- @diagnostic disable-next-line: undefined-field\n+  return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n+end\n+\n+--- Returns the text spanned by the tabstop.\n+---\n+--- @return string\n+function Tabstop:get_text()\n+  local range = self:get_range()\n+  local lines = vim.api.nvim_buf_get_lines(self.bufnr, range[1], range[3] + 1, false)\n+  lines[#lines] = lines[#lines]:sub(1, range[4])\n+  lines[1] = lines[1]:sub(range[2] + 1)\n+\n+  return table.concat(lines, '\\n')\n+end\n+\n+--- Sets the tabstop's text.\n+---\n+--- @param text string\n+function Tabstop:set_text(text)\n+  local range = self:get_range()\n+  vim.api.nvim_buf_set_text(\n+    self.bufnr,\n+    range[1],\n+    range[2],\n+    range[3],\n+    range[4],\n+    remove_newlines(text)\n+  )\n+end\n+\n+--- @class vim.snippet.Session\n+--- @field bufnr integer\n+--- @field tabstops table<integer, vim.snippet.Tabstop[]>\n+--- @field current_tabstop vim.snippet.Tabstop\n+local Session = {}\n+\n+--- Initializes a new snippet session in the current buffer.\n+---\n+--- @return vim.snippet.Session\n+function Session:init()\n+  self.bufnr = vim.api.nvim_get_current_buf()\n+  self.tabstops = {}\n+  self.current_tabstop = Tabstop.new(0, self.bufnr, { 0, 0, 0, 0 })\n+\n+  return self\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359494255",
            "id": 1359494255,
            "in_reply_to_id": 1359202067,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RCDxv",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 202,
            "original_position": 203,
            "original_start_line": 197,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1678244349,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359494255/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T17:19:57Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359494255",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359494552"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359494552"
                }
            },
            "author_association": "MEMBER",
            "body": "One thing to keep in mind is that we may want to allow plugins to hook into the \"expand and jump\" functionality -- maybe creating a Session would be one way?",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T17:21:43Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop\n+\n+--- Creates a new tabstop.\n+---\n+--- @param index integer\n+--- @param bufnr integer\n+--- @param range Range4\n+--- @return vim.snippet.Tabstop\n+function Tabstop.new(index, bufnr, range)\n+  local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, snippet_ns, range[1], range[2], {\n+    right_gravity = false,\n+    end_right_gravity = true,\n+    end_line = range[3],\n+    end_col = range[4],\n+  })\n+\n+  local self = setmetatable(\n+    { index = index, bufnr = bufnr, extmark_id = extmark_id },\n+    { __index = Tabstop }\n+  )\n+\n+  return self\n+end\n+\n+--- Returns the tabstop's range.\n+---\n+--- @return Range4\n+function Tabstop:get_range()\n+  local mark =\n+    vim.api.nvim_buf_get_extmark_by_id(self.bufnr, snippet_ns, self.extmark_id, { details = true })\n+\n+  --- @diagnostic disable-next-line: undefined-field\n+  return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n+end\n+\n+--- Returns the text spanned by the tabstop.\n+---\n+--- @return string\n+function Tabstop:get_text()\n+  local range = self:get_range()\n+  local lines = vim.api.nvim_buf_get_lines(self.bufnr, range[1], range[3] + 1, false)\n+  lines[#lines] = lines[#lines]:sub(1, range[4])\n+  lines[1] = lines[1]:sub(range[2] + 1)\n+\n+  return table.concat(lines, '\\n')\n+end\n+\n+--- Sets the tabstop's text.\n+---\n+--- @param text string\n+function Tabstop:set_text(text)\n+  local range = self:get_range()\n+  vim.api.nvim_buf_set_text(\n+    self.bufnr,\n+    range[1],\n+    range[2],\n+    range[3],\n+    range[4],\n+    remove_newlines(text)\n+  )\n+end\n+\n+--- @class vim.snippet.Session\n+--- @field bufnr integer\n+--- @field tabstops table<integer, vim.snippet.Tabstop[]>\n+--- @field current_tabstop vim.snippet.Tabstop\n+local Session = {}\n+\n+--- Initializes a new snippet session in the current buffer.\n+---\n+--- @return vim.snippet.Session\n+function Session:init()\n+  self.bufnr = vim.api.nvim_get_current_buf()\n+  self.tabstops = {}\n+  self.current_tabstop = Tabstop.new(0, self.bufnr, { 0, 0, 0, 0 })\n+\n+  return self\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359494552",
            "id": 1359494552,
            "in_reply_to_id": 1359202067,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RCD2Y",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 202,
            "original_position": 203,
            "original_start_line": 197,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1678244738,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359494552/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T17:21:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359494552",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359494993"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359494993"
                }
            },
            "author_association": "MEMBER",
            "body": "That's a good point, it does allow for better extensibility in the future. I'll create session instances instead then.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T17:23:36Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop\n+\n+--- Creates a new tabstop.\n+---\n+--- @param index integer\n+--- @param bufnr integer\n+--- @param range Range4\n+--- @return vim.snippet.Tabstop\n+function Tabstop.new(index, bufnr, range)\n+  local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, snippet_ns, range[1], range[2], {\n+    right_gravity = false,\n+    end_right_gravity = true,\n+    end_line = range[3],\n+    end_col = range[4],\n+  })\n+\n+  local self = setmetatable(\n+    { index = index, bufnr = bufnr, extmark_id = extmark_id },\n+    { __index = Tabstop }\n+  )\n+\n+  return self\n+end\n+\n+--- Returns the tabstop's range.\n+---\n+--- @return Range4\n+function Tabstop:get_range()\n+  local mark =\n+    vim.api.nvim_buf_get_extmark_by_id(self.bufnr, snippet_ns, self.extmark_id, { details = true })\n+\n+  --- @diagnostic disable-next-line: undefined-field\n+  return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n+end\n+\n+--- Returns the text spanned by the tabstop.\n+---\n+--- @return string\n+function Tabstop:get_text()\n+  local range = self:get_range()\n+  local lines = vim.api.nvim_buf_get_lines(self.bufnr, range[1], range[3] + 1, false)\n+  lines[#lines] = lines[#lines]:sub(1, range[4])\n+  lines[1] = lines[1]:sub(range[2] + 1)\n+\n+  return table.concat(lines, '\\n')\n+end\n+\n+--- Sets the tabstop's text.\n+---\n+--- @param text string\n+function Tabstop:set_text(text)\n+  local range = self:get_range()\n+  vim.api.nvim_buf_set_text(\n+    self.bufnr,\n+    range[1],\n+    range[2],\n+    range[3],\n+    range[4],\n+    remove_newlines(text)\n+  )\n+end\n+\n+--- @class vim.snippet.Session\n+--- @field bufnr integer\n+--- @field tabstops table<integer, vim.snippet.Tabstop[]>\n+--- @field current_tabstop vim.snippet.Tabstop\n+local Session = {}\n+\n+--- Initializes a new snippet session in the current buffer.\n+---\n+--- @return vim.snippet.Session\n+function Session:init()\n+  self.bufnr = vim.api.nvim_get_current_buf()\n+  self.tabstops = {}\n+  self.current_tabstop = Tabstop.new(0, self.bufnr, { 0, 0, 0, 0 })\n+\n+  return self\n+end",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359494993",
            "id": 1359494993,
            "in_reply_to_id": 1359202067,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5RCD9R",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 202,
            "original_position": 203,
            "original_start_line": 197,
            "path": "runtime/lua/vim/snippet.lua",
            "position": null,
            "pull_request_review_id": 1678245423,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359494993/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T17:23:36Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359494993",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359495693"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359495693"
                }
            },
            "author_association": "MEMBER",
            "body": "Maybe just `lines` then? ",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T17:27:41Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359495693",
            "id": 1359495693,
            "in_reply_to_id": 1359200714,
            "line": 65,
            "node_id": "PRRC_kwDOAPphoM5RCEIN",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 65,
            "original_position": 65,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": 65,
            "pull_request_review_id": 1678246408,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359495693/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-14T17:27:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359495693",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359500711"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359500711"
                }
            },
            "author_association": "MEMBER",
            "body": "Good question. I initially tried that but for some reason that causes the cursor to end up at the end of the selection instead of the beginning. I used [`nvim-snippy`](https://github.com/dcampos/nvim-snippy/blob/5787f088c99c04309a8aa6363fd3ac9a5a26b780/lua/snippy/main.lua#L39-L53) as a reference to handle tabstop selection and this logic is taken from there.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T17:41:44Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop\n+\n+--- Creates a new tabstop.\n+---\n+--- @param index integer\n+--- @param bufnr integer\n+--- @param range Range4\n+--- @return vim.snippet.Tabstop\n+function Tabstop.new(index, bufnr, range)\n+  local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, snippet_ns, range[1], range[2], {\n+    right_gravity = false,\n+    end_right_gravity = true,\n+    end_line = range[3],\n+    end_col = range[4],\n+  })\n+\n+  local self = setmetatable(\n+    { index = index, bufnr = bufnr, extmark_id = extmark_id },\n+    { __index = Tabstop }\n+  )\n+\n+  return self\n+end\n+\n+--- Returns the tabstop's range.\n+---\n+--- @return Range4\n+function Tabstop:get_range()\n+  local mark =\n+    vim.api.nvim_buf_get_extmark_by_id(self.bufnr, snippet_ns, self.extmark_id, { details = true })\n+\n+  --- @diagnostic disable-next-line: undefined-field\n+  return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n+end\n+\n+--- Returns the text spanned by the tabstop.\n+---\n+--- @return string\n+function Tabstop:get_text()\n+  local range = self:get_range()\n+  local lines = vim.api.nvim_buf_get_lines(self.bufnr, range[1], range[3] + 1, false)\n+  lines[#lines] = lines[#lines]:sub(1, range[4])\n+  lines[1] = lines[1]:sub(range[2] + 1)\n+\n+  return table.concat(lines, '\\n')\n+end\n+\n+--- Sets the tabstop's text.\n+---\n+--- @param text string\n+function Tabstop:set_text(text)\n+  local range = self:get_range()\n+  vim.api.nvim_buf_set_text(\n+    self.bufnr,\n+    range[1],\n+    range[2],\n+    range[3],\n+    range[4],\n+    remove_newlines(text)\n+  )\n+end\n+\n+--- @class vim.snippet.Session\n+--- @field bufnr integer\n+--- @field tabstops table<integer, vim.snippet.Tabstop[]>\n+--- @field current_tabstop vim.snippet.Tabstop\n+local Session = {}\n+\n+--- Initializes a new snippet session in the current buffer.\n+---\n+--- @return vim.snippet.Session\n+function Session:init()\n+  self.bufnr = vim.api.nvim_get_current_buf()\n+  self.tabstops = {}\n+  self.current_tabstop = Tabstop.new(0, self.bufnr, { 0, 0, 0, 0 })\n+\n+  return self\n+end\n+\n+--- Returns the number of tabstop indexes in the snippet session.\n+---\n+--- @return integer\n+function Session:get_num_tabstops()\n+  return #vim.tbl_keys(self.tabstops)\n+end\n+\n+--- Adds a tabstop at the given index and spanning `range`.\n+---\n+--- @param index integer\n+--- @param range Range4\n+function Session:add_tabstop(index, range)\n+  self.tabstops[index] = self.tabstops[index] or {}\n+  table.insert(self.tabstops[index], Tabstop.new(index, self.bufnr, range))\n+end\n+\n+--- @class vim.snippet.Snippet\n+--- @field private session? vim.snippet.Session\n+local M = { session = nil }\n+\n+--- Select the given tabstop range.\n+---\n+--- @private\n+--- @param tabstop vim.snippet.Tabstop\n+function M._select_stop(tabstop)\n+  --- @param keys string\n+  local function feedkeys(keys)\n+    keys = vim.api.nvim_replace_termcodes(keys, true, false, true)\n+    vim.api.nvim_feedkeys(keys, 'n', true)\n+  end\n+\n+  --- @param row integer\n+  --- @param col integer\n+  local function move_cursor_to(row, col)\n+    local line = vim.fn.getline(row) --[[ @as string ]]\n+    col = math.max(vim.fn.strchars(line:sub(1, col)) - 1, 0)\n+    feedkeys(string.format('%sG0%s', row, string.rep('<Right>', col)))\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359500711",
            "id": 1359500711,
            "in_reply_to_id": 1359202510,
            "line": 236,
            "node_id": "PRRC_kwDOAPphoM5RCFWn",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 236,
            "original_position": 242,
            "original_start_line": 238,
            "path": "runtime/lua/vim/snippet.lua",
            "position": 236,
            "pull_request_review_id": 1678254982,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359500711/reactions"
            },
            "side": "RIGHT",
            "start_line": 232,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T17:41:45Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359500711",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359504982"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359504982"
                }
            },
            "author_association": "MEMBER",
            "body": "I'll name it `text_to_lines`. `lines` feels to variable-y.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T17:47:06Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359504982",
            "id": 1359504982,
            "in_reply_to_id": 1359200714,
            "line": 65,
            "node_id": "PRRC_kwDOAPphoM5RCGZW",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 65,
            "original_position": 65,
            "original_start_line": null,
            "path": "runtime/lua/vim/snippet.lua",
            "position": 65,
            "pull_request_review_id": 1678260388,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359504982/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-14T17:47:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359504982",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359638941"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359638941"
                }
            },
            "author_association": "MEMBER",
            "body": "I mentioned this in its own bullet instead of putting it under LSP, but lemme know if you want to change that.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T20:35:38Z",
            "diff_hunk": "@@ -189,6 +189,8 @@ The following new APIs and features were added.\n \n • Added |:fclose| command.\n \n+• Added |vim.snippet| for snippet expansion support.",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359638941",
            "id": 1359638941,
            "line": 192,
            "node_id": "PRRC_kwDOAPphoM5RCnGd",
            "original_commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "original_line": 192,
            "original_position": 4,
            "original_start_line": null,
            "path": "runtime/doc/news.txt",
            "position": 4,
            "pull_request_review_id": 1678459440,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359638941/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-10-14T20:35:38Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359638941",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/25301#discussion_r1359639038"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/25301"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359639038"
                }
            },
            "author_association": "MEMBER",
            "body": "I've left the requested comment.",
            "commit_id": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
            "created_at": "2023-10-14T20:37:08Z",
            "diff_hunk": "@@ -0,0 +1,482 @@\n+local G = require('vim.lsp._snippet_grammar')\n+local snippet_group = 'vim/snippet'\n+local snippet_ns = vim.api.nvim_create_namespace(snippet_group)\n+\n+--- Returns the 0-based cursor position.\n+---\n+--- @return integer, integer\n+local function cursor_pos()\n+  local cursor = vim.api.nvim_win_get_cursor(0)\n+  return cursor[1] - 1, cursor[2]\n+end\n+\n+--- Resolves variables (like `$name` or `${name:default}`) as follows:\n+--- - When a variable is unknown (i.e.: its name is not recognized in any of the cases below), return `nil`.\n+--- - When a variable isn't set, return its default (if any) or an empty string.\n+---\n+--- Note that in some cases, the default is ignored since it's not clear how to distinguish an empty\n+--- value from an unset value (e.g.: `TM_CURRENT_LINE`).\n+---\n+--- @param var string\n+--- @param default string\n+--- @return string?\n+local function resolve_variable(var, default)\n+  --- @param str string\n+  --- @return string\n+  local function expand_or_default(str)\n+    local expansion = vim.fn.expand(str) --[[@as string]]\n+    return expansion == '' and default or expansion\n+  end\n+\n+  if var == 'TM_SELECTED_TEXT' then\n+    -- Snippets are expanded in insert mode only, so there's no selection.\n+    return default\n+  elseif var == 'TM_CURRENT_LINE' then\n+    return vim.api.nvim_get_current_line()\n+  elseif var == 'TM_CURRENT_WORD' then\n+    return expand_or_default('<cword>')\n+  elseif var == 'TM_LINE_INDEX' then\n+    return tostring(vim.fn.line('.') - 1)\n+  elseif var == 'TM_LINE_NUMBER' then\n+    return tostring(vim.fn.line('.'))\n+  elseif var == 'TM_FILENAME' then\n+    return expand_or_default('%:t')\n+  elseif var == 'TM_FILENAME_BASE' then\n+    -- Not using '%:t:r' since we want to remove all extensions.\n+    local filename_base = expand_or_default('%:t'):gsub('%.[^%.]*$', '')\n+    return filename_base\n+  elseif var == 'TM_DIRECTORY' then\n+    return expand_or_default('%:p:h:t')\n+  elseif var == 'TM_FILEPATH' then\n+    return expand_or_default('%:p')\n+  end\n+\n+  -- Unknown variable.\n+  return nil\n+end\n+\n+--- Removes newlines from the given text.\n+---\n+--- @param text string|string[]\n+--- @return string[]\n+local function remove_newlines(text)\n+  text = type(text) == 'string' and { text } or text\n+  --- @cast text string[]\n+  return vim.split(table.concat(text), '\\n')\n+end\n+\n+--- Appends the given text to the snippet, taking care of indentation.\n+---\n+--- @param snippet string[]\n+--- @param text string|string[]\n+local function append_to_snippet(snippet, text)\n+  -- Get the base indentation based on the current line and the last line of the snippet.\n+  local base_indent = vim.api.nvim_get_current_line():match('^%s*') or ''\n+  if #snippet > 0 then\n+    base_indent = base_indent .. (snippet[#snippet]:match('^%s*') or '') --- @type string\n+  end\n+\n+  local expand_tab = vim.api.nvim_get_option_value('expandtab', {})\n+  local lines = vim.iter.map(function(i, line)\n+    -- Replace tabs by spaces.\n+    if expand_tab then\n+      line = line:gsub('\\t', (' '):rep(vim.fn.shiftwidth())) --- @type string\n+    end\n+    -- Add the base indentation.\n+    if i > 1 then\n+      line = base_indent .. line\n+    end\n+    return line\n+  end, ipairs(remove_newlines(text)))\n+\n+  table.insert(snippet, table.concat(lines, '\\n'))\n+end\n+\n+--- Computes the 0-based position of a tabstop located at the end of `snippet` and spanning\n+--- `placeholder` (if given).\n+---\n+--- @param snippet string[]\n+--- @param placeholder string?\n+--- @return Range4\n+local function compute_tabstop_range(snippet, placeholder)\n+  local cursor_row, cursor_col = cursor_pos()\n+  local snippet_text = remove_newlines(snippet)\n+  local placeholder_text = remove_newlines(placeholder or '')\n+  local start_row = cursor_row + #snippet_text - 1\n+  local start_col = #(snippet_text[#snippet_text] or '')\n+\n+  -- Add the cursor's column offset to the first line.\n+  if start_row == cursor_row then\n+    start_col = start_col + cursor_col\n+  end\n+\n+  return {\n+    start_row,\n+    start_col,\n+    start_row + #placeholder_text - 1,\n+    start_col + #(placeholder_text[#placeholder_text] or ''),\n+  }\n+end\n+\n+--- @class vim.snippet.Tabstop\n+--- @field extmark_id integer\n+--- @field index integer\n+--- @field bufnr integer\n+local Tabstop = {}\n+Tabstop.__index = Tabstop\n+\n+--- Creates a new tabstop.\n+---\n+--- @param index integer\n+--- @param bufnr integer\n+--- @param range Range4\n+--- @return vim.snippet.Tabstop\n+function Tabstop.new(index, bufnr, range)\n+  local extmark_id = vim.api.nvim_buf_set_extmark(bufnr, snippet_ns, range[1], range[2], {\n+    right_gravity = false,\n+    end_right_gravity = true,\n+    end_line = range[3],\n+    end_col = range[4],\n+  })\n+\n+  local self = setmetatable(\n+    { index = index, bufnr = bufnr, extmark_id = extmark_id },\n+    { __index = Tabstop }\n+  )\n+\n+  return self\n+end\n+\n+--- Returns the tabstop's range.\n+---\n+--- @return Range4\n+function Tabstop:get_range()\n+  local mark =\n+    vim.api.nvim_buf_get_extmark_by_id(self.bufnr, snippet_ns, self.extmark_id, { details = true })\n+\n+  --- @diagnostic disable-next-line: undefined-field\n+  return { mark[1], mark[2], mark[3].end_row, mark[3].end_col }\n+end\n+\n+--- Returns the text spanned by the tabstop.\n+---\n+--- @return string\n+function Tabstop:get_text()\n+  local range = self:get_range()\n+  local lines = vim.api.nvim_buf_get_lines(self.bufnr, range[1], range[3] + 1, false)\n+  lines[#lines] = lines[#lines]:sub(1, range[4])\n+  lines[1] = lines[1]:sub(range[2] + 1)\n+\n+  return table.concat(lines, '\\n')\n+end\n+\n+--- Sets the tabstop's text.\n+---\n+--- @param text string\n+function Tabstop:set_text(text)\n+  local range = self:get_range()\n+  vim.api.nvim_buf_set_text(\n+    self.bufnr,\n+    range[1],\n+    range[2],\n+    range[3],\n+    range[4],\n+    remove_newlines(text)\n+  )\n+end\n+\n+--- @class vim.snippet.Session\n+--- @field bufnr integer\n+--- @field tabstops table<integer, vim.snippet.Tabstop[]>\n+--- @field current_tabstop vim.snippet.Tabstop\n+local Session = {}\n+\n+--- Initializes a new snippet session in the current buffer.\n+---\n+--- @return vim.snippet.Session\n+function Session:init()\n+  self.bufnr = vim.api.nvim_get_current_buf()\n+  self.tabstops = {}\n+  self.current_tabstop = Tabstop.new(0, self.bufnr, { 0, 0, 0, 0 })\n+\n+  return self\n+end\n+\n+--- Returns the number of tabstop indexes in the snippet session.\n+---\n+--- @return integer\n+function Session:get_num_tabstops()\n+  return #vim.tbl_keys(self.tabstops)\n+end\n+\n+--- Adds a tabstop at the given index and spanning `range`.\n+---\n+--- @param index integer\n+--- @param range Range4\n+function Session:add_tabstop(index, range)\n+  self.tabstops[index] = self.tabstops[index] or {}\n+  table.insert(self.tabstops[index], Tabstop.new(index, self.bufnr, range))\n+end\n+\n+--- @class vim.snippet.Snippet\n+--- @field private session? vim.snippet.Session\n+local M = { session = nil }\n+\n+--- Select the given tabstop range.\n+---\n+--- @private\n+--- @param tabstop vim.snippet.Tabstop\n+function M._select_stop(tabstop)\n+  --- @param keys string\n+  local function feedkeys(keys)\n+    keys = vim.api.nvim_replace_termcodes(keys, true, false, true)\n+    vim.api.nvim_feedkeys(keys, 'n', true)\n+  end\n+\n+  --- @param row integer\n+  --- @param col integer\n+  local function move_cursor_to(row, col)\n+    local line = vim.fn.getline(row) --[[ @as string ]]\n+    col = math.max(vim.fn.strchars(line:sub(1, col)) - 1, 0)\n+    feedkeys(string.format('%sG0%s', row, string.rep('<Right>', col)))\n+  end",
            "html_url": "https://github.com/neovim/neovim/pull/25301#discussion_r1359639038",
            "id": 1359639038,
            "in_reply_to_id": 1359202510,
            "line": 236,
            "node_id": "PRRC_kwDOAPphoM5RCnH-",
            "original_commit_id": "de47f404633dd871d4c13fbd180a23eee01a4cc5",
            "original_line": 236,
            "original_position": 242,
            "original_start_line": 238,
            "path": "runtime/lua/vim/snippet.lua",
            "position": 236,
            "pull_request_review_id": 1678459574,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359639038/reactions"
            },
            "side": "RIGHT",
            "start_line": 232,
            "start_side": "RIGHT",
            "subject_type": "line",
            "updated_at": "2023-10-14T20:37:09Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1359639038",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "If this is in `vim.snippet` that implies this is a general interface (like `vim.diagnostics`), not dependent on LSP?\r\n\r\nWhat is the format for defining snippets? I have the sense that LuaSnip's snippet format is hard to work with. ",
            "created_at": "2023-09-22T12:15:27Z",
            "html_url": "https://github.com/neovim/neovim/pull/25301#issuecomment-1731316986",
            "id": 1731316986,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/25301",
            "node_id": "IC_kwDOAPphoM5nMcz6",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1731316986/reactions"
            },
            "updated_at": "2023-09-22T12:15:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1731316986",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "author_association": "CONTRIBUTOR",
            "body": "LuaSnip supports quite a few different ways of defining snippets. But the format which is hard to work with which you talk about is definitely out of scope for a minimal api. It's not that bad to work with if you got used to it and also really powerful.\r\nBut since this api has to be able to expand lsp snippets I'd expect it to use the [lsp snippet syntax](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#snippet_syntax). Afaict by looking at the tests this is also the case. So I guess you define your snippets just as simple strings (which I don't like to be honest but don't see an easy way around).",
            "created_at": "2023-09-22T12:51:50Z",
            "html_url": "https://github.com/neovim/neovim/pull/25301#issuecomment-1731363101",
            "id": 1731363101,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/25301",
            "node_id": "IC_kwDOAPphoM5nMoEd",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1731363101/reactions"
            },
            "updated_at": "2023-09-22T12:51:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1731363101",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/81827001?v=4",
                "events_url": "https://api.github.com/users/max397574/events{/privacy}",
                "followers_url": "https://api.github.com/users/max397574/followers",
                "following_url": "https://api.github.com/users/max397574/following{/other_user}",
                "gists_url": "https://api.github.com/users/max397574/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/max397574",
                "id": 81827001,
                "login": "max397574",
                "node_id": "MDQ6VXNlcjgxODI3MDAx",
                "organizations_url": "https://api.github.com/users/max397574/orgs",
                "received_events_url": "https://api.github.com/users/max397574/received_events",
                "repos_url": "https://api.github.com/users/max397574/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/max397574/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/max397574/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/max397574"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> If this is in vim.snippet that implies this is a general interface (like vim.diagnostics), not dependent on LSP?\r\n\r\nThis is a (future) discussion on the form of the public API for external snippet plugins. Let me briefly summarize the state of play:\r\n\r\n1. We need snippet _expansion_ as this is part of the LSP specs (completion items may be snippets), and we are committed to implementing the full spec.\r\n2. Expansion (keeping track of placeholders, moving between them, and replacing them with typed text) is a basic component of _every_ snippet plugin, so it makes sense to expose that to reduce duplication.\r\n3. The [snippet _format_ is defined by the spec](https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#snippet_syntax), so is indeed LSP specific. However, it has become a kind of *lingua franca* for snippets, so most editors and plugins support this (possibly in addition to their own, more powerful format) -- and we certainly don't want to invent yet another, internal, format. This justifies having this outside the `lsp` module. \r\n4. Snippet _libraries_ (defining your own snippets or installing collections of them from the internet) is definitely out of scope for us and left to snippet plugins to do however they see fit. This applies doubly to LuaSnips.\r\n\r\n",
            "created_at": "2023-09-22T13:33:10Z",
            "html_url": "https://github.com/neovim/neovim/pull/25301#issuecomment-1731428833",
            "id": 1731428833,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/25301",
            "node_id": "IC_kwDOAPphoM5nM4Hh",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 10,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 10,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1731428833/reactions"
            },
            "updated_at": "2023-09-22T13:34:08Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1731428833",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> I'm not 100% sure about the name of vim.snippet.cancel, since sometimes it does cancel the snippet session but it's also invoked when the snippet navigation is complete. Do we want to give it another name?\r\n\r\n`detach` has precedents in our API (though it has the same problem as `cancel`: does not quite have the connotation of \"successful completion\"). An alternative would be `exit`, which is also used in one or two places.",
            "created_at": "2023-10-13T08:49:15Z",
            "html_url": "https://github.com/neovim/neovim/pull/25301#issuecomment-1761151964",
            "id": 1761151964,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/25301",
            "node_id": "IC_kwDOAPphoM5o-Qvc",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1761151964/reactions"
            },
            "updated_at": "2023-10-13T08:49:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1761151964",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "> `detach` has precedents in our API (though it has the same problem as `cancel`: does not quite have the connotation of \"successful completion\"). An alternative would be `exit`, which is also used in one or two places.\r\n\r\nI like `exit`. I'll wait for more people to weigh in though.\r\n\r\n",
            "created_at": "2023-10-13T22:26:52Z",
            "html_url": "https://github.com/neovim/neovim/pull/25301#issuecomment-1762315535",
            "id": 1762315535,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/25301",
            "node_id": "IC_kwDOAPphoM5pCs0P",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1762315535/reactions"
            },
            "updated_at": "2023-10-13T22:26:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1762315535",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "Alright, I'm satisfied with the current functionality so I'm marking this as ready for review. <s>I'm still missing tests and documentation (also need #25611 to get merged first)</s>, but I want to start getting some feedback here :)\r\n\r\nEDIT: Done with docs and tests!",
            "created_at": "2023-10-13T22:29:08Z",
            "html_url": "https://github.com/neovim/neovim/pull/25301#issuecomment-1762316995",
            "id": 1762316995,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/25301",
            "node_id": "IC_kwDOAPphoM5pCtLD",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1762316995/reactions"
            },
            "updated_at": "2023-10-14T20:37:44Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1762316995",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/25301/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/25301/commits",
    "created_at": "2023-09-22T03:49:20Z",
    "diff_url": "https://github.com/neovim/neovim/pull/25301.diff",
    "draft": false,
    "head": {
        "label": "MariaSolOs:snippets",
        "ref": "snippets",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/MariaSolOs/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/MariaSolOs/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/MariaSolOs/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/MariaSolOs/neovim/branches{/branch}",
            "clone_url": "https://github.com/MariaSolOs/neovim.git",
            "collaborators_url": "https://api.github.com/repos/MariaSolOs/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/MariaSolOs/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/MariaSolOs/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/MariaSolOs/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/MariaSolOs/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/MariaSolOs/neovim/contributors",
            "created_at": "2023-08-05T17:10:58Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/MariaSolOs/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/MariaSolOs/neovim/downloads",
            "events_url": "https://api.github.com/repos/MariaSolOs/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/MariaSolOs/neovim/forks",
            "full_name": "MariaSolOs/neovim",
            "git_commits_url": "https://api.github.com/repos/MariaSolOs/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/MariaSolOs/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/MariaSolOs/neovim/git/tags{/sha}",
            "git_url": "git://github.com/MariaSolOs/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/MariaSolOs/neovim/hooks",
            "html_url": "https://github.com/MariaSolOs/neovim",
            "id": 675070403,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/MariaSolOs/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/MariaSolOs/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/MariaSolOs/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/MariaSolOs/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/MariaSolOs/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/MariaSolOs/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/MariaSolOs/neovim/merges",
            "milestones_url": "https://api.github.com/repos/MariaSolOs/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOKDzBww",
            "notifications_url": "https://api.github.com/repos/MariaSolOs/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/MariaSolOs/neovim/pulls{/number}",
            "pushed_at": "2023-10-14T21:08:48Z",
            "releases_url": "https://api.github.com/repos/MariaSolOs/neovim/releases{/id}",
            "size": 243169,
            "ssh_url": "git@github.com:MariaSolOs/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/MariaSolOs/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/MariaSolOs/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/MariaSolOs/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/MariaSolOs/neovim/subscription",
            "svn_url": "https://github.com/MariaSolOs/neovim",
            "tags_url": "https://api.github.com/repos/MariaSolOs/neovim/tags",
            "teams_url": "https://api.github.com/repos/MariaSolOs/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/MariaSolOs/neovim/git/trees{/sha}",
            "updated_at": "2023-08-09T04:34:06Z",
            "url": "https://api.github.com/repos/MariaSolOs/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "b7cd2c79d39981fe99ba771edf5e7541b8295410",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
            "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
            "followers_url": "https://api.github.com/users/MariaSolOs/followers",
            "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
            "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/MariaSolOs",
            "id": 62502207,
            "login": "MariaSolOs",
            "node_id": "MDQ6VXNlcjYyNTAyMjA3",
            "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
            "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
            "repos_url": "https://api.github.com/users/MariaSolOs/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/MariaSolOs"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/25301",
    "id": 1525897868,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/25301",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": null,
            "id": 662566370,
            "name": "lsp",
            "node_id": "MDU6TGFiZWw2NjI1NjYzNzA=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lsp"
        }
    ],
    "locked": false,
    "merge_commit_sha": "1bab5ccbc98047e7909587409035a498633ce9c4",
    "merged_at": null,
    "milestone": null,
    "node_id": "PR_kwDOAPphoM5a81qM",
    "number": 25301,
    "patch_url": "https://github.com/neovim/neovim/pull/25301.patch",
    "requested_reviewers": [
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/292349?v=4",
            "events_url": "https://api.github.com/users/folke/events{/privacy}",
            "followers_url": "https://api.github.com/users/folke/followers",
            "following_url": "https://api.github.com/users/folke/following{/other_user}",
            "gists_url": "https://api.github.com/users/folke/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/folke",
            "id": 292349,
            "login": "folke",
            "node_id": "MDQ6VXNlcjI5MjM0OQ==",
            "organizations_url": "https://api.github.com/users/folke/orgs",
            "received_events_url": "https://api.github.com/users/folke/received_events",
            "repos_url": "https://api.github.com/users/folke/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/folke/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/folke/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/folke"
        },
        {
            "avatar_url": "https://avatars.githubusercontent.com/u/41671631?v=4",
            "events_url": "https://api.github.com/users/glepnir/events{/privacy}",
            "followers_url": "https://api.github.com/users/glepnir/followers",
            "following_url": "https://api.github.com/users/glepnir/following{/other_user}",
            "gists_url": "https://api.github.com/users/glepnir/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/glepnir",
            "id": 41671631,
            "login": "glepnir",
            "node_id": "MDQ6VXNlcjQxNjcxNjMx",
            "organizations_url": "https://api.github.com/users/glepnir/orgs",
            "received_events_url": "https://api.github.com/users/glepnir/received_events",
            "repos_url": "https://api.github.com/users/glepnir/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/glepnir/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/glepnir/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/glepnir"
        }
    ],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/25301/comments",
    "state": "open",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/b7cd2c79d39981fe99ba771edf5e7541b8295410",
    "title": "feat(lsp): snippet API",
    "updated_at": "2023-10-14T20:37:44Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/25301",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
        "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
        "followers_url": "https://api.github.com/users/MariaSolOs/followers",
        "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
        "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/MariaSolOs",
        "id": 62502207,
        "login": "MariaSolOs",
        "node_id": "MDQ6VXNlcjYyNTAyMjA3",
        "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
        "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
        "repos_url": "https://api.github.com/users/MariaSolOs/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/MariaSolOs"
    }
}