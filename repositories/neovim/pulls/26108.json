{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/26108/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/26108/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/26108"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/26108"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/26108/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/26108"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/8b1f10e42490b4abe4914e96bea8b521c02ccc08"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 4986,
            "forks_count": 4986,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1689,
            "open_issues_count": 1689,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2023-11-20T02:00:26Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 234098,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 71031,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2023-11-20T01:26:24Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 71031,
            "watchers_count": 71031,
            "web_commit_signoff_required": false
        },
        "sha": "a84b454ebe661981f292ee8fc73be4f9cd3a5884",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim"
        }
    },
    "body": "Should help with https://github.com/neovim/neovim/issues/23291\r\n\r\nOn linux `new_fs_event` doesn't support recursive watching, but we can\r\nstill use it to watch folders.\r\n\r\nThe downside of this approach is that we may end up sending some false\r\n`Deleted` events. For example, if you save a file named `foo` there will\r\nbe a intermediate `foo~` due to the save mechanism of neovim.\r\n\r\nThe events we get from vim.uv in that case are:\r\n\r\n- rename: foo~\r\n- rename: foo~\r\n- rename: foo\r\n- rename: foo\r\n- change: foo\r\n- change: foo\r\n\r\nThe mechanism in this PR uses a debounce to reduce this to:\r\n\r\n- deleted: foo~\r\n- changed: foo\r\n\r\n`foo~` will be the false positive.\r\n\r\nAnother case where it sends an extra delete is if you delete a folder. `rmdir\r\nfoobar` will result in a deleted event for both `foobar` and `foobar/foobar`.\r\n\r\nI suspect that for the LSP case this is good enough. If not, we may need\r\nto follow up on this and keep a table in memory that tracks available\r\nfiles.\r\n",
    "closed_at": "2023-11-19T13:25:32Z",
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26108#discussion_r1398376518"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26108"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398376518"
                }
            },
            "author_association": "MEMBER",
            "body": "Is there a functional difference if we don't call `stop()` and just call `start()`? From what I can tell there isn't since `start()` should effectively call `stop()` anyway but I could be wrong.",
            "commit_id": "8b1f10e42490b4abe4914e96bea8b521c02ccc08",
            "created_at": "2023-11-19T10:52:41Z",
            "diff_hunk": "@@ -72,129 +76,127 @@ function M.watch(path, opts, callback)\n   end\n end\n \n-local default_poll_interval_ms = 2000\n-\n---- @class watch.Watches\n---- @field is_dir boolean\n---- @field children? table<string,watch.Watches>\n---- @field cancel? fun()\n---- @field started? boolean\n---- @field handle? uv.uv_fs_poll_t\n-\n --- @class watch.PollOpts\n---- @field interval? integer\n---- @field include_pattern? userdata\n---- @field exclude_pattern? userdata\n+--- @field debounce? integer\n+--- @field include_pattern? vim.lpeg.Pattern\n+--- @field exclude_pattern? vim.lpeg.Pattern\n \n---- Implementation for poll, hiding internally-used parameters.\n----\n ---@param path string\n ---@param opts watch.PollOpts\n----@param callback fun(patch: string, filechangetype: integer)\n----@param watches (watch.Watches|nil) A tree structure to maintain state for recursive watches.\n----     - handle (uv_fs_poll_t)\n----               The libuv handle\n----     - cancel (function)\n----               A function that cancels the handle and all children's handles\n----     - is_dir (boolean)\n----               Indicates whether the path is a directory (and the poll should\n----               be invoked recursively)\n----     - children (table|nil)\n----               A mapping of directory entry name to its recursive watches\n----     - started (boolean|nil)\n----               Whether or not the watcher has first been initialized. Used\n----               to prevent a flood of Created events on startup.\n----@return fun() Cancel function\n-local function poll_internal(path, opts, callback, watches)\n-  path = vim.fs.normalize(path)\n-  local interval = opts and opts.interval or default_poll_interval_ms\n-  watches = watches or {\n-    is_dir = true,\n-  }\n-  watches.cancel = function()\n-    if watches.children then\n-      for _, w in pairs(watches.children) do\n-        w.cancel()\n-      end\n-    end\n-    if watches.handle then\n-      stop(watches.handle)\n-    end\n+---@param callback function Called on new events\n+---@return function cancel stops the watcher\n+local function recurse_watch(path, opts, callback)\n+  opts = opts or {}\n+  local debounce = opts.debounce or 500\n+  local uvflags = {}\n+  ---@type table<string, uv.uv_fs_event_t> handle by fullpath\n+  local handles = {}\n+\n+  local timer = assert(uv.new_timer())\n+\n+  ---@type table[]\n+  local changesets = {}\n+\n+  local function is_included(filepath)\n+    return opts.include_pattern and opts.include_pattern:match(filepath)\n   end\n-\n-  local function incl_match()\n-    return not opts.include_pattern or opts.include_pattern:match(path) ~= nil\n-  end\n-  local function excl_match()\n-    return opts.exclude_pattern and opts.exclude_pattern:match(path) ~= nil\n+  local function is_excluded(filepath)\n+    return opts.exclude_pattern and opts.exclude_pattern:match(filepath)\n   end\n-  if not watches.is_dir and not incl_match() or excl_match() then\n-    return watches.cancel\n+\n+  local process_changes = function()\n+    assert(false, \"Replaced later. I'm only here as forward reference\")\n   end\n \n-  if not watches.handle then\n-    local poll, new_err = vim.uv.new_fs_poll()\n-    assert(not new_err, new_err)\n-    watches.handle = poll\n-    local _, start_err = poll:start(\n-      path,\n-      interval,\n-      vim.schedule_wrap(function(err)\n-        if err == 'ENOENT' then\n-          return\n-        end\n-        assert(not err, err)\n-        poll_internal(path, opts, callback, watches)\n-        callback(path, M.FileChangeType.Changed)\n-      end)\n-    )\n-    assert(not start_err, start_err)\n-    if watches.started then\n-      callback(path, M.FileChangeType.Created)\n+  local function create_on_change(filepath)\n+    return function(err, filename, events)\n+      assert(not err, err)\n+      local fullpath = vim.fs.joinpath(filepath, filename)\n+      if is_included(fullpath) and not is_excluded(filepath) then\n+        table.insert(changesets, {\n+          fullpath = fullpath,\n+          events = events,\n+        })\n+        timer:stop()",
            "html_url": "https://github.com/neovim/neovim/pull/26108#discussion_r1398376518",
            "id": 1398376518,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5TWYhG",
            "original_commit_id": "73955906975942e7dbdb22fcdaed3e75f79697c8",
            "original_line": 120,
            "original_position": 135,
            "original_start_line": null,
            "path": "runtime/lua/vim/_watch.lua",
            "position": null,
            "pull_request_review_id": 1738597908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26108",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398376518/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-11-19T11:03:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398376518",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26108#discussion_r1398376809"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26108"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398376809"
                }
            },
            "author_association": "MEMBER",
            "body": "Where does 640k come from?",
            "commit_id": "8b1f10e42490b4abe4914e96bea8b521c02ccc08",
            "created_at": "2023-11-19T10:54:47Z",
            "diff_hunk": "@@ -72,129 +76,127 @@ function M.watch(path, opts, callback)\n   end\n end\n \n-local default_poll_interval_ms = 2000\n-\n---- @class watch.Watches\n---- @field is_dir boolean\n---- @field children? table<string,watch.Watches>\n---- @field cancel? fun()\n---- @field started? boolean\n---- @field handle? uv.uv_fs_poll_t\n-\n --- @class watch.PollOpts\n---- @field interval? integer\n---- @field include_pattern? userdata\n---- @field exclude_pattern? userdata\n+--- @field debounce? integer\n+--- @field include_pattern? vim.lpeg.Pattern\n+--- @field exclude_pattern? vim.lpeg.Pattern\n \n---- Implementation for poll, hiding internally-used parameters.\n----\n ---@param path string\n ---@param opts watch.PollOpts\n----@param callback fun(patch: string, filechangetype: integer)\n----@param watches (watch.Watches|nil) A tree structure to maintain state for recursive watches.\n----     - handle (uv_fs_poll_t)\n----               The libuv handle\n----     - cancel (function)\n----               A function that cancels the handle and all children's handles\n----     - is_dir (boolean)\n----               Indicates whether the path is a directory (and the poll should\n----               be invoked recursively)\n----     - children (table|nil)\n----               A mapping of directory entry name to its recursive watches\n----     - started (boolean|nil)\n----               Whether or not the watcher has first been initialized. Used\n----               to prevent a flood of Created events on startup.\n----@return fun() Cancel function\n-local function poll_internal(path, opts, callback, watches)\n-  path = vim.fs.normalize(path)\n-  local interval = opts and opts.interval or default_poll_interval_ms\n-  watches = watches or {\n-    is_dir = true,\n-  }\n-  watches.cancel = function()\n-    if watches.children then\n-      for _, w in pairs(watches.children) do\n-        w.cancel()\n-      end\n-    end\n-    if watches.handle then\n-      stop(watches.handle)\n-    end\n+---@param callback function Called on new events\n+---@return function cancel stops the watcher\n+local function recurse_watch(path, opts, callback)\n+  opts = opts or {}\n+  local debounce = opts.debounce or 500\n+  local uvflags = {}\n+  ---@type table<string, uv.uv_fs_event_t> handle by fullpath\n+  local handles = {}\n+\n+  local timer = assert(uv.new_timer())\n+\n+  ---@type table[]\n+  local changesets = {}\n+\n+  local function is_included(filepath)\n+    return opts.include_pattern and opts.include_pattern:match(filepath)\n   end\n-\n-  local function incl_match()\n-    return not opts.include_pattern or opts.include_pattern:match(path) ~= nil\n-  end\n-  local function excl_match()\n-    return opts.exclude_pattern and opts.exclude_pattern:match(path) ~= nil\n+  local function is_excluded(filepath)\n+    return opts.exclude_pattern and opts.exclude_pattern:match(filepath)\n   end\n-  if not watches.is_dir and not incl_match() or excl_match() then\n-    return watches.cancel\n+\n+  local process_changes = function()\n+    assert(false, \"Replaced later. I'm only here as forward reference\")\n   end\n \n-  if not watches.handle then\n-    local poll, new_err = vim.uv.new_fs_poll()\n-    assert(not new_err, new_err)\n-    watches.handle = poll\n-    local _, start_err = poll:start(\n-      path,\n-      interval,\n-      vim.schedule_wrap(function(err)\n-        if err == 'ENOENT' then\n-          return\n-        end\n-        assert(not err, err)\n-        poll_internal(path, opts, callback, watches)\n-        callback(path, M.FileChangeType.Changed)\n-      end)\n-    )\n-    assert(not start_err, start_err)\n-    if watches.started then\n-      callback(path, M.FileChangeType.Created)\n+  local function create_on_change(filepath)\n+    return function(err, filename, events)\n+      assert(not err, err)\n+      local fullpath = vim.fs.joinpath(filepath, filename)\n+      if is_included(fullpath) and not is_excluded(filepath) then\n+        table.insert(changesets, {\n+          fullpath = fullpath,\n+          events = events,\n+        })\n+        timer:stop()\n+        timer:start(debounce, 0, process_changes)\n+      end\n     end\n   end\n \n-  if watches.is_dir then\n-    watches.children = watches.children or {}\n-    local exists = {} --- @type table<string,true>\n-    for name, ftype in vim.fs.dir(path) do\n-      exists[name] = true\n-      if not watches.children[name] then\n-        watches.children[name] = {\n-          is_dir = ftype == 'directory',\n-          started = watches.started,\n-        }\n-        poll_internal(filepath_join(path, name), opts, callback, watches.children[name])\n+  process_changes = function()\n+    ---@type table<string, table[]>\n+    local filechanges = vim.defaulttable()\n+    for i, change in ipairs(changesets) do\n+      changesets[i] = nil\n+      if is_included(change.fullpath) and not is_excluded(change.fullpath) then\n+        table.insert(filechanges[change.fullpath], change.events)\n       end\n     end\n-\n-    local newchildren = {} ---@type table<string,watch.Watches>\n-    for name, watch in pairs(watches.children) do\n-      if exists[name] then\n-        newchildren[name] = watch\n+    for fullpath, events_list in pairs(filechanges) do\n+      local stat = uv.fs_stat(fullpath)\n+      ---@type vim._watch.FileChangeType\n+      local change_type\n+      if stat then\n+        change_type = FileChangeType.Created\n+        for _, event in ipairs(events_list) do\n+          if event.change then\n+            change_type = FileChangeType.Changed\n+          end\n+        end\n+        if stat.type == 'directory' then\n+          local handle = assert(uv.new_fs_event())\n+          handles[fullpath] = handle\n+          handle:start(fullpath, uvflags, create_on_change(fullpath))\n+        end\n       else\n-        watch.cancel()\n-        watches.children[name] = nil\n-        if watch.handle then\n-          callback(path .. '/' .. name, M.FileChangeType.Deleted)\n+        local handle = handles[fullpath]\n+        if handle then\n+          if not handle:is_closing() then\n+            handle:close()\n+          end\n+          handles[fullpath] = nil\n         end\n+        change_type = FileChangeType.Deleted\n       end\n+      callback(fullpath, change_type)\n     end\n-    watches.children = newchildren\n   end\n-\n-  watches.started = true\n-\n-  return watches.cancel\n+  local root_handle = assert(uv.new_fs_event())\n+  handles[path] = root_handle\n+  root_handle:start(path, uvflags, create_on_change(path))\n+\n+  --- 640K ought to be enough for anyone",
            "html_url": "https://github.com/neovim/neovim/pull/26108#discussion_r1398376809",
            "id": 1398376809,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5TWYlp",
            "original_commit_id": "73955906975942e7dbdb22fcdaed3e75f79697c8",
            "original_line": 168,
            "original_position": 208,
            "original_start_line": null,
            "path": "runtime/lua/vim/_watch.lua",
            "position": null,
            "pull_request_review_id": 1738597908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26108",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398376809/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-11-19T11:03:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398376809",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26108#discussion_r1398377983"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26108"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398377983"
                }
            },
            "author_association": "MEMBER",
            "body": "It's not clear to me why we need to create a new watcher on changes to a directory? Can this result in multiple watchers on the same directory?",
            "commit_id": "8b1f10e42490b4abe4914e96bea8b521c02ccc08",
            "created_at": "2023-11-19T11:02:33Z",
            "diff_hunk": "@@ -72,129 +76,127 @@ function M.watch(path, opts, callback)\n   end\n end\n \n-local default_poll_interval_ms = 2000\n-\n---- @class watch.Watches\n---- @field is_dir boolean\n---- @field children? table<string,watch.Watches>\n---- @field cancel? fun()\n---- @field started? boolean\n---- @field handle? uv.uv_fs_poll_t\n-\n --- @class watch.PollOpts\n---- @field interval? integer\n---- @field include_pattern? userdata\n---- @field exclude_pattern? userdata\n+--- @field debounce? integer\n+--- @field include_pattern? vim.lpeg.Pattern\n+--- @field exclude_pattern? vim.lpeg.Pattern\n \n---- Implementation for poll, hiding internally-used parameters.\n----\n ---@param path string\n ---@param opts watch.PollOpts\n----@param callback fun(patch: string, filechangetype: integer)\n----@param watches (watch.Watches|nil) A tree structure to maintain state for recursive watches.\n----     - handle (uv_fs_poll_t)\n----               The libuv handle\n----     - cancel (function)\n----               A function that cancels the handle and all children's handles\n----     - is_dir (boolean)\n----               Indicates whether the path is a directory (and the poll should\n----               be invoked recursively)\n----     - children (table|nil)\n----               A mapping of directory entry name to its recursive watches\n----     - started (boolean|nil)\n----               Whether or not the watcher has first been initialized. Used\n----               to prevent a flood of Created events on startup.\n----@return fun() Cancel function\n-local function poll_internal(path, opts, callback, watches)\n-  path = vim.fs.normalize(path)\n-  local interval = opts and opts.interval or default_poll_interval_ms\n-  watches = watches or {\n-    is_dir = true,\n-  }\n-  watches.cancel = function()\n-    if watches.children then\n-      for _, w in pairs(watches.children) do\n-        w.cancel()\n-      end\n-    end\n-    if watches.handle then\n-      stop(watches.handle)\n-    end\n+---@param callback function Called on new events\n+---@return function cancel stops the watcher\n+local function recurse_watch(path, opts, callback)\n+  opts = opts or {}\n+  local debounce = opts.debounce or 500\n+  local uvflags = {}\n+  ---@type table<string, uv.uv_fs_event_t> handle by fullpath\n+  local handles = {}\n+\n+  local timer = assert(uv.new_timer())\n+\n+  ---@type table[]\n+  local changesets = {}\n+\n+  local function is_included(filepath)\n+    return opts.include_pattern and opts.include_pattern:match(filepath)\n   end\n-\n-  local function incl_match()\n-    return not opts.include_pattern or opts.include_pattern:match(path) ~= nil\n-  end\n-  local function excl_match()\n-    return opts.exclude_pattern and opts.exclude_pattern:match(path) ~= nil\n+  local function is_excluded(filepath)\n+    return opts.exclude_pattern and opts.exclude_pattern:match(filepath)\n   end\n-  if not watches.is_dir and not incl_match() or excl_match() then\n-    return watches.cancel\n+\n+  local process_changes = function()\n+    assert(false, \"Replaced later. I'm only here as forward reference\")\n   end\n \n-  if not watches.handle then\n-    local poll, new_err = vim.uv.new_fs_poll()\n-    assert(not new_err, new_err)\n-    watches.handle = poll\n-    local _, start_err = poll:start(\n-      path,\n-      interval,\n-      vim.schedule_wrap(function(err)\n-        if err == 'ENOENT' then\n-          return\n-        end\n-        assert(not err, err)\n-        poll_internal(path, opts, callback, watches)\n-        callback(path, M.FileChangeType.Changed)\n-      end)\n-    )\n-    assert(not start_err, start_err)\n-    if watches.started then\n-      callback(path, M.FileChangeType.Created)\n+  local function create_on_change(filepath)\n+    return function(err, filename, events)\n+      assert(not err, err)\n+      local fullpath = vim.fs.joinpath(filepath, filename)\n+      if is_included(fullpath) and not is_excluded(filepath) then\n+        table.insert(changesets, {\n+          fullpath = fullpath,\n+          events = events,\n+        })\n+        timer:stop()\n+        timer:start(debounce, 0, process_changes)\n+      end\n     end\n   end\n \n-  if watches.is_dir then\n-    watches.children = watches.children or {}\n-    local exists = {} --- @type table<string,true>\n-    for name, ftype in vim.fs.dir(path) do\n-      exists[name] = true\n-      if not watches.children[name] then\n-        watches.children[name] = {\n-          is_dir = ftype == 'directory',\n-          started = watches.started,\n-        }\n-        poll_internal(filepath_join(path, name), opts, callback, watches.children[name])\n+  process_changes = function()\n+    ---@type table<string, table[]>\n+    local filechanges = vim.defaulttable()\n+    for i, change in ipairs(changesets) do\n+      changesets[i] = nil\n+      if is_included(change.fullpath) and not is_excluded(change.fullpath) then\n+        table.insert(filechanges[change.fullpath], change.events)\n       end\n     end\n-\n-    local newchildren = {} ---@type table<string,watch.Watches>\n-    for name, watch in pairs(watches.children) do\n-      if exists[name] then\n-        newchildren[name] = watch\n+    for fullpath, events_list in pairs(filechanges) do\n+      local stat = uv.fs_stat(fullpath)\n+      ---@type vim._watch.FileChangeType\n+      local change_type\n+      if stat then\n+        change_type = FileChangeType.Created\n+        for _, event in ipairs(events_list) do\n+          if event.change then\n+            change_type = FileChangeType.Changed\n+          end\n+        end\n+        if stat.type == 'directory' then\n+          local handle = assert(uv.new_fs_event())\n+          handles[fullpath] = handle\n+          handle:start(fullpath, uvflags, create_on_change(fullpath))",
            "html_url": "https://github.com/neovim/neovim/pull/26108#discussion_r1398377983",
            "id": 1398377983,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5TWY3_",
            "original_commit_id": "73955906975942e7dbdb22fcdaed3e75f79697c8",
            "original_line": 149,
            "original_position": 180,
            "original_start_line": null,
            "path": "runtime/lua/vim/_watch.lua",
            "position": null,
            "pull_request_review_id": 1738597908,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26108",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398377983/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-11-19T11:03:31Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398377983",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26108#discussion_r1398378299"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26108"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398378299"
                }
            },
            "author_association": "MEMBER",
            "body": "Bill Gates ;)",
            "commit_id": "8b1f10e42490b4abe4914e96bea8b521c02ccc08",
            "created_at": "2023-11-19T11:04:57Z",
            "diff_hunk": "@@ -72,129 +76,127 @@ function M.watch(path, opts, callback)\n   end\n end\n \n-local default_poll_interval_ms = 2000\n-\n---- @class watch.Watches\n---- @field is_dir boolean\n---- @field children? table<string,watch.Watches>\n---- @field cancel? fun()\n---- @field started? boolean\n---- @field handle? uv.uv_fs_poll_t\n-\n --- @class watch.PollOpts\n---- @field interval? integer\n---- @field include_pattern? userdata\n---- @field exclude_pattern? userdata\n+--- @field debounce? integer\n+--- @field include_pattern? vim.lpeg.Pattern\n+--- @field exclude_pattern? vim.lpeg.Pattern\n \n---- Implementation for poll, hiding internally-used parameters.\n----\n ---@param path string\n ---@param opts watch.PollOpts\n----@param callback fun(patch: string, filechangetype: integer)\n----@param watches (watch.Watches|nil) A tree structure to maintain state for recursive watches.\n----     - handle (uv_fs_poll_t)\n----               The libuv handle\n----     - cancel (function)\n----               A function that cancels the handle and all children's handles\n----     - is_dir (boolean)\n----               Indicates whether the path is a directory (and the poll should\n----               be invoked recursively)\n----     - children (table|nil)\n----               A mapping of directory entry name to its recursive watches\n----     - started (boolean|nil)\n----               Whether or not the watcher has first been initialized. Used\n----               to prevent a flood of Created events on startup.\n----@return fun() Cancel function\n-local function poll_internal(path, opts, callback, watches)\n-  path = vim.fs.normalize(path)\n-  local interval = opts and opts.interval or default_poll_interval_ms\n-  watches = watches or {\n-    is_dir = true,\n-  }\n-  watches.cancel = function()\n-    if watches.children then\n-      for _, w in pairs(watches.children) do\n-        w.cancel()\n-      end\n-    end\n-    if watches.handle then\n-      stop(watches.handle)\n-    end\n+---@param callback function Called on new events\n+---@return function cancel stops the watcher\n+local function recurse_watch(path, opts, callback)\n+  opts = opts or {}\n+  local debounce = opts.debounce or 500\n+  local uvflags = {}\n+  ---@type table<string, uv.uv_fs_event_t> handle by fullpath\n+  local handles = {}\n+\n+  local timer = assert(uv.new_timer())\n+\n+  ---@type table[]\n+  local changesets = {}\n+\n+  local function is_included(filepath)\n+    return opts.include_pattern and opts.include_pattern:match(filepath)\n   end\n-\n-  local function incl_match()\n-    return not opts.include_pattern or opts.include_pattern:match(path) ~= nil\n-  end\n-  local function excl_match()\n-    return opts.exclude_pattern and opts.exclude_pattern:match(path) ~= nil\n+  local function is_excluded(filepath)\n+    return opts.exclude_pattern and opts.exclude_pattern:match(filepath)\n   end\n-  if not watches.is_dir and not incl_match() or excl_match() then\n-    return watches.cancel\n+\n+  local process_changes = function()\n+    assert(false, \"Replaced later. I'm only here as forward reference\")\n   end\n \n-  if not watches.handle then\n-    local poll, new_err = vim.uv.new_fs_poll()\n-    assert(not new_err, new_err)\n-    watches.handle = poll\n-    local _, start_err = poll:start(\n-      path,\n-      interval,\n-      vim.schedule_wrap(function(err)\n-        if err == 'ENOENT' then\n-          return\n-        end\n-        assert(not err, err)\n-        poll_internal(path, opts, callback, watches)\n-        callback(path, M.FileChangeType.Changed)\n-      end)\n-    )\n-    assert(not start_err, start_err)\n-    if watches.started then\n-      callback(path, M.FileChangeType.Created)\n+  local function create_on_change(filepath)\n+    return function(err, filename, events)\n+      assert(not err, err)\n+      local fullpath = vim.fs.joinpath(filepath, filename)\n+      if is_included(fullpath) and not is_excluded(filepath) then\n+        table.insert(changesets, {\n+          fullpath = fullpath,\n+          events = events,\n+        })\n+        timer:stop()\n+        timer:start(debounce, 0, process_changes)\n+      end\n     end\n   end\n \n-  if watches.is_dir then\n-    watches.children = watches.children or {}\n-    local exists = {} --- @type table<string,true>\n-    for name, ftype in vim.fs.dir(path) do\n-      exists[name] = true\n-      if not watches.children[name] then\n-        watches.children[name] = {\n-          is_dir = ftype == 'directory',\n-          started = watches.started,\n-        }\n-        poll_internal(filepath_join(path, name), opts, callback, watches.children[name])\n+  process_changes = function()\n+    ---@type table<string, table[]>\n+    local filechanges = vim.defaulttable()\n+    for i, change in ipairs(changesets) do\n+      changesets[i] = nil\n+      if is_included(change.fullpath) and not is_excluded(change.fullpath) then\n+        table.insert(filechanges[change.fullpath], change.events)\n       end\n     end\n-\n-    local newchildren = {} ---@type table<string,watch.Watches>\n-    for name, watch in pairs(watches.children) do\n-      if exists[name] then\n-        newchildren[name] = watch\n+    for fullpath, events_list in pairs(filechanges) do\n+      local stat = uv.fs_stat(fullpath)\n+      ---@type vim._watch.FileChangeType\n+      local change_type\n+      if stat then\n+        change_type = FileChangeType.Created\n+        for _, event in ipairs(events_list) do\n+          if event.change then\n+            change_type = FileChangeType.Changed\n+          end\n+        end\n+        if stat.type == 'directory' then\n+          local handle = assert(uv.new_fs_event())\n+          handles[fullpath] = handle\n+          handle:start(fullpath, uvflags, create_on_change(fullpath))\n+        end\n       else\n-        watch.cancel()\n-        watches.children[name] = nil\n-        if watch.handle then\n-          callback(path .. '/' .. name, M.FileChangeType.Deleted)\n+        local handle = handles[fullpath]\n+        if handle then\n+          if not handle:is_closing() then\n+            handle:close()\n+          end\n+          handles[fullpath] = nil\n         end\n+        change_type = FileChangeType.Deleted\n       end\n+      callback(fullpath, change_type)\n     end\n-    watches.children = newchildren\n   end\n-\n-  watches.started = true\n-\n-  return watches.cancel\n+  local root_handle = assert(uv.new_fs_event())\n+  handles[path] = root_handle\n+  root_handle:start(path, uvflags, create_on_change(path))\n+\n+  --- 640K ought to be enough for anyone",
            "html_url": "https://github.com/neovim/neovim/pull/26108#discussion_r1398378299",
            "id": 1398378299,
            "in_reply_to_id": 1398376809,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5TWY87",
            "original_commit_id": "73955906975942e7dbdb22fcdaed3e75f79697c8",
            "original_line": 168,
            "original_position": 208,
            "original_start_line": null,
            "path": "runtime/lua/vim/_watch.lua",
            "position": null,
            "pull_request_review_id": 1738599517,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26108",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398378299/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-11-19T12:28:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398378299",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26108#discussion_r1398378566"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26108"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398378566"
                }
            },
            "author_association": "MEMBER",
            "body": "Ahh, maybe put this in quotes to not throw off dummys like me.",
            "commit_id": "8b1f10e42490b4abe4914e96bea8b521c02ccc08",
            "created_at": "2023-11-19T11:07:30Z",
            "diff_hunk": "@@ -72,129 +76,127 @@ function M.watch(path, opts, callback)\n   end\n end\n \n-local default_poll_interval_ms = 2000\n-\n---- @class watch.Watches\n---- @field is_dir boolean\n---- @field children? table<string,watch.Watches>\n---- @field cancel? fun()\n---- @field started? boolean\n---- @field handle? uv.uv_fs_poll_t\n-\n --- @class watch.PollOpts\n---- @field interval? integer\n---- @field include_pattern? userdata\n---- @field exclude_pattern? userdata\n+--- @field debounce? integer\n+--- @field include_pattern? vim.lpeg.Pattern\n+--- @field exclude_pattern? vim.lpeg.Pattern\n \n---- Implementation for poll, hiding internally-used parameters.\n----\n ---@param path string\n ---@param opts watch.PollOpts\n----@param callback fun(patch: string, filechangetype: integer)\n----@param watches (watch.Watches|nil) A tree structure to maintain state for recursive watches.\n----     - handle (uv_fs_poll_t)\n----               The libuv handle\n----     - cancel (function)\n----               A function that cancels the handle and all children's handles\n----     - is_dir (boolean)\n----               Indicates whether the path is a directory (and the poll should\n----               be invoked recursively)\n----     - children (table|nil)\n----               A mapping of directory entry name to its recursive watches\n----     - started (boolean|nil)\n----               Whether or not the watcher has first been initialized. Used\n----               to prevent a flood of Created events on startup.\n----@return fun() Cancel function\n-local function poll_internal(path, opts, callback, watches)\n-  path = vim.fs.normalize(path)\n-  local interval = opts and opts.interval or default_poll_interval_ms\n-  watches = watches or {\n-    is_dir = true,\n-  }\n-  watches.cancel = function()\n-    if watches.children then\n-      for _, w in pairs(watches.children) do\n-        w.cancel()\n-      end\n-    end\n-    if watches.handle then\n-      stop(watches.handle)\n-    end\n+---@param callback function Called on new events\n+---@return function cancel stops the watcher\n+local function recurse_watch(path, opts, callback)\n+  opts = opts or {}\n+  local debounce = opts.debounce or 500\n+  local uvflags = {}\n+  ---@type table<string, uv.uv_fs_event_t> handle by fullpath\n+  local handles = {}\n+\n+  local timer = assert(uv.new_timer())\n+\n+  ---@type table[]\n+  local changesets = {}\n+\n+  local function is_included(filepath)\n+    return opts.include_pattern and opts.include_pattern:match(filepath)\n   end\n-\n-  local function incl_match()\n-    return not opts.include_pattern or opts.include_pattern:match(path) ~= nil\n-  end\n-  local function excl_match()\n-    return opts.exclude_pattern and opts.exclude_pattern:match(path) ~= nil\n+  local function is_excluded(filepath)\n+    return opts.exclude_pattern and opts.exclude_pattern:match(filepath)\n   end\n-  if not watches.is_dir and not incl_match() or excl_match() then\n-    return watches.cancel\n+\n+  local process_changes = function()\n+    assert(false, \"Replaced later. I'm only here as forward reference\")\n   end\n \n-  if not watches.handle then\n-    local poll, new_err = vim.uv.new_fs_poll()\n-    assert(not new_err, new_err)\n-    watches.handle = poll\n-    local _, start_err = poll:start(\n-      path,\n-      interval,\n-      vim.schedule_wrap(function(err)\n-        if err == 'ENOENT' then\n-          return\n-        end\n-        assert(not err, err)\n-        poll_internal(path, opts, callback, watches)\n-        callback(path, M.FileChangeType.Changed)\n-      end)\n-    )\n-    assert(not start_err, start_err)\n-    if watches.started then\n-      callback(path, M.FileChangeType.Created)\n+  local function create_on_change(filepath)\n+    return function(err, filename, events)\n+      assert(not err, err)\n+      local fullpath = vim.fs.joinpath(filepath, filename)\n+      if is_included(fullpath) and not is_excluded(filepath) then\n+        table.insert(changesets, {\n+          fullpath = fullpath,\n+          events = events,\n+        })\n+        timer:stop()\n+        timer:start(debounce, 0, process_changes)\n+      end\n     end\n   end\n \n-  if watches.is_dir then\n-    watches.children = watches.children or {}\n-    local exists = {} --- @type table<string,true>\n-    for name, ftype in vim.fs.dir(path) do\n-      exists[name] = true\n-      if not watches.children[name] then\n-        watches.children[name] = {\n-          is_dir = ftype == 'directory',\n-          started = watches.started,\n-        }\n-        poll_internal(filepath_join(path, name), opts, callback, watches.children[name])\n+  process_changes = function()\n+    ---@type table<string, table[]>\n+    local filechanges = vim.defaulttable()\n+    for i, change in ipairs(changesets) do\n+      changesets[i] = nil\n+      if is_included(change.fullpath) and not is_excluded(change.fullpath) then\n+        table.insert(filechanges[change.fullpath], change.events)\n       end\n     end\n-\n-    local newchildren = {} ---@type table<string,watch.Watches>\n-    for name, watch in pairs(watches.children) do\n-      if exists[name] then\n-        newchildren[name] = watch\n+    for fullpath, events_list in pairs(filechanges) do\n+      local stat = uv.fs_stat(fullpath)\n+      ---@type vim._watch.FileChangeType\n+      local change_type\n+      if stat then\n+        change_type = FileChangeType.Created\n+        for _, event in ipairs(events_list) do\n+          if event.change then\n+            change_type = FileChangeType.Changed\n+          end\n+        end\n+        if stat.type == 'directory' then\n+          local handle = assert(uv.new_fs_event())\n+          handles[fullpath] = handle\n+          handle:start(fullpath, uvflags, create_on_change(fullpath))\n+        end\n       else\n-        watch.cancel()\n-        watches.children[name] = nil\n-        if watch.handle then\n-          callback(path .. '/' .. name, M.FileChangeType.Deleted)\n+        local handle = handles[fullpath]\n+        if handle then\n+          if not handle:is_closing() then\n+            handle:close()\n+          end\n+          handles[fullpath] = nil\n         end\n+        change_type = FileChangeType.Deleted\n       end\n+      callback(fullpath, change_type)\n     end\n-    watches.children = newchildren\n   end\n-\n-  watches.started = true\n-\n-  return watches.cancel\n+  local root_handle = assert(uv.new_fs_event())\n+  handles[path] = root_handle\n+  root_handle:start(path, uvflags, create_on_change(path))\n+\n+  --- 640K ought to be enough for anyone",
            "html_url": "https://github.com/neovim/neovim/pull/26108#discussion_r1398378566",
            "id": 1398378566,
            "in_reply_to_id": 1398376809,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5TWZBG",
            "original_commit_id": "73955906975942e7dbdb22fcdaed3e75f79697c8",
            "original_line": 168,
            "original_position": 208,
            "original_start_line": null,
            "path": "runtime/lua/vim/_watch.lua",
            "position": null,
            "pull_request_review_id": 1738599817,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26108",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398378566/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-11-19T12:28:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398378566",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26108#discussion_r1398380332"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26108"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398380332"
                }
            },
            "author_association": "MEMBER",
            "body": "If a new directory gets created within a watched directory we need to start watching it for changes too. The stat call above should ensure it didn't exist,  but I'll add a check to see if a handle already exists in case there's some weird create-delete-create chain",
            "commit_id": "8b1f10e42490b4abe4914e96bea8b521c02ccc08",
            "created_at": "2023-11-19T11:19:16Z",
            "diff_hunk": "@@ -72,129 +76,127 @@ function M.watch(path, opts, callback)\n   end\n end\n \n-local default_poll_interval_ms = 2000\n-\n---- @class watch.Watches\n---- @field is_dir boolean\n---- @field children? table<string,watch.Watches>\n---- @field cancel? fun()\n---- @field started? boolean\n---- @field handle? uv.uv_fs_poll_t\n-\n --- @class watch.PollOpts\n---- @field interval? integer\n---- @field include_pattern? userdata\n---- @field exclude_pattern? userdata\n+--- @field debounce? integer\n+--- @field include_pattern? vim.lpeg.Pattern\n+--- @field exclude_pattern? vim.lpeg.Pattern\n \n---- Implementation for poll, hiding internally-used parameters.\n----\n ---@param path string\n ---@param opts watch.PollOpts\n----@param callback fun(patch: string, filechangetype: integer)\n----@param watches (watch.Watches|nil) A tree structure to maintain state for recursive watches.\n----     - handle (uv_fs_poll_t)\n----               The libuv handle\n----     - cancel (function)\n----               A function that cancels the handle and all children's handles\n----     - is_dir (boolean)\n----               Indicates whether the path is a directory (and the poll should\n----               be invoked recursively)\n----     - children (table|nil)\n----               A mapping of directory entry name to its recursive watches\n----     - started (boolean|nil)\n----               Whether or not the watcher has first been initialized. Used\n----               to prevent a flood of Created events on startup.\n----@return fun() Cancel function\n-local function poll_internal(path, opts, callback, watches)\n-  path = vim.fs.normalize(path)\n-  local interval = opts and opts.interval or default_poll_interval_ms\n-  watches = watches or {\n-    is_dir = true,\n-  }\n-  watches.cancel = function()\n-    if watches.children then\n-      for _, w in pairs(watches.children) do\n-        w.cancel()\n-      end\n-    end\n-    if watches.handle then\n-      stop(watches.handle)\n-    end\n+---@param callback function Called on new events\n+---@return function cancel stops the watcher\n+local function recurse_watch(path, opts, callback)\n+  opts = opts or {}\n+  local debounce = opts.debounce or 500\n+  local uvflags = {}\n+  ---@type table<string, uv.uv_fs_event_t> handle by fullpath\n+  local handles = {}\n+\n+  local timer = assert(uv.new_timer())\n+\n+  ---@type table[]\n+  local changesets = {}\n+\n+  local function is_included(filepath)\n+    return opts.include_pattern and opts.include_pattern:match(filepath)\n   end\n-\n-  local function incl_match()\n-    return not opts.include_pattern or opts.include_pattern:match(path) ~= nil\n-  end\n-  local function excl_match()\n-    return opts.exclude_pattern and opts.exclude_pattern:match(path) ~= nil\n+  local function is_excluded(filepath)\n+    return opts.exclude_pattern and opts.exclude_pattern:match(filepath)\n   end\n-  if not watches.is_dir and not incl_match() or excl_match() then\n-    return watches.cancel\n+\n+  local process_changes = function()\n+    assert(false, \"Replaced later. I'm only here as forward reference\")\n   end\n \n-  if not watches.handle then\n-    local poll, new_err = vim.uv.new_fs_poll()\n-    assert(not new_err, new_err)\n-    watches.handle = poll\n-    local _, start_err = poll:start(\n-      path,\n-      interval,\n-      vim.schedule_wrap(function(err)\n-        if err == 'ENOENT' then\n-          return\n-        end\n-        assert(not err, err)\n-        poll_internal(path, opts, callback, watches)\n-        callback(path, M.FileChangeType.Changed)\n-      end)\n-    )\n-    assert(not start_err, start_err)\n-    if watches.started then\n-      callback(path, M.FileChangeType.Created)\n+  local function create_on_change(filepath)\n+    return function(err, filename, events)\n+      assert(not err, err)\n+      local fullpath = vim.fs.joinpath(filepath, filename)\n+      if is_included(fullpath) and not is_excluded(filepath) then\n+        table.insert(changesets, {\n+          fullpath = fullpath,\n+          events = events,\n+        })\n+        timer:stop()\n+        timer:start(debounce, 0, process_changes)\n+      end\n     end\n   end\n \n-  if watches.is_dir then\n-    watches.children = watches.children or {}\n-    local exists = {} --- @type table<string,true>\n-    for name, ftype in vim.fs.dir(path) do\n-      exists[name] = true\n-      if not watches.children[name] then\n-        watches.children[name] = {\n-          is_dir = ftype == 'directory',\n-          started = watches.started,\n-        }\n-        poll_internal(filepath_join(path, name), opts, callback, watches.children[name])\n+  process_changes = function()\n+    ---@type table<string, table[]>\n+    local filechanges = vim.defaulttable()\n+    for i, change in ipairs(changesets) do\n+      changesets[i] = nil\n+      if is_included(change.fullpath) and not is_excluded(change.fullpath) then\n+        table.insert(filechanges[change.fullpath], change.events)\n       end\n     end\n-\n-    local newchildren = {} ---@type table<string,watch.Watches>\n-    for name, watch in pairs(watches.children) do\n-      if exists[name] then\n-        newchildren[name] = watch\n+    for fullpath, events_list in pairs(filechanges) do\n+      local stat = uv.fs_stat(fullpath)\n+      ---@type vim._watch.FileChangeType\n+      local change_type\n+      if stat then\n+        change_type = FileChangeType.Created\n+        for _, event in ipairs(events_list) do\n+          if event.change then\n+            change_type = FileChangeType.Changed\n+          end\n+        end\n+        if stat.type == 'directory' then\n+          local handle = assert(uv.new_fs_event())\n+          handles[fullpath] = handle\n+          handle:start(fullpath, uvflags, create_on_change(fullpath))",
            "html_url": "https://github.com/neovim/neovim/pull/26108#discussion_r1398380332",
            "id": 1398380332,
            "in_reply_to_id": 1398377983,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5TWZcs",
            "original_commit_id": "73955906975942e7dbdb22fcdaed3e75f79697c8",
            "original_line": 149,
            "original_position": 180,
            "original_start_line": null,
            "path": "runtime/lua/vim/_watch.lua",
            "position": null,
            "pull_request_review_id": 1738601398,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26108",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398380332/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-11-19T11:19:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398380332",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26108#discussion_r1398381269"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26108"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398381269"
                }
            },
            "author_association": "MEMBER",
            "body": "The stat call on line 136? Doesn't that just ensure the path exists?",
            "commit_id": "8b1f10e42490b4abe4914e96bea8b521c02ccc08",
            "created_at": "2023-11-19T11:25:43Z",
            "diff_hunk": "@@ -72,129 +76,127 @@ function M.watch(path, opts, callback)\n   end\n end\n \n-local default_poll_interval_ms = 2000\n-\n---- @class watch.Watches\n---- @field is_dir boolean\n---- @field children? table<string,watch.Watches>\n---- @field cancel? fun()\n---- @field started? boolean\n---- @field handle? uv.uv_fs_poll_t\n-\n --- @class watch.PollOpts\n---- @field interval? integer\n---- @field include_pattern? userdata\n---- @field exclude_pattern? userdata\n+--- @field debounce? integer\n+--- @field include_pattern? vim.lpeg.Pattern\n+--- @field exclude_pattern? vim.lpeg.Pattern\n \n---- Implementation for poll, hiding internally-used parameters.\n----\n ---@param path string\n ---@param opts watch.PollOpts\n----@param callback fun(patch: string, filechangetype: integer)\n----@param watches (watch.Watches|nil) A tree structure to maintain state for recursive watches.\n----     - handle (uv_fs_poll_t)\n----               The libuv handle\n----     - cancel (function)\n----               A function that cancels the handle and all children's handles\n----     - is_dir (boolean)\n----               Indicates whether the path is a directory (and the poll should\n----               be invoked recursively)\n----     - children (table|nil)\n----               A mapping of directory entry name to its recursive watches\n----     - started (boolean|nil)\n----               Whether or not the watcher has first been initialized. Used\n----               to prevent a flood of Created events on startup.\n----@return fun() Cancel function\n-local function poll_internal(path, opts, callback, watches)\n-  path = vim.fs.normalize(path)\n-  local interval = opts and opts.interval or default_poll_interval_ms\n-  watches = watches or {\n-    is_dir = true,\n-  }\n-  watches.cancel = function()\n-    if watches.children then\n-      for _, w in pairs(watches.children) do\n-        w.cancel()\n-      end\n-    end\n-    if watches.handle then\n-      stop(watches.handle)\n-    end\n+---@param callback function Called on new events\n+---@return function cancel stops the watcher\n+local function recurse_watch(path, opts, callback)\n+  opts = opts or {}\n+  local debounce = opts.debounce or 500\n+  local uvflags = {}\n+  ---@type table<string, uv.uv_fs_event_t> handle by fullpath\n+  local handles = {}\n+\n+  local timer = assert(uv.new_timer())\n+\n+  ---@type table[]\n+  local changesets = {}\n+\n+  local function is_included(filepath)\n+    return opts.include_pattern and opts.include_pattern:match(filepath)\n   end\n-\n-  local function incl_match()\n-    return not opts.include_pattern or opts.include_pattern:match(path) ~= nil\n-  end\n-  local function excl_match()\n-    return opts.exclude_pattern and opts.exclude_pattern:match(path) ~= nil\n+  local function is_excluded(filepath)\n+    return opts.exclude_pattern and opts.exclude_pattern:match(filepath)\n   end\n-  if not watches.is_dir and not incl_match() or excl_match() then\n-    return watches.cancel\n+\n+  local process_changes = function()\n+    assert(false, \"Replaced later. I'm only here as forward reference\")\n   end\n \n-  if not watches.handle then\n-    local poll, new_err = vim.uv.new_fs_poll()\n-    assert(not new_err, new_err)\n-    watches.handle = poll\n-    local _, start_err = poll:start(\n-      path,\n-      interval,\n-      vim.schedule_wrap(function(err)\n-        if err == 'ENOENT' then\n-          return\n-        end\n-        assert(not err, err)\n-        poll_internal(path, opts, callback, watches)\n-        callback(path, M.FileChangeType.Changed)\n-      end)\n-    )\n-    assert(not start_err, start_err)\n-    if watches.started then\n-      callback(path, M.FileChangeType.Created)\n+  local function create_on_change(filepath)\n+    return function(err, filename, events)\n+      assert(not err, err)\n+      local fullpath = vim.fs.joinpath(filepath, filename)\n+      if is_included(fullpath) and not is_excluded(filepath) then\n+        table.insert(changesets, {\n+          fullpath = fullpath,\n+          events = events,\n+        })\n+        timer:stop()\n+        timer:start(debounce, 0, process_changes)\n+      end\n     end\n   end\n \n-  if watches.is_dir then\n-    watches.children = watches.children or {}\n-    local exists = {} --- @type table<string,true>\n-    for name, ftype in vim.fs.dir(path) do\n-      exists[name] = true\n-      if not watches.children[name] then\n-        watches.children[name] = {\n-          is_dir = ftype == 'directory',\n-          started = watches.started,\n-        }\n-        poll_internal(filepath_join(path, name), opts, callback, watches.children[name])\n+  process_changes = function()\n+    ---@type table<string, table[]>\n+    local filechanges = vim.defaulttable()\n+    for i, change in ipairs(changesets) do\n+      changesets[i] = nil\n+      if is_included(change.fullpath) and not is_excluded(change.fullpath) then\n+        table.insert(filechanges[change.fullpath], change.events)\n       end\n     end\n-\n-    local newchildren = {} ---@type table<string,watch.Watches>\n-    for name, watch in pairs(watches.children) do\n-      if exists[name] then\n-        newchildren[name] = watch\n+    for fullpath, events_list in pairs(filechanges) do\n+      local stat = uv.fs_stat(fullpath)\n+      ---@type vim._watch.FileChangeType\n+      local change_type\n+      if stat then\n+        change_type = FileChangeType.Created\n+        for _, event in ipairs(events_list) do\n+          if event.change then\n+            change_type = FileChangeType.Changed\n+          end\n+        end\n+        if stat.type == 'directory' then\n+          local handle = assert(uv.new_fs_event())\n+          handles[fullpath] = handle\n+          handle:start(fullpath, uvflags, create_on_change(fullpath))",
            "html_url": "https://github.com/neovim/neovim/pull/26108#discussion_r1398381269",
            "id": 1398381269,
            "in_reply_to_id": 1398377983,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5TWZrV",
            "original_commit_id": "73955906975942e7dbdb22fcdaed3e75f79697c8",
            "original_line": 149,
            "original_position": 180,
            "original_start_line": null,
            "path": "runtime/lua/vim/_watch.lua",
            "position": null,
            "pull_request_review_id": 1738602594,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26108",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398381269/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-11-19T11:25:43Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398381269",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26108#discussion_r1398381307"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26108"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398381307"
                }
            },
            "author_association": "MEMBER",
            "body": "I think you're right:\r\n\r\n```\r\n#!/usr/bin/env -S v -l\r\n\r\nlocal timer = assert(vim.uv.new_timer())\r\n\r\ntimer:start(500, 0, function() vim.print(\"timer1\") end)\r\ntimer:start(3000, 0, function() vim.print(\"timer2\") end)\r\n\r\nvim.wait(10000)\r\n```\r\n\r\nOnly prints `timer2`, I'll remove the explicit stop call",
            "commit_id": "8b1f10e42490b4abe4914e96bea8b521c02ccc08",
            "created_at": "2023-11-19T11:26:07Z",
            "diff_hunk": "@@ -72,129 +76,127 @@ function M.watch(path, opts, callback)\n   end\n end\n \n-local default_poll_interval_ms = 2000\n-\n---- @class watch.Watches\n---- @field is_dir boolean\n---- @field children? table<string,watch.Watches>\n---- @field cancel? fun()\n---- @field started? boolean\n---- @field handle? uv.uv_fs_poll_t\n-\n --- @class watch.PollOpts\n---- @field interval? integer\n---- @field include_pattern? userdata\n---- @field exclude_pattern? userdata\n+--- @field debounce? integer\n+--- @field include_pattern? vim.lpeg.Pattern\n+--- @field exclude_pattern? vim.lpeg.Pattern\n \n---- Implementation for poll, hiding internally-used parameters.\n----\n ---@param path string\n ---@param opts watch.PollOpts\n----@param callback fun(patch: string, filechangetype: integer)\n----@param watches (watch.Watches|nil) A tree structure to maintain state for recursive watches.\n----     - handle (uv_fs_poll_t)\n----               The libuv handle\n----     - cancel (function)\n----               A function that cancels the handle and all children's handles\n----     - is_dir (boolean)\n----               Indicates whether the path is a directory (and the poll should\n----               be invoked recursively)\n----     - children (table|nil)\n----               A mapping of directory entry name to its recursive watches\n----     - started (boolean|nil)\n----               Whether or not the watcher has first been initialized. Used\n----               to prevent a flood of Created events on startup.\n----@return fun() Cancel function\n-local function poll_internal(path, opts, callback, watches)\n-  path = vim.fs.normalize(path)\n-  local interval = opts and opts.interval or default_poll_interval_ms\n-  watches = watches or {\n-    is_dir = true,\n-  }\n-  watches.cancel = function()\n-    if watches.children then\n-      for _, w in pairs(watches.children) do\n-        w.cancel()\n-      end\n-    end\n-    if watches.handle then\n-      stop(watches.handle)\n-    end\n+---@param callback function Called on new events\n+---@return function cancel stops the watcher\n+local function recurse_watch(path, opts, callback)\n+  opts = opts or {}\n+  local debounce = opts.debounce or 500\n+  local uvflags = {}\n+  ---@type table<string, uv.uv_fs_event_t> handle by fullpath\n+  local handles = {}\n+\n+  local timer = assert(uv.new_timer())\n+\n+  ---@type table[]\n+  local changesets = {}\n+\n+  local function is_included(filepath)\n+    return opts.include_pattern and opts.include_pattern:match(filepath)\n   end\n-\n-  local function incl_match()\n-    return not opts.include_pattern or opts.include_pattern:match(path) ~= nil\n-  end\n-  local function excl_match()\n-    return opts.exclude_pattern and opts.exclude_pattern:match(path) ~= nil\n+  local function is_excluded(filepath)\n+    return opts.exclude_pattern and opts.exclude_pattern:match(filepath)\n   end\n-  if not watches.is_dir and not incl_match() or excl_match() then\n-    return watches.cancel\n+\n+  local process_changes = function()\n+    assert(false, \"Replaced later. I'm only here as forward reference\")\n   end\n \n-  if not watches.handle then\n-    local poll, new_err = vim.uv.new_fs_poll()\n-    assert(not new_err, new_err)\n-    watches.handle = poll\n-    local _, start_err = poll:start(\n-      path,\n-      interval,\n-      vim.schedule_wrap(function(err)\n-        if err == 'ENOENT' then\n-          return\n-        end\n-        assert(not err, err)\n-        poll_internal(path, opts, callback, watches)\n-        callback(path, M.FileChangeType.Changed)\n-      end)\n-    )\n-    assert(not start_err, start_err)\n-    if watches.started then\n-      callback(path, M.FileChangeType.Created)\n+  local function create_on_change(filepath)\n+    return function(err, filename, events)\n+      assert(not err, err)\n+      local fullpath = vim.fs.joinpath(filepath, filename)\n+      if is_included(fullpath) and not is_excluded(filepath) then\n+        table.insert(changesets, {\n+          fullpath = fullpath,\n+          events = events,\n+        })\n+        timer:stop()",
            "html_url": "https://github.com/neovim/neovim/pull/26108#discussion_r1398381307",
            "id": 1398381307,
            "in_reply_to_id": 1398376518,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5TWZr7",
            "original_commit_id": "73955906975942e7dbdb22fcdaed3e75f79697c8",
            "original_line": 120,
            "original_position": 135,
            "original_start_line": null,
            "path": "runtime/lua/vim/_watch.lua",
            "position": null,
            "pull_request_review_id": 1738602642,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26108",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398381307/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-11-19T11:26:07Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398381307",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26108#discussion_r1398381713"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26108"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398381713"
                }
            },
            "author_association": "MEMBER",
            "body": "Ah wait. I think I follow since the watcher only checks for deletes, creates and renamed.",
            "commit_id": "8b1f10e42490b4abe4914e96bea8b521c02ccc08",
            "created_at": "2023-11-19T11:28:50Z",
            "diff_hunk": "@@ -72,129 +76,127 @@ function M.watch(path, opts, callback)\n   end\n end\n \n-local default_poll_interval_ms = 2000\n-\n---- @class watch.Watches\n---- @field is_dir boolean\n---- @field children? table<string,watch.Watches>\n---- @field cancel? fun()\n---- @field started? boolean\n---- @field handle? uv.uv_fs_poll_t\n-\n --- @class watch.PollOpts\n---- @field interval? integer\n---- @field include_pattern? userdata\n---- @field exclude_pattern? userdata\n+--- @field debounce? integer\n+--- @field include_pattern? vim.lpeg.Pattern\n+--- @field exclude_pattern? vim.lpeg.Pattern\n \n---- Implementation for poll, hiding internally-used parameters.\n----\n ---@param path string\n ---@param opts watch.PollOpts\n----@param callback fun(patch: string, filechangetype: integer)\n----@param watches (watch.Watches|nil) A tree structure to maintain state for recursive watches.\n----     - handle (uv_fs_poll_t)\n----               The libuv handle\n----     - cancel (function)\n----               A function that cancels the handle and all children's handles\n----     - is_dir (boolean)\n----               Indicates whether the path is a directory (and the poll should\n----               be invoked recursively)\n----     - children (table|nil)\n----               A mapping of directory entry name to its recursive watches\n----     - started (boolean|nil)\n----               Whether or not the watcher has first been initialized. Used\n----               to prevent a flood of Created events on startup.\n----@return fun() Cancel function\n-local function poll_internal(path, opts, callback, watches)\n-  path = vim.fs.normalize(path)\n-  local interval = opts and opts.interval or default_poll_interval_ms\n-  watches = watches or {\n-    is_dir = true,\n-  }\n-  watches.cancel = function()\n-    if watches.children then\n-      for _, w in pairs(watches.children) do\n-        w.cancel()\n-      end\n-    end\n-    if watches.handle then\n-      stop(watches.handle)\n-    end\n+---@param callback function Called on new events\n+---@return function cancel stops the watcher\n+local function recurse_watch(path, opts, callback)\n+  opts = opts or {}\n+  local debounce = opts.debounce or 500\n+  local uvflags = {}\n+  ---@type table<string, uv.uv_fs_event_t> handle by fullpath\n+  local handles = {}\n+\n+  local timer = assert(uv.new_timer())\n+\n+  ---@type table[]\n+  local changesets = {}\n+\n+  local function is_included(filepath)\n+    return opts.include_pattern and opts.include_pattern:match(filepath)\n   end\n-\n-  local function incl_match()\n-    return not opts.include_pattern or opts.include_pattern:match(path) ~= nil\n-  end\n-  local function excl_match()\n-    return opts.exclude_pattern and opts.exclude_pattern:match(path) ~= nil\n+  local function is_excluded(filepath)\n+    return opts.exclude_pattern and opts.exclude_pattern:match(filepath)\n   end\n-  if not watches.is_dir and not incl_match() or excl_match() then\n-    return watches.cancel\n+\n+  local process_changes = function()\n+    assert(false, \"Replaced later. I'm only here as forward reference\")\n   end\n \n-  if not watches.handle then\n-    local poll, new_err = vim.uv.new_fs_poll()\n-    assert(not new_err, new_err)\n-    watches.handle = poll\n-    local _, start_err = poll:start(\n-      path,\n-      interval,\n-      vim.schedule_wrap(function(err)\n-        if err == 'ENOENT' then\n-          return\n-        end\n-        assert(not err, err)\n-        poll_internal(path, opts, callback, watches)\n-        callback(path, M.FileChangeType.Changed)\n-      end)\n-    )\n-    assert(not start_err, start_err)\n-    if watches.started then\n-      callback(path, M.FileChangeType.Created)\n+  local function create_on_change(filepath)\n+    return function(err, filename, events)\n+      assert(not err, err)\n+      local fullpath = vim.fs.joinpath(filepath, filename)\n+      if is_included(fullpath) and not is_excluded(filepath) then\n+        table.insert(changesets, {\n+          fullpath = fullpath,\n+          events = events,\n+        })\n+        timer:stop()\n+        timer:start(debounce, 0, process_changes)\n+      end\n     end\n   end\n \n-  if watches.is_dir then\n-    watches.children = watches.children or {}\n-    local exists = {} --- @type table<string,true>\n-    for name, ftype in vim.fs.dir(path) do\n-      exists[name] = true\n-      if not watches.children[name] then\n-        watches.children[name] = {\n-          is_dir = ftype == 'directory',\n-          started = watches.started,\n-        }\n-        poll_internal(filepath_join(path, name), opts, callback, watches.children[name])\n+  process_changes = function()\n+    ---@type table<string, table[]>\n+    local filechanges = vim.defaulttable()\n+    for i, change in ipairs(changesets) do\n+      changesets[i] = nil\n+      if is_included(change.fullpath) and not is_excluded(change.fullpath) then\n+        table.insert(filechanges[change.fullpath], change.events)\n       end\n     end\n-\n-    local newchildren = {} ---@type table<string,watch.Watches>\n-    for name, watch in pairs(watches.children) do\n-      if exists[name] then\n-        newchildren[name] = watch\n+    for fullpath, events_list in pairs(filechanges) do\n+      local stat = uv.fs_stat(fullpath)\n+      ---@type vim._watch.FileChangeType\n+      local change_type\n+      if stat then\n+        change_type = FileChangeType.Created\n+        for _, event in ipairs(events_list) do\n+          if event.change then\n+            change_type = FileChangeType.Changed\n+          end\n+        end\n+        if stat.type == 'directory' then\n+          local handle = assert(uv.new_fs_event())\n+          handles[fullpath] = handle\n+          handle:start(fullpath, uvflags, create_on_change(fullpath))",
            "html_url": "https://github.com/neovim/neovim/pull/26108#discussion_r1398381713",
            "id": 1398381713,
            "in_reply_to_id": 1398377983,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5TWZyR",
            "original_commit_id": "73955906975942e7dbdb22fcdaed3e75f79697c8",
            "original_line": 149,
            "original_position": 180,
            "original_start_line": null,
            "path": "runtime/lua/vim/_watch.lua",
            "position": null,
            "pull_request_review_id": 1738603167,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26108",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398381713/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-11-19T11:28:51Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398381713",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/7904185?v=4",
                "events_url": "https://api.github.com/users/lewis6991/events{/privacy}",
                "followers_url": "https://api.github.com/users/lewis6991/followers",
                "following_url": "https://api.github.com/users/lewis6991/following{/other_user}",
                "gists_url": "https://api.github.com/users/lewis6991/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/lewis6991",
                "id": 7904185,
                "login": "lewis6991",
                "node_id": "MDQ6VXNlcjc5MDQxODU=",
                "organizations_url": "https://api.github.com/users/lewis6991/orgs",
                "received_events_url": "https://api.github.com/users/lewis6991/received_events",
                "repos_url": "https://api.github.com/users/lewis6991/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/lewis6991/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/lewis6991/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/lewis6991"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26108#discussion_r1398383027"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26108"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398383027"
                }
            },
            "author_association": "MEMBER",
            "body": "Yes, my thinking was that a folder either gets created or deleted, and otherwise there is no event.  But I actually didn't check what happens on permission changes or a touch.\r\n\r\nIn any case,  I pushed a fixup to check if a handle already exists",
            "commit_id": "8b1f10e42490b4abe4914e96bea8b521c02ccc08",
            "created_at": "2023-11-19T11:37:19Z",
            "diff_hunk": "@@ -72,129 +76,127 @@ function M.watch(path, opts, callback)\n   end\n end\n \n-local default_poll_interval_ms = 2000\n-\n---- @class watch.Watches\n---- @field is_dir boolean\n---- @field children? table<string,watch.Watches>\n---- @field cancel? fun()\n---- @field started? boolean\n---- @field handle? uv.uv_fs_poll_t\n-\n --- @class watch.PollOpts\n---- @field interval? integer\n---- @field include_pattern? userdata\n---- @field exclude_pattern? userdata\n+--- @field debounce? integer\n+--- @field include_pattern? vim.lpeg.Pattern\n+--- @field exclude_pattern? vim.lpeg.Pattern\n \n---- Implementation for poll, hiding internally-used parameters.\n----\n ---@param path string\n ---@param opts watch.PollOpts\n----@param callback fun(patch: string, filechangetype: integer)\n----@param watches (watch.Watches|nil) A tree structure to maintain state for recursive watches.\n----     - handle (uv_fs_poll_t)\n----               The libuv handle\n----     - cancel (function)\n----               A function that cancels the handle and all children's handles\n----     - is_dir (boolean)\n----               Indicates whether the path is a directory (and the poll should\n----               be invoked recursively)\n----     - children (table|nil)\n----               A mapping of directory entry name to its recursive watches\n----     - started (boolean|nil)\n----               Whether or not the watcher has first been initialized. Used\n----               to prevent a flood of Created events on startup.\n----@return fun() Cancel function\n-local function poll_internal(path, opts, callback, watches)\n-  path = vim.fs.normalize(path)\n-  local interval = opts and opts.interval or default_poll_interval_ms\n-  watches = watches or {\n-    is_dir = true,\n-  }\n-  watches.cancel = function()\n-    if watches.children then\n-      for _, w in pairs(watches.children) do\n-        w.cancel()\n-      end\n-    end\n-    if watches.handle then\n-      stop(watches.handle)\n-    end\n+---@param callback function Called on new events\n+---@return function cancel stops the watcher\n+local function recurse_watch(path, opts, callback)\n+  opts = opts or {}\n+  local debounce = opts.debounce or 500\n+  local uvflags = {}\n+  ---@type table<string, uv.uv_fs_event_t> handle by fullpath\n+  local handles = {}\n+\n+  local timer = assert(uv.new_timer())\n+\n+  ---@type table[]\n+  local changesets = {}\n+\n+  local function is_included(filepath)\n+    return opts.include_pattern and opts.include_pattern:match(filepath)\n   end\n-\n-  local function incl_match()\n-    return not opts.include_pattern or opts.include_pattern:match(path) ~= nil\n-  end\n-  local function excl_match()\n-    return opts.exclude_pattern and opts.exclude_pattern:match(path) ~= nil\n+  local function is_excluded(filepath)\n+    return opts.exclude_pattern and opts.exclude_pattern:match(filepath)\n   end\n-  if not watches.is_dir and not incl_match() or excl_match() then\n-    return watches.cancel\n+\n+  local process_changes = function()\n+    assert(false, \"Replaced later. I'm only here as forward reference\")\n   end\n \n-  if not watches.handle then\n-    local poll, new_err = vim.uv.new_fs_poll()\n-    assert(not new_err, new_err)\n-    watches.handle = poll\n-    local _, start_err = poll:start(\n-      path,\n-      interval,\n-      vim.schedule_wrap(function(err)\n-        if err == 'ENOENT' then\n-          return\n-        end\n-        assert(not err, err)\n-        poll_internal(path, opts, callback, watches)\n-        callback(path, M.FileChangeType.Changed)\n-      end)\n-    )\n-    assert(not start_err, start_err)\n-    if watches.started then\n-      callback(path, M.FileChangeType.Created)\n+  local function create_on_change(filepath)\n+    return function(err, filename, events)\n+      assert(not err, err)\n+      local fullpath = vim.fs.joinpath(filepath, filename)\n+      if is_included(fullpath) and not is_excluded(filepath) then\n+        table.insert(changesets, {\n+          fullpath = fullpath,\n+          events = events,\n+        })\n+        timer:stop()\n+        timer:start(debounce, 0, process_changes)\n+      end\n     end\n   end\n \n-  if watches.is_dir then\n-    watches.children = watches.children or {}\n-    local exists = {} --- @type table<string,true>\n-    for name, ftype in vim.fs.dir(path) do\n-      exists[name] = true\n-      if not watches.children[name] then\n-        watches.children[name] = {\n-          is_dir = ftype == 'directory',\n-          started = watches.started,\n-        }\n-        poll_internal(filepath_join(path, name), opts, callback, watches.children[name])\n+  process_changes = function()\n+    ---@type table<string, table[]>\n+    local filechanges = vim.defaulttable()\n+    for i, change in ipairs(changesets) do\n+      changesets[i] = nil\n+      if is_included(change.fullpath) and not is_excluded(change.fullpath) then\n+        table.insert(filechanges[change.fullpath], change.events)\n       end\n     end\n-\n-    local newchildren = {} ---@type table<string,watch.Watches>\n-    for name, watch in pairs(watches.children) do\n-      if exists[name] then\n-        newchildren[name] = watch\n+    for fullpath, events_list in pairs(filechanges) do\n+      local stat = uv.fs_stat(fullpath)\n+      ---@type vim._watch.FileChangeType\n+      local change_type\n+      if stat then\n+        change_type = FileChangeType.Created\n+        for _, event in ipairs(events_list) do\n+          if event.change then\n+            change_type = FileChangeType.Changed\n+          end\n+        end\n+        if stat.type == 'directory' then\n+          local handle = assert(uv.new_fs_event())\n+          handles[fullpath] = handle\n+          handle:start(fullpath, uvflags, create_on_change(fullpath))",
            "html_url": "https://github.com/neovim/neovim/pull/26108#discussion_r1398383027",
            "id": 1398383027,
            "in_reply_to_id": 1398377983,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5TWaGz",
            "original_commit_id": "73955906975942e7dbdb22fcdaed3e75f79697c8",
            "original_line": 149,
            "original_position": 180,
            "original_start_line": null,
            "path": "runtime/lua/vim/_watch.lua",
            "position": null,
            "pull_request_review_id": 1738604409,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26108",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398383027/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2023-11-19T11:37:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1398383027",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            }
        }
    ],
    "comment_regular_data": [],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/26108/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/26108/commits",
    "created_at": "2023-11-19T10:12:29Z",
    "diff_url": "https://github.com/neovim/neovim/pull/26108.diff",
    "draft": false,
    "head": {
        "label": "mfussenegger:lsp-watch",
        "ref": "lsp-watch",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/mfussenegger/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/mfussenegger/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/mfussenegger/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/mfussenegger/neovim/branches{/branch}",
            "clone_url": "https://github.com/mfussenegger/neovim.git",
            "collaborators_url": "https://api.github.com/repos/mfussenegger/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/mfussenegger/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/mfussenegger/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/mfussenegger/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/mfussenegger/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/mfussenegger/neovim/contributors",
            "created_at": "2020-01-25T15:44:28Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/mfussenegger/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/mfussenegger/neovim/downloads",
            "events_url": "https://api.github.com/repos/mfussenegger/neovim/events",
            "fork": true,
            "forks": 1,
            "forks_count": 1,
            "forks_url": "https://api.github.com/repos/mfussenegger/neovim/forks",
            "full_name": "mfussenegger/neovim",
            "git_commits_url": "https://api.github.com/repos/mfussenegger/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/mfussenegger/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/mfussenegger/neovim/git/tags{/sha}",
            "git_url": "git://github.com/mfussenegger/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/mfussenegger/neovim/hooks",
            "html_url": "https://github.com/mfussenegger/neovim",
            "id": 236190222,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/mfussenegger/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/mfussenegger/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/mfussenegger/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/mfussenegger/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/mfussenegger/neovim/labels{/name}",
            "language": "Vim script",
            "languages_url": "https://api.github.com/repos/mfussenegger/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/mfussenegger/neovim/merges",
            "milestones_url": "https://api.github.com/repos/mfussenegger/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkyMzYxOTAyMjI=",
            "notifications_url": "https://api.github.com/repos/mfussenegger/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
                "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
                "followers_url": "https://api.github.com/users/mfussenegger/followers",
                "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
                "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/mfussenegger",
                "id": 38700,
                "login": "mfussenegger",
                "node_id": "MDQ6VXNlcjM4NzAw",
                "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
                "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
                "repos_url": "https://api.github.com/users/mfussenegger/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/mfussenegger"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/mfussenegger/neovim/pulls{/number}",
            "pushed_at": "2023-11-19T17:37:52Z",
            "releases_url": "https://api.github.com/repos/mfussenegger/neovim/releases{/id}",
            "size": 228786,
            "ssh_url": "git@github.com:mfussenegger/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/mfussenegger/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/mfussenegger/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/mfussenegger/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/mfussenegger/neovim/subscription",
            "svn_url": "https://github.com/mfussenegger/neovim",
            "tags_url": "https://api.github.com/repos/mfussenegger/neovim/tags",
            "teams_url": "https://api.github.com/repos/mfussenegger/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/mfussenegger/neovim/git/trees{/sha}",
            "updated_at": "2023-07-25T14:32:22Z",
            "url": "https://api.github.com/repos/mfussenegger/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "8b1f10e42490b4abe4914e96bea8b521c02ccc08",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
            "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
            "followers_url": "https://api.github.com/users/mfussenegger/followers",
            "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
            "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/mfussenegger",
            "id": 38700,
            "login": "mfussenegger",
            "node_id": "MDQ6VXNlcjM4NzAw",
            "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
            "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
            "repos_url": "https://api.github.com/users/mfussenegger/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/mfussenegger"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/26108",
    "id": 1607869636,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/26108",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": null,
            "id": 662566370,
            "name": "lsp",
            "node_id": "MDU6TGFiZWw2NjI1NjYzNzA=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/lsp"
        }
    ],
    "locked": false,
    "merge_commit_sha": "de28a0f84c577e264f37cd001b03d640db7d5ef9",
    "merged_at": "2023-11-19T13:25:32Z",
    "milestone": null,
    "node_id": "PR_kwDOAPphoM5f1iTE",
    "number": 26108,
    "patch_url": "https://github.com/neovim/neovim/pull/26108.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/26108/comments",
    "state": "closed",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/8b1f10e42490b4abe4914e96bea8b521c02ccc08",
    "title": "perf(lsp): use one watcher per directory instead of per file",
    "updated_at": "2023-11-19T13:25:48Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/26108",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/38700?v=4",
        "events_url": "https://api.github.com/users/mfussenegger/events{/privacy}",
        "followers_url": "https://api.github.com/users/mfussenegger/followers",
        "following_url": "https://api.github.com/users/mfussenegger/following{/other_user}",
        "gists_url": "https://api.github.com/users/mfussenegger/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/mfussenegger",
        "id": 38700,
        "login": "mfussenegger",
        "node_id": "MDQ6VXNlcjM4NzAw",
        "organizations_url": "https://api.github.com/users/mfussenegger/orgs",
        "received_events_url": "https://api.github.com/users/mfussenegger/received_events",
        "repos_url": "https://api.github.com/users/mfussenegger/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/mfussenegger/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/mfussenegger/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/mfussenegger"
    }
}