{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/26989/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/26989/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/26989"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/26989"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/26989/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/89975f60c10b33ad36a728a267acb3f2ccb2e25b"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 5201,
            "forks_count": 5201,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1728,
            "open_issues_count": 1728,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2024-02-12T23:38:13Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 252813,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 73720,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2024-02-13T01:34:21Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 73720,
            "watchers_count": 73720,
            "web_commit_signoff_required": false
        },
        "sha": "2dc439c672facaeb8e51ef6aa20efc0e7092eee2",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim"
        }
    },
    "body": "\r\n- Add section `VIM.LPEG` and `VIM.RE` to docs/lua.txt.\r\n\r\n- Add `_meta/re.lua` which adds luadoc and type annotations, for the\r\n  vendored `vim.re` package.\r\n\r\n- Fix minor style issues on `_meta/lpeg.lua` luadoc for better vimdocs\r\n  generation.\r\n\r\n- Fix a bug on `gen_vimdoc` where non-helptags in verbatim code blocks\r\n  were parsed as helptags, affecting code examples on `vim.lpeg.Cf`,\r\n  etc.\r\n\r\n- Also move the `vim.regex` section below so that it can be located\r\n  closer to `vim.lpeg` and `vim.re`.\r\n\r\n\r\n\r\n\r\n\r\n\r\n## Relevant issues\r\n\r\n- #23216 added lpeg\r\n- #25016 lpeg v1.1.0, added vendored `re.lua`\r\n- #24363 `vim.regex` docs added\r\n- #25311 typing for `vim.lpeg`\r\n- Closes #26194\r\n- Suprsedes #26199, lacking automation /cc @EraldCaka",
    "closed_at": "2024-01-14T11:08:33Z",
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1449179411"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449179411"
                }
            },
            "author_association": "MEMBER",
            "body": "I feel the tag here should be fixed to `*vim.lpeg.Pattern:match()*`, it's weird to strip off the fstem prefix for this method only. See https://github.com/neovim/neovim/pull/24363#discussion_r1265364176\r\n\r\nIf I remove the following `fn_helptag_fmt` rule:\r\n```python\r\n            # Exclude fstem for methods\r\n            f'*{name}()*' if ':' in name else\r\n```\r\n`vim.Iter:*()`, `vim.Ringbuf:*()` will be affected.\r\n\r\nShould I handle this as an exception?",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-11T17:27:35Z",
            "diff_hunk": "@@ -3034,6 +3027,363 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+The Lpeg library for parsing expression grammars is being included as\n+`vim.lpeg` (https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+                                                                    *vim.re*\n+In addition, its regex-like interface is available as\n+`vim.re` (https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example:>lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *\n+          return lpeg.match(p, s)\n+        end\n+        local a, b, c = split('a,b,c', ',')\n+        assert(a == 'a')\n+        assert(b == 'b')\n+        assert(c == 'c')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Carg({n})                                           *vim.lpeg.Carg()*\n+    Creates an argument capture. This pattern matches the empty string and\n+    produces the value given as the nth extra argument given in the call to `lpeg.match` .\n+\n+    Parameters: ~\n+      • {n}  (`integer`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cb({name})                                            *vim.lpeg.Cb()*\n+    Creates a back capture. This pattern matches the empty string and produces\n+    the values produced by the most recent group capture named `name` (where\n+    `name` can be any Lua value). Most recent means the last complete\n+    outermost group capture with the given name. A Complete capture means that\n+    the entire pattern corresponding to the capture has matched. An Outermost\n+    capture means that the capture is not inside another complete capture. In\n+    the same way that LPeg does not specify when it evaluates captures, it\n+    does not specify whether it reuses values previously produced by the group\n+    or re-evaluates them.\n+\n+    Parameters: ~\n+      • {name}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cc({...})                                             *vim.lpeg.Cc()*\n+    Creates a constant capture. This pattern matches the empty string and\n+    produces all given values as its captured values.\n+\n+    Parameters: ~\n+      • {...}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cf({patt}, {func})                                    *vim.lpeg.Cf()*\n+    Creates a fold capture. If `patt` produces a list of captures C1 C2 ...\n+    Cn, this capture will produce the value `func(...func(func(C1, C2),\n+    C3)...,Cn)`, that is, it will fold (or accumulate, or reduce) the captures\n+    from `patt` using function `func`. This capture assumes that `patt` should\n+    produce at least one capture with at least one value (of any type), which\n+    becomes the initial value of an accumulator. (If you need a specific\n+    initial value, you may prefix a constant captureto `patt`.) For each\n+    subsequent capture, LPeg calls `func` with this accumulator as the first\n+    argument and all values produced by the capture as extra arguments; the\n+    first result from this call becomes the new value for the accumulator. The\n+    final value of the accumulator becomes the captured value.\n+\n+    Example:>lua\n+        local number = lpeg.R(\"09\") ^ 1 / tonumber\n+        local list = numbernumber) ^ 0                                * (\",\" *\n+        local function add(acc, newvalue) return acc + newvalue end\n+        local sum = lpeg.Cf(list, add)\n+        assert(sum:match(\"10,30,43\") == 83)\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {func}  (`fun(acc, newvalue)`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cg({patt}, {name})                                    *vim.lpeg.Cg()*\n+    Creates a group capture. It groups all values returned by `patt` into a\n+    single capture. The group may be anonymous (if no name is given) or named\n+    with the given name (which can be any non-nil Lua value).\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {name}  (`string?`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cmt({patt}, {fn})                                    *vim.lpeg.Cmt()*\n+    Creates a match-time capture. Unlike all other captures, this one is\n+    evaluated immediately when a match occurs (even if it is part of a larger\n+    pattern that fails later). It forces the immediate evaluation of all its\n+    nested captures and then calls `function`. The given function gets as\n+    arguments the entire subject, the current position (after the match of\n+    `patt`), plus any capture values produced by `patt`. The first value\n+    returned by `function` defines how the match happens. If the call returns\n+    a number, the match succeeds and the returned number becomes the new\n+    current position. (Assuming a subject sand current position i, the\n+    returned number must be in the range [i, len(s) + 1].) If the call returns\n+    true, the match succeeds without consuming any input (so, to return true\n+    is equivalent to return i). If the call returns false, nil, or no value,\n+    the match fails. Any extra values returned by the function become the\n+    values produced by the capture.\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {fn}    (`function`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cp()                                                  *vim.lpeg.Cp()*\n+    Creates a position capture. It matches the empty string and captures the\n+    position in the subject where the match occurs. The captured value is a\n+    number.\n+\n+    Example:>lua\n+        local I = lpeg.Cp()\n+        local function anywhere(p) return lpeg.P({II + 1 * lpeg.V(1)}) end * p *\n+        local match_start, match_end = anywhere(\"world\"):match(\"hello world!\")\n+        assert(match_start == 7)\n+        assert(match_end == 12)\n+<\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cs({patt})                                            *vim.lpeg.Cs()*\n+    Creates a substitution capture. This function creates a substitution\n+    capture, which captures the substring of the subject that matches `patt`,\n+    with substitutions. For any capture inside `patt` with a value, the\n+    substring that matched the capture is replaced by the capture value (which\n+    should be a string). The final captured value is the string resulting from\n+    all replacements.\n+\n+    Example:>lua\n+        local function gsub (s, patt, repl)\n+          patt = lpeg.P(patt)\n+          patt = lpeg.Cs((patt / repl + 1)^0)\n+          return lpeg.match(patt, s)\n+        end\n+        assert(gsub('Hello, xxx!', 'xxx', 'World') == 'Hello, World!')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Ct({patt})                                            *vim.lpeg.Ct()*\n+    Creates a table capture. This capture returns a table with all values from\n+    all anonymous captures made by `patt` inside this table in successive\n+    integer keys, starting at 1. Moreover, for each named capture group\n+    created by `patt`, the first value of the group is put into the table with\n+    the group name as its key. The captured value is only the table.\n+\n+    Parameters: ~\n+      • {patt}  (vim.lpeg.Pattern |' `) @return (` vim.lpeg.Capture`)\n+\n+vim.lpeg.lpeg                                                     *vim.lpeg()*\n+    LPeg is a new pattern-matching library for Lua, based on Parsing Expression\n+    Grammars (PEGs).\n+\n+vim.lpeg.match({pattern}, {subject}, {init})                *vim.lpeg.match()*\n+    Matches the given `pattern` against the `subject` string. If the match\n+    succeeds, returns the index in the subject of the first character after\n+    the match, or the captured values (if the pattern captured any value). An\n+    optional numeric argument `init` makes the match start at that position in\n+    the subject string. As usual in Lua libraries, a negative value counts\n+    from the end. Unlike typical pattern-matching functions, `match` works\n+    only in anchored mode; that is, it tries to match the pattern with a\n+    prefix of the given subject string (at position `init`), not with an\n+    arbitrary substring of the subject. So, if we want to find a pattern\n+    anywhere in a string, we must either write a loop in Lua or write a\n+    pattern that matches anywhere.\n+\n+    Example:>lua\n+        local pattern = lpeg.R(\"az\") ^ 1 * -1\n+        assert(pattern:match(\"hello\") == 6)\n+        assert(lpeg.match(pattern, \"hello\") == 6)\n+        assert(pattern:match(\"1 hello\") == nil)\n+<\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+      • {subject}  (`string`)\n+      • {init}     (`integer?`)\n+\n+    Return: ~\n+        (`integer|vim.lpeg.Capture?`)\n+\n+vim.lpeg.P({value})                                             *vim.lpeg.P()*\n+    Converts the given value into a proper pattern. This following rules are\n+    applied:\n+    • If the argument is a pattern, it is returned unmodified.\n+    • If the argument is a string, it is translated to a pattern that matches\n+      the string literally.\n+    • If the argument is a non-negative number `n`, the result is a pattern\n+      that matches exactly `n` characters.\n+    • If the argument is a negative number `-n`, the result is a pattern that\n+      succeeds only if the input string has less than `n` characters left:\n+      `lpeg.P(-n)` is equivalent to `-lpeg.P(n)` (see the unary minus\n+      operation).\n+    • If the argument is a boolean, the result is a pattern that always\n+      succeeds or always fails (according to the boolean value), without\n+      consuming any input.\n+    • If the argument is a table, it is interpreted as a grammar (see\n+      Grammars).\n+    • If the argument is a function, returns a pattern equivalent to a\n+      match-time captureover the empty string.\n+\n+    Parameters: ~\n+      • {value}  (`vim.lpeg.Pattern|string|integer|boolean|table|function`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.Pattern:match({subject}, {init})                    *Pattern:match()*",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1449179411",
            "id": 1449179411,
            "line": 3246,
            "node_id": "PRRC_kwDOAPphoM5WYLkT",
            "original_commit_id": "7fb339b2fd9438feeffc1a6461ba35444203690a",
            "original_line": 3246,
            "original_position": 373,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 327,
            "pull_request_review_id": 1816108196,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449179411/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-11T17:46:17Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449179411",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1449193466"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449193466"
                }
            },
            "author_association": "MEMBER",
            "body": "What's sauce for the goose is sauce for the ganter. Either we consistently strip the leading module for objects or we don't -- `vim.lpeg` is not special.\r\n\r\nI don't care much either way, but I'd check for tag _links_ to these anchors in our documentation first; that will tell us what effect keeping the module will have.",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-11T17:38:52Z",
            "diff_hunk": "@@ -3034,6 +3027,363 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+The Lpeg library for parsing expression grammars is being included as\n+`vim.lpeg` (https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+                                                                    *vim.re*\n+In addition, its regex-like interface is available as\n+`vim.re` (https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example:>lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *\n+          return lpeg.match(p, s)\n+        end\n+        local a, b, c = split('a,b,c', ',')\n+        assert(a == 'a')\n+        assert(b == 'b')\n+        assert(c == 'c')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Carg({n})                                           *vim.lpeg.Carg()*\n+    Creates an argument capture. This pattern matches the empty string and\n+    produces the value given as the nth extra argument given in the call to `lpeg.match` .\n+\n+    Parameters: ~\n+      • {n}  (`integer`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cb({name})                                            *vim.lpeg.Cb()*\n+    Creates a back capture. This pattern matches the empty string and produces\n+    the values produced by the most recent group capture named `name` (where\n+    `name` can be any Lua value). Most recent means the last complete\n+    outermost group capture with the given name. A Complete capture means that\n+    the entire pattern corresponding to the capture has matched. An Outermost\n+    capture means that the capture is not inside another complete capture. In\n+    the same way that LPeg does not specify when it evaluates captures, it\n+    does not specify whether it reuses values previously produced by the group\n+    or re-evaluates them.\n+\n+    Parameters: ~\n+      • {name}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cc({...})                                             *vim.lpeg.Cc()*\n+    Creates a constant capture. This pattern matches the empty string and\n+    produces all given values as its captured values.\n+\n+    Parameters: ~\n+      • {...}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cf({patt}, {func})                                    *vim.lpeg.Cf()*\n+    Creates a fold capture. If `patt` produces a list of captures C1 C2 ...\n+    Cn, this capture will produce the value `func(...func(func(C1, C2),\n+    C3)...,Cn)`, that is, it will fold (or accumulate, or reduce) the captures\n+    from `patt` using function `func`. This capture assumes that `patt` should\n+    produce at least one capture with at least one value (of any type), which\n+    becomes the initial value of an accumulator. (If you need a specific\n+    initial value, you may prefix a constant captureto `patt`.) For each\n+    subsequent capture, LPeg calls `func` with this accumulator as the first\n+    argument and all values produced by the capture as extra arguments; the\n+    first result from this call becomes the new value for the accumulator. The\n+    final value of the accumulator becomes the captured value.\n+\n+    Example:>lua\n+        local number = lpeg.R(\"09\") ^ 1 / tonumber\n+        local list = numbernumber) ^ 0                                * (\",\" *\n+        local function add(acc, newvalue) return acc + newvalue end\n+        local sum = lpeg.Cf(list, add)\n+        assert(sum:match(\"10,30,43\") == 83)\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {func}  (`fun(acc, newvalue)`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cg({patt}, {name})                                    *vim.lpeg.Cg()*\n+    Creates a group capture. It groups all values returned by `patt` into a\n+    single capture. The group may be anonymous (if no name is given) or named\n+    with the given name (which can be any non-nil Lua value).\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {name}  (`string?`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cmt({patt}, {fn})                                    *vim.lpeg.Cmt()*\n+    Creates a match-time capture. Unlike all other captures, this one is\n+    evaluated immediately when a match occurs (even if it is part of a larger\n+    pattern that fails later). It forces the immediate evaluation of all its\n+    nested captures and then calls `function`. The given function gets as\n+    arguments the entire subject, the current position (after the match of\n+    `patt`), plus any capture values produced by `patt`. The first value\n+    returned by `function` defines how the match happens. If the call returns\n+    a number, the match succeeds and the returned number becomes the new\n+    current position. (Assuming a subject sand current position i, the\n+    returned number must be in the range [i, len(s) + 1].) If the call returns\n+    true, the match succeeds without consuming any input (so, to return true\n+    is equivalent to return i). If the call returns false, nil, or no value,\n+    the match fails. Any extra values returned by the function become the\n+    values produced by the capture.\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {fn}    (`function`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cp()                                                  *vim.lpeg.Cp()*\n+    Creates a position capture. It matches the empty string and captures the\n+    position in the subject where the match occurs. The captured value is a\n+    number.\n+\n+    Example:>lua\n+        local I = lpeg.Cp()\n+        local function anywhere(p) return lpeg.P({II + 1 * lpeg.V(1)}) end * p *\n+        local match_start, match_end = anywhere(\"world\"):match(\"hello world!\")\n+        assert(match_start == 7)\n+        assert(match_end == 12)\n+<\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cs({patt})                                            *vim.lpeg.Cs()*\n+    Creates a substitution capture. This function creates a substitution\n+    capture, which captures the substring of the subject that matches `patt`,\n+    with substitutions. For any capture inside `patt` with a value, the\n+    substring that matched the capture is replaced by the capture value (which\n+    should be a string). The final captured value is the string resulting from\n+    all replacements.\n+\n+    Example:>lua\n+        local function gsub (s, patt, repl)\n+          patt = lpeg.P(patt)\n+          patt = lpeg.Cs((patt / repl + 1)^0)\n+          return lpeg.match(patt, s)\n+        end\n+        assert(gsub('Hello, xxx!', 'xxx', 'World') == 'Hello, World!')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Ct({patt})                                            *vim.lpeg.Ct()*\n+    Creates a table capture. This capture returns a table with all values from\n+    all anonymous captures made by `patt` inside this table in successive\n+    integer keys, starting at 1. Moreover, for each named capture group\n+    created by `patt`, the first value of the group is put into the table with\n+    the group name as its key. The captured value is only the table.\n+\n+    Parameters: ~\n+      • {patt}  (vim.lpeg.Pattern |' `) @return (` vim.lpeg.Capture`)\n+\n+vim.lpeg.lpeg                                                     *vim.lpeg()*\n+    LPeg is a new pattern-matching library for Lua, based on Parsing Expression\n+    Grammars (PEGs).\n+\n+vim.lpeg.match({pattern}, {subject}, {init})                *vim.lpeg.match()*\n+    Matches the given `pattern` against the `subject` string. If the match\n+    succeeds, returns the index in the subject of the first character after\n+    the match, or the captured values (if the pattern captured any value). An\n+    optional numeric argument `init` makes the match start at that position in\n+    the subject string. As usual in Lua libraries, a negative value counts\n+    from the end. Unlike typical pattern-matching functions, `match` works\n+    only in anchored mode; that is, it tries to match the pattern with a\n+    prefix of the given subject string (at position `init`), not with an\n+    arbitrary substring of the subject. So, if we want to find a pattern\n+    anywhere in a string, we must either write a loop in Lua or write a\n+    pattern that matches anywhere.\n+\n+    Example:>lua\n+        local pattern = lpeg.R(\"az\") ^ 1 * -1\n+        assert(pattern:match(\"hello\") == 6)\n+        assert(lpeg.match(pattern, \"hello\") == 6)\n+        assert(pattern:match(\"1 hello\") == nil)\n+<\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+      • {subject}  (`string`)\n+      • {init}     (`integer?`)\n+\n+    Return: ~\n+        (`integer|vim.lpeg.Capture?`)\n+\n+vim.lpeg.P({value})                                             *vim.lpeg.P()*\n+    Converts the given value into a proper pattern. This following rules are\n+    applied:\n+    • If the argument is a pattern, it is returned unmodified.\n+    • If the argument is a string, it is translated to a pattern that matches\n+      the string literally.\n+    • If the argument is a non-negative number `n`, the result is a pattern\n+      that matches exactly `n` characters.\n+    • If the argument is a negative number `-n`, the result is a pattern that\n+      succeeds only if the input string has less than `n` characters left:\n+      `lpeg.P(-n)` is equivalent to `-lpeg.P(n)` (see the unary minus\n+      operation).\n+    • If the argument is a boolean, the result is a pattern that always\n+      succeeds or always fails (according to the boolean value), without\n+      consuming any input.\n+    • If the argument is a table, it is interpreted as a grammar (see\n+      Grammars).\n+    • If the argument is a function, returns a pattern equivalent to a\n+      match-time captureover the empty string.\n+\n+    Parameters: ~\n+      • {value}  (`vim.lpeg.Pattern|string|integer|boolean|table|function`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.Pattern:match({subject}, {init})                    *Pattern:match()*",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1449193466",
            "id": 1449193466,
            "in_reply_to_id": 1449179411,
            "line": 3246,
            "node_id": "PRRC_kwDOAPphoM5WYO_6",
            "original_commit_id": "7fb339b2fd9438feeffc1a6461ba35444203690a",
            "original_line": 3246,
            "original_position": 373,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 327,
            "pull_request_review_id": 1816128625,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 3,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 3,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449193466/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-11T17:38:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449193466",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1449323052"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449323052"
                }
            },
            "author_association": "MEMBER",
            "body": "Broken lua type parsing, should be fixed.",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-11T19:49:25Z",
            "diff_hunk": "@@ -3034,6 +2984,473 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+The Lpeg library for parsing expression grammars is being included as\n+`vim.lpeg` (https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as\n+|vim.re| (https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example:>lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *\n+          return lpeg.match(p, s)\n+        end\n+        local a, b, c = split('a,b,c', ',')\n+        assert(a == 'a')\n+        assert(b == 'b')\n+        assert(c == 'c')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Carg({n})                                           *vim.lpeg.Carg()*\n+    Creates an argument capture. This pattern matches the empty string and\n+    produces the value given as the nth extra argument given in the call to `lpeg.match` .\n+\n+    Parameters: ~\n+      • {n}  (`integer`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cb({name})                                            *vim.lpeg.Cb()*\n+    Creates a back capture. This pattern matches the empty string and produces\n+    the values produced by the most recent group capture named `name` (where\n+    `name` can be any Lua value). Most recent means the last complete\n+    outermost group capture with the given name. A Complete capture means that\n+    the entire pattern corresponding to the capture has matched. An Outermost\n+    capture means that the capture is not inside another complete capture. In\n+    the same way that LPeg does not specify when it evaluates captures, it\n+    does not specify whether it reuses values previously produced by the group\n+    or re-evaluates them.\n+\n+    Parameters: ~\n+      • {name}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cc({...})                                             *vim.lpeg.Cc()*\n+    Creates a constant capture. This pattern matches the empty string and\n+    produces all given values as its captured values.\n+\n+    Parameters: ~\n+      • {...}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cf({patt}, {func})                                    *vim.lpeg.Cf()*\n+    Creates a fold capture. If `patt` produces a list of captures C1 C2 ...\n+    Cn, this capture will produce the value `func(...func(func(C1, C2),\n+    C3)...,Cn)`, that is, it will fold (or accumulate, or reduce) the captures\n+    from `patt` using function `func`. This capture assumes that `patt` should\n+    produce at least one capture with at least one value (of any type), which\n+    becomes the initial value of an accumulator. (If you need a specific\n+    initial value, you may prefix a constant captureto `patt`.) For each\n+    subsequent capture, LPeg calls `func` with this accumulator as the first\n+    argument and all values produced by the capture as extra arguments; the\n+    first result from this call becomes the new value for the accumulator. The\n+    final value of the accumulator becomes the captured value.\n+\n+    Example:>lua\n+        local number = lpeg.R(\"09\") ^ 1 / tonumber\n+        local list = numbernumber) ^ 0                                * (\",\" *\n+        local function add(acc, newvalue) return acc + newvalue end\n+        local sum = lpeg.Cf(list, add)\n+        assert(sum:match(\"10,30,43\") == 83)\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {func}  (`fun(acc, newvalue)`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cg({patt}, {name})                                    *vim.lpeg.Cg()*\n+    Creates a group capture. It groups all values returned by `patt` into a\n+    single capture. The group may be anonymous (if no name is given) or named\n+    with the given name (which can be any non-nil Lua value).\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {name}  (`string?`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cmt({patt}, {fn})                                    *vim.lpeg.Cmt()*\n+    Creates a match-time capture. Unlike all other captures, this one is\n+    evaluated immediately when a match occurs (even if it is part of a larger\n+    pattern that fails later). It forces the immediate evaluation of all its\n+    nested captures and then calls `function`. The given function gets as\n+    arguments the entire subject, the current position (after the match of\n+    `patt`), plus any capture values produced by `patt`. The first value\n+    returned by `function` defines how the match happens. If the call returns\n+    a number, the match succeeds and the returned number becomes the new\n+    current position. (Assuming a subject sand current position i, the\n+    returned number must be in the range [i, len(s) + 1].) If the call returns\n+    true, the match succeeds without consuming any input (so, to return true\n+    is equivalent to return i). If the call returns false, nil, or no value,\n+    the match fails. Any extra values returned by the function become the\n+    values produced by the capture.\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {fn}    (`function`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cp()                                                  *vim.lpeg.Cp()*\n+    Creates a position capture. It matches the empty string and captures the\n+    position in the subject where the match occurs. The captured value is a\n+    number.\n+\n+    Example:>lua\n+        local I = lpeg.Cp()\n+        local function anywhere(p) return lpeg.P({II + 1 * lpeg.V(1)}) end * p *\n+        local match_start, match_end = anywhere(\"world\"):match(\"hello world!\")\n+        assert(match_start == 7)\n+        assert(match_end == 12)\n+<\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cs({patt})                                            *vim.lpeg.Cs()*\n+    Creates a substitution capture. This function creates a substitution\n+    capture, which captures the substring of the subject that matches `patt`,\n+    with substitutions. For any capture inside `patt` with a value, the\n+    substring that matched the capture is replaced by the capture value (which\n+    should be a string). The final captured value is the string resulting from\n+    all replacements.\n+\n+    Example:>lua\n+        local function gsub (s, patt, repl)\n+          patt = lpeg.P(patt)\n+          patt = lpeg.Cs((patt / repl + 1)^0)\n+          return lpeg.match(patt, s)\n+        end\n+        assert(gsub('Hello, xxx!', 'xxx', 'World') == 'Hello, World!')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Ct({patt})                                            *vim.lpeg.Ct()*\n+    Creates a table capture. This capture returns a table with all values from\n+    all anonymous captures made by `patt` inside this table in successive\n+    integer keys, starting at 1. Moreover, for each named capture group\n+    created by `patt`, the first value of the group is put into the table with\n+    the group name as its key. The captured value is only the table.\n+\n+    Parameters: ~\n+      • {patt}  (vim.lpeg.Pattern |' `) @return (` vim.lpeg.Capture`)",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1449323052",
            "id": 1449323052,
            "line": 3186,
            "node_id": "PRRC_kwDOAPphoM5WYuos",
            "original_commit_id": "fbb615b921d2310b81bb5b769fb9fd930f2fb8fa",
            "original_line": 3186,
            "original_position": 262,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 267,
            "pull_request_review_id": 1816477793,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449323052/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-11T20:25:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449323052",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1449343062"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449343062"
                }
            },
            "author_association": "MEMBER",
            "body": "TODO: luadoc parser or doxygen issue, should be fixed (there are many similar occurrences, e.g., `Cf()`, `Cp()`, `V`)",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-11T20:08:40Z",
            "diff_hunk": "@@ -3034,6 +2984,473 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+The Lpeg library for parsing expression grammars is being included as\n+`vim.lpeg` (https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as\n+|vim.re| (https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example:>lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1449343062",
            "id": 1449343062,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5WYzhW",
            "original_commit_id": "fbb615b921d2310b81bb5b769fb9fd930f2fb8fa",
            "original_line": 3024,
            "original_position": 100,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1816477793,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449343062/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-12T23:37:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449343062",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1449346008"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449346008"
                }
            },
            "author_association": "MEMBER",
            "body": "I thought the files under `_meta` were autogenerated?",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-11T20:11:41Z",
            "diff_hunk": "@@ -158,6 +158,8 @@ These dependencies are \"vendored\" (inlined), we must update the sources manually\n     * Refer to [`LuaCATS/lpeg`](https://github.com/LuaCATS/lpeg) for updates.\n * `runtime/lua/vim/re.lua`: LPeg regex module.\n     * Vendored from LPeg. Needs to be updated when LPeg is updated.\n+* `runtime/lua/vim/_meta/re.lua`: docs for LPeg regex module.",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1449346008",
            "id": 1449346008,
            "line": 162,
            "node_id": "PRRC_kwDOAPphoM5WY0PY",
            "original_commit_id": "fbb615b921d2310b81bb5b769fb9fd930f2fb8fa",
            "original_line": 162,
            "original_position": 4,
            "original_start_line": null,
            "path": "MAINTAIN.md",
            "position": 7,
            "pull_request_review_id": 1816539940,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449346008/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-11T20:11:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449346008",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1449349977"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449349977"
                }
            },
            "author_association": "MEMBER",
            "body": "Yes -- so far. But that's not what makes them live under _meta (it's that they contain no code). ",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-11T20:14:55Z",
            "diff_hunk": "@@ -158,6 +158,8 @@ These dependencies are \"vendored\" (inlined), we must update the sources manually\n     * Refer to [`LuaCATS/lpeg`](https://github.com/LuaCATS/lpeg) for updates.\n * `runtime/lua/vim/re.lua`: LPeg regex module.\n     * Vendored from LPeg. Needs to be updated when LPeg is updated.\n+* `runtime/lua/vim/_meta/re.lua`: docs for LPeg regex module.",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1449349977",
            "id": 1449349977,
            "in_reply_to_id": 1449346008,
            "line": 162,
            "node_id": "PRRC_kwDOAPphoM5WY1NZ",
            "original_commit_id": "fbb615b921d2310b81bb5b769fb9fd930f2fb8fa",
            "original_line": 162,
            "original_position": 4,
            "original_start_line": null,
            "path": "MAINTAIN.md",
            "position": 7,
            "pull_request_review_id": 1816549568,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449349977/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-11T20:14:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449349977",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1449357730"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449357730"
                }
            },
            "author_association": "MEMBER",
            "body": "This also fails, need to handle literal string types",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-11T20:23:40Z",
            "diff_hunk": "@@ -3034,6 +2984,473 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+The Lpeg library for parsing expression grammars is being included as\n+`vim.lpeg` (https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as\n+|vim.re| (https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example:>lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *\n+          return lpeg.match(p, s)\n+        end\n+        local a, b, c = split('a,b,c', ',')\n+        assert(a == 'a')\n+        assert(b == 'b')\n+        assert(c == 'c')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Carg({n})                                           *vim.lpeg.Carg()*\n+    Creates an argument capture. This pattern matches the empty string and\n+    produces the value given as the nth extra argument given in the call to `lpeg.match` .\n+\n+    Parameters: ~\n+      • {n}  (`integer`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cb({name})                                            *vim.lpeg.Cb()*\n+    Creates a back capture. This pattern matches the empty string and produces\n+    the values produced by the most recent group capture named `name` (where\n+    `name` can be any Lua value). Most recent means the last complete\n+    outermost group capture with the given name. A Complete capture means that\n+    the entire pattern corresponding to the capture has matched. An Outermost\n+    capture means that the capture is not inside another complete capture. In\n+    the same way that LPeg does not specify when it evaluates captures, it\n+    does not specify whether it reuses values previously produced by the group\n+    or re-evaluates them.\n+\n+    Parameters: ~\n+      • {name}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cc({...})                                             *vim.lpeg.Cc()*\n+    Creates a constant capture. This pattern matches the empty string and\n+    produces all given values as its captured values.\n+\n+    Parameters: ~\n+      • {...}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cf({patt}, {func})                                    *vim.lpeg.Cf()*\n+    Creates a fold capture. If `patt` produces a list of captures C1 C2 ...\n+    Cn, this capture will produce the value `func(...func(func(C1, C2),\n+    C3)...,Cn)`, that is, it will fold (or accumulate, or reduce) the captures\n+    from `patt` using function `func`. This capture assumes that `patt` should\n+    produce at least one capture with at least one value (of any type), which\n+    becomes the initial value of an accumulator. (If you need a specific\n+    initial value, you may prefix a constant captureto `patt`.) For each\n+    subsequent capture, LPeg calls `func` with this accumulator as the first\n+    argument and all values produced by the capture as extra arguments; the\n+    first result from this call becomes the new value for the accumulator. The\n+    final value of the accumulator becomes the captured value.\n+\n+    Example:>lua\n+        local number = lpeg.R(\"09\") ^ 1 / tonumber\n+        local list = numbernumber) ^ 0                                * (\",\" *\n+        local function add(acc, newvalue) return acc + newvalue end\n+        local sum = lpeg.Cf(list, add)\n+        assert(sum:match(\"10,30,43\") == 83)\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {func}  (`fun(acc, newvalue)`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cg({patt}, {name})                                    *vim.lpeg.Cg()*\n+    Creates a group capture. It groups all values returned by `patt` into a\n+    single capture. The group may be anonymous (if no name is given) or named\n+    with the given name (which can be any non-nil Lua value).\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {name}  (`string?`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cmt({patt}, {fn})                                    *vim.lpeg.Cmt()*\n+    Creates a match-time capture. Unlike all other captures, this one is\n+    evaluated immediately when a match occurs (even if it is part of a larger\n+    pattern that fails later). It forces the immediate evaluation of all its\n+    nested captures and then calls `function`. The given function gets as\n+    arguments the entire subject, the current position (after the match of\n+    `patt`), plus any capture values produced by `patt`. The first value\n+    returned by `function` defines how the match happens. If the call returns\n+    a number, the match succeeds and the returned number becomes the new\n+    current position. (Assuming a subject sand current position i, the\n+    returned number must be in the range [i, len(s) + 1].) If the call returns\n+    true, the match succeeds without consuming any input (so, to return true\n+    is equivalent to return i). If the call returns false, nil, or no value,\n+    the match fails. Any extra values returned by the function become the\n+    values produced by the capture.\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {fn}    (`function`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cp()                                                  *vim.lpeg.Cp()*\n+    Creates a position capture. It matches the empty string and captures the\n+    position in the subject where the match occurs. The captured value is a\n+    number.\n+\n+    Example:>lua\n+        local I = lpeg.Cp()\n+        local function anywhere(p) return lpeg.P({II + 1 * lpeg.V(1)}) end * p *\n+        local match_start, match_end = anywhere(\"world\"):match(\"hello world!\")\n+        assert(match_start == 7)\n+        assert(match_end == 12)\n+<\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cs({patt})                                            *vim.lpeg.Cs()*\n+    Creates a substitution capture. This function creates a substitution\n+    capture, which captures the substring of the subject that matches `patt`,\n+    with substitutions. For any capture inside `patt` with a value, the\n+    substring that matched the capture is replaced by the capture value (which\n+    should be a string). The final captured value is the string resulting from\n+    all replacements.\n+\n+    Example:>lua\n+        local function gsub (s, patt, repl)\n+          patt = lpeg.P(patt)\n+          patt = lpeg.Cs((patt / repl + 1)^0)\n+          return lpeg.match(patt, s)\n+        end\n+        assert(gsub('Hello, xxx!', 'xxx', 'World') == 'Hello, World!')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Ct({patt})                                            *vim.lpeg.Ct()*\n+    Creates a table capture. This capture returns a table with all values from\n+    all anonymous captures made by `patt` inside this table in successive\n+    integer keys, starting at 1. Moreover, for each named capture group\n+    created by `patt`, the first value of the group is put into the table with\n+    the group name as its key. The captured value is only the table.\n+\n+    Parameters: ~\n+      • {patt}  (vim.lpeg.Pattern |' `) @return (` vim.lpeg.Capture`)\n+\n+vim.lpeg.lpeg                                                     *vim.lpeg()*\n+    LPeg is a new pattern-matching library for Lua, based on Parsing Expression\n+    Grammars (PEGs).\n+\n+vim.lpeg.match({pattern}, {subject}, {init})                *vim.lpeg.match()*\n+    Matches the given `pattern` against the `subject` string. If the match\n+    succeeds, returns the index in the subject of the first character after\n+    the match, or the captured values (if the pattern captured any value). An\n+    optional numeric argument `init` makes the match start at that position in\n+    the subject string. As usual in Lua libraries, a negative value counts\n+    from the end. Unlike typical pattern-matching functions, `match` works\n+    only in anchored mode; that is, it tries to match the pattern with a\n+    prefix of the given subject string (at position `init`), not with an\n+    arbitrary substring of the subject. So, if we want to find a pattern\n+    anywhere in a string, we must either write a loop in Lua or write a\n+    pattern that matches anywhere.\n+\n+    Example:>lua\n+        local pattern = lpeg.R(\"az\") ^ 1 * -1\n+        assert(pattern:match(\"hello\") == 6)\n+        assert(lpeg.match(pattern, \"hello\") == 6)\n+        assert(pattern:match(\"1 hello\") == nil)\n+<\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+      • {subject}  (`string`)\n+      • {init}     (`integer?`)\n+\n+    Return: ~\n+        (`integer|vim.lpeg.Capture?`)\n+\n+vim.lpeg.P({value})                                             *vim.lpeg.P()*\n+    Converts the given value into a proper pattern. This following rules are\n+    applied:\n+    • If the argument is a pattern, it is returned unmodified.\n+    • If the argument is a string, it is translated to a pattern that matches\n+      the string literally.\n+    • If the argument is a non-negative number `n`, the result is a pattern\n+      that matches exactly `n` characters.\n+    • If the argument is a negative number `-n`, the result is a pattern that\n+      succeeds only if the input string has less than `n` characters left:\n+      `lpeg.P(-n)` is equivalent to `-lpeg.P(n)` (see the unary minus\n+      operation).\n+    • If the argument is a boolean, the result is a pattern that always\n+      succeeds or always fails (according to the boolean value), without\n+      consuming any input.\n+    • If the argument is a table, it is interpreted as a grammar (see\n+      Grammars).\n+    • If the argument is a function, returns a pattern equivalent to a\n+      match-time captureover the empty string.\n+\n+    Parameters: ~\n+      • {value}  (`vim.lpeg.Pattern|string|integer|boolean|table|function`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.Pattern:match({subject}, {init})                    *Pattern:match()*\n+    Matches the given `pattern` against the `subject` string. If the match\n+    succeeds, returns the index in the subject of the first character after\n+    the match, or the captured values (if the pattern captured any value). An\n+    optional numeric argument `init` makes the match start at that position in\n+    the subject string. As usual in Lua libraries, a negative value counts\n+    from the end. Unlike typical pattern-matching functions, `match` works\n+    only in anchored mode; that is, it tries to match the pattern with a\n+    prefix of the given subject string (at position `init`), not with an\n+    arbitrary substring of the subject. So, if we want to find a pattern\n+    anywhere in a string, we must either write a loop in Lua or write a\n+    pattern that matches anywhere.\n+\n+    Example:>lua\n+        local pattern = lpeg.R(\"az\") ^ 1 * -1\n+        assert(pattern:match(\"hello\") == 6)\n+        assert(lpeg.match(pattern, \"hello\") == 6)\n+        assert(pattern:match(\"1 hello\") == nil)\n+<\n+\n+    Parameters: ~\n+      • {subject}  (`string`)\n+      • {init}     (`integer?`)\n+\n+    Return: ~\n+        (`integer|vim.lpeg.Capture?`)\n+\n+vim.lpeg.R({...})                                               *vim.lpeg.R()*\n+    Returns a pattern that matches any single character belonging to one of\n+    the given ranges. Each `range` is a string `xy` of length 2, representing\n+    all characters with code between the codes of `x` and `y` (both\n+    inclusive). As an example, the pattern `lpeg.R(\"09\")` matches any digit,\n+    and `lpeg.R(\"az\", \"AZ\")` matches any ASCII letter.\n+\n+    Example:>lua\n+        local pattern = lpeg.R(\"az\") ^ 1 * -1\n+        assert(pattern:match(\"hello\") == 6)\n+<\n+\n+    Parameters: ~\n+      • {...}  (`string`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.S({string})                                            *vim.lpeg.S()*\n+    Returns a pattern that matches any single character that appears in the\n+    given string (the `S` stands for Set). As an example, the pattern\n+    `lpeg.S(\"+-*&zwj;/\")` matches any arithmetic operator. Note that, if `s`\n+    is a character (that is, a string of length 1), then `lpeg.P(s)` is\n+    equivalent to `lpeg.S(s)` which is equivalent to `lpeg.R(s..s)`. Note also\n+    that both `lpeg.S(\"\")` and `lpeg.R()` are patterns that always fail.\n+\n+    Parameters: ~\n+      • {string}  (`string`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.setmaxstack({max})                           *vim.lpeg.setmaxstack()*\n+    Sets a limit for the size of the backtrack stack used by LPeg to track\n+    calls and choices. The default limit is `400`. Most well-written patterns\n+    need little backtrack levels and therefore you seldom need to change this\n+    limit; before changing it you should try to rewrite your pattern to avoid\n+    the need for extra space. Nevertheless, a few useful patterns may\n+    overflow. Also, with recursive grammars, subjects with deep recursion may\n+    also need larger limits.\n+\n+    Parameters: ~\n+      • {max}  (`integer`)\n+\n+vim.lpeg.type({value})                                       *vim.lpeg.type()*\n+    Returns the string `\"pattern\"` if the given value is a pattern, otherwise\n+    `nil`.\n+\n+    Return: ~\n+        ('pattern ?`)",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1449357730",
            "id": 1449357730,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5WY3Gi",
            "original_commit_id": "fbb615b921d2310b81bb5b769fb9fd930f2fb8fa",
            "original_line": 3322,
            "original_position": 398,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1816477793,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449357730/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-11T20:25:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449357730",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1449363130"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449363130"
                }
            },
            "author_association": "MEMBER",
            "body": "There are a few others: `lpeg.lua`, `base64.lua`, `builtin_types.lua`, `misc.lua`, etc. that are not autogenerated.\r\n\r\nAuto-generated files are supposed to have:\r\n```\r\n-- THIS FILE IS GENERATED\r\n-- DO NOT EDIT\r\n```\r\n\r\nhttps://github.com/neovim/neovim/blob/master/.gitattributes#L8-L12",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-11T20:30:10Z",
            "diff_hunk": "@@ -158,6 +158,8 @@ These dependencies are \"vendored\" (inlined), we must update the sources manually\n     * Refer to [`LuaCATS/lpeg`](https://github.com/LuaCATS/lpeg) for updates.\n * `runtime/lua/vim/re.lua`: LPeg regex module.\n     * Vendored from LPeg. Needs to be updated when LPeg is updated.\n+* `runtime/lua/vim/_meta/re.lua`: docs for LPeg regex module.",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1449363130",
            "id": 1449363130,
            "in_reply_to_id": 1449346008,
            "line": 162,
            "node_id": "PRRC_kwDOAPphoM5WY4a6",
            "original_commit_id": "fbb615b921d2310b81bb5b769fb9fd930f2fb8fa",
            "original_line": 162,
            "original_position": 4,
            "original_start_line": null,
            "path": "MAINTAIN.md",
            "position": 7,
            "pull_request_review_id": 1816589419,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449363130/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-11T21:17:30Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1449363130",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1450986576"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1450986576"
                }
            },
            "author_association": "MEMBER",
            "body": "lua2dox prints\r\n```\r\n/// @return (`'pattern'?`)\r\n```\r\n\r\nbut doxygen fails to parse correctly when both of \\` and \\' present 🤔\r\n```xml\r\n<para>(<lsquo/>&apos;pattern<rsquo/>?`) <linebreak/> </para>\r\n```\r\n\r\nThis is a doxygen bug. https://github.com/doxygen/doxygen/issues/8614\r\n\r\nA workaround is to use `\"pattern\"` instead of `'pattern'`. ",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-12T22:37:43Z",
            "diff_hunk": "@@ -3034,6 +2984,473 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+The Lpeg library for parsing expression grammars is being included as\n+`vim.lpeg` (https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as\n+|vim.re| (https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example:>lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *\n+          return lpeg.match(p, s)\n+        end\n+        local a, b, c = split('a,b,c', ',')\n+        assert(a == 'a')\n+        assert(b == 'b')\n+        assert(c == 'c')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Carg({n})                                           *vim.lpeg.Carg()*\n+    Creates an argument capture. This pattern matches the empty string and\n+    produces the value given as the nth extra argument given in the call to `lpeg.match` .\n+\n+    Parameters: ~\n+      • {n}  (`integer`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cb({name})                                            *vim.lpeg.Cb()*\n+    Creates a back capture. This pattern matches the empty string and produces\n+    the values produced by the most recent group capture named `name` (where\n+    `name` can be any Lua value). Most recent means the last complete\n+    outermost group capture with the given name. A Complete capture means that\n+    the entire pattern corresponding to the capture has matched. An Outermost\n+    capture means that the capture is not inside another complete capture. In\n+    the same way that LPeg does not specify when it evaluates captures, it\n+    does not specify whether it reuses values previously produced by the group\n+    or re-evaluates them.\n+\n+    Parameters: ~\n+      • {name}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cc({...})                                             *vim.lpeg.Cc()*\n+    Creates a constant capture. This pattern matches the empty string and\n+    produces all given values as its captured values.\n+\n+    Parameters: ~\n+      • {...}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cf({patt}, {func})                                    *vim.lpeg.Cf()*\n+    Creates a fold capture. If `patt` produces a list of captures C1 C2 ...\n+    Cn, this capture will produce the value `func(...func(func(C1, C2),\n+    C3)...,Cn)`, that is, it will fold (or accumulate, or reduce) the captures\n+    from `patt` using function `func`. This capture assumes that `patt` should\n+    produce at least one capture with at least one value (of any type), which\n+    becomes the initial value of an accumulator. (If you need a specific\n+    initial value, you may prefix a constant captureto `patt`.) For each\n+    subsequent capture, LPeg calls `func` with this accumulator as the first\n+    argument and all values produced by the capture as extra arguments; the\n+    first result from this call becomes the new value for the accumulator. The\n+    final value of the accumulator becomes the captured value.\n+\n+    Example:>lua\n+        local number = lpeg.R(\"09\") ^ 1 / tonumber\n+        local list = numbernumber) ^ 0                                * (\",\" *\n+        local function add(acc, newvalue) return acc + newvalue end\n+        local sum = lpeg.Cf(list, add)\n+        assert(sum:match(\"10,30,43\") == 83)\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {func}  (`fun(acc, newvalue)`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cg({patt}, {name})                                    *vim.lpeg.Cg()*\n+    Creates a group capture. It groups all values returned by `patt` into a\n+    single capture. The group may be anonymous (if no name is given) or named\n+    with the given name (which can be any non-nil Lua value).\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {name}  (`string?`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cmt({patt}, {fn})                                    *vim.lpeg.Cmt()*\n+    Creates a match-time capture. Unlike all other captures, this one is\n+    evaluated immediately when a match occurs (even if it is part of a larger\n+    pattern that fails later). It forces the immediate evaluation of all its\n+    nested captures and then calls `function`. The given function gets as\n+    arguments the entire subject, the current position (after the match of\n+    `patt`), plus any capture values produced by `patt`. The first value\n+    returned by `function` defines how the match happens. If the call returns\n+    a number, the match succeeds and the returned number becomes the new\n+    current position. (Assuming a subject sand current position i, the\n+    returned number must be in the range [i, len(s) + 1].) If the call returns\n+    true, the match succeeds without consuming any input (so, to return true\n+    is equivalent to return i). If the call returns false, nil, or no value,\n+    the match fails. Any extra values returned by the function become the\n+    values produced by the capture.\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {fn}    (`function`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cp()                                                  *vim.lpeg.Cp()*\n+    Creates a position capture. It matches the empty string and captures the\n+    position in the subject where the match occurs. The captured value is a\n+    number.\n+\n+    Example:>lua\n+        local I = lpeg.Cp()\n+        local function anywhere(p) return lpeg.P({II + 1 * lpeg.V(1)}) end * p *\n+        local match_start, match_end = anywhere(\"world\"):match(\"hello world!\")\n+        assert(match_start == 7)\n+        assert(match_end == 12)\n+<\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cs({patt})                                            *vim.lpeg.Cs()*\n+    Creates a substitution capture. This function creates a substitution\n+    capture, which captures the substring of the subject that matches `patt`,\n+    with substitutions. For any capture inside `patt` with a value, the\n+    substring that matched the capture is replaced by the capture value (which\n+    should be a string). The final captured value is the string resulting from\n+    all replacements.\n+\n+    Example:>lua\n+        local function gsub (s, patt, repl)\n+          patt = lpeg.P(patt)\n+          patt = lpeg.Cs((patt / repl + 1)^0)\n+          return lpeg.match(patt, s)\n+        end\n+        assert(gsub('Hello, xxx!', 'xxx', 'World') == 'Hello, World!')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Ct({patt})                                            *vim.lpeg.Ct()*\n+    Creates a table capture. This capture returns a table with all values from\n+    all anonymous captures made by `patt` inside this table in successive\n+    integer keys, starting at 1. Moreover, for each named capture group\n+    created by `patt`, the first value of the group is put into the table with\n+    the group name as its key. The captured value is only the table.\n+\n+    Parameters: ~\n+      • {patt}  (vim.lpeg.Pattern |' `) @return (` vim.lpeg.Capture`)\n+\n+vim.lpeg.lpeg                                                     *vim.lpeg()*\n+    LPeg is a new pattern-matching library for Lua, based on Parsing Expression\n+    Grammars (PEGs).\n+\n+vim.lpeg.match({pattern}, {subject}, {init})                *vim.lpeg.match()*\n+    Matches the given `pattern` against the `subject` string. If the match\n+    succeeds, returns the index in the subject of the first character after\n+    the match, or the captured values (if the pattern captured any value). An\n+    optional numeric argument `init` makes the match start at that position in\n+    the subject string. As usual in Lua libraries, a negative value counts\n+    from the end. Unlike typical pattern-matching functions, `match` works\n+    only in anchored mode; that is, it tries to match the pattern with a\n+    prefix of the given subject string (at position `init`), not with an\n+    arbitrary substring of the subject. So, if we want to find a pattern\n+    anywhere in a string, we must either write a loop in Lua or write a\n+    pattern that matches anywhere.\n+\n+    Example:>lua\n+        local pattern = lpeg.R(\"az\") ^ 1 * -1\n+        assert(pattern:match(\"hello\") == 6)\n+        assert(lpeg.match(pattern, \"hello\") == 6)\n+        assert(pattern:match(\"1 hello\") == nil)\n+<\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+      • {subject}  (`string`)\n+      • {init}     (`integer?`)\n+\n+    Return: ~\n+        (`integer|vim.lpeg.Capture?`)\n+\n+vim.lpeg.P({value})                                             *vim.lpeg.P()*\n+    Converts the given value into a proper pattern. This following rules are\n+    applied:\n+    • If the argument is a pattern, it is returned unmodified.\n+    • If the argument is a string, it is translated to a pattern that matches\n+      the string literally.\n+    • If the argument is a non-negative number `n`, the result is a pattern\n+      that matches exactly `n` characters.\n+    • If the argument is a negative number `-n`, the result is a pattern that\n+      succeeds only if the input string has less than `n` characters left:\n+      `lpeg.P(-n)` is equivalent to `-lpeg.P(n)` (see the unary minus\n+      operation).\n+    • If the argument is a boolean, the result is a pattern that always\n+      succeeds or always fails (according to the boolean value), without\n+      consuming any input.\n+    • If the argument is a table, it is interpreted as a grammar (see\n+      Grammars).\n+    • If the argument is a function, returns a pattern equivalent to a\n+      match-time captureover the empty string.\n+\n+    Parameters: ~\n+      • {value}  (`vim.lpeg.Pattern|string|integer|boolean|table|function`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.Pattern:match({subject}, {init})                    *Pattern:match()*\n+    Matches the given `pattern` against the `subject` string. If the match\n+    succeeds, returns the index in the subject of the first character after\n+    the match, or the captured values (if the pattern captured any value). An\n+    optional numeric argument `init` makes the match start at that position in\n+    the subject string. As usual in Lua libraries, a negative value counts\n+    from the end. Unlike typical pattern-matching functions, `match` works\n+    only in anchored mode; that is, it tries to match the pattern with a\n+    prefix of the given subject string (at position `init`), not with an\n+    arbitrary substring of the subject. So, if we want to find a pattern\n+    anywhere in a string, we must either write a loop in Lua or write a\n+    pattern that matches anywhere.\n+\n+    Example:>lua\n+        local pattern = lpeg.R(\"az\") ^ 1 * -1\n+        assert(pattern:match(\"hello\") == 6)\n+        assert(lpeg.match(pattern, \"hello\") == 6)\n+        assert(pattern:match(\"1 hello\") == nil)\n+<\n+\n+    Parameters: ~\n+      • {subject}  (`string`)\n+      • {init}     (`integer?`)\n+\n+    Return: ~\n+        (`integer|vim.lpeg.Capture?`)\n+\n+vim.lpeg.R({...})                                               *vim.lpeg.R()*\n+    Returns a pattern that matches any single character belonging to one of\n+    the given ranges. Each `range` is a string `xy` of length 2, representing\n+    all characters with code between the codes of `x` and `y` (both\n+    inclusive). As an example, the pattern `lpeg.R(\"09\")` matches any digit,\n+    and `lpeg.R(\"az\", \"AZ\")` matches any ASCII letter.\n+\n+    Example:>lua\n+        local pattern = lpeg.R(\"az\") ^ 1 * -1\n+        assert(pattern:match(\"hello\") == 6)\n+<\n+\n+    Parameters: ~\n+      • {...}  (`string`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.S({string})                                            *vim.lpeg.S()*\n+    Returns a pattern that matches any single character that appears in the\n+    given string (the `S` stands for Set). As an example, the pattern\n+    `lpeg.S(\"+-*&zwj;/\")` matches any arithmetic operator. Note that, if `s`\n+    is a character (that is, a string of length 1), then `lpeg.P(s)` is\n+    equivalent to `lpeg.S(s)` which is equivalent to `lpeg.R(s..s)`. Note also\n+    that both `lpeg.S(\"\")` and `lpeg.R()` are patterns that always fail.\n+\n+    Parameters: ~\n+      • {string}  (`string`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.setmaxstack({max})                           *vim.lpeg.setmaxstack()*\n+    Sets a limit for the size of the backtrack stack used by LPeg to track\n+    calls and choices. The default limit is `400`. Most well-written patterns\n+    need little backtrack levels and therefore you seldom need to change this\n+    limit; before changing it you should try to rewrite your pattern to avoid\n+    the need for extra space. Nevertheless, a few useful patterns may\n+    overflow. Also, with recursive grammars, subjects with deep recursion may\n+    also need larger limits.\n+\n+    Parameters: ~\n+      • {max}  (`integer`)\n+\n+vim.lpeg.type({value})                                       *vim.lpeg.type()*\n+    Returns the string `\"pattern\"` if the given value is a pattern, otherwise\n+    `nil`.\n+\n+    Return: ~\n+        ('pattern ?`)",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1450986576",
            "id": 1450986576,
            "in_reply_to_id": 1449357730,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5WfExQ",
            "original_commit_id": "fbb615b921d2310b81bb5b769fb9fd930f2fb8fa",
            "original_line": 3322,
            "original_position": 398,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1819212839,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1450986576/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-12T22:42:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1450986576",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1451122570"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451122570"
                }
            },
            "author_association": "MEMBER",
            "body": "Is this comment referring to line 3024? Because something funky is happening there.",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-13T02:57:29Z",
            "diff_hunk": "@@ -3034,6 +2984,473 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+The Lpeg library for parsing expression grammars is being included as\n+`vim.lpeg` (https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as\n+|vim.re| (https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example:>lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1451122570",
            "id": 1451122570,
            "in_reply_to_id": 1449343062,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5Wfl-K",
            "original_commit_id": "fbb615b921d2310b81bb5b769fb9fd930f2fb8fa",
            "original_line": 3024,
            "original_position": 100,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1819699202,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451122570/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-13T03:05:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451122570",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1451122972"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451122972"
                }
            },
            "author_association": "MEMBER",
            "body": "For readability: \r\n```suggestion\r\n    with some fixed length, and it cannot contain captures. Like the `and`\r\n```",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-13T02:58:16Z",
            "diff_hunk": "@@ -3034,6 +2984,478 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+LPeg is a pattern-matching library for Lua, based on\n+Parsing Expression Grammars (https://bford.info/packrat/) (PEGs).\n+\n+                                                                    *lua-lpeg*\n+                                                            *vim.lpeg.Pattern*\n+The LPeg library for parsing expression grammars is included as `vim.lpeg`\n+(https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as |vim.re|\n+(https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1451122972",
            "id": 1451122972,
            "line": 3005,
            "node_id": "PRRC_kwDOAPphoM5WfmEc",
            "original_commit_id": "095d7d85882ad25da9a9d60e3038e332eff3c86e",
            "original_line": 3005,
            "original_position": 86,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 86,
            "pull_request_review_id": 1819699202,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451122972/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-13T03:05:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451122972",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1451123060"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451123060"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    produces the value given as the nth extra argument given in the call to `lpeg.match`.\r\n```",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-13T02:58:26Z",
            "diff_hunk": "@@ -3034,6 +2984,478 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+LPeg is a pattern-matching library for Lua, based on\n+Parsing Expression Grammars (https://bford.info/packrat/) (PEGs).\n+\n+                                                                    *lua-lpeg*\n+                                                            *vim.lpeg.Pattern*\n+The LPeg library for parsing expression grammars is included as `vim.lpeg`\n+(https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as |vim.re|\n+(https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example: >lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *\n+          return lpeg.match(p, s)\n+        end\n+        local a, b, c = split('a,b,c', ',')\n+        assert(a == 'a')\n+        assert(b == 'b')\n+        assert(c == 'c')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Carg({n})                                           *vim.lpeg.Carg()*\n+    Creates an argument capture. This pattern matches the empty string and\n+    produces the value given as the nth extra argument given in the call to `lpeg.match` .",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1451123060",
            "id": 1451123060,
            "line": 3041,
            "node_id": "PRRC_kwDOAPphoM5WfmF0",
            "original_commit_id": "095d7d85882ad25da9a9d60e3038e332eff3c86e",
            "original_line": 3041,
            "original_position": 122,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 122,
            "pull_request_review_id": 1819699202,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451123060/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-13T03:05:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451123060",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1451123657"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451123657"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    initial value, you may prefix a constant capture to `patt`.) For each\r\n```",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-13T02:59:15Z",
            "diff_hunk": "@@ -3034,6 +2984,478 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+LPeg is a pattern-matching library for Lua, based on\n+Parsing Expression Grammars (https://bford.info/packrat/) (PEGs).\n+\n+                                                                    *lua-lpeg*\n+                                                            *vim.lpeg.Pattern*\n+The LPeg library for parsing expression grammars is included as `vim.lpeg`\n+(https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as |vim.re|\n+(https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example: >lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *\n+          return lpeg.match(p, s)\n+        end\n+        local a, b, c = split('a,b,c', ',')\n+        assert(a == 'a')\n+        assert(b == 'b')\n+        assert(c == 'c')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Carg({n})                                           *vim.lpeg.Carg()*\n+    Creates an argument capture. This pattern matches the empty string and\n+    produces the value given as the nth extra argument given in the call to `lpeg.match` .\n+\n+    Parameters: ~\n+      • {n}  (`integer`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cb({name})                                            *vim.lpeg.Cb()*\n+    Creates a back capture. This pattern matches the empty string and produces\n+    the values produced by the most recent group capture named `name` (where\n+    `name` can be any Lua value). Most recent means the last complete\n+    outermost group capture with the given name. A Complete capture means that\n+    the entire pattern corresponding to the capture has matched. An Outermost\n+    capture means that the capture is not inside another complete capture. In\n+    the same way that LPeg does not specify when it evaluates captures, it\n+    does not specify whether it reuses values previously produced by the group\n+    or re-evaluates them.\n+\n+    Parameters: ~\n+      • {name}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cc({...})                                             *vim.lpeg.Cc()*\n+    Creates a constant capture. This pattern matches the empty string and\n+    produces all given values as its captured values.\n+\n+    Parameters: ~\n+      • {...}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cf({patt}, {func})                                    *vim.lpeg.Cf()*\n+    Creates a fold capture. If `patt` produces a list of captures C1 C2 ...\n+    Cn, this capture will produce the value `func(...func(func(C1, C2),\n+    C3)...,Cn)`, that is, it will fold (or accumulate, or reduce) the captures\n+    from `patt` using function `func`. This capture assumes that `patt` should\n+    produce at least one capture with at least one value (of any type), which\n+    becomes the initial value of an accumulator. (If you need a specific\n+    initial value, you may prefix a constant captureto `patt`.) For each",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1451123657",
            "id": 1451123657,
            "line": 3083,
            "node_id": "PRRC_kwDOAPphoM5WfmPJ",
            "original_commit_id": "095d7d85882ad25da9a9d60e3038e332eff3c86e",
            "original_line": 3083,
            "original_position": 164,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 164,
            "pull_request_review_id": 1819699202,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451123657/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-13T03:05:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451123657",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1451124947"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451124947"
                }
            },
            "author_association": "MEMBER",
            "body": "Nit: Other examples use single quotes. Let's try to keep that consistent.",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-13T03:00:40Z",
            "diff_hunk": "@@ -3034,6 +2984,478 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+LPeg is a pattern-matching library for Lua, based on\n+Parsing Expression Grammars (https://bford.info/packrat/) (PEGs).\n+\n+                                                                    *lua-lpeg*\n+                                                            *vim.lpeg.Pattern*\n+The LPeg library for parsing expression grammars is included as `vim.lpeg`\n+(https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as |vim.re|\n+(https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example: >lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *\n+          return lpeg.match(p, s)\n+        end\n+        local a, b, c = split('a,b,c', ',')\n+        assert(a == 'a')\n+        assert(b == 'b')\n+        assert(c == 'c')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Carg({n})                                           *vim.lpeg.Carg()*\n+    Creates an argument capture. This pattern matches the empty string and\n+    produces the value given as the nth extra argument given in the call to `lpeg.match` .\n+\n+    Parameters: ~\n+      • {n}  (`integer`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cb({name})                                            *vim.lpeg.Cb()*\n+    Creates a back capture. This pattern matches the empty string and produces\n+    the values produced by the most recent group capture named `name` (where\n+    `name` can be any Lua value). Most recent means the last complete\n+    outermost group capture with the given name. A Complete capture means that\n+    the entire pattern corresponding to the capture has matched. An Outermost\n+    capture means that the capture is not inside another complete capture. In\n+    the same way that LPeg does not specify when it evaluates captures, it\n+    does not specify whether it reuses values previously produced by the group\n+    or re-evaluates them.\n+\n+    Parameters: ~\n+      • {name}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cc({...})                                             *vim.lpeg.Cc()*\n+    Creates a constant capture. This pattern matches the empty string and\n+    produces all given values as its captured values.\n+\n+    Parameters: ~\n+      • {...}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cf({patt}, {func})                                    *vim.lpeg.Cf()*\n+    Creates a fold capture. If `patt` produces a list of captures C1 C2 ...\n+    Cn, this capture will produce the value `func(...func(func(C1, C2),\n+    C3)...,Cn)`, that is, it will fold (or accumulate, or reduce) the captures\n+    from `patt` using function `func`. This capture assumes that `patt` should\n+    produce at least one capture with at least one value (of any type), which\n+    becomes the initial value of an accumulator. (If you need a specific\n+    initial value, you may prefix a constant captureto `patt`.) For each\n+    subsequent capture, LPeg calls `func` with this accumulator as the first\n+    argument and all values produced by the capture as extra arguments; the\n+    first result from this call becomes the new value for the accumulator. The\n+    final value of the accumulator becomes the captured value.\n+\n+    Example: >lua\n+        local number = lpeg.R(\"09\") ^ 1 / tonumber\n+        local list = numbernumber) ^ 0                                * (\",\" *\n+        local function add(acc, newvalue) return acc + newvalue end\n+        local sum = lpeg.Cf(list, add)\n+        assert(sum:match(\"10,30,43\") == 83)",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1451124947",
            "id": 1451124947,
            "line": 3094,
            "node_id": "PRRC_kwDOAPphoM5WfmjT",
            "original_commit_id": "095d7d85882ad25da9a9d60e3038e332eff3c86e",
            "original_line": 3094,
            "original_position": 175,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 175,
            "pull_request_review_id": 1819699202,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451124947/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-13T03:05:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451124947",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1451126567"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451126567"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n    Converts the given value into a proper pattern. These following rules are\r\n```",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-13T03:03:14Z",
            "diff_hunk": "@@ -3034,6 +2984,478 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+LPeg is a pattern-matching library for Lua, based on\n+Parsing Expression Grammars (https://bford.info/packrat/) (PEGs).\n+\n+                                                                    *lua-lpeg*\n+                                                            *vim.lpeg.Pattern*\n+The LPeg library for parsing expression grammars is included as `vim.lpeg`\n+(https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as |vim.re|\n+(https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example: >lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *\n+          return lpeg.match(p, s)\n+        end\n+        local a, b, c = split('a,b,c', ',')\n+        assert(a == 'a')\n+        assert(b == 'b')\n+        assert(c == 'c')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Carg({n})                                           *vim.lpeg.Carg()*\n+    Creates an argument capture. This pattern matches the empty string and\n+    produces the value given as the nth extra argument given in the call to `lpeg.match` .\n+\n+    Parameters: ~\n+      • {n}  (`integer`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cb({name})                                            *vim.lpeg.Cb()*\n+    Creates a back capture. This pattern matches the empty string and produces\n+    the values produced by the most recent group capture named `name` (where\n+    `name` can be any Lua value). Most recent means the last complete\n+    outermost group capture with the given name. A Complete capture means that\n+    the entire pattern corresponding to the capture has matched. An Outermost\n+    capture means that the capture is not inside another complete capture. In\n+    the same way that LPeg does not specify when it evaluates captures, it\n+    does not specify whether it reuses values previously produced by the group\n+    or re-evaluates them.\n+\n+    Parameters: ~\n+      • {name}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cc({...})                                             *vim.lpeg.Cc()*\n+    Creates a constant capture. This pattern matches the empty string and\n+    produces all given values as its captured values.\n+\n+    Parameters: ~\n+      • {...}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cf({patt}, {func})                                    *vim.lpeg.Cf()*\n+    Creates a fold capture. If `patt` produces a list of captures C1 C2 ...\n+    Cn, this capture will produce the value `func(...func(func(C1, C2),\n+    C3)...,Cn)`, that is, it will fold (or accumulate, or reduce) the captures\n+    from `patt` using function `func`. This capture assumes that `patt` should\n+    produce at least one capture with at least one value (of any type), which\n+    becomes the initial value of an accumulator. (If you need a specific\n+    initial value, you may prefix a constant captureto `patt`.) For each\n+    subsequent capture, LPeg calls `func` with this accumulator as the first\n+    argument and all values produced by the capture as extra arguments; the\n+    first result from this call becomes the new value for the accumulator. The\n+    final value of the accumulator becomes the captured value.\n+\n+    Example: >lua\n+        local number = lpeg.R(\"09\") ^ 1 / tonumber\n+        local list = numbernumber) ^ 0                                * (\",\" *\n+        local function add(acc, newvalue) return acc + newvalue end\n+        local sum = lpeg.Cf(list, add)\n+        assert(sum:match(\"10,30,43\") == 83)\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {func}  (`fun(acc, newvalue)`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cg({patt}, {name})                                    *vim.lpeg.Cg()*\n+    Creates a group capture. It groups all values returned by `patt` into a\n+    single capture. The group may be anonymous (if no name is given) or named\n+    with the given name (which can be any non-nil Lua value).\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {name}  (`string?`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cmt({patt}, {fn})                                    *vim.lpeg.Cmt()*\n+    Creates a match-time capture. Unlike all other captures, this one is\n+    evaluated immediately when a match occurs (even if it is part of a larger\n+    pattern that fails later). It forces the immediate evaluation of all its\n+    nested captures and then calls `function`. The given function gets as\n+    arguments the entire subject, the current position (after the match of\n+    `patt`), plus any capture values produced by `patt`. The first value\n+    returned by `function` defines how the match happens. If the call returns\n+    a number, the match succeeds and the returned number becomes the new\n+    current position. (Assuming a subject sand current position i, the\n+    returned number must be in the range [i, len(s) + 1].) If the call returns\n+    true, the match succeeds without consuming any input (so, to return true\n+    is equivalent to return i). If the call returns false, nil, or no value,\n+    the match fails. Any extra values returned by the function become the\n+    values produced by the capture.\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {fn}    (`function`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cp()                                                  *vim.lpeg.Cp()*\n+    Creates a position capture. It matches the empty string and captures the\n+    position in the subject where the match occurs. The captured value is a\n+    number.\n+\n+    Example: >lua\n+        local I = lpeg.Cp()\n+        local function anywhere(p) return lpeg.P({II + 1 * lpeg.V(1)}) end * p *\n+        local match_start, match_end = anywhere(\"world\"):match(\"hello world!\")\n+        assert(match_start == 7)\n+        assert(match_end == 12)\n+<\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cs({patt})                                            *vim.lpeg.Cs()*\n+    Creates a substitution capture. This function creates a substitution\n+    capture, which captures the substring of the subject that matches `patt`,\n+    with substitutions. For any capture inside `patt` with a value, the\n+    substring that matched the capture is replaced by the capture value (which\n+    should be a string). The final captured value is the string resulting from\n+    all replacements.\n+\n+    Example: >lua\n+        local function gsub (s, patt, repl)\n+          patt = lpeg.P(patt)\n+          patt = lpeg.Cs((patt / repl + 1)^0)\n+          return lpeg.match(patt, s)\n+        end\n+        assert(gsub('Hello, xxx!', 'xxx', 'World') == 'Hello, World!')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Ct({patt})                                            *vim.lpeg.Ct()*\n+    Creates a table capture. This capture returns a table with all values from\n+    all anonymous captures made by `patt` inside this table in successive\n+    integer keys, starting at 1. Moreover, for each named capture group\n+    created by `patt`, the first value of the group is put into the table with\n+    the group name as its key. The captured value is only the table.\n+\n+    Parameters: ~\n+      • {patt}  (vim.lpeg.Pattern |' `) @return (` vim.lpeg.Capture`)\n+\n+vim.lpeg.lpeg                                                     *vim.lpeg()*\n+    LPeg is a new pattern-matching library for Lua, based on Parsing Expression\n+    Grammars (PEGs).\n+\n+vim.lpeg.match({pattern}, {subject}, {init})                *vim.lpeg.match()*\n+    Matches the given `pattern` against the `subject` string. If the match\n+    succeeds, returns the index in the subject of the first character after\n+    the match, or the captured values (if the pattern captured any value). An\n+    optional numeric argument `init` makes the match start at that position in\n+    the subject string. As usual in Lua libraries, a negative value counts\n+    from the end. Unlike typical pattern-matching functions, `match` works\n+    only in anchored mode; that is, it tries to match the pattern with a\n+    prefix of the given subject string (at position `init`), not with an\n+    arbitrary substring of the subject. So, if we want to find a pattern\n+    anywhere in a string, we must either write a loop in Lua or write a\n+    pattern that matches anywhere.\n+\n+    Example: >lua\n+        local pattern = lpeg.R(\"az\") ^ 1 * -1\n+        assert(pattern:match(\"hello\") == 6)\n+        assert(lpeg.match(pattern, \"hello\") == 6)\n+        assert(pattern:match(\"1 hello\") == nil)\n+<\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+      • {subject}  (`string`)\n+      • {init}     (`integer?`)\n+\n+    Return: ~\n+        (`integer|vim.lpeg.Capture?`)\n+\n+vim.lpeg.P({value})                                             *vim.lpeg.P()*\n+    Converts the given value into a proper pattern. This following rules are",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1451126567",
            "id": 1451126567,
            "line": 3221,
            "node_id": "PRRC_kwDOAPphoM5Wfm8n",
            "original_commit_id": "095d7d85882ad25da9a9d60e3038e332eff3c86e",
            "original_line": 3221,
            "original_position": 302,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 302,
            "pull_request_review_id": 1819699202,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451126567/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-13T03:05:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451126567",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/62502207?v=4",
                "events_url": "https://api.github.com/users/MariaSolOs/events{/privacy}",
                "followers_url": "https://api.github.com/users/MariaSolOs/followers",
                "following_url": "https://api.github.com/users/MariaSolOs/following{/other_user}",
                "gists_url": "https://api.github.com/users/MariaSolOs/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/MariaSolOs",
                "id": 62502207,
                "login": "MariaSolOs",
                "node_id": "MDQ6VXNlcjYyNTAyMjA3",
                "organizations_url": "https://api.github.com/users/MariaSolOs/orgs",
                "received_events_url": "https://api.github.com/users/MariaSolOs/received_events",
                "repos_url": "https://api.github.com/users/MariaSolOs/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/MariaSolOs/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/MariaSolOs/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/MariaSolOs"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1451475681"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451475681"
                }
            },
            "author_association": "MEMBER",
            "body": "Yes `* sep (*` tag... from `---   local p = elem * (sep * elem)^0`. \r\n\r\n~~Wrapping these with `<pre></pre>` also doesn't work. Not sure yet how to fix this.~~ It's not a doxygen problem, an issue of our `gen_vimdoc.py`; will try to fix these",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-13T12:03:53Z",
            "diff_hunk": "@@ -3034,6 +2984,473 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+The Lpeg library for parsing expression grammars is being included as\n+`vim.lpeg` (https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as\n+|vim.re| (https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example:>lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1451475681",
            "id": 1451475681,
            "in_reply_to_id": 1449343062,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5Wg8Lh",
            "original_commit_id": "fbb615b921d2310b81bb5b769fb9fd930f2fb8fa",
            "original_line": 3024,
            "original_position": 100,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1819982993,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451475681/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-13T12:06:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451475681",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1451479432"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451479432"
                }
            },
            "author_association": "MEMBER",
            "body": "The documentation and code example were brought from #25311 (https://github.com/LuaCATS/lpeg/blob/master/library/lpeg.lua), so I would vote to not converting them for such externally-written docs (other than minor style and punctuation edit so that vimdoc generation doesn't go wonky).",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-13T12:11:32Z",
            "diff_hunk": "@@ -3034,6 +2984,478 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+LPeg is a pattern-matching library for Lua, based on\n+Parsing Expression Grammars (https://bford.info/packrat/) (PEGs).\n+\n+                                                                    *lua-lpeg*\n+                                                            *vim.lpeg.Pattern*\n+The LPeg library for parsing expression grammars is included as `vim.lpeg`\n+(https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as |vim.re|\n+(https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example: >lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *\n+          return lpeg.match(p, s)\n+        end\n+        local a, b, c = split('a,b,c', ',')\n+        assert(a == 'a')\n+        assert(b == 'b')\n+        assert(c == 'c')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Carg({n})                                           *vim.lpeg.Carg()*\n+    Creates an argument capture. This pattern matches the empty string and\n+    produces the value given as the nth extra argument given in the call to `lpeg.match` .\n+\n+    Parameters: ~\n+      • {n}  (`integer`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cb({name})                                            *vim.lpeg.Cb()*\n+    Creates a back capture. This pattern matches the empty string and produces\n+    the values produced by the most recent group capture named `name` (where\n+    `name` can be any Lua value). Most recent means the last complete\n+    outermost group capture with the given name. A Complete capture means that\n+    the entire pattern corresponding to the capture has matched. An Outermost\n+    capture means that the capture is not inside another complete capture. In\n+    the same way that LPeg does not specify when it evaluates captures, it\n+    does not specify whether it reuses values previously produced by the group\n+    or re-evaluates them.\n+\n+    Parameters: ~\n+      • {name}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cc({...})                                             *vim.lpeg.Cc()*\n+    Creates a constant capture. This pattern matches the empty string and\n+    produces all given values as its captured values.\n+\n+    Parameters: ~\n+      • {...}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cf({patt}, {func})                                    *vim.lpeg.Cf()*\n+    Creates a fold capture. If `patt` produces a list of captures C1 C2 ...\n+    Cn, this capture will produce the value `func(...func(func(C1, C2),\n+    C3)...,Cn)`, that is, it will fold (or accumulate, or reduce) the captures\n+    from `patt` using function `func`. This capture assumes that `patt` should\n+    produce at least one capture with at least one value (of any type), which\n+    becomes the initial value of an accumulator. (If you need a specific\n+    initial value, you may prefix a constant captureto `patt`.) For each\n+    subsequent capture, LPeg calls `func` with this accumulator as the first\n+    argument and all values produced by the capture as extra arguments; the\n+    first result from this call becomes the new value for the accumulator. The\n+    final value of the accumulator becomes the captured value.\n+\n+    Example: >lua\n+        local number = lpeg.R(\"09\") ^ 1 / tonumber\n+        local list = numbernumber) ^ 0                                * (\",\" *\n+        local function add(acc, newvalue) return acc + newvalue end\n+        local sum = lpeg.Cf(list, add)\n+        assert(sum:match(\"10,30,43\") == 83)",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1451479432",
            "id": 1451479432,
            "in_reply_to_id": 1451124947,
            "line": 3094,
            "node_id": "PRRC_kwDOAPphoM5Wg9GI",
            "original_commit_id": "095d7d85882ad25da9a9d60e3038e332eff3c86e",
            "original_line": 3094,
            "original_position": 175,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 175,
            "pull_request_review_id": 1819985534,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451479432/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-13T12:11:32Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451479432",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1451479973"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451479973"
                }
            },
            "author_association": "MEMBER",
            "body": "Good catch! I can submit a PR to https://github.com/LuaCATS/lpeg/, but this should be fixed in the upstream.",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-13T12:12:34Z",
            "diff_hunk": "@@ -3034,6 +2984,478 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+LPeg is a pattern-matching library for Lua, based on\n+Parsing Expression Grammars (https://bford.info/packrat/) (PEGs).\n+\n+                                                                    *lua-lpeg*\n+                                                            *vim.lpeg.Pattern*\n+The LPeg library for parsing expression grammars is included as `vim.lpeg`\n+(https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as |vim.re|\n+(https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example: >lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *\n+          return lpeg.match(p, s)\n+        end\n+        local a, b, c = split('a,b,c', ',')\n+        assert(a == 'a')\n+        assert(b == 'b')\n+        assert(c == 'c')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Carg({n})                                           *vim.lpeg.Carg()*\n+    Creates an argument capture. This pattern matches the empty string and\n+    produces the value given as the nth extra argument given in the call to `lpeg.match` .\n+\n+    Parameters: ~\n+      • {n}  (`integer`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cb({name})                                            *vim.lpeg.Cb()*\n+    Creates a back capture. This pattern matches the empty string and produces\n+    the values produced by the most recent group capture named `name` (where\n+    `name` can be any Lua value). Most recent means the last complete\n+    outermost group capture with the given name. A Complete capture means that\n+    the entire pattern corresponding to the capture has matched. An Outermost\n+    capture means that the capture is not inside another complete capture. In\n+    the same way that LPeg does not specify when it evaluates captures, it\n+    does not specify whether it reuses values previously produced by the group\n+    or re-evaluates them.\n+\n+    Parameters: ~\n+      • {name}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cc({...})                                             *vim.lpeg.Cc()*\n+    Creates a constant capture. This pattern matches the empty string and\n+    produces all given values as its captured values.\n+\n+    Parameters: ~\n+      • {...}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cf({patt}, {func})                                    *vim.lpeg.Cf()*\n+    Creates a fold capture. If `patt` produces a list of captures C1 C2 ...\n+    Cn, this capture will produce the value `func(...func(func(C1, C2),\n+    C3)...,Cn)`, that is, it will fold (or accumulate, or reduce) the captures\n+    from `patt` using function `func`. This capture assumes that `patt` should\n+    produce at least one capture with at least one value (of any type), which\n+    becomes the initial value of an accumulator. (If you need a specific\n+    initial value, you may prefix a constant captureto `patt`.) For each\n+    subsequent capture, LPeg calls `func` with this accumulator as the first\n+    argument and all values produced by the capture as extra arguments; the\n+    first result from this call becomes the new value for the accumulator. The\n+    final value of the accumulator becomes the captured value.\n+\n+    Example: >lua\n+        local number = lpeg.R(\"09\") ^ 1 / tonumber\n+        local list = numbernumber) ^ 0                                * (\",\" *\n+        local function add(acc, newvalue) return acc + newvalue end\n+        local sum = lpeg.Cf(list, add)\n+        assert(sum:match(\"10,30,43\") == 83)\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {func}  (`fun(acc, newvalue)`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cg({patt}, {name})                                    *vim.lpeg.Cg()*\n+    Creates a group capture. It groups all values returned by `patt` into a\n+    single capture. The group may be anonymous (if no name is given) or named\n+    with the given name (which can be any non-nil Lua value).\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {name}  (`string?`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cmt({patt}, {fn})                                    *vim.lpeg.Cmt()*\n+    Creates a match-time capture. Unlike all other captures, this one is\n+    evaluated immediately when a match occurs (even if it is part of a larger\n+    pattern that fails later). It forces the immediate evaluation of all its\n+    nested captures and then calls `function`. The given function gets as\n+    arguments the entire subject, the current position (after the match of\n+    `patt`), plus any capture values produced by `patt`. The first value\n+    returned by `function` defines how the match happens. If the call returns\n+    a number, the match succeeds and the returned number becomes the new\n+    current position. (Assuming a subject sand current position i, the\n+    returned number must be in the range [i, len(s) + 1].) If the call returns\n+    true, the match succeeds without consuming any input (so, to return true\n+    is equivalent to return i). If the call returns false, nil, or no value,\n+    the match fails. Any extra values returned by the function become the\n+    values produced by the capture.\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {fn}    (`function`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cp()                                                  *vim.lpeg.Cp()*\n+    Creates a position capture. It matches the empty string and captures the\n+    position in the subject where the match occurs. The captured value is a\n+    number.\n+\n+    Example: >lua\n+        local I = lpeg.Cp()\n+        local function anywhere(p) return lpeg.P({II + 1 * lpeg.V(1)}) end * p *\n+        local match_start, match_end = anywhere(\"world\"):match(\"hello world!\")\n+        assert(match_start == 7)\n+        assert(match_end == 12)\n+<\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cs({patt})                                            *vim.lpeg.Cs()*\n+    Creates a substitution capture. This function creates a substitution\n+    capture, which captures the substring of the subject that matches `patt`,\n+    with substitutions. For any capture inside `patt` with a value, the\n+    substring that matched the capture is replaced by the capture value (which\n+    should be a string). The final captured value is the string resulting from\n+    all replacements.\n+\n+    Example: >lua\n+        local function gsub (s, patt, repl)\n+          patt = lpeg.P(patt)\n+          patt = lpeg.Cs((patt / repl + 1)^0)\n+          return lpeg.match(patt, s)\n+        end\n+        assert(gsub('Hello, xxx!', 'xxx', 'World') == 'Hello, World!')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Ct({patt})                                            *vim.lpeg.Ct()*\n+    Creates a table capture. This capture returns a table with all values from\n+    all anonymous captures made by `patt` inside this table in successive\n+    integer keys, starting at 1. Moreover, for each named capture group\n+    created by `patt`, the first value of the group is put into the table with\n+    the group name as its key. The captured value is only the table.\n+\n+    Parameters: ~\n+      • {patt}  (vim.lpeg.Pattern |' `) @return (` vim.lpeg.Capture`)\n+\n+vim.lpeg.lpeg                                                     *vim.lpeg()*\n+    LPeg is a new pattern-matching library for Lua, based on Parsing Expression\n+    Grammars (PEGs).\n+\n+vim.lpeg.match({pattern}, {subject}, {init})                *vim.lpeg.match()*\n+    Matches the given `pattern` against the `subject` string. If the match\n+    succeeds, returns the index in the subject of the first character after\n+    the match, or the captured values (if the pattern captured any value). An\n+    optional numeric argument `init` makes the match start at that position in\n+    the subject string. As usual in Lua libraries, a negative value counts\n+    from the end. Unlike typical pattern-matching functions, `match` works\n+    only in anchored mode; that is, it tries to match the pattern with a\n+    prefix of the given subject string (at position `init`), not with an\n+    arbitrary substring of the subject. So, if we want to find a pattern\n+    anywhere in a string, we must either write a loop in Lua or write a\n+    pattern that matches anywhere.\n+\n+    Example: >lua\n+        local pattern = lpeg.R(\"az\") ^ 1 * -1\n+        assert(pattern:match(\"hello\") == 6)\n+        assert(lpeg.match(pattern, \"hello\") == 6)\n+        assert(pattern:match(\"1 hello\") == nil)\n+<\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+      • {subject}  (`string`)\n+      • {init}     (`integer?`)\n+\n+    Return: ~\n+        (`integer|vim.lpeg.Capture?`)\n+\n+vim.lpeg.P({value})                                             *vim.lpeg.P()*\n+    Converts the given value into a proper pattern. This following rules are",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1451479973",
            "id": 1451479973,
            "in_reply_to_id": 1451126567,
            "line": 3221,
            "node_id": "PRRC_kwDOAPphoM5Wg9Ol",
            "original_commit_id": "095d7d85882ad25da9a9d60e3038e332eff3c86e",
            "original_line": 3221,
            "original_position": 302,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 302,
            "pull_request_review_id": 1819986059,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451479973/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-13T12:12:34Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451479973",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1451522840"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451522840"
                }
            },
            "author_association": "MEMBER",
            "body": "\"The following rules\", while you're at it ;)",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-13T13:50:35Z",
            "diff_hunk": "@@ -3034,6 +2984,478 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+LPeg is a pattern-matching library for Lua, based on\n+Parsing Expression Grammars (https://bford.info/packrat/) (PEGs).\n+\n+                                                                    *lua-lpeg*\n+                                                            *vim.lpeg.Pattern*\n+The LPeg library for parsing expression grammars is included as `vim.lpeg`\n+(https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as |vim.re|\n+(https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example: >lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *\n+          return lpeg.match(p, s)\n+        end\n+        local a, b, c = split('a,b,c', ',')\n+        assert(a == 'a')\n+        assert(b == 'b')\n+        assert(c == 'c')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Carg({n})                                           *vim.lpeg.Carg()*\n+    Creates an argument capture. This pattern matches the empty string and\n+    produces the value given as the nth extra argument given in the call to `lpeg.match` .\n+\n+    Parameters: ~\n+      • {n}  (`integer`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cb({name})                                            *vim.lpeg.Cb()*\n+    Creates a back capture. This pattern matches the empty string and produces\n+    the values produced by the most recent group capture named `name` (where\n+    `name` can be any Lua value). Most recent means the last complete\n+    outermost group capture with the given name. A Complete capture means that\n+    the entire pattern corresponding to the capture has matched. An Outermost\n+    capture means that the capture is not inside another complete capture. In\n+    the same way that LPeg does not specify when it evaluates captures, it\n+    does not specify whether it reuses values previously produced by the group\n+    or re-evaluates them.\n+\n+    Parameters: ~\n+      • {name}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cc({...})                                             *vim.lpeg.Cc()*\n+    Creates a constant capture. This pattern matches the empty string and\n+    produces all given values as its captured values.\n+\n+    Parameters: ~\n+      • {...}  (`any`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cf({patt}, {func})                                    *vim.lpeg.Cf()*\n+    Creates a fold capture. If `patt` produces a list of captures C1 C2 ...\n+    Cn, this capture will produce the value `func(...func(func(C1, C2),\n+    C3)...,Cn)`, that is, it will fold (or accumulate, or reduce) the captures\n+    from `patt` using function `func`. This capture assumes that `patt` should\n+    produce at least one capture with at least one value (of any type), which\n+    becomes the initial value of an accumulator. (If you need a specific\n+    initial value, you may prefix a constant captureto `patt`.) For each\n+    subsequent capture, LPeg calls `func` with this accumulator as the first\n+    argument and all values produced by the capture as extra arguments; the\n+    first result from this call becomes the new value for the accumulator. The\n+    final value of the accumulator becomes the captured value.\n+\n+    Example: >lua\n+        local number = lpeg.R(\"09\") ^ 1 / tonumber\n+        local list = numbernumber) ^ 0                                * (\",\" *\n+        local function add(acc, newvalue) return acc + newvalue end\n+        local sum = lpeg.Cf(list, add)\n+        assert(sum:match(\"10,30,43\") == 83)\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {func}  (`fun(acc, newvalue)`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cg({patt}, {name})                                    *vim.lpeg.Cg()*\n+    Creates a group capture. It groups all values returned by `patt` into a\n+    single capture. The group may be anonymous (if no name is given) or named\n+    with the given name (which can be any non-nil Lua value).\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {name}  (`string?`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cmt({patt}, {fn})                                    *vim.lpeg.Cmt()*\n+    Creates a match-time capture. Unlike all other captures, this one is\n+    evaluated immediately when a match occurs (even if it is part of a larger\n+    pattern that fails later). It forces the immediate evaluation of all its\n+    nested captures and then calls `function`. The given function gets as\n+    arguments the entire subject, the current position (after the match of\n+    `patt`), plus any capture values produced by `patt`. The first value\n+    returned by `function` defines how the match happens. If the call returns\n+    a number, the match succeeds and the returned number becomes the new\n+    current position. (Assuming a subject sand current position i, the\n+    returned number must be in the range [i, len(s) + 1].) If the call returns\n+    true, the match succeeds without consuming any input (so, to return true\n+    is equivalent to return i). If the call returns false, nil, or no value,\n+    the match fails. Any extra values returned by the function become the\n+    values produced by the capture.\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+      • {fn}    (`function`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cp()                                                  *vim.lpeg.Cp()*\n+    Creates a position capture. It matches the empty string and captures the\n+    position in the subject where the match occurs. The captured value is a\n+    number.\n+\n+    Example: >lua\n+        local I = lpeg.Cp()\n+        local function anywhere(p) return lpeg.P({II + 1 * lpeg.V(1)}) end * p *\n+        local match_start, match_end = anywhere(\"world\"):match(\"hello world!\")\n+        assert(match_start == 7)\n+        assert(match_end == 12)\n+<\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Cs({patt})                                            *vim.lpeg.Cs()*\n+    Creates a substitution capture. This function creates a substitution\n+    capture, which captures the substring of the subject that matches `patt`,\n+    with substitutions. For any capture inside `patt` with a value, the\n+    substring that matched the capture is replaced by the capture value (which\n+    should be a string). The final captured value is the string resulting from\n+    all replacements.\n+\n+    Example: >lua\n+        local function gsub (s, patt, repl)\n+          patt = lpeg.P(patt)\n+          patt = lpeg.Cs((patt / repl + 1)^0)\n+          return lpeg.match(patt, s)\n+        end\n+        assert(gsub('Hello, xxx!', 'xxx', 'World') == 'Hello, World!')\n+<\n+\n+    Parameters: ~\n+      • {patt}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Capture`)\n+\n+vim.lpeg.Ct({patt})                                            *vim.lpeg.Ct()*\n+    Creates a table capture. This capture returns a table with all values from\n+    all anonymous captures made by `patt` inside this table in successive\n+    integer keys, starting at 1. Moreover, for each named capture group\n+    created by `patt`, the first value of the group is put into the table with\n+    the group name as its key. The captured value is only the table.\n+\n+    Parameters: ~\n+      • {patt}  (vim.lpeg.Pattern |' `) @return (` vim.lpeg.Capture`)\n+\n+vim.lpeg.lpeg                                                     *vim.lpeg()*\n+    LPeg is a new pattern-matching library for Lua, based on Parsing Expression\n+    Grammars (PEGs).\n+\n+vim.lpeg.match({pattern}, {subject}, {init})                *vim.lpeg.match()*\n+    Matches the given `pattern` against the `subject` string. If the match\n+    succeeds, returns the index in the subject of the first character after\n+    the match, or the captured values (if the pattern captured any value). An\n+    optional numeric argument `init` makes the match start at that position in\n+    the subject string. As usual in Lua libraries, a negative value counts\n+    from the end. Unlike typical pattern-matching functions, `match` works\n+    only in anchored mode; that is, it tries to match the pattern with a\n+    prefix of the given subject string (at position `init`), not with an\n+    arbitrary substring of the subject. So, if we want to find a pattern\n+    anywhere in a string, we must either write a loop in Lua or write a\n+    pattern that matches anywhere.\n+\n+    Example: >lua\n+        local pattern = lpeg.R(\"az\") ^ 1 * -1\n+        assert(pattern:match(\"hello\") == 6)\n+        assert(lpeg.match(pattern, \"hello\") == 6)\n+        assert(pattern:match(\"1 hello\") == nil)\n+<\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+      • {subject}  (`string`)\n+      • {init}     (`integer?`)\n+\n+    Return: ~\n+        (`integer|vim.lpeg.Capture?`)\n+\n+vim.lpeg.P({value})                                             *vim.lpeg.P()*\n+    Converts the given value into a proper pattern. This following rules are",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1451522840",
            "id": 1451522840,
            "in_reply_to_id": 1451126567,
            "line": 3221,
            "node_id": "PRRC_kwDOAPphoM5WhHsY",
            "original_commit_id": "095d7d85882ad25da9a9d60e3038e332eff3c86e",
            "original_line": 3221,
            "original_position": 302,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 302,
            "pull_request_review_id": 1820020423,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451522840/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-13T13:50:35Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451522840",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/2361214?v=4",
                "events_url": "https://api.github.com/users/clason/events{/privacy}",
                "followers_url": "https://api.github.com/users/clason/followers",
                "following_url": "https://api.github.com/users/clason/following{/other_user}",
                "gists_url": "https://api.github.com/users/clason/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/clason",
                "id": 2361214,
                "login": "clason",
                "node_id": "MDQ6VXNlcjIzNjEyMTQ=",
                "organizations_url": "https://api.github.com/users/clason/orgs",
                "received_events_url": "https://api.github.com/users/clason/received_events",
                "repos_url": "https://api.github.com/users/clason/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/clason/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/clason/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/clason"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1451547944"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451547944"
                }
            },
            "author_association": "MEMBER",
            "body": "was it an oversight that we didn't have this before?",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-13T15:08:02Z",
            "diff_hunk": "@@ -912,6 +912,7 @@ file(GLOB API_SOURCES CONFIGURE_DEPENDS ${PROJECT_SOURCE_DIR}/src/nvim/api/*.c)\n \n file(GLOB LUA_SOURCES CONFIGURE_DEPENDS\n   ${NVIM_RUNTIME_DIR}/lua/vim/*.lua\n+  ${NVIM_RUNTIME_DIR}/lua/vim/_meta/*.lua",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1451547944",
            "id": 1451547944,
            "line": 915,
            "node_id": "PRRC_kwDOAPphoM5WhN0o",
            "original_commit_id": "095d7d85882ad25da9a9d60e3038e332eff3c86e",
            "original_line": 915,
            "original_position": 4,
            "original_start_line": null,
            "path": "src/nvim/CMakeLists.txt",
            "position": 4,
            "pull_request_review_id": 1820031052,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451547944/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-13T15:08:02Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451547944",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1451548489"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451548489"
                }
            },
            "author_association": "MEMBER",
            "body": "I think so. `make doc` was incorrectly saying the target is up-to-date.",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-13T15:09:29Z",
            "diff_hunk": "@@ -912,6 +912,7 @@ file(GLOB API_SOURCES CONFIGURE_DEPENDS ${PROJECT_SOURCE_DIR}/src/nvim/api/*.c)\n \n file(GLOB LUA_SOURCES CONFIGURE_DEPENDS\n   ${NVIM_RUNTIME_DIR}/lua/vim/*.lua\n+  ${NVIM_RUNTIME_DIR}/lua/vim/_meta/*.lua",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1451548489",
            "id": 1451548489,
            "in_reply_to_id": 1451547944,
            "line": 915,
            "node_id": "PRRC_kwDOAPphoM5WhN9J",
            "original_commit_id": "095d7d85882ad25da9a9d60e3038e332eff3c86e",
            "original_line": 915,
            "original_position": 4,
            "original_start_line": null,
            "path": "src/nvim/CMakeLists.txt",
            "position": 4,
            "pull_request_review_id": 1820031227,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451548489/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-13T15:09:29Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451548489",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1451548769"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451548769"
                }
            },
            "author_association": "MEMBER",
            "body": "Fixed the bug in `gen_vimdoc.py`",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-13T15:10:12Z",
            "diff_hunk": "@@ -3034,6 +2984,473 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+The Lpeg library for parsing expression grammars is being included as\n+`vim.lpeg` (https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as\n+|vim.re| (https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and\n+    predicate, this pattern never consumes any input, independently of success\n+    or failure.\n+\n+    Parameters: ~\n+      • {pattern}  (`vim.lpeg.Pattern`)\n+\n+    Return: ~\n+        (`vim.lpeg.Pattern`)\n+\n+vim.lpeg.C({patt})                                              *vim.lpeg.C()*\n+    Creates a simple capture, which captures the substring of the subject that\n+    matches `patt`. The captured value is a string. If `patt` has other\n+    captures, their values are returned after this one.\n+\n+    Example:>lua\n+        local function split (s, sep)\n+          sep = lpeg.P(sep)\n+          local elem = lpeg.C((1 - sep)^0)\n+          local p = elemelem)^0                                       * (sep *",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1451548769",
            "id": 1451548769,
            "in_reply_to_id": 1449343062,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5WhOBh",
            "original_commit_id": "fbb615b921d2310b81bb5b769fb9fd930f2fb8fa",
            "original_line": 3024,
            "original_position": 100,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": null,
            "pull_request_review_id": 1820031296,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451548769/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-13T15:10:12Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451548769",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1451550125"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451550125"
                }
            },
            "author_association": "MEMBER",
            "body": "note this workaround; for the bug https://github.com/neovim/neovim/pull/26989#discussion_r1450986576\r\n",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-01-13T15:14:32Z",
            "diff_hunk": "@@ -69,7 +88,7 @@ function Pattern:match(subject, init) end\n \n --- Returns the string `\"pattern\"` if the given value is a pattern, otherwise `nil`.\n ---\n---- @return 'pattern'|nil\n+--- @return \"pattern\"|nil",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1451550125",
            "id": 1451550125,
            "line": 91,
            "node_id": "PRRC_kwDOAPphoM5WhOWt",
            "original_commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "original_line": 91,
            "original_position": 48,
            "original_start_line": null,
            "path": "runtime/lua/vim/_meta/lpeg.lua",
            "position": 48,
            "pull_request_review_id": 1820031720,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451550125/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-01-13T15:14:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1451550125",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/26989#discussion_r1484801351"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/26989"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1484801351"
                }
            },
            "author_association": "MEMBER",
            "body": "Continued in #27402 ",
            "commit_id": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
            "created_at": "2024-02-09T21:05:19Z",
            "diff_hunk": "@@ -3034,6 +2984,478 @@ vim.glob.to_lpeg({pattern})                               *vim.glob.to_lpeg()*\n         pattern\n \n \n+==============================================================================\n+VIM.LPEG                                                            *vim.lpeg*\n+\n+\n+LPeg is a pattern-matching library for Lua, based on\n+Parsing Expression Grammars (https://bford.info/packrat/) (PEGs).\n+\n+                                                                    *lua-lpeg*\n+                                                            *vim.lpeg.Pattern*\n+The LPeg library for parsing expression grammars is included as `vim.lpeg`\n+(https://www.inf.puc-rio.br/~roberto/lpeg/).\n+\n+In addition, its regex-like interface is available as |vim.re|\n+(https://www.inf.puc-rio.br/~roberto/lpeg/re.html).\n+\n+vim.lpeg.B({pattern})                                           *vim.lpeg.B()*\n+    Returns a pattern that matches only if the input string at the current\n+    position is preceded by `patt`. Pattern `patt` must match only strings\n+    with some fixed length, and it cannot contain captures. Like the and",
            "html_url": "https://github.com/neovim/neovim/pull/26989#discussion_r1484801351",
            "id": 1484801351,
            "in_reply_to_id": 1451122972,
            "line": 3005,
            "node_id": "PRRC_kwDOAPphoM5YgEVH",
            "original_commit_id": "095d7d85882ad25da9a9d60e3038e332eff3c86e",
            "original_line": 3005,
            "original_position": 86,
            "original_start_line": null,
            "path": "runtime/doc/lua.txt",
            "position": 86,
            "pull_request_review_id": 1873193250,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1484801351/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-02-09T21:05:19Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1484801351",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        }
    ],
    "comment_regular_data": [
        {
            "author_association": "MEMBER",
            "body": "I think all the bugs and issues on docs are now resolved, so this should be fine to merge. @MariaSolOs has pointed out several typos and linguistic things to improve (thanks again for finding those!), but I suggest we merge this as-is for now and address them in subsequent commits after having all the fixes done in the upstream (https://github.com/LuaCATS/lpeg/) and synchronize to neovim; the main point of this PR is to \"auto-generate\" docs for `vim.lpeg` and `vim.re`.",
            "created_at": "2024-01-13T15:13:48Z",
            "html_url": "https://github.com/neovim/neovim/pull/26989#issuecomment-1890484045",
            "id": 1890484045,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/26989",
            "node_id": "IC_kwDOAPphoM5wrn9N",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 1,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1890484045/reactions"
            },
            "updated_at": "2024-01-13T15:59:20Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1890484045",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            }
        },
        {
            "author_association": "MEMBER",
            "body": "@clason @dundargoc if this LGTY please merge",
            "created_at": "2024-01-13T15:54:55Z",
            "html_url": "https://github.com/neovim/neovim/pull/26989#issuecomment-1890533326",
            "id": 1890533326,
            "issue_url": "https://api.github.com/repos/neovim/neovim/issues/26989",
            "node_id": "IC_kwDOAPphoM5wrz_O",
            "performed_via_github_app": null,
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1890533326/reactions"
            },
            "updated_at": "2024-01-13T15:54:55Z",
            "url": "https://api.github.com/repos/neovim/neovim/issues/comments/1890533326",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk"
            }
        }
    ],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/26989/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/26989/commits",
    "created_at": "2024-01-11T17:24:57Z",
    "diff_url": "https://github.com/neovim/neovim/pull/26989.diff",
    "draft": false,
    "head": {
        "label": "wookayin:docs-lpeg",
        "ref": "docs-lpeg",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/wookayin/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/wookayin/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/wookayin/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/wookayin/neovim/branches{/branch}",
            "clone_url": "https://github.com/wookayin/neovim.git",
            "collaborators_url": "https://api.github.com/repos/wookayin/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/wookayin/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/wookayin/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/wookayin/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/wookayin/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/wookayin/neovim/contributors",
            "created_at": "2022-10-30T19:40:29Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/wookayin/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/wookayin/neovim/downloads",
            "events_url": "https://api.github.com/repos/wookayin/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/wookayin/neovim/forks",
            "full_name": "wookayin/neovim",
            "git_commits_url": "https://api.github.com/repos/wookayin/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/wookayin/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/wookayin/neovim/git/tags{/sha}",
            "git_url": "git://github.com/wookayin/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": false,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/wookayin/neovim/hooks",
            "html_url": "https://github.com/wookayin/neovim",
            "id": 559659867,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/wookayin/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/wookayin/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/wookayin/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/wookayin/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/wookayin/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/wookayin/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/wookayin/neovim/merges",
            "milestones_url": "https://api.github.com/repos/wookayin/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "R_kgDOIVu7Ww",
            "notifications_url": "https://api.github.com/repos/wookayin/neovim/notifications{?since,all,participating}",
            "open_issues": 1,
            "open_issues_count": 1,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
                "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
                "followers_url": "https://api.github.com/users/wookayin/followers",
                "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
                "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/wookayin",
                "id": 1009873,
                "login": "wookayin",
                "node_id": "MDQ6VXNlcjEwMDk4NzM=",
                "organizations_url": "https://api.github.com/users/wookayin/orgs",
                "received_events_url": "https://api.github.com/users/wookayin/received_events",
                "repos_url": "https://api.github.com/users/wookayin/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/wookayin"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/wookayin/neovim/pulls{/number}",
            "pushed_at": "2024-02-12T05:28:22Z",
            "releases_url": "https://api.github.com/repos/wookayin/neovim/releases{/id}",
            "size": 247978,
            "ssh_url": "git@github.com:wookayin/neovim.git",
            "stargazers_count": 0,
            "stargazers_url": "https://api.github.com/repos/wookayin/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/wookayin/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/wookayin/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/wookayin/neovim/subscription",
            "svn_url": "https://github.com/wookayin/neovim",
            "tags_url": "https://api.github.com/repos/wookayin/neovim/tags",
            "teams_url": "https://api.github.com/repos/wookayin/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/wookayin/neovim/git/trees{/sha}",
            "updated_at": "2024-01-25T20:45:40Z",
            "url": "https://api.github.com/repos/wookayin/neovim",
            "visibility": "public",
            "watchers": 0,
            "watchers_count": 0,
            "web_commit_signoff_required": false
        },
        "sha": "89975f60c10b33ad36a728a267acb3f2ccb2e25b",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
            "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
            "followers_url": "https://api.github.com/users/wookayin/followers",
            "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
            "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/wookayin",
            "id": 1009873,
            "login": "wookayin",
            "node_id": "MDQ6VXNlcjEwMDk4NzM=",
            "organizations_url": "https://api.github.com/users/wookayin/orgs",
            "received_events_url": "https://api.github.com/users/wookayin/received_events",
            "repos_url": "https://api.github.com/users/wookayin/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/wookayin"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/26989",
    "id": 1675014783,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/26989",
    "labels": [
        {
            "color": "c5def5",
            "default": true,
            "description": "",
            "id": 84744038,
            "name": "documentation",
            "node_id": "MDU6TGFiZWw4NDc0NDAzOA==",
            "url": "https://api.github.com/repos/neovim/neovim/labels/documentation"
        }
    ],
    "locked": false,
    "merge_commit_sha": "2cdea852e8934beb89012f2127f333e4dd8aada8",
    "merged_at": "2024-01-14T11:08:33Z",
    "milestone": {
        "closed_at": null,
        "closed_issues": 288,
        "created_at": "2023-02-02T14:11:43Z",
        "creator": {
            "avatar_url": "https://avatars.githubusercontent.com/u/1363104?v=4",
            "events_url": "https://api.github.com/users/bfredl/events{/privacy}",
            "followers_url": "https://api.github.com/users/bfredl/followers",
            "following_url": "https://api.github.com/users/bfredl/following{/other_user}",
            "gists_url": "https://api.github.com/users/bfredl/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/bfredl",
            "id": 1363104,
            "login": "bfredl",
            "node_id": "MDQ6VXNlcjEzNjMxMDQ=",
            "organizations_url": "https://api.github.com/users/bfredl/orgs",
            "received_events_url": "https://api.github.com/users/bfredl/received_events",
            "repos_url": "https://api.github.com/users/bfredl/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/bfredl/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/bfredl/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/bfredl"
        },
        "description": "",
        "due_on": "2024-04-01T07:00:00Z",
        "html_url": "https://github.com/neovim/neovim/milestone/36",
        "id": 8997654,
        "labels_url": "https://api.github.com/repos/neovim/neovim/milestones/36/labels",
        "node_id": "MI_kwDOAPphoM4AiUsW",
        "number": 36,
        "open_issues": 135,
        "state": "open",
        "title": "0.10",
        "updated_at": "2024-02-12T23:38:13Z",
        "url": "https://api.github.com/repos/neovim/neovim/milestones/36"
    },
    "node_id": "PR_kwDOAPphoM5j1rJ_",
    "number": 26989,
    "patch_url": "https://github.com/neovim/neovim/pull/26989.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/26989/comments",
    "state": "closed",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/89975f60c10b33ad36a728a267acb3f2ccb2e25b",
    "title": "docs: auto-generate docs for `vim.lpeg` and `vim.re`",
    "updated_at": "2024-02-09T21:05:19Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/26989",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/1009873?v=4",
        "events_url": "https://api.github.com/users/wookayin/events{/privacy}",
        "followers_url": "https://api.github.com/users/wookayin/followers",
        "following_url": "https://api.github.com/users/wookayin/following{/other_user}",
        "gists_url": "https://api.github.com/users/wookayin/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/wookayin",
        "id": 1009873,
        "login": "wookayin",
        "node_id": "MDQ6VXNlcjEwMDk4NzM=",
        "organizations_url": "https://api.github.com/users/wookayin/orgs",
        "received_events_url": "https://api.github.com/users/wookayin/received_events",
        "repos_url": "https://api.github.com/users/wookayin/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/wookayin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/wookayin/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/wookayin"
    }
}