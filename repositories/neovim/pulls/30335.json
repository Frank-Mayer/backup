{
    "_links": {
        "comments": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/30335/comments"
        },
        "commits": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/30335/commits"
        },
        "html": {
            "href": "https://github.com/neovim/neovim/pull/30335"
        },
        "issue": {
            "href": "https://api.github.com/repos/neovim/neovim/issues/30335"
        },
        "review_comment": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}"
        },
        "review_comments": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/30335/comments"
        },
        "self": {
            "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
        },
        "statuses": {
            "href": "https://api.github.com/repos/neovim/neovim/statuses/8a929db696ebe7ca26836de61659e6af4cdb9cdd"
        }
    },
    "active_lock_reason": null,
    "assignee": null,
    "assignees": [],
    "author_association": "MEMBER",
    "auto_merge": null,
    "base": {
        "label": "neovim:master",
        "ref": "master",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/neovim/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/neovim/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/neovim/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/neovim/neovim/branches{/branch}",
            "clone_url": "https://github.com/neovim/neovim.git",
            "collaborators_url": "https://api.github.com/repos/neovim/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/neovim/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/neovim/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/neovim/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/neovim/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/neovim/neovim/contributors",
            "created_at": "2014-01-31T13:39:22Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/neovim/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/neovim/neovim/downloads",
            "events_url": "https://api.github.com/repos/neovim/neovim/events",
            "fork": false,
            "forks": 5682,
            "forks_count": 5682,
            "forks_url": "https://api.github.com/repos/neovim/neovim/forks",
            "full_name": "neovim/neovim",
            "git_commits_url": "https://api.github.com/repos/neovim/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/neovim/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/neovim/neovim/git/tags{/sha}",
            "git_url": "git://github.com/neovim/neovim.git",
            "has_discussions": true,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": true,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/neovim/neovim/hooks",
            "html_url": "https://github.com/neovim/neovim",
            "id": 16408992,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/neovim/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/neovim/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/neovim/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/neovim/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/neovim/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/neovim/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/neovim/neovim/merges",
            "milestones_url": "https://api.github.com/repos/neovim/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkxNjQwODk5Mg==",
            "notifications_url": "https://api.github.com/repos/neovim/neovim/notifications{?since,all,participating}",
            "open_issues": 1804,
            "open_issues_count": 1804,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
                "events_url": "https://api.github.com/users/neovim/events{/privacy}",
                "followers_url": "https://api.github.com/users/neovim/followers",
                "following_url": "https://api.github.com/users/neovim/following{/other_user}",
                "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/neovim",
                "id": 6471485,
                "login": "neovim",
                "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
                "organizations_url": "https://api.github.com/users/neovim/orgs",
                "received_events_url": "https://api.github.com/users/neovim/received_events",
                "repos_url": "https://api.github.com/users/neovim/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
                "type": "Organization",
                "url": "https://api.github.com/users/neovim",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/neovim/neovim/pulls{/number}",
            "pushed_at": "2024-10-29T01:08:05Z",
            "releases_url": "https://api.github.com/repos/neovim/neovim/releases{/id}",
            "size": 291853,
            "ssh_url": "git@github.com:neovim/neovim.git",
            "stargazers_count": 82872,
            "stargazers_url": "https://api.github.com/repos/neovim/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/neovim/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/neovim/neovim/subscription",
            "svn_url": "https://github.com/neovim/neovim",
            "tags_url": "https://api.github.com/repos/neovim/neovim/tags",
            "teams_url": "https://api.github.com/repos/neovim/neovim/teams",
            "topics": [
                "api",
                "c",
                "lua",
                "neovim",
                "nvim",
                "text-editor",
                "vim"
            ],
            "trees_url": "https://api.github.com/repos/neovim/neovim/git/trees{/sha}",
            "updated_at": "2024-10-29T01:08:09Z",
            "url": "https://api.github.com/repos/neovim/neovim",
            "visibility": "public",
            "watchers": 82872,
            "watchers_count": 82872,
            "web_commit_signoff_required": false
        },
        "sha": "573bcb2aaf3e2421e0d2593b048f684ee05251a6",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/6471485?v=4",
            "events_url": "https://api.github.com/users/neovim/events{/privacy}",
            "followers_url": "https://api.github.com/users/neovim/followers",
            "following_url": "https://api.github.com/users/neovim/following{/other_user}",
            "gists_url": "https://api.github.com/users/neovim/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/neovim",
            "id": 6471485,
            "login": "neovim",
            "node_id": "MDEyOk9yZ2FuaXphdGlvbjY0NzE0ODU=",
            "organizations_url": "https://api.github.com/users/neovim/orgs",
            "received_events_url": "https://api.github.com/users/neovim/received_events",
            "repos_url": "https://api.github.com/users/neovim/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/neovim/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/neovim/subscriptions",
            "type": "Organization",
            "url": "https://api.github.com/users/neovim",
            "user_view_type": "public"
        }
    },
    "body": "These were imported from the v0.3.3 git tag\nhttps://github.com/neovim/libvterm/tree/v0.3.3 and not the latest\ncommit. This is for compatibility reasons as the libvterm code was\nimported from v0.3.3.",
    "closed_at": "2024-10-22T19:20:11Z",
    "comment_data": [
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1773100312"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1773100312"
                }
            },
            "author_association": "MEMBER",
            "body": "removing bitfields are going to expand the size of these structs significantly.\r\n\r\nIf we need to use these in tests it would be better to write parts of the test logic as C helper functions (there is some predecendent for this, marktree e.g. has `ifndef NDEBUG` functions only for debug builds). ",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-09-24T10:44:55Z",
            "diff_hunk": "@@ -499,18 +499,18 @@ void vterm_state_send_selection(VTermState *state, VTermSelectionMask mask, VTer\n // ------------\n \n typedef struct {\n-    unsigned int bold      : 1;",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1773100312",
            "id": 1773100312,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5pr10Y",
            "original_commit_id": "6536be8c58d0484d1435f2fc644ebfd6d6148519",
            "original_line": 502,
            "original_position": 39,
            "original_start_line": null,
            "path": "src/vterm/vterm.h",
            "position": null,
            "pull_request_review_id": 2324841602,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1773100312/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-09-24T10:44:56Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1773100312",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1363104?v=4",
                "events_url": "https://api.github.com/users/bfredl/events{/privacy}",
                "followers_url": "https://api.github.com/users/bfredl/followers",
                "following_url": "https://api.github.com/users/bfredl/following{/other_user}",
                "gists_url": "https://api.github.com/users/bfredl/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/bfredl",
                "id": 1363104,
                "login": "bfredl",
                "node_id": "MDQ6VXNlcjEzNjMxMDQ=",
                "organizations_url": "https://api.github.com/users/bfredl/orgs",
                "received_events_url": "https://api.github.com/users/bfredl/received_events",
                "repos_url": "https://api.github.com/users/bfredl/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/bfredl/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/bfredl/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/bfredl",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1773104164"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1773104164"
                }
            },
            "author_association": "MEMBER",
            "body": "or if we don't need them we just need to filter out them so luajit doesn't need to see them and get angy..\r\n",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-09-24T10:47:50Z",
            "diff_hunk": "@@ -499,18 +499,18 @@ void vterm_state_send_selection(VTermState *state, VTermSelectionMask mask, VTer\n // ------------\n \n typedef struct {\n-    unsigned int bold      : 1;",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1773104164",
            "id": 1773104164,
            "in_reply_to_id": 1773100312,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5pr2wk",
            "original_commit_id": "6536be8c58d0484d1435f2fc644ebfd6d6148519",
            "original_line": 502,
            "original_position": 39,
            "original_start_line": null,
            "path": "src/vterm/vterm.h",
            "position": null,
            "pull_request_review_id": 2324847610,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1773104164/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-09-24T10:47:50Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1773104164",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1363104?v=4",
                "events_url": "https://api.github.com/users/bfredl/events{/privacy}",
                "followers_url": "https://api.github.com/users/bfredl/followers",
                "following_url": "https://api.github.com/users/bfredl/following{/other_user}",
                "gists_url": "https://api.github.com/users/bfredl/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/bfredl",
                "id": 1363104,
                "login": "bfredl",
                "node_id": "MDQ6VXNlcjEzNjMxMDQ=",
                "organizations_url": "https://api.github.com/users/bfredl/orgs",
                "received_events_url": "https://api.github.com/users/bfredl/received_events",
                "repos_url": "https://api.github.com/users/bfredl/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/bfredl/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/bfredl/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/bfredl",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1773841487"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1773841487"
                }
            },
            "author_association": "MEMBER",
            "body": "I suspect they're not needed since both the vterm and our own tests pass without them, but I am not entirely sure. I did it this way for now to unblock the work.",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-09-24T18:38:05Z",
            "diff_hunk": "@@ -499,18 +499,18 @@ void vterm_state_send_selection(VTermState *state, VTermSelectionMask mask, VTer\n // ------------\n \n typedef struct {\n-    unsigned int bold      : 1;",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1773841487",
            "id": 1773841487,
            "in_reply_to_id": 1773100312,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5puqxP",
            "original_commit_id": "6536be8c58d0484d1435f2fc644ebfd6d6148519",
            "original_line": 502,
            "original_position": 39,
            "original_start_line": null,
            "path": "src/vterm/vterm.h",
            "position": null,
            "pull_request_review_id": 2326076601,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1773841487/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-09-24T18:38:05Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1773841487",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1774163044"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1774163044"
                }
            },
            "author_association": "MEMBER",
            "body": "Did you not read the first sentence?",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-09-24T22:24:48Z",
            "diff_hunk": "@@ -499,18 +499,18 @@ void vterm_state_send_selection(VTermState *state, VTermSelectionMask mask, VTer\n // ------------\n \n typedef struct {\n-    unsigned int bold      : 1;",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1774163044",
            "id": 1774163044,
            "in_reply_to_id": 1773100312,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5pv5Rk",
            "original_commit_id": "6536be8c58d0484d1435f2fc644ebfd6d6148519",
            "original_line": 502,
            "original_position": 39,
            "original_start_line": null,
            "path": "src/vterm/vterm.h",
            "position": null,
            "pull_request_review_id": 2326593719,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1774163044/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-09-24T22:24:48Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1774163044",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1778414014"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1778414014"
                }
            },
            "author_association": "MEMBER",
            "body": "I did, but I misunderstood. I've opted to filter out all bitfields in unit tests.",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-09-27T10:37:02Z",
            "diff_hunk": "@@ -499,18 +499,18 @@ void vterm_state_send_selection(VTermState *state, VTermSelectionMask mask, VTer\n // ------------\n \n typedef struct {\n-    unsigned int bold      : 1;",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1778414014",
            "id": 1778414014,
            "in_reply_to_id": 1773100312,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5qAHG-",
            "original_commit_id": "6536be8c58d0484d1435f2fc644ebfd6d6148519",
            "original_line": 502,
            "original_position": 39,
            "original_start_line": null,
            "path": "src/vterm/vterm.h",
            "position": null,
            "pull_request_review_id": 2333390412,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1778414014/reactions"
            },
            "side": "LEFT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-09-27T10:37:03Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1778414014",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1804351748"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804351748"
                }
            },
            "author_association": "MEMBER",
            "body": "if this is a test artifact, should this go in the build/ dir? that is where we store e.g. tempfiles created by `t.tmpname()`",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-10-17T08:37:40Z",
            "diff_hunk": "@@ -46,6 +46,7 @@ set(DEPS_IGNORE_SHA FALSE)\n #-------------------------------------------------------------------------------\n set(FUNCS_DATA ${PROJECT_BINARY_DIR}/funcs_data.mpack)\n set(TOUCHES_DIR ${PROJECT_BINARY_DIR}/touches)\n+set(VTERM_TEST_FILE ${PROJECT_BINARY_DIR}/test/vterm_test_output)",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1804351748",
            "id": 1804351748,
            "line": 49,
            "node_id": "PRRC_kwDOAPphoM5rjDkE",
            "original_commit_id": "d32806f88c11ecec378cba423c4b0441cf508809",
            "original_line": 49,
            "original_position": 4,
            "original_start_line": null,
            "path": "CMakeLists.txt",
            "position": 4,
            "pull_request_review_id": 2374543810,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804351748/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T08:37:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804351748",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1804355659"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804355659"
                }
            },
            "author_association": "MEMBER",
            "body": "👀 is this temporary change or is it explained somewhere?",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-10-17T08:40:14Z",
            "diff_hunk": "@@ -232,7 +232,7 @@ static int parse_osc8(VTermStringFragment frag, int *attr)\n {\n   // Parse the URI from the OSC 8 sequence and add the URL to our URL set.\n   // Skip the ID, we don't use it (for now)\n-  size_t i = 0;\n+  int i = 0;",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1804355659",
            "id": 1804355659,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rjEhL",
            "original_commit_id": "d32806f88c11ecec378cba423c4b0441cf508809",
            "original_line": 235,
            "original_position": 5,
            "original_start_line": null,
            "path": "src/nvim/terminal.c",
            "position": null,
            "pull_request_review_id": 2374549733,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804355659/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T08:40:15Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804355659",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1804415620"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804415620"
                }
            },
            "author_association": "MEMBER",
            "body": "`PROJECT_BINARY_DIR` is the `build/` dir.",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-10-17T09:19:21Z",
            "diff_hunk": "@@ -46,6 +46,7 @@ set(DEPS_IGNORE_SHA FALSE)\n #-------------------------------------------------------------------------------\n set(FUNCS_DATA ${PROJECT_BINARY_DIR}/funcs_data.mpack)\n set(TOUCHES_DIR ${PROJECT_BINARY_DIR}/touches)\n+set(VTERM_TEST_FILE ${PROJECT_BINARY_DIR}/test/vterm_test_output)",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1804415620",
            "id": 1804415620,
            "in_reply_to_id": 1804351748,
            "line": 49,
            "node_id": "PRRC_kwDOAPphoM5rjTKE",
            "original_commit_id": "d32806f88c11ecec378cba423c4b0441cf508809",
            "original_line": 49,
            "original_position": 4,
            "original_start_line": null,
            "path": "CMakeLists.txt",
            "position": 4,
            "pull_request_review_id": 2374644418,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804415620/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T09:19:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804415620",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1804419928"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804419928"
                }
            },
            "author_association": "MEMBER",
            "body": "I needed to change the type of `flag.len` to `int`, which causes \"Comparison of integers of different signs\" if I don't change this to `int`. I can just cast it to `int` every time instead if you prefer.",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-10-17T09:22:22Z",
            "diff_hunk": "@@ -232,7 +232,7 @@ static int parse_osc8(VTermStringFragment frag, int *attr)\n {\n   // Parse the URI from the OSC 8 sequence and add the URL to our URL set.\n   // Skip the ID, we don't use it (for now)\n-  size_t i = 0;\n+  int i = 0;",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1804419928",
            "id": 1804419928,
            "in_reply_to_id": 1804355659,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rjUNY",
            "original_commit_id": "d32806f88c11ecec378cba423c4b0441cf508809",
            "original_line": 235,
            "original_position": 5,
            "original_start_line": null,
            "path": "src/nvim/terminal.c",
            "position": null,
            "pull_request_review_id": 2374651575,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804419928/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T09:22:22Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804419928",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1804683660"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804683660"
                }
            },
            "author_association": "MEMBER",
            "body": "So not temporary. I can keep it like this or revert to `size_t` and cast `flag.len` to `size_t`, both should work equally well. Lemme know if you have a preference.",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-10-17T12:21:06Z",
            "diff_hunk": "@@ -232,7 +232,7 @@ static int parse_osc8(VTermStringFragment frag, int *attr)\n {\n   // Parse the URI from the OSC 8 sequence and add the URL to our URL set.\n   // Skip the ID, we don't use it (for now)\n-  size_t i = 0;\n+  int i = 0;",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1804683660",
            "id": 1804683660,
            "in_reply_to_id": 1804355659,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5rkUmM",
            "original_commit_id": "d32806f88c11ecec378cba423c4b0441cf508809",
            "original_line": 235,
            "original_position": 5,
            "original_start_line": null,
            "path": "src/nvim/terminal.c",
            "position": null,
            "pull_request_review_id": 2375066416,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804683660/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-17T12:21:06Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1804683660",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1809559980"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809559980"
                }
            },
            "author_association": "MEMBER",
            "body": "might need `assert(len >= 0 && len < MAX_INT32)` for coverity\r\n\r\nsimilar for the others.",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-10-21T21:24:26Z",
            "diff_hunk": "@@ -248,21 +248,21 @@ static int parse_osc8(VTermStringFragment frag, int *attr)\n   }\n \n   // Find the terminator\n-  const size_t start = i;\n+  const int start = i;\n   for (; i < frag.len; i++) {\n     if (frag.str[i] == '\\a' || frag.str[i] == '\\x1b') {\n       break;\n     }\n   }\n \n-  const size_t len = i - start;\n+  const int len = i - start;\n   if (len == 0) {\n     // Empty OSC 8, no URL\n     *attr = 0;\n     return 1;\n   }\n \n-  char *url = xmemdupz(&frag.str[start], len + 1);\n+  char *url = xmemdupz(&frag.str[start], (size_t)len + 1);",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1809559980",
            "id": 1809559980,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5r27Gs",
            "original_commit_id": "eec2162be6d8484d1eaf73082e4db58763c4871b",
            "original_line": 266,
            "original_position": 30,
            "original_start_line": null,
            "path": "src/nvim/terminal.c",
            "position": null,
            "pull_request_review_id": 2383338241,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809559980/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-21T21:24:40Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809559980",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1809562457"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809562457"
                }
            },
            "author_association": "MEMBER",
            "body": "```suggestion\r\n// For unit tests.\r\n#ifndef NDEBUG\r\n```",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-10-21T21:27:13Z",
            "diff_hunk": "@@ -429,3 +430,508 @@ void vterm_check_version(int major, int minor)\n \n   // Happy\n }\n+\n+#ifndef NDEBUG",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1809562457",
            "id": 1809562457,
            "line": 435,
            "node_id": "PRRC_kwDOAPphoM5r27tZ",
            "original_commit_id": "eec2162be6d8484d1eaf73082e4db58763c4871b",
            "original_line": 435,
            "original_position": 16,
            "original_start_line": null,
            "path": "src/vterm/vterm.c",
            "position": 17,
            "pull_request_review_id": 2383341949,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809562457/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-21T21:27:13Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809562457",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1809564001"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809564001"
                }
            },
            "author_association": "MEMBER",
            "body": "? 😂 ",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-10-21T21:28:51Z",
            "diff_hunk": "@@ -0,0 +1,3590 @@\n+local t = require('test.unit.testutil')\n+local itp = t.gen_itp(it)\n+local bit = require('bit')\n+\n+--- @class vterm\n+--- @field ENC_UTF8 integer\n+--- @field VTERM_ATTR_BLINK integer\n+--- @field VTERM_ATTR_BOLD integer\n+--- @field VTERM_ATTR_FONT integer\n+--- @field VTERM_ATTR_ITALIC integer\n+--- @field VTERM_ATTR_REVERSE integer\n+--- @field VTERM_ATTR_UNDERLINE integer\n+--- @field VTERM_BASELINE_RAISE integer\n+--- @field VTERM_KEY_ENTER integer\n+--- @field VTERM_KEY_FUNCTION_0 integer\n+--- @field VTERM_KEY_KP_0 integer\n+--- @field VTERM_KEY_NONE integer\n+--- @field VTERM_KEY_TAB integer\n+--- @field VTERM_KEY_UP integer\n+--- @field VTERM_MAX_CHARS_PER_CELL integer\n+--- @field VTERM_MOD_ALT integer\n+--- @field VTERM_MOD_CTRL integer\n+--- @field VTERM_MOD_SHIFT integer\n+--- @field parser_apc function\n+--- @field parser_csi function\n+--- @field parser_dcs function\n+--- @field parser_osc function\n+--- @field parser_pm function\n+--- @field parser_sos function\n+--- @field parser_text function\n+--- @field print_color function\n+--- @field screen_sb_clear function\n+--- @field screen_sb_popline function\n+--- @field screen_sb_pushline function\n+--- @field selection_query function\n+--- @field selection_set function\n+--- @field state_erase function\n+--- @field state_movecursor function\n+--- @field state_moverect function\n+--- @field state_pos function\n+--- @field state_putglyph function\n+--- @field state_sb_clear function\n+--- @field state_scrollrect function\n+--- @field state_setpenattr function\n+--- @field state_settermprop function\n+--- @field term_output function\n+--- @field vterm_input_write function\n+--- @field vterm_keyboard_end_paste function\n+--- @field vterm_keyboard_key function\n+--- @field vterm_keyboard_start_paste function\n+--- @field vterm_keyboard_unichar function\n+--- @field vterm_lookup_encoding fun(any, any):any\n+--- @field vterm_mouse_button function\n+--- @field vterm_mouse_move function\n+--- @field vterm_new fun(any, any):any\n+--- @field vterm_obtain_screen fun(any):any\n+--- @field vterm_obtain_state fun(any): any\n+--- @field vterm_output_set_callback function\n+--- @field vterm_parser_set_callbacks fun(any, any, any):any\n+--- @field vterm_screen_convert_color_to_rgb function\n+--- @field vterm_screen_enable_altscreen function\n+--- @field vterm_screen_enable_reflow function\n+--- @field vterm_screen_get_attrs_extent function\n+--- @field vterm_screen_get_cell function\n+--- @field vterm_screen_get_chars fun(any, any, any, any):any\n+--- @field vterm_screen_get_text fun(any, any, any, any):any\n+--- @field vterm_screen_is_eol fun(any, any):any\n+--- @field vterm_screen_reset function\n+--- @field vterm_screen_set_callbacks function\n+--- @field vterm_set_size function\n+--- @field vterm_set_utf8 fun(any, any, any):any\n+--- @field vterm_state_focus_in function\n+--- @field vterm_state_focus_out function\n+--- @field vterm_state_get_cursorpos fun(any, any)\n+--- @field vterm_state_get_lineinfo fun(any, any):any\n+--- @field vterm_state_get_penattr function\n+--- @field vterm_state_reset function\n+--- @field vterm_state_set_bold_highbright function\n+--- @field vterm_state_set_callbacks function\n+--- @field vterm_state_set_selection_callbacks function\n+--- @field vterm_state_set_unrecognised_fallbacks function\n+local vterm = t.cimport('./src/vterm/vterm.h', './src/vterm/vterm_internal.h')\n+\n+--- @return string\n+local function read_rm()\n+  local f = assert(io.open(t.paths.vterm_test_file, 'rb'))\n+  local text = f:read('*a')\n+  f:close()\n+  vim.fs.rm(t.paths.vterm_test_file, { force = true })\n+  return text\n+end\n+\n+local function append(str)\n+  local f = assert(io.open(t.paths.vterm_test_file, 'a'))\n+  f:write(str)\n+  f:close()\n+  return 1\n+end\n+\n+local function parser_control(control)\n+  return append(string.format('control %02x\\n', control))\n+end\n+\n+local function parser_escape(bytes)\n+  return append(string.format('escape %s\\n', t.ffi.string(bytes)))\n+end\n+\n+local function wantparser(vt)\n+  assert(vt)\n+\n+  local parser_cbs = t.ffi.new('VTermParserCallbacks')\n+  parser_cbs['text'] = vterm.parser_text\n+  parser_cbs['control'] = parser_control\n+  parser_cbs['escape'] = parser_escape\n+  parser_cbs['csi'] = vterm.parser_csi\n+  parser_cbs['osc'] = vterm.parser_osc\n+  parser_cbs['dcs'] = vterm.parser_dcs\n+  parser_cbs['apc'] = vterm.parser_apc\n+  parser_cbs['pm'] = vterm.parser_pm\n+  parser_cbs['sos'] = vterm.parser_sos\n+\n+  vterm.vterm_parser_set_callbacks(vt, parser_cbs, nil)\n+end\n+\n+--- @return any\n+local function init()\n+  local vt = vterm.vterm_new(25, 80)\n+  vterm.vterm_output_set_callback(vt, vterm.term_output, nil)\n+  vterm.vterm_set_utf8(vt, true)\n+  return vt\n+end\n+\n+local function state_setlineinfo()\n+  return 1\n+end\n+\n+--- @return any\n+local function wantstate(vt, opts)\n+  opts = opts or {}\n+  assert(vt)\n+  local state = vterm.vterm_obtain_state(vt)\n+\n+  local state_cbs = t.ffi.new('VTermStateCallbacks')\n+  state_cbs['putglyph'] = vterm.state_putglyph\n+  state_cbs['movecursor'] = vterm.state_movecursor\n+  state_cbs['scrollrect'] = vterm.state_scrollrect\n+  state_cbs['moverect'] = vterm.state_moverect\n+  state_cbs['erase'] = vterm.state_erase\n+  state_cbs['setpenattr'] = vterm.state_setpenattr\n+  state_cbs['settermprop'] = vterm.state_settermprop\n+  state_cbs['setlineinfo'] = state_setlineinfo\n+  state_cbs['sb_clear'] = vterm.state_sb_clear\n+\n+  local selection_cbs = t.ffi.new('VTermSelectionCallbacks')\n+  selection_cbs['set'] = vterm.selection_set\n+  selection_cbs['query'] = vterm.selection_query\n+\n+  vterm.vterm_state_set_callbacks(state, state_cbs, nil)\n+\n+  -- In some tests we want to check the behaviour of overflowing the buffer, so make it nicely small\n+  vterm.vterm_state_set_selection_callbacks(state, selection_cbs, nil, nil, 16)\n+  vterm.vterm_state_set_bold_highbright(state, 1)\n+  vterm.vterm_state_reset(state, 1)\n+\n+  local fallbacks = t.ffi.new('VTermStateFallbacks')\n+  fallbacks['control'] = parser_control\n+  fallbacks['csi'] = vterm.parser_csi\n+  fallbacks['osc'] = vterm.parser_osc\n+  fallbacks['dcs'] = vterm.parser_dcs\n+  fallbacks['apc'] = vterm.parser_apc\n+  fallbacks['pm'] = vterm.parser_pm\n+  fallbacks['sos'] = vterm.parser_sos\n+\n+  vterm.want_state_scrollback = opts.b or false\n+  vterm.want_state_erase = opts.e or false\n+  vterm.vterm_state_set_unrecognised_fallbacks(state, opts.f and fallbacks or nil, nil)\n+  vterm.want_state_putglyph = opts.g or false\n+  vterm.want_state_moverect = opts.m or false\n+  vterm.want_state_settermprop = opts.p or false\n+  vterm.want_state_scrollrect = opts.s or false\n+\n+  return state\n+end\n+\n+--- @return any\n+local function wantscreen(vt, opts)\n+  opts = opts or {}\n+  local screen = vterm.vterm_obtain_screen(vt)\n+  local screen_cbs = t.ffi.new('VTermScreenCallbacks')\n+\n+  -- TODO(dundargoc): fix\n+  -- screen_cbs['damage']      = vterm.screen_damage\n+  screen_cbs['moverect'] = vterm.state_moverect\n+  screen_cbs['movecursor'] = vterm.state_movecursor\n+  screen_cbs['settermprop'] = vterm.state_settermprop\n+  screen_cbs['sb_pushline'] = vterm.screen_sb_pushline\n+  screen_cbs['sb_popline'] = vterm.screen_sb_popline\n+  screen_cbs['sb_clear'] = vterm.screen_sb_clear\n+\n+  vterm.vterm_screen_set_callbacks(screen, screen_cbs, nil)\n+\n+  if opts.a then\n+    vterm.vterm_screen_enable_altscreen(screen, 1)\n+  end\n+  vterm.want_screen_scrollback = opts.b or false\n+  vterm.want_state_movecursor = opts.c or false\n+  -- TODO(dundargoc): fix\n+  -- vterm.want_screen_damage = opts.d or opts.D or false\n+  -- vterm.want_screen_cells = opts.D or false\n+  vterm.want_state_moverect = opts.m or false\n+  vterm.want_state_settermprop = opts.p or false\n+  if opts.r then\n+    vterm.vterm_screen_enable_reflow(screen, true)\n+  end\n+\n+  return screen\n+end\n+\n+local function reset(state, screen)\n+  if state then\n+    vterm.vterm_state_reset(state, 1)\n+    vterm.vterm_state_get_cursorpos(state, vterm.state_pos)\n+  end\n+  if screen then\n+    vterm.vterm_screen_reset(screen, 1)\n+  end\n+end\n+\n+local function push(input, vt)\n+  vterm.vterm_input_write(vt, input, string.len(input))\n+end\n+\n+local function expect(expected)\n+  local actual = read_rm()\n+  t.eq(expected .. '\\n', actual)\n+end\n+\n+local function expect_output(expected_preformat)\n+  local actual = read_rm()\n+  local expected = 'output '\n+\n+  for c in string.gmatch(expected_preformat, '.') do\n+    if expected ~= 'output ' then\n+      expected = expected .. ','\n+    end\n+    expected = string.format('%s%x', expected, string.byte(c))\n+  end\n+\n+  t.eq(expected .. '\\n', actual)\n+end\n+\n+local function cursor(row, col, state)\n+  local pos = t.ffi.new('VTermPos') --- @type {row: integer, col: integer}\n+  vterm.vterm_state_get_cursorpos(state, pos)\n+  t.eq(row, pos.row)\n+  t.eq(col, pos.col)\n+end\n+\n+local function lineinfo(row, expected, state)\n+  local info = vterm.vterm_state_get_lineinfo(state, row)\n+  local dwl = info.doublewidth == 1\n+  local dhl = info.doubleheight == 1\n+  local cont = info.continuation == 1\n+\n+  t.eq(dwl, expected.dwl or false)\n+  t.eq(dhl, expected.dhl or false)\n+  t.eq(cont, expected.cont or false)\n+end\n+\n+local function pen(attribute, expected, state)\n+  local is_bool = { bold = true, italic = true, blink = true, reverse = true }\n+  local vterm_attribute = {\n+    bold = vterm.VTERM_ATTR_BOLD,\n+    underline = vterm.VTERM_ATTR_UNDERLINE,\n+    italic = vterm.VTERM_ATTR_ITALIC,\n+    blink = vterm.VTERM_ATTR_BLINK,\n+    reverse = vterm.VTERM_ATTR_REVERSE,\n+    font = vterm.VTERM_ATTR_FONT,\n+  }\n+\n+  local val = t.ffi.new('VTermValue') --- @type {boolean: integer}\n+  vterm.vterm_state_get_penattr(state, vterm_attribute[attribute], val)\n+  local actual = val.boolean --- @type integer|boolean\n+  if is_bool[attribute] then\n+    actual = val.boolean == 1\n+  end\n+  t.eq(expected, actual)\n+end\n+\n+local function resize(rows, cols, vt)\n+  vterm.vterm_set_size(vt, rows, cols)\n+end\n+\n+local function screen_chars(start_row, start_col, end_row, end_col, expected, screen)\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_row'] = start_row\n+  rect['start_col'] = start_col\n+  rect['end_row'] = end_row\n+  rect['end_col'] = end_col\n+\n+  local len = vterm.vterm_screen_get_chars(screen, nil, 0, rect)\n+\n+  local chars = t.ffi.new('uint32_t[?]', len)\n+  vterm.vterm_screen_get_chars(screen, chars, len, rect)\n+\n+  local actual = ''\n+  for i = 0, tonumber(len) - 1 do\n+    actual = actual .. string.char(chars[i])\n+  end\n+\n+  t.eq(expected, actual)\n+end\n+\n+local function screen_text(start_row, start_col, end_row, end_col, expected, screen)\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_row'] = start_row\n+  rect['start_col'] = start_col\n+  rect['end_row'] = end_row\n+  rect['end_col'] = end_col\n+\n+  local len = vterm.vterm_screen_get_text(screen, nil, 0, rect)\n+\n+  local text = t.ffi.new('unsigned char[?]', len)\n+  vterm.vterm_screen_get_text(screen, text, len, rect)\n+\n+  local actual = ''\n+  for i = 0, tonumber(len) - 1 do\n+    actual = string.format('%s%02x,', actual, text[i])\n+  end\n+  actual = actual:sub(1, -2)\n+\n+  t.eq(expected, actual)\n+end\n+\n+--- @param row integer\n+local function screen_row(row, expected, screen, end_col)\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_row'] = row\n+  rect['start_col'] = 0\n+  rect['end_row'] = row + 1\n+  rect['end_col'] = end_col or 80\n+\n+  local len = vterm.vterm_screen_get_text(screen, nil, 0, rect)\n+\n+  local text = t.ffi.new('unsigned char[?]', len)\n+  vterm.vterm_screen_get_text(screen, text, len, rect)\n+\n+  t.eq(expected, t.ffi.string(text))\n+end\n+\n+local function screen_cell(row, col, expected, screen)\n+  local pos = t.ffi.new('VTermPos')\n+  pos['row'] = row\n+  pos['col'] = col\n+\n+  local cell = t.ffi.new('VTermScreenCell')\n+  vterm.vterm_screen_get_cell(screen, pos, cell)\n+\n+  local actual = '{'\n+  for i = 0, vterm.VTERM_MAX_CHARS_PER_CELL - 1 do\n+    if cell['chars'][i] ~= 0 then\n+      if i > 0 then\n+        actual = actual .. ','\n+      end\n+      actual = string.format('%s%02x', actual, cell['chars'][i])\n+    end\n+  end\n+  actual = string.format('%s} width=%d attrs={', actual, cell['width'])\n+  actual = actual .. (cell['attrs'].bold ~= 0 and 'B' or '')\n+  actual = actual\n+    .. (cell['attrs'].underline ~= 0 and string.format('U%d', cell['attrs'].underline) or '')\n+  actual = actual .. (cell['attrs'].italic ~= 0 and 'I' or '')\n+  actual = actual .. (cell['attrs'].blink ~= 0 and 'K' or '')\n+  actual = actual .. (cell['attrs'].reverse ~= 0 and 'R' or '')\n+  actual = actual .. (cell['attrs'].font ~= 0 and string.format('F%d', cell['attrs'].font) or '')\n+  actual = actual .. (cell['attrs'].small ~= 0 and 'S' or '')\n+  if cell['attrs'].baseline ~= 0 then\n+    actual = actual .. (cell['attrs'].baseline == vterm.VTERM_BASELINE_RAISE and '^' or '_')\n+  end\n+  actual = actual .. '} '\n+\n+  actual = actual .. (cell['attrs'].dwl ~= 0 and 'dwl ' or '')\n+  if cell['attrs'].dhl ~= 0 then\n+    actual = actual .. string.format('dhl-%s ', cell['attrs'].dhl == 2 and 'bottom' or 'top')\n+  end\n+\n+  actual = string.format('%sfg=', actual)\n+  vterm.vterm_screen_convert_color_to_rgb(screen, cell['fg'])\n+  vterm.print_color(cell['fg'])\n+\n+  actual = actual .. read_rm()\n+  actual = actual .. ' bg='\n+\n+  vterm.vterm_screen_convert_color_to_rgb(screen, cell['bg'])\n+  vterm.print_color(cell['bg'])\n+\n+  actual = actual .. read_rm()\n+\n+  t.eq(expected, actual)\n+end\n+\n+local function screen_eol(row, col, expected, screen)\n+  local pos = t.ffi.new('VTermPos')\n+  pos['row'] = row\n+  pos['col'] = col\n+\n+  local is_eol = vterm.vterm_screen_is_eol(screen, pos)\n+  t.eq(expected, is_eol)\n+end\n+\n+local function screen_attrs_extent(row, col, expected, screen)\n+  local pos = t.ffi.new('VTermPos')\n+  pos['row'] = row\n+  pos['col'] = col\n+\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_col'] = 0\n+  rect['end_col'] = -1\n+  vterm.vterm_screen_get_attrs_extent(screen, rect, pos, 1)\n+\n+  local actual = string.format(\n+    '%d,%d-%d,%d',\n+    rect['start_row'],\n+    rect['start_col'],\n+    rect['end_row'],\n+    rect['end_col']\n+  )\n+\n+  t.eq(expected, actual)\n+end\n+\n+local function wantencoding()\n+  local encoding = t.ffi.new('VTermEncodingInstance')\n+  encoding['enc'] = vterm.vterm_lookup_encoding(vterm.ENC_UTF8, string.byte('u'))\n+  if encoding.enc.init then\n+    encoding.enc.init(encoding.enc, encoding['data'])\n+  end\n+  return encoding\n+end\n+\n+local function encin(input, encoding)\n+  local len = string.len(input)\n+\n+  local cp = t.ffi.new('uint32_t[?]', len)\n+  local cpi = t.ffi.new('int[1]')\n+  local pos = t.ffi.new('size_t[1]', 0)\n+\n+  encoding.enc.decode(encoding.enc, encoding.data, cp, cpi, len, input, pos, len)\n+\n+  local f = assert(io.open(t.paths.vterm_test_file, 'w'))\n+  if tonumber(cpi[0]) > 0 then\n+    f:write('encout ')\n+    for i = 0, cpi[0] - 1 do\n+      if i == 0 then\n+        f:write(string.format('%x', cp[i]))\n+      else\n+        f:write(string.format(',%x', cp[i]))\n+      end\n+    end\n+    f:write('\\n')\n+  end\n+  f:close()\n+end\n+\n+local function strpe_modifiers(input_mod)\n+  local mod = t.ffi.new('VTermModifier') ---@type any\n+  if input_mod.C then\n+    mod = bit.bor(mod, vterm.VTERM_MOD_CTRL)\n+  end\n+  if input_mod.S then\n+    mod = bit.bor(mod, vterm.VTERM_MOD_SHIFT)\n+  end\n+  if input_mod.A then\n+    mod = bit.bor(mod, vterm.VTERM_MOD_ALT)\n+  end\n+  return mod\n+end\n+\n+local function strp_key(input_key)\n+  if input_key == 'up' then\n+    return vterm.VTERM_KEY_UP\n+  end\n+\n+  if input_key == 'tab' then\n+    return vterm.VTERM_KEY_TAB\n+  end\n+\n+  if input_key == 'enter' then\n+    return vterm.VTERM_KEY_ENTER\n+  end\n+\n+  if input_key == 'f1' then\n+    return vterm.VTERM_KEY_FUNCTION_0 + 1\n+  end\n+\n+  if input_key == 'kp0' then\n+    return vterm.VTERM_KEY_KP_0\n+  end\n+\n+  return vterm.VTERM_KEY_NONE\n+end\n+\n+local function mousemove(row, col, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  vterm.vterm_mouse_move(vt, row, col, mod)\n+end\n+\n+local function mousebtn(press, button, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  local flag = press == 'd' or press == 'D'\n+  vterm.vterm_mouse_button(vt, button, flag, mod)\n+end\n+\n+local function inchar(c, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  vterm.vterm_keyboard_unichar(vt, c, mod)\n+end\n+\n+local function inkey(input_key, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  local key = strp_key(input_key)\n+  vterm.vterm_keyboard_key(vt, key, mod)\n+end\n+\n+before_each(function()\n+  vim.fs.rm(t.paths.vterm_test_file, { force = true })\n+end)\n+\n+describe('vterm', function()\n+  itp('02parser', function()\n+    local vt = init()\n+    vterm.vterm_set_utf8(vt, false)\n+    wantparser(vt)\n+\n+    -- Basic text\n+    push('hello', vt)\n+    expect('text 68,65,6c,6c,6f')\n+\n+    -- C0\n+    push('\\x03', vt)\n+    expect('control 03')\n+    push('\\x1f', vt)\n+    expect('control 1f')\n+\n+    -- C1 8bit\n+    push('\\x83', vt)\n+    expect('control 83')\n+    push('\\x99', vt)\n+    expect('control 99')\n+\n+    -- C1 7bit\n+    push('\\x1b\\x43', vt)\n+    expect('control 83')\n+    push('\\x1b\\x59', vt)\n+    expect('control 99')\n+\n+    -- High bytes\n+    push('\\xa0\\xcc\\xfe', vt)\n+    expect('text a0,cc,fe')\n+\n+    -- Mixed\n+    push('1\\n2', vt)\n+    expect('text 31\\ncontrol 0a\\ntext 32')\n+\n+    -- Escape\n+    push('\\x1b=', vt)\n+    expect('escape =')\n+\n+    -- Escape 2-byte\n+    push('\\x1b(X', vt)\n+    expect('escape (X')\n+\n+    -- Split write Escape\n+    push('\\x1b(', vt)\n+    push('Y', vt)\n+    expect('escape (Y')\n+\n+    -- Escape cancels Escape, starts another\n+    push('\\x1b(\\x1b)Z', vt)\n+    expect('escape )Z')\n+\n+    -- CAN cancels Escape, returns to normal mode\n+    push('\\x1b(\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in Escape interrupts and continues\n+    push('\\x1b(\\nX', vt)\n+    expect('control 0a\\nescape (X')\n+\n+    -- CSI 0 args\n+    push('\\x1b[a', vt)\n+    expect('csi 61 *')\n+\n+    -- CSI 1 arg\n+    push('\\x1b[9b', vt)\n+    expect('csi 62 9')\n+\n+    -- CSI 2 args\n+    push('\\x1b[3;4c', vt)\n+    expect('csi 63 3,4')\n+\n+    -- CSI 1 arg 1 sub\n+    push('\\x1b[1:2c', vt)\n+    expect('csi 63 1+,2')\n+\n+    -- CSI many digits\n+    push('\\x1b[678d', vt)\n+    expect('csi 64 678')\n+\n+    -- CSI leading zero\n+    push('\\x1b[007e', vt)\n+    expect('csi 65 7')\n+\n+    -- CSI qmark\n+    push('\\x1b[?2;7f', vt)\n+    expect('csi 66 L=3f 2,7')\n+\n+    -- CSI greater\n+    push('\\x1b[>c', vt)\n+    expect('csi 63 L=3e *')\n+\n+    -- CSI SP\n+    push('\\x1b[12 q', vt)\n+    expect('csi 71 12 I=20')\n+\n+    -- Mixed CSI\n+    push('A\\x1b[8mB', vt)\n+    expect('text 41\\ncsi 6d 8\\ntext 42')\n+\n+    -- Split write\n+    push('\\x1b', vt)\n+    push('[a', vt)\n+    expect('csi 61 *')\n+    push('foo\\x1b[', vt)\n+    expect('text 66,6f,6f')\n+    push('4b', vt)\n+    expect('csi 62 4')\n+    push('\\x1b[12;', vt)\n+    push('3c', vt)\n+    expect('csi 63 12,3')\n+\n+    -- Escape cancels CSI, starts Escape\n+    push('\\x1b[123\\x1b9', vt)\n+    expect('escape 9')\n+\n+    -- CAN cancels CSI, returns to normal mode\n+    push('\\x1b[12\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in Escape interrupts and continues\n+    push('\\x1b(\\nX', vt)\n+    expect('control 0a\\nescape (X')\n+\n+    -- OSC BEL\n+    push('\\x1b]1;Hello\\x07', vt)\n+    expect('osc [1;Hello]')\n+\n+    -- OSC ST (7bit)\n+    push('\\x1b]1;Hello\\x1b\\\\', vt)\n+    expect('osc [1;Hello]')\n+\n+    -- OSC ST (8bit)\n+    push('\\x9d1;Hello\\x9c', vt)\n+    expect('osc [1;Hello]')\n+\n+    -- OSC in parts\n+    push('\\x1b]52;abc', vt)\n+    expect('osc [52;abc')\n+    push('def', vt)\n+    expect('osc def')\n+    push('ghi\\x1b\\\\', vt)\n+    expect('osc ghi]')\n+\n+    -- OSC BEL without semicolon\n+    push('\\x1b]1234\\x07', vt)\n+    expect('osc [1234;]')\n+\n+    -- OSC ST without semicolon\n+    push('\\x1b]1234\\x1b\\\\', vt)\n+    expect('osc [1234;]')\n+\n+    -- Escape cancels OSC, starts Escape\n+    push('\\x1b]Something\\x1b9', vt)\n+    expect('escape 9')\n+\n+    -- CAN cancels OSC, returns to normal mode\n+    push('\\x1b]12\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in OSC interrupts and continues\n+    push('\\x1b]2;\\nBye\\x07', vt)\n+    expect('osc [2;\\ncontrol 0a\\nosc Bye]')\n+\n+    -- DCS BEL\n+    push('\\x1bPHello\\x07', vt)\n+    expect('dcs [Hello]')\n+\n+    -- DCS ST (7bit)\n+    push('\\x1bPHello\\x1b\\\\', vt)\n+    expect('dcs [Hello]')\n+\n+    -- DCS ST (8bit)\n+    push('\\x90Hello\\x9c', vt)\n+    expect('dcs [Hello]')\n+\n+    -- Split write of 7bit ST\n+    push('\\x1bPABC\\x1b', vt)\n+    expect('dcs [ABC')\n+    push('\\\\', vt)\n+    expect('dcs ]')\n+\n+    -- Escape cancels DCS, starts Escape\n+    push('\\x1bPSomething\\x1b9', vt)\n+    expect('escape 9')\n+\n+    -- CAN cancels DCS, returns to normal mode\n+    push('\\x1bP12\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in OSC interrupts and continues\n+    push('\\x1bPBy\\ne\\x07', vt)\n+    expect('dcs [By\\ncontrol 0a\\ndcs e]')\n+\n+    -- APC BEL\n+    push('\\x1b_Hello\\x07', vt)\n+    expect('apc [Hello]')\n+\n+    -- APC ST (7bit)\n+    push('\\x1b_Hello\\x1b\\\\', vt)\n+    expect('apc [Hello]')\n+\n+    -- APC ST (8bit)\n+    push('\\x9fHello\\x9c', vt)\n+    expect('apc [Hello]')\n+\n+    -- PM BEL\n+    push('\\x1b^Hello\\x07', vt)\n+    expect('pm [Hello]')\n+\n+    -- PM ST (7bit)\n+    push('\\x1b^Hello\\x1b\\\\', vt)\n+    expect('pm [Hello]')\n+\n+    -- PM ST (8bit)\n+    push('\\x9eHello\\x9c', vt)\n+    expect('pm [Hello]')\n+\n+    -- SOS BEL\n+    push('\\x1bXHello\\x07', vt)\n+    expect('sos [Hello]')\n+\n+    -- SOS ST (7bit)\n+    push('\\x1bXHello\\x1b\\\\', vt)\n+    expect('sos [Hello]')\n+\n+    -- SOS ST (8bit)\n+    push('\\x98Hello\\x9c', vt)\n+    expect('sos [Hello]')\n+\n+    push('\\x1bXABC\\x01DEF\\x1b\\\\', vt)\n+    expect('sos [ABC\\x01DEF]')\n+    push('\\x1bXABC\\x99DEF\\x1b\\\\', vt)\n+    expect('sos [ABC\\x99DEF]')\n+\n+    -- NUL ignored\n+    push('\\x00', vt)\n+\n+    -- NUL ignored within CSI\n+    push('\\x1b[12\\x003m', vt)\n+    expect('csi 6d 123')\n+\n+    -- DEL ignored\n+    push('\\x7f', vt)\n+\n+    -- DEL ignored within CSI\n+    push('\\x1b[12\\x7f3m', vt)\n+    expect('csi 6d 123')\n+\n+    -- DEL inside text\"\n+    push('AB\\x7fC', vt)\n+    expect('text 41,42\\ntext 43')\n+  end)\n+\n+  itp('03encoding_utf8', function()\n+    local encoding = wantencoding()\n+\n+    -- Low\n+    encin('123', encoding)\n+    expect('encout 31,32,33')\n+\n+    -- We want to prove the UTF-8 parser correctly handles all the sequences.\n+    -- Easy way to do this is to check it does low/high boundary cases, as that\n+    -- leaves only two for each sequence length\n+    --\n+    -- These ranges are therefore:\n+    --\n+    -- Two bytes:\n+    -- U+0080 = 000 10000000 =>    00010   000000\n+    --                       => 11000010 10000000 = C2 80\n+    -- U+07FF = 111 11111111 =>    11111   111111\n+    --                       => 11011111 10111111 = DF BF\n+    --\n+    -- Three bytes:\n+    -- U+0800 = 00001000 00000000 =>     0000   100000   000000\n+    --                            => 11100000 10100000 10000000 = E0 A0 80\n+    -- U+FFFD = 11111111 11111101 =>     1111   111111   111101\n+    --                            => 11101111 10111111 10111101 = EF BF BD\n+    -- (We avoid U+FFFE and U+FFFF as they're invalid codepoints)\n+    --\n+    -- Four bytes:\n+    -- U+10000  = 00001 00000000 00000000 =>      000   010000   000000   000000\n+    --                                    => 11110000 10010000 10000000 10000000 = F0 90 80 80\n+    -- U+1FFFFF = 11111 11111111 11111111 =>      111   111111   111111   111111\n+    --                                    => 11110111 10111111 10111111 10111111 = F7 BF BF BF\n+\n+    -- 2 byte\n+    encin('\\xC2\\x80\\xDF\\xBF', encoding)\n+    expect('encout 80,7ff')\n+\n+    -- 3 byte\n+    encin('\\xE0\\xA0\\x80\\xEF\\xBF\\xBD', encoding)\n+    expect('encout 800,fffd')\n+\n+    -- 4 byte\n+    encin('\\xF0\\x90\\x80\\x80\\xF7\\xBF\\xBF\\xBF', encoding)\n+    expect('encout 10000,1fffff')\n+\n+    -- Next up, we check some invalid sequences\n+    --  + Early termination (back to low bytes too soon)\n+    --  + Early restart (another sequence introduction before the previous one was finished)\n+\n+    -- Early termination\n+    encin('\\xC2!', encoding)\n+    expect('encout fffd,21')\n+\n+    encin('\\xE0!\\xE0\\xA0!', encoding)\n+    expect('encout fffd,21,fffd,21')\n+\n+    encin('\\xF0!\\xF0\\x90!\\xF0\\x90\\x80!', encoding)\n+    expect('encout fffd,21,fffd,21,fffd,21')\n+\n+    -- Early restart\n+    encin('\\xC2\\xC2\\x90', encoding)\n+    expect('encout fffd,90')\n+\n+    encin('\\xE0\\xC2\\x90\\xE0\\xA0\\xC2\\x90', encoding)\n+    expect('encout fffd,90,fffd,90')\n+\n+    encin('\\xF0\\xC2\\x90\\xF0\\x90\\xC2\\x90\\xF0\\x90\\x80\\xC2\\x90', encoding)\n+    expect('encout fffd,90,fffd,90,fffd,90')\n+\n+    -- Test the overlong sequences by giving an overlong encoding of U+0000 and\n+    -- an encoding of the highest codepoint still too short\n+    --\n+    -- Two bytes:\n+    -- U+0000 = C0 80\n+    -- U+007F = 000 01111111 =>    00001   111111 =>\n+    --                       => 11000001 10111111 => C1 BF\n+    --\n+    -- Three bytes:\n+    -- U+0000 = E0 80 80\n+    -- U+07FF = 00000111 11111111 =>     0000   011111   111111\n+    --                            => 11100000 10011111 10111111 = E0 9F BF\n+    --\n+    -- Four bytes:\n+    -- U+0000 = F0 80 80 80\n+    -- U+FFFF = 11111111 11111111 =>      000   001111   111111   111111\n+    --                            => 11110000 10001111 10111111 10111111 = F0 8F BF BF\n+\n+    -- Overlong\n+    encin('\\xC0\\x80\\xC1\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    encin('\\xE0\\x80\\x80\\xE0\\x9F\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    encin('\\xF0\\x80\\x80\\x80\\xF0\\x8F\\xBF\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    -- UTF-16 surrogates U+D800 and U+DFFF\n+    -- UTF-16 Surrogates\n+    encin('\\xED\\xA0\\x80\\xED\\xBF\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    -- Split write\n+    encin('\\xC2', encoding)\n+    encin('\\xA0', encoding)\n+    expect('encout a0')\n+\n+    encin('\\xE0', encoding)\n+    encin('\\xA0\\x80', encoding)\n+    expect('encout 800')\n+    encin('\\xE0\\xA0', encoding)\n+    encin('\\x80', encoding)\n+    expect('encout 800')\n+\n+    encin('\\xF0', encoding)\n+    encin('\\x90\\x80\\x80', encoding)\n+    expect('encout 10000')\n+    encin('\\xF0\\x90', encoding)\n+    encin('\\x80\\x80', encoding)\n+    expect('encout 10000')\n+    encin('\\xF0\\x90\\x80', encoding)\n+    encin('\\x80', encoding)\n+    expect('encout 10000')\n+  end)\n+\n+  itp('10state_putglyph', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Low\n+    reset(state, nil)\n+    push('ABC', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 43 1 0,2')\n+\n+    -- UTF-8 1 char\n+    -- U+00C1 = 0xC3 0x81  name: LATIN CAPITAL LETTER A WITH ACUTE\n+    -- U+00E9 = 0xC3 0xA9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(state, nil)\n+    push('\\xC3\\x81\\xC3\\xA9', vt)\n+    expect('putglyph c1 1 0,0\\nputglyph e9 1 0,1')\n+\n+    -- UTF-8 split writes\n+    reset(state, nil)\n+    push('\\xC3', vt)\n+    push('\\x81', vt)\n+    expect('putglyph c1 1 0,0')\n+\n+    -- UTF-8 wide char\n+    -- U+FF10 = EF BC 90  name: FULLWIDTH DIGIT ZERO\n+    reset(state, nil)\n+    push('\\xEF\\xBC\\x90 ', vt)\n+    expect('putglyph ff10 2 0,0\\nputglyph 20 1 0,2')\n+\n+    -- UTF-8 emoji wide char\n+    -- U+1F600 = F0 9F 98 80  name: GRINNING FACE\n+    reset(state, nil)\n+    push('\\xF0\\x9F\\x98\\x80 ', vt)\n+    expect('putglyph 1f600 2 0,0\\nputglyph 20 1 0,2')\n+\n+    -- UTF-8 combining chars\n+    -- U+0301 = CC 81  name: COMBINING ACUTE\n+    reset(state, nil)\n+    push('e\\xCC\\x81Z', vt)\n+    expect('putglyph 65,301 1 0,0\\nputglyph 5a 1 0,1')\n+\n+    -- Combining across buffers\n+    reset(state, nil)\n+    push('e', vt)\n+    expect('putglyph 65 1 0,0')\n+    push('\\xCC\\x81Z', vt)\n+    expect('putglyph 65,301 1 0,0\\nputglyph 5a 1 0,1')\n+\n+    -- Spare combining chars get truncated\n+    reset(state, nil)\n+    push('e' .. string.rep('\\xCC\\x81', 10), vt)\n+    expect('putglyph 65,301,301,301,301,301 1 0,0') -- and nothing more\n+\n+    reset(state, nil)\n+    push('e', vt)\n+    expect('putglyph 65 1 0,0')\n+    push('\\xCC\\x81', vt)\n+    expect('putglyph 65,301 1 0,0')\n+    push('\\xCC\\x82', vt)\n+    expect('putglyph 65,301,302 1 0,0')\n+\n+    -- DECSCA protected\n+    reset(state, nil)\n+    push('A\\x1b[1\"qB\\x1b[2\"qC', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 42 1 0,1 prot\\nputglyph 43 1 0,2')\n+  end)\n+\n+  itp('11state_movecursor', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Implicit\n+    push('ABC', vt)\n+    cursor(0, 3, state)\n+\n+    -- Backspace\n+    push('\\b', vt)\n+    cursor(0, 2, state)\n+    -- Horizontal Tab\n+    push('\\t', vt)\n+    cursor(0, 8, state)\n+    -- Carriage Return\n+    push('\\r', vt)\n+    cursor(0, 0, state)\n+    -- Linefeed\n+    push('\\n', vt)\n+    cursor(1, 0, state)\n+\n+    -- Backspace bounded by lefthand edge\n+    push('\\x1b[4;2H', vt)\n+    cursor(3, 1, state)\n+    push('\\b', vt)\n+    cursor(3, 0, state)\n+    push('\\b', vt)\n+    cursor(3, 0, state)\n+\n+    -- Backspace cancels phantom\n+    push('\\x1b[4;80H', vt)\n+    cursor(3, 79, state)\n+    push('X', vt)\n+    cursor(3, 79, state)\n+    push('\\b', vt)\n+    cursor(3, 78, state)\n+\n+    -- HT bounded by righthand edge\n+    push('\\x1b[1;78H', vt)\n+    cursor(0, 77, state)\n+    push('\\t', vt)\n+    cursor(0, 79, state)\n+    push('\\t', vt)\n+    cursor(0, 79, state)\n+\n+    reset(state, nil)\n+\n+    -- Index\n+    push('ABC\\x1bD', vt)\n+    cursor(1, 3, state)\n+    -- Reverse Index\n+    push('\\x1bM', vt)\n+    cursor(0, 3, state)\n+    -- Newline\n+    push('\\x1bE', vt)\n+    cursor(1, 0, state)\n+\n+    reset(state, nil)\n+\n+    -- Cursor Forward\n+    push('\\x1b[B', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[3B', vt)\n+    cursor(4, 0, state)\n+    push('\\x1b[0B', vt)\n+    cursor(5, 0, state)\n+\n+    -- Cursor Down\n+    push('\\x1b[C', vt)\n+    cursor(5, 1, state)\n+    push('\\x1b[3C', vt)\n+    cursor(5, 4, state)\n+    push('\\x1b[0C', vt)\n+    cursor(5, 5, state)\n+\n+    -- Cursor Up\n+    push('\\x1b[A', vt)\n+    cursor(4, 5, state)\n+    push('\\x1b[3A', vt)\n+    cursor(1, 5, state)\n+    push('\\x1b[0A', vt)\n+    cursor(0, 5, state)\n+\n+    -- Cursor Backward\n+    push('\\x1b[D', vt)\n+    cursor(0, 4, state)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[0D', vt)\n+    cursor(0, 0, state)\n+\n+    -- Cursor Next Line\n+    push('   ', vt)\n+    cursor(0, 3, state)\n+    push('\\x1b[E', vt)\n+    cursor(1, 0, state)\n+    push('   ', vt)\n+    cursor(1, 3, state)\n+    push('\\x1b[2E', vt)\n+    cursor(3, 0, state)\n+    push('\\x1b[0E', vt)\n+    cursor(4, 0, state)\n+\n+    -- Cursor Previous Line\n+    push('   ', vt)\n+    cursor(4, 3, state)\n+    push('\\x1b[F', vt)\n+    cursor(3, 0, state)\n+    push('   ', vt)\n+    cursor(3, 3, state)\n+    push('\\x1b[2F', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[0F', vt)\n+    cursor(0, 0, state)\n+\n+    -- Cursor Horizonal Absolute\n+    push('\\n', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[20G', vt)\n+    cursor(1, 19, state)\n+    push('\\x1b[G', vt)\n+    cursor(1, 0, state)\n+\n+    -- Cursor Position\n+    push('\\x1b[10;5H', vt)\n+    cursor(9, 4, state)\n+    push('\\x1b[8H', vt)\n+    cursor(7, 0, state)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+\n+    -- Cursor Position cancels phantom\n+    push('\\x1b[10;78H', vt)\n+    cursor(9, 77, state)\n+    push('ABC', vt)\n+    cursor(9, 79, state)\n+    push('\\x1b[10;80H', vt)\n+    push('C', vt)\n+    cursor(9, 79, state)\n+    push('X', vt)\n+    cursor(10, 1, state)\n+\n+    reset(state, nil)\n+\n+    -- Bounds Checking\n+    push('\\x1b[A', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[D', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[25;80H', vt)\n+    cursor(24, 79, state)\n+    push('\\x1b[B', vt)\n+    cursor(24, 79, state)\n+    push('\\x1b[C', vt)\n+    cursor(24, 79, state)\n+    push('\\x1b[E', vt)\n+    cursor(24, 0, state)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[F', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[999G', vt)\n+    cursor(0, 79, state)\n+    push('\\x1b[99;99H', vt)\n+    cursor(24, 79, state)\n+\n+    reset(state, nil)\n+\n+    -- Horizontal Position Absolute\n+    push('\\x1b[5`', vt)\n+    cursor(0, 4, state)\n+\n+    -- Horizontal Position Relative\n+    push('\\x1b[3a', vt)\n+    cursor(0, 7, state)\n+\n+    -- Horizontal Position Backward\n+    push('\\x1b[3j', vt)\n+    cursor(0, 4, state)\n+\n+    -- Horizontal and Vertical Position\n+    push('\\x1b[3;3f', vt)\n+    cursor(2, 2, state)\n+\n+    -- Vertical Position Absolute\n+    push('\\x1b[5d', vt)\n+    cursor(4, 2, state)\n+\n+    -- Vertical Position Relative\n+    push('\\x1b[2e', vt)\n+    cursor(6, 2, state)\n+\n+    -- Vertical Position Backward\n+    push('\\x1b[2k', vt)\n+    cursor(4, 2, state)\n+\n+    reset(state, nil)\n+\n+    -- Horizontal Tab\n+    push('\\t', vt)\n+    cursor(0, 8, state)\n+    push('   ', vt)\n+    cursor(0, 11, state)\n+    push('\\t', vt)\n+    cursor(0, 16, state)\n+    push('       ', vt)\n+    cursor(0, 23, state)\n+    push('\\t', vt)\n+    cursor(0, 24, state)\n+    push('        ', vt)\n+    cursor(0, 32, state)\n+    push('\\t', vt)\n+    cursor(0, 40, state)\n+\n+    -- Cursor Horizontal Tab\n+    push('\\x1b[I', vt)\n+    cursor(0, 48, state)\n+    push('\\x1b[2I', vt)\n+    cursor(0, 64, state)\n+\n+    -- Cursor Backward Tab\n+    push('\\x1b[Z', vt)\n+    cursor(0, 56, state)\n+    push('\\x1b[2Z', vt)\n+    cursor(0, 40, state)\n+  end)\n+\n+  itp('12state_scroll', function()\n+    local vt = init()\n+    local state = wantstate(vt, { s = true })\n+\n+    -- Linefeed\n+    push(string.rep('\\n', 24), vt)\n+    cursor(24, 0, state)\n+    push('\\n', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+    cursor(24, 0, state)\n+\n+    reset(state, nil)\n+\n+    -- Index\n+    push('\\x1b[25H', vt)\n+    push('\\x1bD', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+\n+    reset(state, nil)\n+\n+    -- Reverse Index\n+    push('\\x1bM', vt)\n+    expect('scrollrect 0..25,0..80 => -1,+0')\n+\n+    reset(state, nil)\n+\n+    -- Linefeed in DECSTBM\n+    push('\\x1b[1;10r', vt)\n+    cursor(0, 0, state)\n+    push(string.rep('\\n', 9), vt)\n+    cursor(9, 0, state)\n+    push('\\n', vt)\n+    expect('scrollrect 0..10,0..80 => +1,+0')\n+    cursor(9, 0, state)\n+\n+    -- Linefeed outside DECSTBM\n+    push('\\x1b[20H', vt)\n+    cursor(19, 0, state)\n+    push('\\n', vt)\n+    cursor(20, 0, state)\n+\n+    -- Index in DECSTBM\n+    push('\\x1b[9;10r', vt)\n+    push('\\x1b[10H', vt)\n+    push('\\x1bM', vt)\n+    cursor(8, 0, state)\n+    push('\\x1bM', vt)\n+    expect('scrollrect 8..10,0..80 => -1,+0')\n+\n+    -- Reverse Index in DECSTBM\n+    push('\\x1b[25H', vt)\n+    cursor(24, 0, state)\n+    push('\\n', vt)\n+    -- no scrollrect\n+    cursor(24, 0, state)\n+\n+    -- Linefeed in DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[3;10r\\x1b[10;40s', vt)\n+    push('\\x1b[10;10H\\n', vt)\n+    expect('scrollrect 2..10,9..40 => +1,+0')\n+\n+    -- IND/RI in DECSTBM+DECSLRM\n+    push('\\x1bD', vt)\n+    expect('scrollrect 2..10,9..40 => +1,+0')\n+    push('\\x1b[3;10H\\x1bM', vt)\n+    expect('scrollrect 2..10,9..40 => -1,+0')\n+\n+    -- DECRQSS on DECSTBM\n+    push('\\x1bP$qr\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r3;10r\\x1b\\\\')\n+\n+    -- DECRQSS on DECSLRM\n+    push('\\x1bP$qs\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r10;40s\\x1b\\\\')\n+\n+    -- Setting invalid DECSLRM with !DECVSSM is still rejected\n+    push('\\x1b[?69l\\x1b[;0s\\x1b[?69h', vt)\n+\n+    reset(state, nil)\n+\n+    -- Scroll Down\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[2S', vt)\n+    expect('scrollrect 0..25,0..80 => +2,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[100S', vt)\n+    expect('scrollrect 0..25,0..80 => +25,+0')\n+\n+    -- Scroll Up\n+    push('\\x1b[T', vt)\n+    expect('scrollrect 0..25,0..80 => -1,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[2T', vt)\n+    expect('scrollrect 0..25,0..80 => -2,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[100T', vt)\n+    expect('scrollrect 0..25,0..80 => -25,+0')\n+\n+    -- SD/SU in DECSTBM\n+    push('\\x1b[5;20r', vt)\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 4..20,0..80 => +1,+0')\n+    push('\\x1b[T', vt)\n+    expect('scrollrect 4..20,0..80 => -1,+0')\n+\n+    reset(state, nil)\n+\n+    -- SD/SU in DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[3;10r\\x1b[10;40s', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[3;10H', vt)\n+    cursor(2, 9, state)\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 2..10,9..40 => +1,+0')\n+    push('\\x1b[?69l', vt)\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 2..10,0..80 => +1,+0')\n+\n+    -- Invalid boundaries\n+    reset(state, nil)\n+\n+    push('\\x1b[100;105r\\x1bD', vt)\n+    push('\\x1b[5;2r\\x1bD', vt)\n+\n+    reset(state, nil)\n+    state = wantstate(vt, { m = true, e = true })\n+\n+    -- Scroll Down move+erase emulation\n+    push('\\x1b[S', vt)\n+    expect('moverect 1..25,0..80 -> 0..24,0..80\\nerase 24..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2S', vt)\n+    expect('moverect 2..25,0..80 -> 0..23,0..80\\nerase 23..25,0..80')\n+    cursor(0, 0, state)\n+\n+    -- Scroll Up move+erase emulation\n+    push('\\x1b[T', vt)\n+    expect('moverect 0..24,0..80 -> 1..25,0..80\\nerase 0..1,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2T', vt)\n+    expect('moverect 0..23,0..80 -> 2..25,0..80\\nerase 0..2,0..80')\n+    cursor(0, 0, state)\n+\n+    -- DECSTBM resets cursor position\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b[r', vt)\n+    cursor(0, 0, state)\n+  end)\n+\n+  itp('13state_edit', function()\n+    local vt = init()\n+    local state = wantstate(vt, { s = true, e = true, b = true })\n+\n+    -- ICH\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ACD', vt)\n+    push('\\x1b[2D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[@', vt)\n+    expect('scrollrect 0..1,1..80 => +0,-1')\n+    cursor(0, 1, state)\n+    push('B', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[3@', vt)\n+    expect('scrollrect 0..1,2..80 => +0,-3')\n+\n+    -- ICH with DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[;50s', vt)\n+    push('\\x1b[20G\\x1b[@', vt)\n+    expect('scrollrect 0..1,19..50 => +0,-1')\n+\n+    -- ICH outside DECSLRM\n+    push('\\x1b[70G\\x1b[@', vt)\n+    -- nothing happens\n+\n+    -- DCH\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABBC', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[P', vt)\n+    expect('scrollrect 0..1,1..80 => +0,+1')\n+    cursor(0, 1, state)\n+    push('\\x1b[3P', vt)\n+    expect('scrollrect 0..1,1..80 => +0,+3')\n+    cursor(0, 1, state)\n+\n+    -- DCH with DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[;50s', vt)\n+    push('\\x1b[20G\\x1b[P', vt)\n+    expect('scrollrect 0..1,19..50 => +0,+1')\n+\n+    -- DCH outside DECSLRM\n+    push('\\x1b[70G\\x1b[P', vt)\n+    -- nothing happens\n+\n+    -- ECH\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABC', vt)\n+    push('\\x1b[2D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[X', vt)\n+    expect('erase 0..1,1..2')\n+    cursor(0, 1, state)\n+    push('\\x1b[3X', vt)\n+    expect('erase 0..1,1..4')\n+    cursor(0, 1, state)\n+    -- ECH more columns than there are should be bounded\n+    push('\\x1b[100X', vt)\n+    expect('erase 0..1,1..80')\n+\n+    -- IL\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('A\\r\\nC', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[L', vt)\n+    expect('scrollrect 1..25,0..80 => -1,+0')\n+    -- TODO(libvterm): ECMA-48 says we should move to line home, but neither xterm nor xfce4-terminal do this\n+    cursor(1, 1, state)\n+    push('\\rB', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[3L', vt)\n+    expect('scrollrect 1..25,0..80 => -3,+0')\n+\n+    -- IL with DECSTBM\n+    push('\\x1b[5;15r', vt)\n+    push('\\x1b[5H\\x1b[L', vt)\n+    expect('scrollrect 4..15,0..80 => -1,+0')\n+\n+    -- IL outside DECSTBM\n+    push('\\x1b[20H\\x1b[L', vt)\n+    -- nothing happens\n+\n+    -- IL with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[10;50s', vt)\n+    push('\\x1b[5;10H\\x1b[L', vt)\n+    expect('scrollrect 4..15,9..50 => -1,+0')\n+\n+    -- DL\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('A\\r\\nB\\r\\nB\\r\\nC', vt)\n+    cursor(3, 1, state)\n+    push('\\x1b[2H', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[M', vt)\n+    expect('scrollrect 1..25,0..80 => +1,+0')\n+    cursor(1, 0, state)\n+    push('\\x1b[3M', vt)\n+    expect('scrollrect 1..25,0..80 => +3,+0')\n+    cursor(1, 0, state)\n+\n+    -- DL with DECSTBM\n+    push('\\x1b[5;15r', vt)\n+    push('\\x1b[5H\\x1b[M', vt)\n+    expect('scrollrect 4..15,0..80 => +1,+0')\n+\n+    -- DL outside DECSTBM\n+    push('\\x1b[20H\\x1b[M', vt)\n+    -- nothing happens\n+\n+    -- DL with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[10;50s', vt)\n+    push('\\x1b[5;10H\\x1b[M', vt)\n+    expect('scrollrect 4..15,9..50 => +1,+0')\n+\n+    -- DECIC\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    push(\"\\x1b[20G\\x1b[5'}\", vt)\n+    expect('scrollrect 0..25,19..80 => +0,-5')\n+\n+    -- DECIC with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[4;20r\\x1b[20;60s', vt)\n+    push(\"\\x1b[4;20H\\x1b[3'}\", vt)\n+    expect('scrollrect 3..20,19..60 => +0,-3')\n+\n+    -- DECIC outside DECSLRM\n+    push(\"\\x1b[70G\\x1b['}\", vt)\n+    -- nothing happens\n+\n+    -- DECDC\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    push(\"\\x1b[20G\\x1b[5'~\", vt)\n+    expect('scrollrect 0..25,19..80 => +0,+5')\n+\n+    -- DECDC with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[4;20r\\x1b[20;60s', vt)\n+    push(\"\\x1b[4;20H\\x1b[3'~\", vt)\n+    expect('scrollrect 3..20,19..60 => +0,+3')\n+\n+    -- DECDC outside DECSLRM\n+    push(\"\\x1b[70G\\x1b['~\", vt)\n+    -- nothing happens\n+\n+    -- EL 0\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABCDE', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[0K', vt)\n+    expect('erase 0..1,2..80')\n+    cursor(0, 2, state)\n+\n+    -- EL 1\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABCDE', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[1K', vt)\n+    expect('erase 0..1,0..3')\n+    cursor(0, 2, state)\n+\n+    -- EL 2\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABCDE', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[2K', vt)\n+    expect('erase 0..1,0..80')\n+    cursor(0, 2, state)\n+\n+    -- SEL\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[11G', vt)\n+    cursor(0, 10, state)\n+    push('\\x1b[?0K', vt)\n+    expect('erase 0..1,10..80 selective')\n+    cursor(0, 10, state)\n+    push('\\x1b[?1K', vt)\n+    expect('erase 0..1,0..11 selective')\n+    cursor(0, 10, state)\n+    push('\\x1b[?2K', vt)\n+    expect('erase 0..1,0..80 selective')\n+    cursor(0, 10, state)\n+\n+    -- ED 0\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[0J', vt)\n+    expect('erase 1..2,1..80\\nerase 2..25,0..80')\n+    cursor(1, 1, state)\n+\n+    -- ED 1\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[1J', vt)\n+    expect('erase 0..1,0..80\\nerase 1..2,0..2')\n+    cursor(1, 1, state)\n+\n+    -- ED 2\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[2J', vt)\n+    expect('erase 0..25,0..80')\n+    cursor(1, 1, state)\n+\n+    -- ED 3\n+    push('\\x1b[3J', vt)\n+    expect('sb_clear')\n+\n+    -- SED\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b[?0J', vt)\n+    expect('erase 4..5,4..80 selective\\nerase 5..25,0..80 selective')\n+    cursor(4, 4, state)\n+    push('\\x1b[?1J', vt)\n+    expect('erase 0..4,0..80 selective\\nerase 4..5,0..5 selective')\n+    cursor(4, 4, state)\n+    push('\\x1b[?2J', vt)\n+    expect('erase 0..25,0..80 selective')\n+    cursor(4, 4, state)\n+\n+    -- DECRQSS on DECSCA\n+    push('\\x1b[2\"q', vt)\n+    push('\\x1bP$q\"q\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r2\"q\\x1b\\\\')\n+\n+    state = wantstate(vt, { m = true, e = true, b = true })\n+    expect('erase 0..25,0..80') -- TODO(dundargoc): strange, this should not be needed according to the original code\n+\n+    -- ICH move+erase emuation\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ACD', vt)\n+    push('\\x1b[2D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[@', vt)\n+    expect('moverect 0..1,1..79 -> 0..1,2..80\\nerase 0..1,1..2')\n+    cursor(0, 1, state)\n+    push('B', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[3@', vt)\n+    expect('moverect 0..1,2..77 -> 0..1,5..80\\nerase 0..1,2..5')\n+\n+    -- DCH move+erase emulation\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABBC', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[P', vt)\n+    expect('moverect 0..1,2..80 -> 0..1,1..79\\nerase 0..1,79..80')\n+    cursor(0, 1, state)\n+    push('\\x1b[3P', vt)\n+    expect('moverect 0..1,4..80 -> 0..1,1..77\\nerase 0..1,77..80')\n+    cursor(0, 1, state)\n+  end)\n+\n+  itp('14state_encoding', function()\n+    local vt = init()\n+    vterm.vterm_set_utf8(vt, false)\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Default\n+    reset(state, nil)\n+    push('#', vt)\n+    expect('putglyph 23 1 0,0')\n+\n+    -- Designate G0=UK\n+    reset(state, nil)\n+    push('\\x1b(A', vt)\n+    push('#', vt)\n+    expect('putglyph a3 1 0,0')\n+\n+    -- Designate G0=DEC drawing\n+    reset(state, nil)\n+    push('\\x1b(0', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,0')\n+\n+    -- Designate G1 + LS1\n+    reset(state, nil)\n+    push('\\x1b)0', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x0e', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,1')\n+    -- LS0\n+    push('\\x0f', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,2')\n+\n+    -- Designate G2 + LS2\n+    push('\\x1b*0', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,3')\n+    push('\\x1bn', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,4')\n+    push('\\x0f', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,5')\n+\n+    -- Designate G3 + LS3\n+    push('\\x1b+0', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,6')\n+    push('\\x1bo', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,7')\n+    push('\\x0f', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,8')\n+\n+    -- SS2\n+    push('a\\x8eaa', vt)\n+    expect('putglyph 61 1 0,9\\nputglyph 2592 1 0,10\\nputglyph 61 1 0,11')\n+\n+    -- SS3\n+    push('a\\x8faa', vt)\n+    expect('putglyph 61 1 0,12\\nputglyph 2592 1 0,13\\nputglyph 61 1 0,14')\n+\n+    -- LS1R\n+    reset(state, nil)\n+    push('\\x1b~', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x1b)0', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 2592 1 0,1')\n+\n+    -- LS2R\n+    reset(state, nil)\n+    push('\\x1b}', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x1b*0', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 2592 1 0,1')\n+\n+    -- LS3R\n+    reset(state, nil)\n+    push('\\x1b|', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x1b+0', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 2592 1 0,1')\n+\n+    vterm.vterm_set_utf8(vt, true)\n+    -- U+0108 == c4 88\n+    reset(state, nil)\n+    push('\\x1b(B', vt)\n+    push('AB\\xc4\\x88D', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 108 1 0,2\\nputglyph 44 1 0,3')\n+  end)\n+\n+  itp('15state_mode', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true, m = true, e = true })\n+\n+    -- Insert/Replace Mode\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('AC\\x1b[DB', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 43 1 0,1\\nputglyph 42 1 0,1')\n+    push('\\x1b[4h', vt)\n+    push('\\x1b[G', vt)\n+    push('AC\\x1b[DB', vt)\n+    expect(\n+      'moverect 0..1,0..79 -> 0..1,1..80\\nerase 0..1,0..1\\nputglyph 41 1 0,0\\nmoverect 0..1,1..79 -> 0..1,2..80\\nerase 0..1,1..2\\nputglyph 43 1 0,1\\nmoverect 0..1,1..79 -> 0..1,2..80\\nerase 0..1,1..2\\nputglyph 42 1 0,1'\n+    )\n+\n+    -- Insert mode only happens once for UTF-8 combining\n+    push('e', vt)\n+    expect('moverect 0..1,2..79 -> 0..1,3..80\\nerase 0..1,2..3\\nputglyph 65 1 0,2')\n+    push('\\xCC\\x81', vt)\n+    expect('putglyph 65,301 1 0,2')\n+\n+    -- Newline/Linefeed mode\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[5G\\n', vt)\n+    cursor(1, 4, state)\n+    push('\\x1b[20h', vt)\n+    push('\\x1b[5G\\n', vt)\n+    cursor(2, 0, state)\n+\n+    -- DEC origin mode\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[5;15r', vt)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[3;3H', vt)\n+    cursor(2, 2, state)\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[H', vt)\n+    cursor(4, 0, state)\n+    push('\\x1b[3;3H', vt)\n+    cursor(6, 2, state)\n+\n+    -- DECRQM on DECOM\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[?6$p', vt)\n+    expect_output('\\x1b[?6;1$y')\n+    push('\\x1b[?6l', vt)\n+    push('\\x1b[?6$p', vt)\n+    expect_output('\\x1b[?6;2$y')\n+\n+    -- Origin mode with DECSLRM\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[20;60s', vt)\n+    push('\\x1b[H', vt)\n+    cursor(4, 19, state)\n+\n+    push('\\x1b[?69l', vt)\n+\n+    -- Origin mode bounds cursor to scrolling region\n+    push('\\x1b[H', vt)\n+    push('\\x1b[10A', vt)\n+    cursor(4, 0, state)\n+    push('\\x1b[20B', vt)\n+    cursor(14, 0, state)\n+\n+    -- Origin mode without scroll region\n+    push('\\x1b[?6l', vt)\n+    push('\\x1b[r\\x1b[?6h', vt)\n+    cursor(0, 0, state)\n+  end)\n+\n+  itp('16state_resize', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Placement\n+    reset(state, nil)\n+    push('AB\\x1b[79GCDE', vt)\n+    expect(\n+      'putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 43 1 0,78\\nputglyph 44 1 0,79\\nputglyph 45 1 1,0'\n+    )\n+\n+    -- Resize\n+    reset(state, nil)\n+    resize(27, 85, vt)\n+    push('AB\\x1b[79GCDE', vt)\n+    expect(\n+      'putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 43 1 0,78\\nputglyph 44 1 0,79\\nputglyph 45 1 0,80'\n+    )\n+    cursor(0, 81, state)\n+\n+    -- Resize without reset\n+    resize(28, 90, vt)\n+    cursor(0, 81, state)\n+    push('FGHI', vt)\n+    expect('putglyph 46 1 0,81\\nputglyph 47 1 0,82\\nputglyph 48 1 0,83\\nputglyph 49 1 0,84')\n+    cursor(0, 85, state)\n+\n+    -- Resize shrink moves cursor\n+    resize(25, 80, vt)\n+    cursor(0, 79, state)\n+\n+    -- Resize grow doesn't cancel phantom\n+    reset(state, nil)\n+    push('\\x1b[79GAB', vt)\n+    expect('putglyph 41 1 0,78\\nputglyph 42 1 0,79')\n+    cursor(0, 79, state)\n+    resize(30, 100, vt)\n+    cursor(0, 80, state)\n+    push('C', vt)\n+    expect('putglyph 43 1 0,80')\n+    cursor(0, 81, state)\n+  end)\n+\n+  itp('17state_mouse', function()\n+    local vt = init()\n+    local state = wantstate(vt, { p = true })\n+\n+    -- DECRQM on with mouse off\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;2$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;2$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;2$y')\n+\n+    -- Mouse in simple button report mode\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    push('\\x1b[?1000h', vt)\n+    expect('settermprop 8 1')\n+\n+    -- Press 1\n+    mousemove(0, 0, vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\x21\\x21')\n+\n+    -- Release 1\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\x21\\x21')\n+\n+    -- Ctrl-Press 1\n+    mousebtn('d', 1, vt, { C = true })\n+    expect_output('\\x1b[M\\x30\\x21\\x21')\n+    mousebtn('u', 1, vt, { C = true })\n+    expect_output('\\x1b[M\\x33\\x21\\x21')\n+\n+    -- Button 2\n+    mousebtn('d', 2, vt)\n+    expect_output('\\x1b[M\\x21\\x21\\x21')\n+    mousebtn('u', 2, vt)\n+    expect_output('\\x1b[M\\x23\\x21\\x21')\n+\n+    -- Position\n+    mousemove(10, 20, vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\x35\\x2b')\n+\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\x35\\x2b')\n+    mousemove(10, 21, vt)\n+    -- no output\n+\n+    -- Wheel events\n+    mousebtn('d', 4, vt)\n+    expect_output('\\x1b[M\\x60\\x36\\x2b')\n+    mousebtn('d', 4, vt)\n+    expect_output('\\x1b[M\\x60\\x36\\x2b')\n+    mousebtn('d', 5, vt)\n+    expect_output('\\x1b[M\\x61\\x36\\x2b')\n+    mousebtn('d', 6, vt)\n+    expect_output('\\x1b[M\\x62\\x36\\x2b')\n+    mousebtn('d', 7, vt)\n+    expect_output('\\x1b[M\\x63\\x36\\x2b')\n+\n+    -- DECRQM on mouse button mode\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;1$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;2$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;2$y')\n+\n+    -- Drag events\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    push('\\x1b[?1002h', vt)\n+    expect('settermprop 8 2')\n+\n+    mousemove(5, 5, vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\x26\\x26')\n+    mousemove(5, 6, vt)\n+    expect_output('\\x1b[M\\x40\\x27\\x26')\n+    mousemove(6, 6, vt)\n+    expect_output('\\x1b[M\\x40\\x27\\x27')\n+    mousemove(6, 6, vt)\n+    -- no output\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\x27\\x27')\n+    mousemove(6, 7, vt)\n+    -- no output\n+\n+    -- DECRQM on mouse drag mode\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;2$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;1$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;2$y')\n+\n+    -- Non-drag motion events\n+    push('\\x1b[?1003h', vt)\n+    expect('settermprop 8 3')\n+\n+    mousemove(6, 8, vt)\n+    expect_output('\\x1b[M\\x43\\x29\\x27')\n+\n+    -- DECRQM on mouse motion mode\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;2$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;2$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;1$y')\n+\n+    -- Bounds checking\n+    mousemove(300, 300, vt)\n+    expect_output('\\x1b[M\\x43\\xff\\xff')\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\xff\\xff')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\xff\\xff')\n+\n+    -- DECRQM on standard encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;2$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;2$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;2$y')\n+\n+    -- UTF-8 extended encoding mode\n+    -- 300 + 32 + 1 = 333 = U+014d = \\xc5\\x8d\n+    push('\\x1b[?1005h', vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\xc5\\x8d\\xc5\\x8d')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\xc5\\x8d\\xc5\\x8d')\n+\n+    -- DECRQM on UTF-8 extended encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;1$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;2$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;2$y')\n+\n+    -- SGR extended encoding mode\n+    push('\\x1b[?1006h', vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[<0;301;301M')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[<0;301;301m')\n+\n+    -- DECRQM on SGR extended encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;2$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;1$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;2$y')\n+\n+    -- rxvt extended encoding mode\n+    push('\\x1b[?1015h', vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[0;301;301M')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[3;301;301M')\n+\n+    -- DECRQM on rxvt extended encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;2$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;2$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;1$y')\n+\n+    -- Mouse disabled reports nothing\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    mousemove(0, 0, vt)\n+    mousebtn('d', 1, vt)\n+    mousebtn('u', 1, vt)\n+\n+    -- DECSM can set multiple modes at once\n+    push('\\x1b[?1002;1006h', vt)\n+    expect('settermprop 8 2')\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[<0;1;1M')\n+  end)\n+\n+  itp('18state_termprops', function()\n+    local vt = init()\n+    local state = wantstate(vt, { p = true })\n+\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+\n+    -- Cursor visibility\n+    push('\\x1b[?25h', vt)\n+    expect('settermprop 1 true')\n+    push('\\x1b[?25$p', vt)\n+    expect_output('\\x1b[?25;1$y')\n+    push('\\x1b[?25l', vt)\n+    expect('settermprop 1 false')\n+    push('\\x1b[?25$p', vt)\n+    expect_output('\\x1b[?25;2$y')\n+\n+    -- Cursor blink\n+    push('\\x1b[?12h', vt)\n+    expect('settermprop 2 true')\n+    push('\\x1b[?12$p', vt)\n+    expect_output('\\x1b[?12;1$y')\n+    push('\\x1b[?12l', vt)\n+    expect('settermprop 2 false')\n+    push('\\x1b[?12$p', vt)\n+    expect_output('\\x1b[?12;2$y')\n+\n+    -- Cursor shape\n+    push('\\x1b[3 q', vt)\n+    expect('settermprop 2 true\\nsettermprop 7 2')\n+\n+    -- Title\n+    push('\\x1b]2;Here is my title\\a', vt)\n+    expect('settermprop 4 [\"Here is my title\"]')\n+\n+    -- Title split write\n+    push('\\x1b]2;Here is', vt)\n+    expect('settermprop 4 [\"Here is\"')\n+    push(' another title\\a', vt)\n+    expect('settermprop 4 \" another title\"]')\n+  end)\n+\n+  itp('20state_wrapping', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true, m = true })\n+\n+    -- 79th Column\n+    push('\\x1b[75G', vt)\n+    push(string.rep('A', 5), vt)\n+    expect(\n+      'putglyph 41 1 0,74\\nputglyph 41 1 0,75\\nputglyph 41 1 0,76\\nputglyph 41 1 0,77\\nputglyph 41 1 0,78'\n+    )\n+    cursor(0, 79, state)\n+\n+    -- 80th Column Phantom\n+    push('A', vt)\n+    expect('putglyph 41 1 0,79')\n+    cursor(0, 79, state)\n+\n+    -- Line Wraparound\n+    push('B', vt)\n+    expect('putglyph 42 1 1,0')\n+    cursor(1, 1, state)\n+\n+    -- Line Wraparound during combined write\n+    push('\\x1b[78G', vt)\n+    push('BBBCC', vt)\n+    expect(\n+      'putglyph 42 1 1,77\\nputglyph 42 1 1,78\\nputglyph 42 1 1,79\\nputglyph 43 1 2,0\\nputglyph 43 1 2,1'\n+    )\n+    cursor(2, 2, state)\n+\n+    -- DEC Auto Wrap Mode\n+    reset(state, nil)\n+    push('\\x1b[?7l', vt)\n+    push('\\x1b[75G', vt)\n+    push(string.rep('D', 6), vt)\n+    expect(\n+      'putglyph 44 1 0,74\\nputglyph 44 1 0,75\\nputglyph 44 1 0,76\\nputglyph 44 1 0,77\\nputglyph 44 1 0,78\\nputglyph 44 1 0,79'\n+    )\n+    cursor(0, 79, state)\n+    push('D', vt)\n+    expect('putglyph 44 1 0,79')\n+    cursor(0, 79, state)\n+    push('\\x1b[?7h', vt)\n+\n+    -- 80th column causes linefeed on wraparound\n+    push('\\x1b[25;78HABC', vt)\n+    expect('putglyph 41 1 24,77\\nputglyph 42 1 24,78\\nputglyph 43 1 24,79')\n+    cursor(24, 79, state)\n+    push('D', vt)\n+    expect('moverect 1..25,0..80 -> 0..24,0..80\\nputglyph 44 1 24,0')\n+\n+    -- 80th column phantom linefeed phantom cancelled by explicit cursor move\n+    push('\\x1b[25;78HABC', vt)\n+    expect('putglyph 41 1 24,77\\nputglyph 42 1 24,78\\nputglyph 43 1 24,79')\n+    cursor(24, 79, state)\n+    push('\\x1b[25;1HD', vt)\n+    expect('putglyph 44 1 24,0')\n+  end)\n+\n+  itp('21state_tabstops', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Initial\n+    reset(state, nil)\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,8')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,16')\n+    cursor(0, 17, state)\n+\n+    -- HTS\n+    push('\\x1b[5G\\x1bH', vt)\n+    push('\\x1b[G\\tX', vt)\n+    expect('putglyph 58 1 0,4')\n+    cursor(0, 5, state)\n+\n+    -- TBC 0\n+    push('\\x1b[9G\\x1b[g', vt)\n+    push('\\x1b[G\\tX\\tX', vt)\n+    expect('putglyph 58 1 0,4\\nputglyph 58 1 0,16')\n+    cursor(0, 17, state)\n+\n+    -- TBC 3\n+    push('\\x1b[3g\\x1b[50G\\x1bH\\x1b[G', vt)\n+    cursor(0, 0, state)\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,49')\n+    cursor(0, 50, state)\n+\n+    -- Tabstops after resize\n+    reset(state, nil)\n+    resize(30, 100, vt)\n+    -- Should be 100/8 = 12 tabstops\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,8')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,16')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,24')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,32')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,40')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,48')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,56')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,64')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,72')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,80')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,88')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,96')\n+    cursor(0, 97, state)\n+  end)\n+\n+  itp('22state_save', function()\n+    local vt = init()\n+    local state = wantstate(vt, { p = true })\n+\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+\n+    -- Set up state\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[1m', vt)\n+    pen('bold', true, state)\n+\n+    -- Save\n+    push('\\x1b[?1048h', vt)\n+\n+    -- Change state\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b[4 q', vt)\n+    expect('settermprop 2 false\\nsettermprop 7 2')\n+    push('\\x1b[22;4m', vt)\n+    pen('bold', false, state)\n+    pen('underline', 1, state)\n+\n+    -- Restore\n+    push('\\x1b[?1048l', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(1, 1, state)\n+    pen('bold', true, state)\n+    pen('underline', 0, state)\n+\n+    -- Save/restore using DECSC/DECRC\n+    push('\\x1b[2;2H\\x1b7', vt)\n+    cursor(1, 1, state)\n+\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b8', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(1, 1, state)\n+\n+    -- Save twice, restore twice happens on both edge transitions\n+    push('\\x1b[2;10H\\x1b[?1048h\\x1b[6;10H\\x1b[?1048h', vt)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[?1048l', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(5, 9, state)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[?1048l', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(5, 9, state)\n+  end)\n+\n+  itp('25state_input', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Unmodified ASCII\n+    inchar(41, vt)\n+    expect('output 29')\n+    inchar(61, vt)\n+    expect('output 3d')\n+\n+    -- Ctrl modifier on ASCII letters\n+    inchar(41, vt, { C = true })\n+    expect('output 1b,5b,34,31,3b,35,75')\n+    inchar(61, vt, { C = true })\n+    expect('output 1b,5b,36,31,3b,35,75')\n+\n+    -- Alt modifier on ASCII letters\n+    inchar(41, vt, { A = true })\n+    expect('output 1b,29')\n+    inchar(61, vt, { A = true })\n+    expect('output 1b,3d')\n+\n+    -- Ctrl-Alt modifier on ASCII letters\n+    inchar(41, vt, { C = true, A = true })\n+    expect('output 1b,5b,34,31,3b,37,75')\n+    inchar(61, vt, { C = true, A = true })\n+    expect('output 1b,5b,36,31,3b,37,75')\n+\n+    -- Special handling of Ctrl-I\n+    inchar(49, vt)\n+    expect('output 31')\n+    inchar(69, vt)\n+    expect('output 45')\n+    inchar(49, vt, { C = true })\n+    expect('output 1b,5b,34,39,3b,35,75')\n+    inchar(69, vt, { C = true })\n+    expect('output 1b,5b,36,39,3b,35,75')\n+    inchar(49, vt, { A = true })\n+    expect('output 1b,31')\n+    inchar(69, vt, { A = true })\n+    expect('output 1b,45')\n+    inchar(49, vt, { A = true, C = true })\n+    expect('output 1b,5b,34,39,3b,37,75')\n+    inchar(69, vt, { A = true, C = true })\n+    expect('output 1b,5b,36,39,3b,37,75')\n+\n+    -- Special handling of Space\n+    inchar(20, vt)\n+    expect('output 14')\n+    inchar(20, vt, { S = true })\n+    expect('output 14')\n+    inchar(20, vt, { C = true })\n+    expect('output 1b,5b,32,30,3b,35,75')\n+    inchar(20, vt, { C = true, S = true })\n+    expect('output 1b,5b,32,30,3b,35,75')\n+    inchar(20, vt, { A = true })\n+    expect('output 1b,14')\n+    inchar(20, vt, { S = true, A = true })\n+    expect('output 1b,14')\n+    inchar(20, vt, { C = true, A = true })\n+    expect('output 1b,5b,32,30,3b,37,75')\n+    inchar(20, vt, { S = true, C = true, A = true })\n+    expect('output 1b,5b,32,30,3b,37,75')\n+\n+    -- Cursor keys in reset (cursor) mode\n+    inkey('up', vt)\n+    expect_output('\\x1b[A')\n+    inkey('up', vt, { S = true })\n+    expect_output('\\x1b[1;2A')\n+    inkey('up', vt, { C = true })\n+    expect_output('\\x1b[1;5A')\n+    inkey('up', vt, { S = true, C = true })\n+    expect_output('\\x1b[1;6A')\n+    inkey('up', vt, { A = true })\n+    expect_output('\\x1b[1;3A')\n+    inkey('up', vt, { S = true, A = true })\n+    expect_output('\\x1b[1;4A')\n+    inkey('up', vt, { C = true, A = true })\n+    expect_output('\\x1b[1;7A')\n+    inkey('up', vt, { S = true, C = true, A = true })\n+    expect_output('\\x1b[1;8A')\n+\n+    -- Cursor keys in application mode\n+    push('\\x1b[?1h', vt)\n+    -- Plain \"Up\" should be SS3 A now\n+    inkey('up', vt)\n+    expect_output('\\x1bOA')\n+    -- Modified keys should still use CSI\n+    inkey('up', vt, { S = true })\n+    expect_output('\\x1b[1;2A')\n+    inkey('up', vt, { C = true })\n+    expect_output('\\x1b[1;5A')\n+\n+    -- Shift-Tab should be different\n+    inkey('tab', vt)\n+    expect_output('\\x09')\n+    inkey('tab', vt, { S = true })\n+    expect_output('\\x1b[Z')\n+    inkey('tab', vt, { C = true })\n+    expect_output('\\x1b[9;5u')\n+    inkey('tab', vt, { A = true })\n+    expect_output('\\x1b\\x09')\n+    inkey('tab', vt, { C = true, A = true })\n+    expect_output('\\x1b[9;7u')\n+\n+    -- Enter in linefeed mode\n+    inkey('enter', vt)\n+    expect_output('\\x0d')\n+\n+    -- Enter in newline mode\n+    push('\\x1b[20h', vt)\n+    inkey('enter', vt)\n+    expect_output('\\x0d\\x0a')\n+\n+    -- Unmodified F1 is SS3 P\n+    inkey('f1', vt)\n+    expect_output('\\x1bOP')\n+\n+    -- Modified F1 is CSI P\n+    inkey('f1', vt, { S = true })\n+    expect_output('\\x1b[1;2P')\n+    inkey('f1', vt, { A = true })\n+    expect_output('\\x1b[1;3P')\n+    inkey('f1', vt, { C = true })\n+    expect_output('\\x1b[1;5P')\n+\n+    -- Keypad in DECKPNM\n+    inkey('kp0', vt)\n+    expect_output('0')\n+\n+    -- Keypad in DECKPAM\n+    push('\\x1b=', vt)\n+    inkey('kp0', vt)\n+    expect_output('\\x1bOp')\n+\n+    -- Bracketed paste mode off\n+    vterm.vterm_keyboard_start_paste(vt)\n+    vterm.vterm_keyboard_end_paste(vt)\n+\n+    -- Bracketed paste mode on\n+    push('\\x1b[?2004h', vt)\n+    vterm.vterm_keyboard_start_paste(vt)\n+    expect_output('\\x1b[200~')\n+    vterm.vterm_keyboard_end_paste(vt)\n+    expect_output('\\x1b[201~')\n+\n+    -- Focus reporting disabled\n+    vterm.vterm_state_focus_in(state)\n+    vterm.vterm_state_focus_out(state)\n+\n+    -- Focus reporting enabled\n+    state = wantstate(vt, { p = true })\n+    push('\\x1b[?1004h', vt)\n+    expect('settermprop 9 true')\n+    vterm.vterm_state_focus_in(state)\n+    expect_output('\\x1b[I')\n+    vterm.vterm_state_focus_out(state)\n+    expect_output('\\x1b[O')\n+  end)\n+\n+  itp('26state_query', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- DA\n+    reset(state, nil)\n+    push('\\x1b[c', vt)\n+    expect_output('\\x1b[?1;2c')\n+\n+    -- XTVERSION\n+    reset(state, nil)\n+    push('\\x1b[>q', vt)\n+    expect_output('\\x1bP>|libvterm(0.3)\\x1b\\\\')\n+\n+    -- DSR\n+    reset(state, nil)\n+    push('\\x1b[5n', vt)\n+    expect_output('\\x1b[0n')\n+\n+    -- CPR\n+    push('\\x1b[6n', vt)\n+    expect_output('\\x1b[1;1R')\n+    push('\\x1b[10;10H\\x1b[6n', vt)\n+    expect_output('\\x1b[10;10R')\n+\n+    -- DECCPR\n+    push('\\x1b[?6n', vt)\n+    expect_output('\\x1b[?10;10R')\n+\n+    -- DECRQSS on DECSCUSR\n+    push('\\x1b[3 q', vt)\n+    push('\\x1bP$q q\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r3 q\\x1b\\\\')\n+\n+    -- DECRQSS on SGR\n+    push('\\x1b[1;5;7m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r1;5;7m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR ANSI colours\n+    push('\\x1b[0;31;42m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r31;42m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR ANSI hi-bright colours\n+    push('\\x1b[0;93;104m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r93;104m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR 256-palette colours\n+    push('\\x1b[0;38:5:56;48:5:78m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r38:5:56;48:5:78m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR RGB8 colours\n+    push('\\x1b[0;38:2:24:68:112;48:2:13:57:101m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r38:2:24:68:112;48:2:13:57:101m\\x1b\\\\')\n+\n+    -- S8C1T on DSR\n+    push('\\x1b G', vt)\n+    push('\\x1b[5n', vt)\n+    expect_output('\\x9b0n')\n+    push('\\x1b F', vt)\n+  end)\n+\n+  itp('27state_reset', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    reset(state, nil)\n+\n+    -- RIS homes cursor\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    state = wantstate(vt, { m = true })\n+    push('\\x1bc', vt)\n+    cursor(0, 0, state)\n+    wantstate(vt)\n+\n+    -- RIS cancels scrolling region\n+    push('\\x1b[5;10r', vt)\n+    wantstate(vt, { s = true })\n+    push('\\x1bc\\x1b[25H\\n', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+    wantstate(vt)\n+\n+    -- RIS erases screen\n+    push('ABCDE', vt)\n+    state = wantstate(vt, { e = true })\n+    push('\\x1bc', vt)\n+    expect('erase 0..25,0..80')\n+    wantstate(vt)\n+\n+    -- RIS clears tabstops\n+    push('\\x1b[5G\\x1bH\\x1b[G\\t', vt)\n+    cursor(0, 4, state)\n+    push('\\x1bc\\t', vt)\n+    cursor(0, 8, state)\n+  end)\n+\n+  itp('28state_dbl_wh', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Single Width, Single Height\n+    reset(state, nil)\n+    push('\\x1b#5', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 0,0\\nputglyph 65 1 0,1\\nputglyph 6c 1 0,2\\nputglyph 6c 1 0,3\\nputglyph 6f 1 0,4'\n+    )\n+\n+    -- Double Width, Single Height\n+    reset(state, nil)\n+    push('\\x1b#6', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 0,0 dwl\\nputglyph 65 1 0,1 dwl\\nputglyph 6c 1 0,2 dwl\\nputglyph 6c 1 0,3 dwl\\nputglyph 6f 1 0,4 dwl'\n+    )\n+    cursor(0, 5, state)\n+    push('\\x1b[40GAB', vt)\n+    expect('putglyph 41 1 0,39 dwl\\nputglyph 42 1 1,0')\n+    cursor(1, 1, state)\n+\n+    -- Double Height\n+    reset(state, nil)\n+    push('\\x1b#3', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 0,0 dwl dhl-top\\nputglyph 65 1 0,1 dwl dhl-top\\nputglyph 6c 1 0,2 dwl dhl-top\\nputglyph 6c 1 0,3 dwl dhl-top\\nputglyph 6f 1 0,4 dwl dhl-top'\n+    )\n+    cursor(0, 5, state)\n+    push('\\r\\n\\x1b#4', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 1,0 dwl dhl-bottom\\nputglyph 65 1 1,1 dwl dhl-bottom\\nputglyph 6c 1 1,2 dwl dhl-bottom\\nputglyph 6c 1 1,3 dwl dhl-bottom\\nputglyph 6f 1 1,4 dwl dhl-bottom'\n+    )\n+    cursor(1, 5, state)\n+\n+    -- Double Width scrolling\n+    reset(state, nil)\n+    push('\\x1b[20H\\x1b#6ABC', vt)\n+    expect('putglyph 41 1 19,0 dwl\\nputglyph 42 1 19,1 dwl\\nputglyph 43 1 19,2 dwl')\n+    push('\\x1b[25H\\n', vt)\n+    push('\\x1b[19;4HDE', vt)\n+    expect('putglyph 44 1 18,3 dwl\\nputglyph 45 1 18,4 dwl')\n+    push('\\x1b[H\\x1bM', vt)\n+    push('\\x1b[20;6HFG', vt)\n+    expect('putglyph 46 1 19,5 dwl\\nputglyph 47 1 19,6 dwl')\n+  end)\n+\n+  itp('29state_fallback', function()\n+    local vt = init()\n+    local state = wantstate(vt, { f = true })\n+    reset(state, nil)\n+\n+    -- Unrecognised control\n+    push('\\x03', vt)\n+    expect('control 03')\n+\n+    -- Unrecognised CSI\n+    push('\\x1b[?15;2z', vt)\n+    expect('csi 7a L=3f 15,2')\n+\n+    -- Unrecognised OSC\n+    push('\\x1b]27;Something\\x1b\\\\', vt)\n+    expect('osc [27;Something]')\n+\n+    -- Unrecognised DCS\n+    push('\\x1bPz123\\x1b\\\\', vt)\n+    expect('dcs [z123]')\n+\n+    -- Unrecognised APC\n+    push('\\x1b_z123\\x1b\\\\', vt)\n+    expect('apc [z123]')\n+\n+    -- Unrecognised PM\n+    push('\\x1b^z123\\x1b\\\\', vt)\n+    expect('pm [z123]')\n+\n+    -- Unrecognised SOS\n+    push('\\x1bXz123\\x1b\\\\', vt)\n+    expect('sos [z123]')\n+  end)\n+\n+  itp('30state_pen', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Reset\n+    push('\\x1b[m', vt)\n+    pen('bold', false, state)\n+    pen('underline', 0, state)\n+    pen('italic', false, state)\n+    pen('blink', false, state)\n+    pen('reverse', false, state)\n+    pen('font', 0, state)\n+    -- TODO(dundargoc): fix\n+    -- ?pen foreground = rgb(240,240,240,is_default_fg)\n+    -- ?pen background = rgb(0,0,0,is_default_bg)\n+\n+    -- Bold\n+    push('\\x1b[1m', vt)\n+    pen('bold', true, state)\n+    push('\\x1b[22m', vt)\n+    pen('bold', false, state)\n+    push('\\x1b[1m\\x1b[m', vt)\n+    pen('bold', false, state)\n+\n+    -- Underline\n+    push('\\x1b[4m', vt)\n+    pen('underline', 1, state)\n+    push('\\x1b[21m', vt)\n+    pen('underline', 2, state)\n+    push('\\x1b[24m', vt)\n+    pen('underline', 0, state)\n+    push('\\x1b[4m\\x1b[4:0m', vt)\n+    pen('underline', 0, state)\n+    push('\\x1b[4:1m', vt)\n+    pen('underline', 1, state)\n+    push('\\x1b[4:2m', vt)\n+    pen('underline', 2, state)\n+    push('\\x1b[4:3m', vt)\n+    pen('underline', 3, state)\n+    push('\\x1b[4m\\x1b[m', vt)\n+    pen('underline', 0, state)\n+\n+    -- Italic\n+    push('\\x1b[3m', vt)\n+    pen('italic', true, state)\n+    push('\\x1b[23m', vt)\n+    pen('italic', false, state)\n+    push('\\x1b[3m\\x1b[m', vt)\n+    pen('italic', false, state)\n+\n+    -- Blink\n+    push('\\x1b[5m', vt)\n+    pen('blink', true, state)\n+    push('\\x1b[25m', vt)\n+    pen('blink', false, state)\n+    push('\\x1b[5m\\x1b[m', vt)\n+    pen('blink', false, state)\n+\n+    -- Reverse\n+    push('\\x1b[7m', vt)\n+    pen('reverse', true, state)\n+    push('\\x1b[27m', vt)\n+    pen('reverse', false, state)\n+    push('\\x1b[7m\\x1b[m', vt)\n+    pen('reverse', false, state)\n+\n+    -- Font Selection\n+    push('\\x1b[11m', vt)\n+    pen('font', 1, state)\n+    push('\\x1b[19m', vt)\n+    pen('font', 9, state)\n+    push('\\x1b[10m', vt)\n+    pen('font', 0, state)\n+    push('\\x1b[11m\\x1b[m', vt)\n+    pen('font', 0, state)\n+\n+    -- TODO(dundargoc): fix\n+    -- -- Foreground\n+    -- push \"\\x1b[31m\"\n+    --   ?pen foreground = idx(1)\n+    -- push \"\\x1b[32m\"\n+    --   ?pen foreground = idx(2)\n+    -- push \"\\x1b[34m\"\n+    --   ?pen foreground = idx(4)\n+    -- push \"\\x1b[91m\"\n+    --   ?pen foreground = idx(9)\n+    -- push \"\\x1b[38:2:10:20:30m\"\n+    --   ?pen foreground = rgb(10,20,30)\n+    -- push \"\\x1b[38:5:1m\"\n+    --   ?pen foreground = idx(1)\n+    -- push \"\\x1b[39m\"\n+    --   ?pen foreground = rgb(240,240,240,is_default_fg)\n+    --\n+    -- -- Background\n+    -- push \"\\x1b[41m\"\n+    --   ?pen background = idx(1)\n+    -- push \"\\x1b[42m\"\n+    --   ?pen background = idx(2)\n+    -- push \"\\x1b[44m\"\n+    --   ?pen background = idx(4)\n+    -- push \"\\x1b[101m\"\n+    --   ?pen background = idx(9)\n+    -- push \"\\x1b[48:2:10:20:30m\"\n+    --   ?pen background = rgb(10,20,30)\n+    -- push \"\\x1b[48:5:1m\"\n+    --   ?pen background = idx(1)\n+    -- push \"\\x1b[49m\"\n+    --   ?pen background = rgb(0,0,0,is_default_bg)\n+    --\n+    -- -- Bold+ANSI colour == highbright\n+    -- push \"\\x1b[m\\x1b[1;37m\"\n+    --   ?pen bold = on\n+    --   ?pen foreground = idx(15)\n+    -- push \"\\x1b[m\\x1b[37;1m\"\n+    --   ?pen bold = on\n+    --   ?pen foreground = idx(15)\n+    --\n+    -- -- Super/Subscript\n+    -- push \"\\x1b[73m\"\n+    --   ?pen small = on\n+    --   ?pen baseline = raise\n+    -- push \"\\x1b[74m\"\n+    --   ?pen small = on\n+    --   ?pen baseline = lower\n+    -- push \"\\x1b[75m\"\n+    --   ?pen small = off\n+    --   ?pen baseline = normal\n+    --\n+    -- -- DECSTR resets pen attributes\n+    -- push \"\\x1b[1;4m\"\n+    --   ?pen bold = on\n+    --   ?pen underline = 1\n+    -- push \"\\x1b[!p\"\n+    --   ?pen bold = off\n+    --   ?pen underline = 0\n+  end)\n+\n+  itp('31state_rep', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- REP no argument\n+    reset(state, nil)\n+    push('a\\x1b[b', vt)\n+    expect('putglyph 61 1 0,0\\nputglyph 61 1 0,1')\n+\n+    -- REP zero (zero should be interpreted as one)\n+    reset(state, nil)\n+    push('a\\x1b[0b', vt)\n+    expect('putglyph 61 1 0,0\\nputglyph 61 1 0,1')\n+\n+    -- REP lowercase a times two\n+    reset(state, nil)\n+    push('a\\x1b[2b', vt)\n+    expect('putglyph 61 1 0,0\\nputglyph 61 1 0,1\\nputglyph 61 1 0,2')\n+\n+    -- REP with UTF-8 1 char\n+    -- U+00E9 = C3 A9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(state, nil)\n+    push('\\xC3\\xA9\\x1b[b', vt)\n+    expect('putglyph e9 1 0,0\\nputglyph e9 1 0,1')\n+\n+    -- REP with UTF-8 wide char\n+    -- U+00E9 = C3 A9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(state, nil)\n+    push('\\xEF\\xBC\\x90\\x1b[b', vt)\n+    expect('putglyph ff10 2 0,0\\nputglyph ff10 2 0,2')\n+\n+    -- REP with UTF-8 combining character\n+    reset(state, nil)\n+    push('e\\xCC\\x81\\x1b[b', vt)\n+    expect('putglyph 65,301 1 0,0\\nputglyph 65,301 1 0,1')\n+\n+    -- REP till end of line\n+    reset(state, nil)\n+    push('a\\x1b[1000bb', vt)\n+    expect(\n+      'putglyph 61 1 0,0\\nputglyph 61 1 0,1\\nputglyph 61 1 0,2\\nputglyph 61 1 0,3\\nputglyph 61 1 0,4\\nputglyph 61 1 0,5\\nputglyph 61 1 0,6\\nputglyph 61 1 0,7\\nputglyph 61 1 0,8\\nputglyph 61 1 0,9\\nputglyph 61 1 0,10\\nputglyph 61 1 0,11\\nputglyph 61 1 0,12\\nputglyph 61 1 0,13\\nputglyph 61 1 0,14\\nputglyph 61 1 0,15\\nputglyph 61 1 0,16\\nputglyph 61 1 0,17\\nputglyph 61 1 0,18\\nputglyph 61 1 0,19\\nputglyph 61 1 0,20\\nputglyph 61 1 0,21\\nputglyph 61 1 0,22\\nputglyph 61 1 0,23\\nputglyph 61 1 0,24\\nputglyph 61 1 0,25\\nputglyph 61 1 0,26\\nputglyph 61 1 0,27\\nputglyph 61 1 0,28\\nputglyph 61 1 0,29\\nputglyph 61 1 0,30\\nputglyph 61 1 0,31\\nputglyph 61 1 0,32\\nputglyph 61 1 0,33\\nputglyph 61 1 0,34\\nputglyph 61 1 0,35\\nputglyph 61 1 0,36\\nputglyph 61 1 0,37\\nputglyph 61 1 0,38\\nputglyph 61 1 0,39\\nputglyph 61 1 0,40\\nputglyph 61 1 0,41\\nputglyph 61 1 0,42\\nputglyph 61 1 0,43\\nputglyph 61 1 0,44\\nputglyph 61 1 0,45\\nputglyph 61 1 0,46\\nputglyph 61 1 0,47\\nputglyph 61 1 0,48\\nputglyph 61 1 0,49\\nputglyph 61 1 0,50\\nputglyph 61 1 0,51\\nputglyph 61 1 0,52\\nputglyph 61 1 0,53\\nputglyph 61 1 0,54\\nputglyph 61 1 0,55\\nputglyph 61 1 0,56\\nputglyph 61 1 0,57\\nputglyph 61 1 0,58\\nputglyph 61 1 0,59\\nputglyph 61 1 0,60\\nputglyph 61 1 0,61\\nputglyph 61 1 0,62\\nputglyph 61 1 0,63\\nputglyph 61 1 0,64\\nputglyph 61 1 0,65\\nputglyph 61 1 0,66\\nputglyph 61 1 0,67\\nputglyph 61 1 0,68\\nputglyph 61 1 0,69\\nputglyph 61 1 0,70\\nputglyph 61 1 0,71\\nputglyph 61 1 0,72\\nputglyph 61 1 0,73\\nputglyph 61 1 0,74\\nputglyph 61 1 0,75\\nputglyph 61 1 0,76\\nputglyph 61 1 0,77\\nputglyph 61 1 0,78\\nputglyph 61 1 0,79\\nputglyph 62 1 1,0'\n+    )\n+  end)\n+\n+  itp('32state_flow', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Many of these test cases inspired by\n+    -- https://blueprints.launchpad.net/libvterm/+spec/reflow-cases\n+\n+    -- Spillover text marks continuation on second line\n+    reset(state, nil)\n+    push(string.rep('A', 100), vt)\n+    push('\\r\\n', vt)\n+    lineinfo(0, {}, state)\n+    lineinfo(1, { cont = true }, state)\n+\n+    -- CRLF in column 80 does not mark continuation\n+    reset(state, nil)\n+    push(string.rep('B', 80), vt)\n+    push('\\r\\n', vt)\n+    push(string.rep('B', 20), vt)\n+    push('\\r\\n', vt)\n+    lineinfo(0, {}, state)\n+    lineinfo(1, {}, state)\n+\n+    -- EL cancels continuation of following line\n+    reset(state, nil)\n+    push(string.rep('D', 100), vt)\n+    lineinfo(1, { cont = true }, state)\n+    push('\\x1bM\\x1b[79G\\x1b[K', vt)\n+    lineinfo(1, {}, state)\n+  end)\n+\n+  itp('40state_selection', function()\n+    local vt = init()\n+    wantstate(vt)\n+\n+    -- Set clipboard; final chunk len 4\n+    push('\\x1b]52;c;SGVsbG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello,]')\n+\n+    -- Set clipboard; final chunk len 3\n+    push('\\x1b]52;c;SGVsbG8sIHc=\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello, w]')\n+\n+    -- Set clipboard; final chunk len 2\n+    push('\\x1b]52;c;SGVsbG8sIHdvcmxkCg==\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello, world\\n]')\n+\n+    -- Set clipboard; split between chunks\n+    push('\\x1b]52;c;SGVs', vt)\n+    expect('selection-set mask=0001 [Hel')\n+    push('bG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 lo,]')\n+\n+    -- Set clipboard; split within chunk\n+    push('\\x1b]52;c;SGVsbG', vt)\n+    expect('selection-set mask=0001 [Hel')\n+    push('8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 lo,]')\n+\n+    -- Set clipboard; empty first chunk\n+    push('\\x1b]52;c;', vt)\n+    push('SGVsbG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello,]')\n+\n+    -- Set clipboard; empty final chunk\n+    push('\\x1b]52;c;SGVsbG8s', vt)\n+    expect('selection-set mask=0001 [Hello,')\n+    push('\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 ]')\n+\n+    -- Set clipboard; longer than buffer\n+    push('\\x1b]52;c;' .. string.rep('LS0t', 10) .. '\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [---------------\\nselection-set mask=0001 ---------------]')\n+\n+    -- Clear clipboard\n+    push('\\x1b]52;c;\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 []')\n+\n+    -- Set invalid data clears and ignores\n+    push('\\x1b]52;c;SGVs*SGVsbG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 []')\n+\n+    -- Query clipboard\n+    push('\\x1b]52;c;?\\x1b\\\\', vt)\n+    expect('selection-query mask=0001')\n+\n+    -- TODO(dundargoc): fix\n+    -- -- Send clipboard; final chunk len 4\n+    -- SELECTION 1 [\"Hello,\"]\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVsbG8s\"\n+    --   output \"\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; final chunk len 3\n+    -- SELECTION 1 [\"Hello, w\"]\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVsbG8s\"\n+    --   output \"IHc=\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; final chunk len 2\n+    -- SELECTION 1 [\"Hello, world\\n\"]\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVsbG8sIHdvcmxk\"\n+    --   output \"Cg==\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; split between chunks\n+    -- SELECTION 1 [\"Hel\"\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVs\"\n+    -- SELECTION 1  \"lo,\"]\n+    --   output \"bG8s\"\n+    --   output \"\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; split within chunk\n+    -- SELECTION 1 [\"Hello\"\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVs\"\n+    -- SELECTION 1 \",\"]\n+    --   output \"bG8s\"\n+    --   output \"\\x1b\\\\\"\n+  end)\n+\n+  itp('60screen_ascii', function()\n+    local vt = init()\n+    local screen = wantscreen(vt, { a = true, c = true })\n+\n+    -- Get\n+    reset(nil, screen)\n+    push('ABC', vt)\n+    expect('movecursor 0,3')\n+    screen_chars(0, 0, 1, 3, 'ABC', screen)\n+    screen_chars(0, 0, 1, 80, 'ABC', screen)\n+    screen_text(0, 0, 1, 3, '41,42,43', screen)\n+    screen_text(0, 0, 1, 80, '41,42,43', screen)\n+    screen_cell(0, 0, '{41} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 1, '{42} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 2, '{43} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_row(0, 'ABC', screen)\n+    screen_eol(0, 0, 0, screen)\n+    screen_eol(0, 2, 0, screen)\n+    screen_eol(0, 3, 1, screen)\n+    push('\\x1b[H', vt)\n+    expect('movecursor 0,0')\n+    screen_row(0, 'ABC', screen)\n+    screen_text(0, 0, 1, 80, '41,42,43', screen)\n+    push('E', vt)\n+    expect('movecursor 0,1')\n+    screen_row(0, 'EBC', screen)\n+    screen_text(0, 0, 1, 80, '45,42,43', screen)\n+\n+    screen = wantscreen(vt, { a = true })\n+\n+    -- Erase\n+    reset(nil, screen)\n+    push('ABCDE\\x1b[H\\x1b[K', vt)\n+    -- TODO(dundargoc): fix\n+    -- screen_row(0, '', screen)\n+    screen_text(0, 0, 1, 80, '', screen)\n+\n+    -- Copycell\n+    reset(nil, screen)\n+    push('ABC\\x1b[H\\x1b[@', vt)\n+    push('1', vt)\n+    screen_row(0, '1ABC', screen)\n+\n+    reset(nil, screen)\n+    push('ABC\\x1b[H\\x1b[P', vt)\n+    screen_chars(0, 0, 1, 1, 'B', screen)\n+    screen_chars(0, 1, 1, 2, 'C', screen)\n+    screen_chars(0, 0, 1, 80, 'BC', screen)\n+\n+    -- Space padding\n+    reset(nil, screen)\n+    push('Hello\\x1b[CWorld', vt)\n+    screen_row(0, 'Hello World', screen)\n+    screen_text(0, 0, 1, 80, '48,65,6c,6c,6f,20,57,6f,72,6c,64', screen)\n+\n+    -- Linefeed padding\n+    reset(nil, screen)\n+    push('Hello\\r\\nWorld', vt)\n+    screen_chars(0, 0, 2, 80, 'Hello\\nWorld', screen)\n+    screen_text(0, 0, 2, 80, '48,65,6c,6c,6f,0a,57,6f,72,6c,64', screen)\n+\n+    -- Altscreen\n+    reset(nil, screen)\n+    push('P', vt)\n+    screen_row(0, 'P', screen)\n+    -- TODO(dundargoc): fix\n+    -- push('\\x1b[?1049h', vt)\n+    -- screen_row(0, '', screen)\n+    -- push('\\x1b[2K\\x1b[HA', vt)\n+    -- screen_row(0, 'A', screen)\n+    -- push('\\x1b[?1049l', vt)\n+    -- screen_row(0, 'P', screen)\n+  end)\n+\n+  itp('61screen_unicode', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    -- Single width UTF-8\n+    -- U+00C1 = C3 81  name: LATIN CAPITAL LETTER A WITH ACUTE\n+    -- U+00E9 = C3 A9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(nil, screen)\n+    push('\\xC3\\x81\\xC3\\xA9', vt)\n+    screen_row(0, 'Áé', screen)\n+    screen_text(0, 0, 1, 80, 'c3,81,c3,a9', screen)\n+    screen_cell(0, 0, '{c1} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Wide char\n+    -- U+FF10 = EF BC 90  name: FULLWIDTH DIGIT ZERO\n+    reset(nil, screen)\n+    push('0123\\x1b[H', vt)\n+    push('\\xEF\\xBC\\x90', vt)\n+    screen_row(0, '０23', screen)\n+    screen_text(0, 0, 1, 80, 'ef,bc,90,32,33', screen)\n+    screen_cell(0, 0, '{ff10} width=2 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Combining char\n+    -- U+0301 = CC 81  name: COMBINING ACUTE\n+    reset(nil, screen)\n+    push('0123\\x1b[H', vt)\n+    push('e\\xCC\\x81', vt)\n+    screen_row(0, 'é123', screen)\n+    screen_text(0, 0, 1, 80, '65,cc,81,31,32,33', screen)\n+    screen_cell(0, 0, '{65,301} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- 10 combining accents should not crash\n+    reset(nil, screen)\n+    push('e\\xCC\\x81\\xCC\\x82\\xCC\\x83\\xCC\\x84\\xCC\\x85\\xCC\\x86\\xCC\\x87\\xCC\\x88\\xCC\\x89\\xCC\\x8A', vt)\n+    screen_cell(\n+      0,\n+      0,\n+      '{65,301,302,303,304,305} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)',\n+      screen\n+    )\n+\n+    -- 40 combining accents in two split writes of 20 should not crash\n+    reset(nil, screen)\n+    push(\n+      'e\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81',\n+      vt\n+    )\n+    push(\n+      '\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81',\n+      vt\n+    )\n+    screen_cell(\n+      0,\n+      0,\n+      '{65,301,301,301,301,301} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)',\n+      screen\n+    )\n+\n+    -- Outputing CJK doublewidth in 80th column should wraparound to next line and not crash\"\n+    reset(nil, screen)\n+    push('\\x1b[80G\\xEF\\xBC\\x90', vt)\n+    screen_cell(0, 79, '{} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(1, 0, '{ff10} width=2 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+  end)\n+\n+  pending('62screen_damage', function() end)\n+\n+  itp('63screen_resize', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+    local screen = wantscreen(vt)\n+\n+    -- Resize wider preserves cells\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('AB\\r\\nCD', vt)\n+    screen_chars(0, 0, 1, 80, 'AB', screen)\n+    screen_chars(1, 0, 2, 80, 'CD', screen)\n+    resize(25, 100, vt)\n+    screen_chars(0, 0, 1, 100, 'AB', screen)\n+    screen_chars(1, 0, 2, 100, 'CD', screen)\n+\n+    -- Resize wider allows print in new area\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('AB\\x1b[79GCD', vt)\n+    screen_chars(0, 0, 1, 2, 'AB', screen)\n+    screen_chars(0, 78, 1, 80, 'CD', screen)\n+    resize(25, 100, vt)\n+    screen_chars(0, 0, 1, 2, 'AB', screen)\n+    screen_chars(0, 78, 1, 80, 'CD', screen)\n+    push('E', vt)\n+    screen_chars(0, 78, 1, 81, 'CDE', screen)\n+\n+    -- Resize shorter with blanks just truncates\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('Top\\x1b[10HLine 10', vt)\n+    screen_row(0, 'Top', screen)\n+    screen_row(9, 'Line 10', screen)\n+    cursor(9, 7, state)\n+    resize(20, 80, vt)\n+    screen_row(0, 'Top', screen)\n+    screen_row(9, 'Line 10', screen)\n+    cursor(9, 7, state)\n+\n+    -- Resize shorter with content must scroll\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('Top\\x1b[25HLine 25\\x1b[15H', vt)\n+    screen_row(0, 'Top', screen)\n+    screen_row(24, 'Line 25', screen)\n+    cursor(14, 0, state)\n+    screen = wantscreen(vt, { b = true })\n+    resize(20, 80, vt)\n+    expect(\n+      'sb_pushline 80 = 54 6F 70\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 ='\n+    )\n+    -- TODO(dundargoc): fix or remove\n+    -- screen_row( 0  , \"\",screen)\n+    screen_row(19, 'Line 25', screen)\n+    cursor(9, 0, state)\n+\n+    -- Resize shorter does not lose line with cursor\n+    -- See also https://github.com/neovim/libvterm/commit/1b745d29d45623aa8d22a7b9288c7b0e331c7088\n+    reset(state, screen)\n+    wantscreen(vt)\n+    resize(25, 80, vt)\n+    screen = wantscreen(vt, { b = true })\n+    push('\\x1b[24HLine 24\\r\\nLine 25\\r\\n', vt)\n+    expect('sb_pushline 80 =')\n+    screen_row(23, 'Line 25', screen)\n+    cursor(24, 0, state)\n+    resize(24, 80, vt)\n+    expect('sb_pushline 80 =')\n+    screen_row(22, 'Line 25', screen)\n+    cursor(23, 0, state)\n+\n+    -- Resize shorter does not send the cursor to a negative row\n+    -- See also https://github.com/vim/vim/pull/6141\n+    reset(state, screen)\n+    wantscreen(vt)\n+    resize(25, 80, vt)\n+    screen = wantscreen(vt, { b = true })\n+    push('\\x1b[24HLine 24\\r\\nLine 25\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    resize(20, 80, vt)\n+    expect(\n+      'sb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 ='\n+    )\n+    cursor(0, 0, state)\n+\n+    -- Resize taller attempts to pop scrollback\n+    reset(state, screen)\n+    screen = wantscreen(vt)\n+    resize(25, 80, vt)\n+    push('Line 1\\x1b[25HBottom\\x1b[15H', vt)\n+    screen_row(0, 'Line 1', screen)\n+    screen_row(24, 'Bottom', screen)\n+    cursor(14, 0, state)\n+    screen = wantscreen(vt, { b = true })\n+    resize(30, 80, vt)\n+    expect('sb_popline 80\\nsb_popline 80\\nsb_popline 80\\nsb_popline 80\\nsb_popline 80')\n+    screen_row(0, 'ABCDE', screen)\n+    screen_row(5, 'Line 1', screen)\n+    screen_row(29, 'Bottom', screen)\n+    cursor(19, 0, state)\n+    screen = wantscreen(vt)\n+\n+    -- Resize can operate on altscreen\n+    reset(state, screen)\n+    screen = wantscreen(vt, { a = true })\n+    resize(25, 80, vt)\n+    push('Main screen\\x1b[?1049h\\x1b[HAlt screen', vt)\n+    resize(30, 80, vt)\n+    screen_row(0, 'Alt screen', screen)\n+    push('\\x1b[?1049l', vt)\n+    screen_row(0, 'Main screen', screen)\n+  end)\n+\n+  itp('64screen_pen', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    -- Plain\n+    push('A', vt)\n+    screen_cell(0, 0, '{41} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Bold\n+    push('\\x1b[1mB', vt)\n+    screen_cell(0, 1, '{42} width=1 attrs={B} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Italic\n+    push('\\x1b[3mC', vt)\n+    screen_cell(0, 2, '{43} width=1 attrs={BI} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Underline\n+    push('\\x1b[4mD', vt)\n+    screen_cell(0, 3, '{44} width=1 attrs={BU1I} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Reset\n+    push('\\x1b[mE', vt)\n+    screen_cell(0, 4, '{45} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Font\n+    push('\\x1b[11mF\\x1b[m', vt)\n+    screen_cell(0, 5, '{46} width=1 attrs={F1} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Foreground\n+    push('\\x1b[31mG\\x1b[m', vt)\n+    screen_cell(0, 6, '{47} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(0,0,0)', screen)\n+\n+    -- Background\n+    push('\\x1b[42mH\\x1b[m', vt)\n+    screen_cell(0, 7, '{48} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,224,0)', screen)\n+\n+    -- Super/subscript\n+    push('x\\x1b[74m0\\x1b[73m2\\x1b[m', vt)\n+    screen_cell(0, 8, '{78} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 9, '{30} width=1 attrs={S_} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 10, '{32} width=1 attrs={S^} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- EL sets only colours to end of line, not other attrs\n+    push('\\x1b[H\\x1b[7;33;44m\\x1b[K', vt)\n+    screen_cell(0, 0, '{} width=1 attrs={} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+    screen_cell(0, 79, '{} width=1 attrs={} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+\n+    -- DECSCNM xors reverse for entire screen\n+    push('R\\x1b[?5h', vt)\n+    screen_cell(0, 0, '{52} width=1 attrs={} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+    screen_cell(1, 0, '{} width=1 attrs={R} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    push('\\x1b[?5$p', vt)\n+    expect_output('\\x1b[?5;1$y')\n+    push('\\x1b[?5l', vt)\n+    screen_cell(0, 0, '{52} width=1 attrs={R} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+    screen_cell(1, 0, '{} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    -- TODO(dundargoc): fix\n+    -- push('\\x1b[?5$p')\n+    -- expect_output('\\x1b[?5;2$y')\n+\n+    -- Set default colours\n+    reset(nil, screen)\n+    push('ABC\\x1b[31mDEF\\x1b[m', vt)\n+    screen_cell(0, 0, '{41} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 3, '{44} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(0,0,0)', screen)\n+    -- TODO(dundargoc): fix\n+    -- SETDEFAULTCOL rgb(252,253,254)\n+    --   ?screen_cell 0,0  = {41} width=1 attrs={} fg=rgb(252,253,254) bg=rgb(0,0,0)\n+    --   ?screen_cell 0,3  = {44} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(0,0,0)\n+    -- SETDEFAULTCOL rgb(250,250,250) rgb(10,20,30)\n+    --   ?screen_cell 0,0  = {41} width=1 attrs={} fg=rgb(250,250,250) bg=rgb(10,20,30)\n+    --   ?screen_cell 0,3  = {44} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(10,20,30)\n+  end)\n+\n+  itp('65screen_protect', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    -- Selective erase\n+    reset(nil, screen)\n+    push('A\\x1b[1\"qB\\x1b[\"qC', vt)\n+    screen_row(0, 'ABC', screen)\n+    push('\\x1b[G\\x1b[?J', vt)\n+    screen_row(0, ' B', screen)\n+\n+    -- Non-selective erase\n+    reset(nil, screen)\n+    push('A\\x1b[1\"qB\\x1b[\"qC', vt)\n+    screen_row(0, 'ABC', screen)\n+    -- TODO(dundargoc): fix\n+    -- push('\\x1b[G\\x1b[J', vt)\n+    -- screen_row(0, '', screen)\n+  end)\n+\n+  itp('66screen_extent', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    -- Bold extent\n+    reset(nil, screen)\n+    push('AB\\x1b[1mCD\\x1b[mE', vt)\n+    screen_attrs_extent(0, 0, '0,0-1,1', screen)\n+    screen_attrs_extent(0, 1, '0,0-1,1', screen)\n+    screen_attrs_extent(0, 2, '0,2-1,3', screen)\n+    screen_attrs_extent(0, 3, '0,2-1,3', screen)\n+    screen_attrs_extent(0, 4, '0,4-1,79', screen)\n+  end)\n+\n+  itp('67screen_dbl_wh', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    -- Single Width, Single Height\n+    reset(nil, screen)\n+    push('\\x1b#5', vt)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Double Width, Single Height\n+    reset(nil, screen)\n+    push('\\x1b#6', vt)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} dwl fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Double Height\n+    reset(nil, screen)\n+    push('\\x1b#3', vt)\n+    push('abcde', vt)\n+    push('\\r\\n\\x1b#4', vt)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} dwl dhl-top fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(\n+      1,\n+      0,\n+      '{61} width=1 attrs={} dwl dhl-bottom fg=rgb(240,240,240) bg=rgb(0,0,0)',\n+      screen\n+    )\n+\n+    -- Late change\n+    reset(nil, screen)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    push('\\x1b#6', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} dwl fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- DWL doesn't spill over on scroll\n+    reset(nil, screen)\n+    push('\\x1b[25H\\x1b#6Final\\r\\n', vt)\n+    screen_cell(23, 0, '{46} width=1 attrs={} dwl fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(24, 0, '{} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+  end)\n+\n+  itp('68screen_termprops', function()\n+    local vt = init()\n+    local screen = wantscreen(vt, { p = true })\n+\n+    reset(nil, screen)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+\n+    -- Cursor visibility\n+    push('\\x1b[?25h', vt)\n+    expect('settermprop 1 true')\n+    push('\\x1b[?25l', vt)\n+    expect('settermprop 1 false')\n+\n+    -- Title\n+    push('\\x1b]2;Here is my title\\a', vt)\n+    expect('settermprop 4 [\"Here is my title\"]')\n+  end)\n+\n+  itp('69screen_pushline', function()\n+    local vt = init()\n+    -- Run these tests on a much smaller default screen, so debug output is nowhere near as noisy\n+    resize(5, 10, vt)\n+    local state = wantstate(vt)\n+    local screen = wantscreen(vt, { r = true })\n+    reset(state, screen)\n+\n+    -- Resize wider reflows wide lines\n+    reset(state, screen)\n+    push(string.rep('A', 12), vt)\n+    screen_row(0, 'AAAAAAAAAA', screen, vt.cols)\n+    screen_row(1, 'AA', screen, vt.cols)\n+    lineinfo(1, { cont = true }, state)\n+    cursor(1, 2, state)\n+    resize(5, 15, vt)\n+    screen_row(0, 'AAAAAAAAAAAA', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row(1, '', screen, vt.cols)\n+    lineinfo(1, {}, state)\n+    cursor(0, 12, state)\n+    resize(5, 20, vt)\n+    screen_row(0, 'AAAAAAAAAAAA', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 ,'',screen, vt.cols)\n+    lineinfo(1, {}, state)\n+    cursor(0, 12, state)\n+\n+    -- Resize narrower can create continuation lines\n+    reset(state, screen)\n+    resize(5, 10, vt)\n+    push('ABCDEFGHI', vt)\n+    screen_row(0, 'ABCDEFGHI', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen, vt.cols)\n+    lineinfo(1, {}, state)\n+    cursor(0, 9, state)\n+    resize(5, 8, vt)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 0 , \"ABCDEFGH\",screen,vt.cols)\n+    screen_row(1, 'I', screen, vt.cols)\n+    lineinfo(1, { cont = true }, state)\n+    cursor(1, 1, state)\n+    resize(5, 6, vt)\n+    screen_row(0, 'ABCDEF', screen, vt.cols)\n+    screen_row(1, 'GHI', screen, vt.cols)\n+    lineinfo(1, { cont = true }, state)\n+    cursor(1, 3, state)\n+\n+    -- Shell wrapped prompt behaviour\n+    reset(state, screen)\n+    resize(5, 10, vt)\n+    push('PROMPT GOES HERE\\r\\n> \\r\\n\\r\\nPROMPT GOES HERE\\r\\n> ', vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    screen_row(2, 'PROMPT GOE', screen, vt.cols)\n+    screen_row(3, 'S HERE', screen, vt.cols)\n+    lineinfo(3, { cont = true }, state)\n+    screen_row(4, '> ', screen, vt.cols)\n+    cursor(4, 2, state)\n+    resize(5, 11, vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    screen_row(2, 'PROMPT GOES', screen, vt.cols)\n+    screen_row(3, ' HERE', screen, vt.cols)\n+    lineinfo(3, { cont = true }, state)\n+    screen_row(4, '> ', screen, vt.cols)\n+    cursor(4, 2, state)\n+    resize(5, 12, vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    screen_row(2, 'PROMPT GOES ', screen, vt.cols)\n+    screen_row(3, 'HERE', screen, vt.cols)\n+    lineinfo(3, { cont = true }, state)\n+    screen_row(4, '> ', screen, vt.cols)\n+    cursor(4, 2, state)\n+    resize(5, 16, vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    -- screen_row( 2 , \"PROMPT GOES HERE\",screen,vt.cols)\n+    lineinfo(3, {}, state)\n+    screen_row(3, '> ', screen, vt.cols)\n+    cursor(3, 2, state)\n+\n+    -- Cursor goes missing\n+    -- For more context: https://github.com/neovim/neovim/pull/21124\n+    reset(state, screen)\n+    resize(5, 5, vt)\n+    resize(3, 1, vt)\n+    push('\\x1b[2;1Habc\\r\\n\\x1b[H', vt)\n+    resize(1, 1, vt)\n+    cursor(0, 0, state)\n+  end)\n+\n+  pending('90vttest_01-movement-1', function() end)\n+  pending('90vttest_01-movement-2', function() end)\n+\n+  itp('90vttest_01-movement-3', function()\n+    -- Test of cursor-control characters inside ESC sequences\n+    local vt = init()\n+    local state = wantstate(vt)\n+    local screen = wantscreen(vt)\n+\n+    reset(state, screen)\n+\n+    push('A B C D E F G H I', vt)\n+    push('\\x0d\\x0a', vt)\n+    push('A\\x1b[2\\bCB\\x1b[2\\bCC\\x1b[2\\bCD\\x1b[2\\bCE\\x1b[2\\bCF\\x1b[2\\bCG\\x1b[2\\bCH\\x1b[2\\bCI', vt)\n+    push('\\x0d\\x0a', vt)\n+    push(\n+      'A \\x1b[\\x0d2CB\\x1b[\\x0d4CC\\x1b[\\x0d6CD\\x1b[\\x0d8CE\\x1b[\\x0d10CF\\x1b[\\x0d12CG\\x1b[\\x0d14CH\\x1b[\\x0d16CI',\n+      vt\n+    )\n+    push('\\x0d\\x0a', vt)\n+    push(\n+      'A \\x1b[1\\x0bAB \\x1b[1\\x0bAC \\x1b[1\\x0bAD \\x1b[1\\x0bAE \\x1b[1\\x0bAF \\x1b[1\\x0bAG \\x1b[1\\x0bAH \\x1b[1\\x0bAI \\x1b[1\\x0bA',\n+      vt\n+    )\n+\n+    -- Output\n+\n+    for i = 0, 2 do\n+      screen_row(i, 'A B C D E F G H I', screen)\n+    end\n+    screen_row(3, 'A B C D E F G H I ', screen)\n+\n+    cursor(3, 18, state)\n+  end)\n+\n+  itp('90vttest_01-movement-4', function()\n+    -- Test of leading zeroes in ESC sequences\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    push('\\x1b[00000000004;000000001HT', vt)\n+    push('\\x1b[00000000004;000000002Hh', vt)\n+    push('\\x1b[00000000004;000000003Hi', vt)\n+    push('\\x1b[00000000004;000000004Hs', vt)\n+    push('\\x1b[00000000004;000000005H ', vt)\n+    push('\\x1b[00000000004;000000006Hi', vt)\n+    push('\\x1b[00000000004;000000007Hs', vt)\n+    push('\\x1b[00000000004;000000008H ', vt)\n+    push('\\x1b[00000000004;000000009Ha', vt)\n+    push('\\x1b[00000000004;0000000010H ', vt)\n+    push('\\x1b[00000000004;0000000011Hc', vt)\n+    push('\\x1b[00000000004;0000000012Ho', vt)\n+    push('\\x1b[00000000004;0000000013Hr', vt)\n+    push('\\x1b[00000000004;0000000014Hr', vt)\n+    push('\\x1b[00000000004;0000000015He', vt)\n+    push('\\x1b[00000000004;0000000016Hc', vt)\n+    push('\\x1b[00000000004;0000000017Ht', vt)\n+    push('\\x1b[00000000004;0000000018H ', vt)\n+    push('\\x1b[00000000004;0000000019Hs', vt)\n+    push('\\x1b[00000000004;0000000020He', vt)\n+    push('\\x1b[00000000004;0000000021Hn', vt)\n+    push('\\x1b[00000000004;0000000022Ht', vt)\n+    push('\\x1b[00000000004;0000000023He', vt)\n+    push('\\x1b[00000000004;0000000024Hn', vt)\n+    push('\\x1b[00000000004;0000000025Hc', vt)\n+    push('\\x1b[00000000004;0000000026He', vt)\n+\n+    -- Output\n+\n+    screen_row(3, 'This is a correct sentence', screen)\n+  end)\n+\n+  pending('90vttest_02-screen-1', function() end)\n+  pending('90vttest_02-screen-2', function() end)\n+\n+  itp('90vttest_02-screen-3', function()\n+    -- Origin mode\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[23;24r', vt)\n+    push('\\n', vt)\n+    push('Bottom', vt)\n+    push('\\x1b[1;1H', vt)\n+    push('Above', vt)\n+\n+    -- Output\n+    screen_row(22, 'Above', screen)\n+    screen_row(23, 'Bottom', screen)\n+  end)\n+\n+  itp('90vttest_02-screen-4', function()\n+    -- Origin mode (2)\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    push('\\x1b[?6l', vt)\n+    push('\\x1b[23;24r', vt)\n+    push('\\x1b[24;1H', vt)\n+    push('Bottom', vt)\n+    push('\\x1b[1;1H', vt)\n+    push('Top', vt)\n+\n+    -- Output\n+    screen_row(23, 'Bottom', screen)\n+    screen_row(0, 'Top', screen)\n+  end)\n+\n+  itp('92lp1640917', function()",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1809564001",
            "id": 1809564001,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5r28Fh",
            "original_commit_id": "eec2162be6d8484d1eaf73082e4db58763c4871b",
            "original_line": 3575,
            "original_position": 3575,
            "original_start_line": null,
            "path": "test/unit/vterm_spec.lua",
            "position": null,
            "pull_request_review_id": 2383344095,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809564001/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-21T21:28:52Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809564001",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1809567019"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809567019"
                }
            },
            "author_association": "MEMBER",
            "body": "That is the name of the original test file. Don't ask lol.",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-10-21T21:32:25Z",
            "diff_hunk": "@@ -0,0 +1,3590 @@\n+local t = require('test.unit.testutil')\n+local itp = t.gen_itp(it)\n+local bit = require('bit')\n+\n+--- @class vterm\n+--- @field ENC_UTF8 integer\n+--- @field VTERM_ATTR_BLINK integer\n+--- @field VTERM_ATTR_BOLD integer\n+--- @field VTERM_ATTR_FONT integer\n+--- @field VTERM_ATTR_ITALIC integer\n+--- @field VTERM_ATTR_REVERSE integer\n+--- @field VTERM_ATTR_UNDERLINE integer\n+--- @field VTERM_BASELINE_RAISE integer\n+--- @field VTERM_KEY_ENTER integer\n+--- @field VTERM_KEY_FUNCTION_0 integer\n+--- @field VTERM_KEY_KP_0 integer\n+--- @field VTERM_KEY_NONE integer\n+--- @field VTERM_KEY_TAB integer\n+--- @field VTERM_KEY_UP integer\n+--- @field VTERM_MAX_CHARS_PER_CELL integer\n+--- @field VTERM_MOD_ALT integer\n+--- @field VTERM_MOD_CTRL integer\n+--- @field VTERM_MOD_SHIFT integer\n+--- @field parser_apc function\n+--- @field parser_csi function\n+--- @field parser_dcs function\n+--- @field parser_osc function\n+--- @field parser_pm function\n+--- @field parser_sos function\n+--- @field parser_text function\n+--- @field print_color function\n+--- @field screen_sb_clear function\n+--- @field screen_sb_popline function\n+--- @field screen_sb_pushline function\n+--- @field selection_query function\n+--- @field selection_set function\n+--- @field state_erase function\n+--- @field state_movecursor function\n+--- @field state_moverect function\n+--- @field state_pos function\n+--- @field state_putglyph function\n+--- @field state_sb_clear function\n+--- @field state_scrollrect function\n+--- @field state_setpenattr function\n+--- @field state_settermprop function\n+--- @field term_output function\n+--- @field vterm_input_write function\n+--- @field vterm_keyboard_end_paste function\n+--- @field vterm_keyboard_key function\n+--- @field vterm_keyboard_start_paste function\n+--- @field vterm_keyboard_unichar function\n+--- @field vterm_lookup_encoding fun(any, any):any\n+--- @field vterm_mouse_button function\n+--- @field vterm_mouse_move function\n+--- @field vterm_new fun(any, any):any\n+--- @field vterm_obtain_screen fun(any):any\n+--- @field vterm_obtain_state fun(any): any\n+--- @field vterm_output_set_callback function\n+--- @field vterm_parser_set_callbacks fun(any, any, any):any\n+--- @field vterm_screen_convert_color_to_rgb function\n+--- @field vterm_screen_enable_altscreen function\n+--- @field vterm_screen_enable_reflow function\n+--- @field vterm_screen_get_attrs_extent function\n+--- @field vterm_screen_get_cell function\n+--- @field vterm_screen_get_chars fun(any, any, any, any):any\n+--- @field vterm_screen_get_text fun(any, any, any, any):any\n+--- @field vterm_screen_is_eol fun(any, any):any\n+--- @field vterm_screen_reset function\n+--- @field vterm_screen_set_callbacks function\n+--- @field vterm_set_size function\n+--- @field vterm_set_utf8 fun(any, any, any):any\n+--- @field vterm_state_focus_in function\n+--- @field vterm_state_focus_out function\n+--- @field vterm_state_get_cursorpos fun(any, any)\n+--- @field vterm_state_get_lineinfo fun(any, any):any\n+--- @field vterm_state_get_penattr function\n+--- @field vterm_state_reset function\n+--- @field vterm_state_set_bold_highbright function\n+--- @field vterm_state_set_callbacks function\n+--- @field vterm_state_set_selection_callbacks function\n+--- @field vterm_state_set_unrecognised_fallbacks function\n+local vterm = t.cimport('./src/vterm/vterm.h', './src/vterm/vterm_internal.h')\n+\n+--- @return string\n+local function read_rm()\n+  local f = assert(io.open(t.paths.vterm_test_file, 'rb'))\n+  local text = f:read('*a')\n+  f:close()\n+  vim.fs.rm(t.paths.vterm_test_file, { force = true })\n+  return text\n+end\n+\n+local function append(str)\n+  local f = assert(io.open(t.paths.vterm_test_file, 'a'))\n+  f:write(str)\n+  f:close()\n+  return 1\n+end\n+\n+local function parser_control(control)\n+  return append(string.format('control %02x\\n', control))\n+end\n+\n+local function parser_escape(bytes)\n+  return append(string.format('escape %s\\n', t.ffi.string(bytes)))\n+end\n+\n+local function wantparser(vt)\n+  assert(vt)\n+\n+  local parser_cbs = t.ffi.new('VTermParserCallbacks')\n+  parser_cbs['text'] = vterm.parser_text\n+  parser_cbs['control'] = parser_control\n+  parser_cbs['escape'] = parser_escape\n+  parser_cbs['csi'] = vterm.parser_csi\n+  parser_cbs['osc'] = vterm.parser_osc\n+  parser_cbs['dcs'] = vterm.parser_dcs\n+  parser_cbs['apc'] = vterm.parser_apc\n+  parser_cbs['pm'] = vterm.parser_pm\n+  parser_cbs['sos'] = vterm.parser_sos\n+\n+  vterm.vterm_parser_set_callbacks(vt, parser_cbs, nil)\n+end\n+\n+--- @return any\n+local function init()\n+  local vt = vterm.vterm_new(25, 80)\n+  vterm.vterm_output_set_callback(vt, vterm.term_output, nil)\n+  vterm.vterm_set_utf8(vt, true)\n+  return vt\n+end\n+\n+local function state_setlineinfo()\n+  return 1\n+end\n+\n+--- @return any\n+local function wantstate(vt, opts)\n+  opts = opts or {}\n+  assert(vt)\n+  local state = vterm.vterm_obtain_state(vt)\n+\n+  local state_cbs = t.ffi.new('VTermStateCallbacks')\n+  state_cbs['putglyph'] = vterm.state_putglyph\n+  state_cbs['movecursor'] = vterm.state_movecursor\n+  state_cbs['scrollrect'] = vterm.state_scrollrect\n+  state_cbs['moverect'] = vterm.state_moverect\n+  state_cbs['erase'] = vterm.state_erase\n+  state_cbs['setpenattr'] = vterm.state_setpenattr\n+  state_cbs['settermprop'] = vterm.state_settermprop\n+  state_cbs['setlineinfo'] = state_setlineinfo\n+  state_cbs['sb_clear'] = vterm.state_sb_clear\n+\n+  local selection_cbs = t.ffi.new('VTermSelectionCallbacks')\n+  selection_cbs['set'] = vterm.selection_set\n+  selection_cbs['query'] = vterm.selection_query\n+\n+  vterm.vterm_state_set_callbacks(state, state_cbs, nil)\n+\n+  -- In some tests we want to check the behaviour of overflowing the buffer, so make it nicely small\n+  vterm.vterm_state_set_selection_callbacks(state, selection_cbs, nil, nil, 16)\n+  vterm.vterm_state_set_bold_highbright(state, 1)\n+  vterm.vterm_state_reset(state, 1)\n+\n+  local fallbacks = t.ffi.new('VTermStateFallbacks')\n+  fallbacks['control'] = parser_control\n+  fallbacks['csi'] = vterm.parser_csi\n+  fallbacks['osc'] = vterm.parser_osc\n+  fallbacks['dcs'] = vterm.parser_dcs\n+  fallbacks['apc'] = vterm.parser_apc\n+  fallbacks['pm'] = vterm.parser_pm\n+  fallbacks['sos'] = vterm.parser_sos\n+\n+  vterm.want_state_scrollback = opts.b or false\n+  vterm.want_state_erase = opts.e or false\n+  vterm.vterm_state_set_unrecognised_fallbacks(state, opts.f and fallbacks or nil, nil)\n+  vterm.want_state_putglyph = opts.g or false\n+  vterm.want_state_moverect = opts.m or false\n+  vterm.want_state_settermprop = opts.p or false\n+  vterm.want_state_scrollrect = opts.s or false\n+\n+  return state\n+end\n+\n+--- @return any\n+local function wantscreen(vt, opts)\n+  opts = opts or {}\n+  local screen = vterm.vterm_obtain_screen(vt)\n+  local screen_cbs = t.ffi.new('VTermScreenCallbacks')\n+\n+  -- TODO(dundargoc): fix\n+  -- screen_cbs['damage']      = vterm.screen_damage\n+  screen_cbs['moverect'] = vterm.state_moverect\n+  screen_cbs['movecursor'] = vterm.state_movecursor\n+  screen_cbs['settermprop'] = vterm.state_settermprop\n+  screen_cbs['sb_pushline'] = vterm.screen_sb_pushline\n+  screen_cbs['sb_popline'] = vterm.screen_sb_popline\n+  screen_cbs['sb_clear'] = vterm.screen_sb_clear\n+\n+  vterm.vterm_screen_set_callbacks(screen, screen_cbs, nil)\n+\n+  if opts.a then\n+    vterm.vterm_screen_enable_altscreen(screen, 1)\n+  end\n+  vterm.want_screen_scrollback = opts.b or false\n+  vterm.want_state_movecursor = opts.c or false\n+  -- TODO(dundargoc): fix\n+  -- vterm.want_screen_damage = opts.d or opts.D or false\n+  -- vterm.want_screen_cells = opts.D or false\n+  vterm.want_state_moverect = opts.m or false\n+  vterm.want_state_settermprop = opts.p or false\n+  if opts.r then\n+    vterm.vterm_screen_enable_reflow(screen, true)\n+  end\n+\n+  return screen\n+end\n+\n+local function reset(state, screen)\n+  if state then\n+    vterm.vterm_state_reset(state, 1)\n+    vterm.vterm_state_get_cursorpos(state, vterm.state_pos)\n+  end\n+  if screen then\n+    vterm.vterm_screen_reset(screen, 1)\n+  end\n+end\n+\n+local function push(input, vt)\n+  vterm.vterm_input_write(vt, input, string.len(input))\n+end\n+\n+local function expect(expected)\n+  local actual = read_rm()\n+  t.eq(expected .. '\\n', actual)\n+end\n+\n+local function expect_output(expected_preformat)\n+  local actual = read_rm()\n+  local expected = 'output '\n+\n+  for c in string.gmatch(expected_preformat, '.') do\n+    if expected ~= 'output ' then\n+      expected = expected .. ','\n+    end\n+    expected = string.format('%s%x', expected, string.byte(c))\n+  end\n+\n+  t.eq(expected .. '\\n', actual)\n+end\n+\n+local function cursor(row, col, state)\n+  local pos = t.ffi.new('VTermPos') --- @type {row: integer, col: integer}\n+  vterm.vterm_state_get_cursorpos(state, pos)\n+  t.eq(row, pos.row)\n+  t.eq(col, pos.col)\n+end\n+\n+local function lineinfo(row, expected, state)\n+  local info = vterm.vterm_state_get_lineinfo(state, row)\n+  local dwl = info.doublewidth == 1\n+  local dhl = info.doubleheight == 1\n+  local cont = info.continuation == 1\n+\n+  t.eq(dwl, expected.dwl or false)\n+  t.eq(dhl, expected.dhl or false)\n+  t.eq(cont, expected.cont or false)\n+end\n+\n+local function pen(attribute, expected, state)\n+  local is_bool = { bold = true, italic = true, blink = true, reverse = true }\n+  local vterm_attribute = {\n+    bold = vterm.VTERM_ATTR_BOLD,\n+    underline = vterm.VTERM_ATTR_UNDERLINE,\n+    italic = vterm.VTERM_ATTR_ITALIC,\n+    blink = vterm.VTERM_ATTR_BLINK,\n+    reverse = vterm.VTERM_ATTR_REVERSE,\n+    font = vterm.VTERM_ATTR_FONT,\n+  }\n+\n+  local val = t.ffi.new('VTermValue') --- @type {boolean: integer}\n+  vterm.vterm_state_get_penattr(state, vterm_attribute[attribute], val)\n+  local actual = val.boolean --- @type integer|boolean\n+  if is_bool[attribute] then\n+    actual = val.boolean == 1\n+  end\n+  t.eq(expected, actual)\n+end\n+\n+local function resize(rows, cols, vt)\n+  vterm.vterm_set_size(vt, rows, cols)\n+end\n+\n+local function screen_chars(start_row, start_col, end_row, end_col, expected, screen)\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_row'] = start_row\n+  rect['start_col'] = start_col\n+  rect['end_row'] = end_row\n+  rect['end_col'] = end_col\n+\n+  local len = vterm.vterm_screen_get_chars(screen, nil, 0, rect)\n+\n+  local chars = t.ffi.new('uint32_t[?]', len)\n+  vterm.vterm_screen_get_chars(screen, chars, len, rect)\n+\n+  local actual = ''\n+  for i = 0, tonumber(len) - 1 do\n+    actual = actual .. string.char(chars[i])\n+  end\n+\n+  t.eq(expected, actual)\n+end\n+\n+local function screen_text(start_row, start_col, end_row, end_col, expected, screen)\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_row'] = start_row\n+  rect['start_col'] = start_col\n+  rect['end_row'] = end_row\n+  rect['end_col'] = end_col\n+\n+  local len = vterm.vterm_screen_get_text(screen, nil, 0, rect)\n+\n+  local text = t.ffi.new('unsigned char[?]', len)\n+  vterm.vterm_screen_get_text(screen, text, len, rect)\n+\n+  local actual = ''\n+  for i = 0, tonumber(len) - 1 do\n+    actual = string.format('%s%02x,', actual, text[i])\n+  end\n+  actual = actual:sub(1, -2)\n+\n+  t.eq(expected, actual)\n+end\n+\n+--- @param row integer\n+local function screen_row(row, expected, screen, end_col)\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_row'] = row\n+  rect['start_col'] = 0\n+  rect['end_row'] = row + 1\n+  rect['end_col'] = end_col or 80\n+\n+  local len = vterm.vterm_screen_get_text(screen, nil, 0, rect)\n+\n+  local text = t.ffi.new('unsigned char[?]', len)\n+  vterm.vterm_screen_get_text(screen, text, len, rect)\n+\n+  t.eq(expected, t.ffi.string(text))\n+end\n+\n+local function screen_cell(row, col, expected, screen)\n+  local pos = t.ffi.new('VTermPos')\n+  pos['row'] = row\n+  pos['col'] = col\n+\n+  local cell = t.ffi.new('VTermScreenCell')\n+  vterm.vterm_screen_get_cell(screen, pos, cell)\n+\n+  local actual = '{'\n+  for i = 0, vterm.VTERM_MAX_CHARS_PER_CELL - 1 do\n+    if cell['chars'][i] ~= 0 then\n+      if i > 0 then\n+        actual = actual .. ','\n+      end\n+      actual = string.format('%s%02x', actual, cell['chars'][i])\n+    end\n+  end\n+  actual = string.format('%s} width=%d attrs={', actual, cell['width'])\n+  actual = actual .. (cell['attrs'].bold ~= 0 and 'B' or '')\n+  actual = actual\n+    .. (cell['attrs'].underline ~= 0 and string.format('U%d', cell['attrs'].underline) or '')\n+  actual = actual .. (cell['attrs'].italic ~= 0 and 'I' or '')\n+  actual = actual .. (cell['attrs'].blink ~= 0 and 'K' or '')\n+  actual = actual .. (cell['attrs'].reverse ~= 0 and 'R' or '')\n+  actual = actual .. (cell['attrs'].font ~= 0 and string.format('F%d', cell['attrs'].font) or '')\n+  actual = actual .. (cell['attrs'].small ~= 0 and 'S' or '')\n+  if cell['attrs'].baseline ~= 0 then\n+    actual = actual .. (cell['attrs'].baseline == vterm.VTERM_BASELINE_RAISE and '^' or '_')\n+  end\n+  actual = actual .. '} '\n+\n+  actual = actual .. (cell['attrs'].dwl ~= 0 and 'dwl ' or '')\n+  if cell['attrs'].dhl ~= 0 then\n+    actual = actual .. string.format('dhl-%s ', cell['attrs'].dhl == 2 and 'bottom' or 'top')\n+  end\n+\n+  actual = string.format('%sfg=', actual)\n+  vterm.vterm_screen_convert_color_to_rgb(screen, cell['fg'])\n+  vterm.print_color(cell['fg'])\n+\n+  actual = actual .. read_rm()\n+  actual = actual .. ' bg='\n+\n+  vterm.vterm_screen_convert_color_to_rgb(screen, cell['bg'])\n+  vterm.print_color(cell['bg'])\n+\n+  actual = actual .. read_rm()\n+\n+  t.eq(expected, actual)\n+end\n+\n+local function screen_eol(row, col, expected, screen)\n+  local pos = t.ffi.new('VTermPos')\n+  pos['row'] = row\n+  pos['col'] = col\n+\n+  local is_eol = vterm.vterm_screen_is_eol(screen, pos)\n+  t.eq(expected, is_eol)\n+end\n+\n+local function screen_attrs_extent(row, col, expected, screen)\n+  local pos = t.ffi.new('VTermPos')\n+  pos['row'] = row\n+  pos['col'] = col\n+\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_col'] = 0\n+  rect['end_col'] = -1\n+  vterm.vterm_screen_get_attrs_extent(screen, rect, pos, 1)\n+\n+  local actual = string.format(\n+    '%d,%d-%d,%d',\n+    rect['start_row'],\n+    rect['start_col'],\n+    rect['end_row'],\n+    rect['end_col']\n+  )\n+\n+  t.eq(expected, actual)\n+end\n+\n+local function wantencoding()\n+  local encoding = t.ffi.new('VTermEncodingInstance')\n+  encoding['enc'] = vterm.vterm_lookup_encoding(vterm.ENC_UTF8, string.byte('u'))\n+  if encoding.enc.init then\n+    encoding.enc.init(encoding.enc, encoding['data'])\n+  end\n+  return encoding\n+end\n+\n+local function encin(input, encoding)\n+  local len = string.len(input)\n+\n+  local cp = t.ffi.new('uint32_t[?]', len)\n+  local cpi = t.ffi.new('int[1]')\n+  local pos = t.ffi.new('size_t[1]', 0)\n+\n+  encoding.enc.decode(encoding.enc, encoding.data, cp, cpi, len, input, pos, len)\n+\n+  local f = assert(io.open(t.paths.vterm_test_file, 'w'))\n+  if tonumber(cpi[0]) > 0 then\n+    f:write('encout ')\n+    for i = 0, cpi[0] - 1 do\n+      if i == 0 then\n+        f:write(string.format('%x', cp[i]))\n+      else\n+        f:write(string.format(',%x', cp[i]))\n+      end\n+    end\n+    f:write('\\n')\n+  end\n+  f:close()\n+end\n+\n+local function strpe_modifiers(input_mod)\n+  local mod = t.ffi.new('VTermModifier') ---@type any\n+  if input_mod.C then\n+    mod = bit.bor(mod, vterm.VTERM_MOD_CTRL)\n+  end\n+  if input_mod.S then\n+    mod = bit.bor(mod, vterm.VTERM_MOD_SHIFT)\n+  end\n+  if input_mod.A then\n+    mod = bit.bor(mod, vterm.VTERM_MOD_ALT)\n+  end\n+  return mod\n+end\n+\n+local function strp_key(input_key)\n+  if input_key == 'up' then\n+    return vterm.VTERM_KEY_UP\n+  end\n+\n+  if input_key == 'tab' then\n+    return vterm.VTERM_KEY_TAB\n+  end\n+\n+  if input_key == 'enter' then\n+    return vterm.VTERM_KEY_ENTER\n+  end\n+\n+  if input_key == 'f1' then\n+    return vterm.VTERM_KEY_FUNCTION_0 + 1\n+  end\n+\n+  if input_key == 'kp0' then\n+    return vterm.VTERM_KEY_KP_0\n+  end\n+\n+  return vterm.VTERM_KEY_NONE\n+end\n+\n+local function mousemove(row, col, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  vterm.vterm_mouse_move(vt, row, col, mod)\n+end\n+\n+local function mousebtn(press, button, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  local flag = press == 'd' or press == 'D'\n+  vterm.vterm_mouse_button(vt, button, flag, mod)\n+end\n+\n+local function inchar(c, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  vterm.vterm_keyboard_unichar(vt, c, mod)\n+end\n+\n+local function inkey(input_key, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  local key = strp_key(input_key)\n+  vterm.vterm_keyboard_key(vt, key, mod)\n+end\n+\n+before_each(function()\n+  vim.fs.rm(t.paths.vterm_test_file, { force = true })\n+end)\n+\n+describe('vterm', function()\n+  itp('02parser', function()\n+    local vt = init()\n+    vterm.vterm_set_utf8(vt, false)\n+    wantparser(vt)\n+\n+    -- Basic text\n+    push('hello', vt)\n+    expect('text 68,65,6c,6c,6f')\n+\n+    -- C0\n+    push('\\x03', vt)\n+    expect('control 03')\n+    push('\\x1f', vt)\n+    expect('control 1f')\n+\n+    -- C1 8bit\n+    push('\\x83', vt)\n+    expect('control 83')\n+    push('\\x99', vt)\n+    expect('control 99')\n+\n+    -- C1 7bit\n+    push('\\x1b\\x43', vt)\n+    expect('control 83')\n+    push('\\x1b\\x59', vt)\n+    expect('control 99')\n+\n+    -- High bytes\n+    push('\\xa0\\xcc\\xfe', vt)\n+    expect('text a0,cc,fe')\n+\n+    -- Mixed\n+    push('1\\n2', vt)\n+    expect('text 31\\ncontrol 0a\\ntext 32')\n+\n+    -- Escape\n+    push('\\x1b=', vt)\n+    expect('escape =')\n+\n+    -- Escape 2-byte\n+    push('\\x1b(X', vt)\n+    expect('escape (X')\n+\n+    -- Split write Escape\n+    push('\\x1b(', vt)\n+    push('Y', vt)\n+    expect('escape (Y')\n+\n+    -- Escape cancels Escape, starts another\n+    push('\\x1b(\\x1b)Z', vt)\n+    expect('escape )Z')\n+\n+    -- CAN cancels Escape, returns to normal mode\n+    push('\\x1b(\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in Escape interrupts and continues\n+    push('\\x1b(\\nX', vt)\n+    expect('control 0a\\nescape (X')\n+\n+    -- CSI 0 args\n+    push('\\x1b[a', vt)\n+    expect('csi 61 *')\n+\n+    -- CSI 1 arg\n+    push('\\x1b[9b', vt)\n+    expect('csi 62 9')\n+\n+    -- CSI 2 args\n+    push('\\x1b[3;4c', vt)\n+    expect('csi 63 3,4')\n+\n+    -- CSI 1 arg 1 sub\n+    push('\\x1b[1:2c', vt)\n+    expect('csi 63 1+,2')\n+\n+    -- CSI many digits\n+    push('\\x1b[678d', vt)\n+    expect('csi 64 678')\n+\n+    -- CSI leading zero\n+    push('\\x1b[007e', vt)\n+    expect('csi 65 7')\n+\n+    -- CSI qmark\n+    push('\\x1b[?2;7f', vt)\n+    expect('csi 66 L=3f 2,7')\n+\n+    -- CSI greater\n+    push('\\x1b[>c', vt)\n+    expect('csi 63 L=3e *')\n+\n+    -- CSI SP\n+    push('\\x1b[12 q', vt)\n+    expect('csi 71 12 I=20')\n+\n+    -- Mixed CSI\n+    push('A\\x1b[8mB', vt)\n+    expect('text 41\\ncsi 6d 8\\ntext 42')\n+\n+    -- Split write\n+    push('\\x1b', vt)\n+    push('[a', vt)\n+    expect('csi 61 *')\n+    push('foo\\x1b[', vt)\n+    expect('text 66,6f,6f')\n+    push('4b', vt)\n+    expect('csi 62 4')\n+    push('\\x1b[12;', vt)\n+    push('3c', vt)\n+    expect('csi 63 12,3')\n+\n+    -- Escape cancels CSI, starts Escape\n+    push('\\x1b[123\\x1b9', vt)\n+    expect('escape 9')\n+\n+    -- CAN cancels CSI, returns to normal mode\n+    push('\\x1b[12\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in Escape interrupts and continues\n+    push('\\x1b(\\nX', vt)\n+    expect('control 0a\\nescape (X')\n+\n+    -- OSC BEL\n+    push('\\x1b]1;Hello\\x07', vt)\n+    expect('osc [1;Hello]')\n+\n+    -- OSC ST (7bit)\n+    push('\\x1b]1;Hello\\x1b\\\\', vt)\n+    expect('osc [1;Hello]')\n+\n+    -- OSC ST (8bit)\n+    push('\\x9d1;Hello\\x9c', vt)\n+    expect('osc [1;Hello]')\n+\n+    -- OSC in parts\n+    push('\\x1b]52;abc', vt)\n+    expect('osc [52;abc')\n+    push('def', vt)\n+    expect('osc def')\n+    push('ghi\\x1b\\\\', vt)\n+    expect('osc ghi]')\n+\n+    -- OSC BEL without semicolon\n+    push('\\x1b]1234\\x07', vt)\n+    expect('osc [1234;]')\n+\n+    -- OSC ST without semicolon\n+    push('\\x1b]1234\\x1b\\\\', vt)\n+    expect('osc [1234;]')\n+\n+    -- Escape cancels OSC, starts Escape\n+    push('\\x1b]Something\\x1b9', vt)\n+    expect('escape 9')\n+\n+    -- CAN cancels OSC, returns to normal mode\n+    push('\\x1b]12\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in OSC interrupts and continues\n+    push('\\x1b]2;\\nBye\\x07', vt)\n+    expect('osc [2;\\ncontrol 0a\\nosc Bye]')\n+\n+    -- DCS BEL\n+    push('\\x1bPHello\\x07', vt)\n+    expect('dcs [Hello]')\n+\n+    -- DCS ST (7bit)\n+    push('\\x1bPHello\\x1b\\\\', vt)\n+    expect('dcs [Hello]')\n+\n+    -- DCS ST (8bit)\n+    push('\\x90Hello\\x9c', vt)\n+    expect('dcs [Hello]')\n+\n+    -- Split write of 7bit ST\n+    push('\\x1bPABC\\x1b', vt)\n+    expect('dcs [ABC')\n+    push('\\\\', vt)\n+    expect('dcs ]')\n+\n+    -- Escape cancels DCS, starts Escape\n+    push('\\x1bPSomething\\x1b9', vt)\n+    expect('escape 9')\n+\n+    -- CAN cancels DCS, returns to normal mode\n+    push('\\x1bP12\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in OSC interrupts and continues\n+    push('\\x1bPBy\\ne\\x07', vt)\n+    expect('dcs [By\\ncontrol 0a\\ndcs e]')\n+\n+    -- APC BEL\n+    push('\\x1b_Hello\\x07', vt)\n+    expect('apc [Hello]')\n+\n+    -- APC ST (7bit)\n+    push('\\x1b_Hello\\x1b\\\\', vt)\n+    expect('apc [Hello]')\n+\n+    -- APC ST (8bit)\n+    push('\\x9fHello\\x9c', vt)\n+    expect('apc [Hello]')\n+\n+    -- PM BEL\n+    push('\\x1b^Hello\\x07', vt)\n+    expect('pm [Hello]')\n+\n+    -- PM ST (7bit)\n+    push('\\x1b^Hello\\x1b\\\\', vt)\n+    expect('pm [Hello]')\n+\n+    -- PM ST (8bit)\n+    push('\\x9eHello\\x9c', vt)\n+    expect('pm [Hello]')\n+\n+    -- SOS BEL\n+    push('\\x1bXHello\\x07', vt)\n+    expect('sos [Hello]')\n+\n+    -- SOS ST (7bit)\n+    push('\\x1bXHello\\x1b\\\\', vt)\n+    expect('sos [Hello]')\n+\n+    -- SOS ST (8bit)\n+    push('\\x98Hello\\x9c', vt)\n+    expect('sos [Hello]')\n+\n+    push('\\x1bXABC\\x01DEF\\x1b\\\\', vt)\n+    expect('sos [ABC\\x01DEF]')\n+    push('\\x1bXABC\\x99DEF\\x1b\\\\', vt)\n+    expect('sos [ABC\\x99DEF]')\n+\n+    -- NUL ignored\n+    push('\\x00', vt)\n+\n+    -- NUL ignored within CSI\n+    push('\\x1b[12\\x003m', vt)\n+    expect('csi 6d 123')\n+\n+    -- DEL ignored\n+    push('\\x7f', vt)\n+\n+    -- DEL ignored within CSI\n+    push('\\x1b[12\\x7f3m', vt)\n+    expect('csi 6d 123')\n+\n+    -- DEL inside text\"\n+    push('AB\\x7fC', vt)\n+    expect('text 41,42\\ntext 43')\n+  end)\n+\n+  itp('03encoding_utf8', function()\n+    local encoding = wantencoding()\n+\n+    -- Low\n+    encin('123', encoding)\n+    expect('encout 31,32,33')\n+\n+    -- We want to prove the UTF-8 parser correctly handles all the sequences.\n+    -- Easy way to do this is to check it does low/high boundary cases, as that\n+    -- leaves only two for each sequence length\n+    --\n+    -- These ranges are therefore:\n+    --\n+    -- Two bytes:\n+    -- U+0080 = 000 10000000 =>    00010   000000\n+    --                       => 11000010 10000000 = C2 80\n+    -- U+07FF = 111 11111111 =>    11111   111111\n+    --                       => 11011111 10111111 = DF BF\n+    --\n+    -- Three bytes:\n+    -- U+0800 = 00001000 00000000 =>     0000   100000   000000\n+    --                            => 11100000 10100000 10000000 = E0 A0 80\n+    -- U+FFFD = 11111111 11111101 =>     1111   111111   111101\n+    --                            => 11101111 10111111 10111101 = EF BF BD\n+    -- (We avoid U+FFFE and U+FFFF as they're invalid codepoints)\n+    --\n+    -- Four bytes:\n+    -- U+10000  = 00001 00000000 00000000 =>      000   010000   000000   000000\n+    --                                    => 11110000 10010000 10000000 10000000 = F0 90 80 80\n+    -- U+1FFFFF = 11111 11111111 11111111 =>      111   111111   111111   111111\n+    --                                    => 11110111 10111111 10111111 10111111 = F7 BF BF BF\n+\n+    -- 2 byte\n+    encin('\\xC2\\x80\\xDF\\xBF', encoding)\n+    expect('encout 80,7ff')\n+\n+    -- 3 byte\n+    encin('\\xE0\\xA0\\x80\\xEF\\xBF\\xBD', encoding)\n+    expect('encout 800,fffd')\n+\n+    -- 4 byte\n+    encin('\\xF0\\x90\\x80\\x80\\xF7\\xBF\\xBF\\xBF', encoding)\n+    expect('encout 10000,1fffff')\n+\n+    -- Next up, we check some invalid sequences\n+    --  + Early termination (back to low bytes too soon)\n+    --  + Early restart (another sequence introduction before the previous one was finished)\n+\n+    -- Early termination\n+    encin('\\xC2!', encoding)\n+    expect('encout fffd,21')\n+\n+    encin('\\xE0!\\xE0\\xA0!', encoding)\n+    expect('encout fffd,21,fffd,21')\n+\n+    encin('\\xF0!\\xF0\\x90!\\xF0\\x90\\x80!', encoding)\n+    expect('encout fffd,21,fffd,21,fffd,21')\n+\n+    -- Early restart\n+    encin('\\xC2\\xC2\\x90', encoding)\n+    expect('encout fffd,90')\n+\n+    encin('\\xE0\\xC2\\x90\\xE0\\xA0\\xC2\\x90', encoding)\n+    expect('encout fffd,90,fffd,90')\n+\n+    encin('\\xF0\\xC2\\x90\\xF0\\x90\\xC2\\x90\\xF0\\x90\\x80\\xC2\\x90', encoding)\n+    expect('encout fffd,90,fffd,90,fffd,90')\n+\n+    -- Test the overlong sequences by giving an overlong encoding of U+0000 and\n+    -- an encoding of the highest codepoint still too short\n+    --\n+    -- Two bytes:\n+    -- U+0000 = C0 80\n+    -- U+007F = 000 01111111 =>    00001   111111 =>\n+    --                       => 11000001 10111111 => C1 BF\n+    --\n+    -- Three bytes:\n+    -- U+0000 = E0 80 80\n+    -- U+07FF = 00000111 11111111 =>     0000   011111   111111\n+    --                            => 11100000 10011111 10111111 = E0 9F BF\n+    --\n+    -- Four bytes:\n+    -- U+0000 = F0 80 80 80\n+    -- U+FFFF = 11111111 11111111 =>      000   001111   111111   111111\n+    --                            => 11110000 10001111 10111111 10111111 = F0 8F BF BF\n+\n+    -- Overlong\n+    encin('\\xC0\\x80\\xC1\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    encin('\\xE0\\x80\\x80\\xE0\\x9F\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    encin('\\xF0\\x80\\x80\\x80\\xF0\\x8F\\xBF\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    -- UTF-16 surrogates U+D800 and U+DFFF\n+    -- UTF-16 Surrogates\n+    encin('\\xED\\xA0\\x80\\xED\\xBF\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    -- Split write\n+    encin('\\xC2', encoding)\n+    encin('\\xA0', encoding)\n+    expect('encout a0')\n+\n+    encin('\\xE0', encoding)\n+    encin('\\xA0\\x80', encoding)\n+    expect('encout 800')\n+    encin('\\xE0\\xA0', encoding)\n+    encin('\\x80', encoding)\n+    expect('encout 800')\n+\n+    encin('\\xF0', encoding)\n+    encin('\\x90\\x80\\x80', encoding)\n+    expect('encout 10000')\n+    encin('\\xF0\\x90', encoding)\n+    encin('\\x80\\x80', encoding)\n+    expect('encout 10000')\n+    encin('\\xF0\\x90\\x80', encoding)\n+    encin('\\x80', encoding)\n+    expect('encout 10000')\n+  end)\n+\n+  itp('10state_putglyph', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Low\n+    reset(state, nil)\n+    push('ABC', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 43 1 0,2')\n+\n+    -- UTF-8 1 char\n+    -- U+00C1 = 0xC3 0x81  name: LATIN CAPITAL LETTER A WITH ACUTE\n+    -- U+00E9 = 0xC3 0xA9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(state, nil)\n+    push('\\xC3\\x81\\xC3\\xA9', vt)\n+    expect('putglyph c1 1 0,0\\nputglyph e9 1 0,1')\n+\n+    -- UTF-8 split writes\n+    reset(state, nil)\n+    push('\\xC3', vt)\n+    push('\\x81', vt)\n+    expect('putglyph c1 1 0,0')\n+\n+    -- UTF-8 wide char\n+    -- U+FF10 = EF BC 90  name: FULLWIDTH DIGIT ZERO\n+    reset(state, nil)\n+    push('\\xEF\\xBC\\x90 ', vt)\n+    expect('putglyph ff10 2 0,0\\nputglyph 20 1 0,2')\n+\n+    -- UTF-8 emoji wide char\n+    -- U+1F600 = F0 9F 98 80  name: GRINNING FACE\n+    reset(state, nil)\n+    push('\\xF0\\x9F\\x98\\x80 ', vt)\n+    expect('putglyph 1f600 2 0,0\\nputglyph 20 1 0,2')\n+\n+    -- UTF-8 combining chars\n+    -- U+0301 = CC 81  name: COMBINING ACUTE\n+    reset(state, nil)\n+    push('e\\xCC\\x81Z', vt)\n+    expect('putglyph 65,301 1 0,0\\nputglyph 5a 1 0,1')\n+\n+    -- Combining across buffers\n+    reset(state, nil)\n+    push('e', vt)\n+    expect('putglyph 65 1 0,0')\n+    push('\\xCC\\x81Z', vt)\n+    expect('putglyph 65,301 1 0,0\\nputglyph 5a 1 0,1')\n+\n+    -- Spare combining chars get truncated\n+    reset(state, nil)\n+    push('e' .. string.rep('\\xCC\\x81', 10), vt)\n+    expect('putglyph 65,301,301,301,301,301 1 0,0') -- and nothing more\n+\n+    reset(state, nil)\n+    push('e', vt)\n+    expect('putglyph 65 1 0,0')\n+    push('\\xCC\\x81', vt)\n+    expect('putglyph 65,301 1 0,0')\n+    push('\\xCC\\x82', vt)\n+    expect('putglyph 65,301,302 1 0,0')\n+\n+    -- DECSCA protected\n+    reset(state, nil)\n+    push('A\\x1b[1\"qB\\x1b[2\"qC', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 42 1 0,1 prot\\nputglyph 43 1 0,2')\n+  end)\n+\n+  itp('11state_movecursor', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Implicit\n+    push('ABC', vt)\n+    cursor(0, 3, state)\n+\n+    -- Backspace\n+    push('\\b', vt)\n+    cursor(0, 2, state)\n+    -- Horizontal Tab\n+    push('\\t', vt)\n+    cursor(0, 8, state)\n+    -- Carriage Return\n+    push('\\r', vt)\n+    cursor(0, 0, state)\n+    -- Linefeed\n+    push('\\n', vt)\n+    cursor(1, 0, state)\n+\n+    -- Backspace bounded by lefthand edge\n+    push('\\x1b[4;2H', vt)\n+    cursor(3, 1, state)\n+    push('\\b', vt)\n+    cursor(3, 0, state)\n+    push('\\b', vt)\n+    cursor(3, 0, state)\n+\n+    -- Backspace cancels phantom\n+    push('\\x1b[4;80H', vt)\n+    cursor(3, 79, state)\n+    push('X', vt)\n+    cursor(3, 79, state)\n+    push('\\b', vt)\n+    cursor(3, 78, state)\n+\n+    -- HT bounded by righthand edge\n+    push('\\x1b[1;78H', vt)\n+    cursor(0, 77, state)\n+    push('\\t', vt)\n+    cursor(0, 79, state)\n+    push('\\t', vt)\n+    cursor(0, 79, state)\n+\n+    reset(state, nil)\n+\n+    -- Index\n+    push('ABC\\x1bD', vt)\n+    cursor(1, 3, state)\n+    -- Reverse Index\n+    push('\\x1bM', vt)\n+    cursor(0, 3, state)\n+    -- Newline\n+    push('\\x1bE', vt)\n+    cursor(1, 0, state)\n+\n+    reset(state, nil)\n+\n+    -- Cursor Forward\n+    push('\\x1b[B', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[3B', vt)\n+    cursor(4, 0, state)\n+    push('\\x1b[0B', vt)\n+    cursor(5, 0, state)\n+\n+    -- Cursor Down\n+    push('\\x1b[C', vt)\n+    cursor(5, 1, state)\n+    push('\\x1b[3C', vt)\n+    cursor(5, 4, state)\n+    push('\\x1b[0C', vt)\n+    cursor(5, 5, state)\n+\n+    -- Cursor Up\n+    push('\\x1b[A', vt)\n+    cursor(4, 5, state)\n+    push('\\x1b[3A', vt)\n+    cursor(1, 5, state)\n+    push('\\x1b[0A', vt)\n+    cursor(0, 5, state)\n+\n+    -- Cursor Backward\n+    push('\\x1b[D', vt)\n+    cursor(0, 4, state)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[0D', vt)\n+    cursor(0, 0, state)\n+\n+    -- Cursor Next Line\n+    push('   ', vt)\n+    cursor(0, 3, state)\n+    push('\\x1b[E', vt)\n+    cursor(1, 0, state)\n+    push('   ', vt)\n+    cursor(1, 3, state)\n+    push('\\x1b[2E', vt)\n+    cursor(3, 0, state)\n+    push('\\x1b[0E', vt)\n+    cursor(4, 0, state)\n+\n+    -- Cursor Previous Line\n+    push('   ', vt)\n+    cursor(4, 3, state)\n+    push('\\x1b[F', vt)\n+    cursor(3, 0, state)\n+    push('   ', vt)\n+    cursor(3, 3, state)\n+    push('\\x1b[2F', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[0F', vt)\n+    cursor(0, 0, state)\n+\n+    -- Cursor Horizonal Absolute\n+    push('\\n', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[20G', vt)\n+    cursor(1, 19, state)\n+    push('\\x1b[G', vt)\n+    cursor(1, 0, state)\n+\n+    -- Cursor Position\n+    push('\\x1b[10;5H', vt)\n+    cursor(9, 4, state)\n+    push('\\x1b[8H', vt)\n+    cursor(7, 0, state)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+\n+    -- Cursor Position cancels phantom\n+    push('\\x1b[10;78H', vt)\n+    cursor(9, 77, state)\n+    push('ABC', vt)\n+    cursor(9, 79, state)\n+    push('\\x1b[10;80H', vt)\n+    push('C', vt)\n+    cursor(9, 79, state)\n+    push('X', vt)\n+    cursor(10, 1, state)\n+\n+    reset(state, nil)\n+\n+    -- Bounds Checking\n+    push('\\x1b[A', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[D', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[25;80H', vt)\n+    cursor(24, 79, state)\n+    push('\\x1b[B', vt)\n+    cursor(24, 79, state)\n+    push('\\x1b[C', vt)\n+    cursor(24, 79, state)\n+    push('\\x1b[E', vt)\n+    cursor(24, 0, state)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[F', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[999G', vt)\n+    cursor(0, 79, state)\n+    push('\\x1b[99;99H', vt)\n+    cursor(24, 79, state)\n+\n+    reset(state, nil)\n+\n+    -- Horizontal Position Absolute\n+    push('\\x1b[5`', vt)\n+    cursor(0, 4, state)\n+\n+    -- Horizontal Position Relative\n+    push('\\x1b[3a', vt)\n+    cursor(0, 7, state)\n+\n+    -- Horizontal Position Backward\n+    push('\\x1b[3j', vt)\n+    cursor(0, 4, state)\n+\n+    -- Horizontal and Vertical Position\n+    push('\\x1b[3;3f', vt)\n+    cursor(2, 2, state)\n+\n+    -- Vertical Position Absolute\n+    push('\\x1b[5d', vt)\n+    cursor(4, 2, state)\n+\n+    -- Vertical Position Relative\n+    push('\\x1b[2e', vt)\n+    cursor(6, 2, state)\n+\n+    -- Vertical Position Backward\n+    push('\\x1b[2k', vt)\n+    cursor(4, 2, state)\n+\n+    reset(state, nil)\n+\n+    -- Horizontal Tab\n+    push('\\t', vt)\n+    cursor(0, 8, state)\n+    push('   ', vt)\n+    cursor(0, 11, state)\n+    push('\\t', vt)\n+    cursor(0, 16, state)\n+    push('       ', vt)\n+    cursor(0, 23, state)\n+    push('\\t', vt)\n+    cursor(0, 24, state)\n+    push('        ', vt)\n+    cursor(0, 32, state)\n+    push('\\t', vt)\n+    cursor(0, 40, state)\n+\n+    -- Cursor Horizontal Tab\n+    push('\\x1b[I', vt)\n+    cursor(0, 48, state)\n+    push('\\x1b[2I', vt)\n+    cursor(0, 64, state)\n+\n+    -- Cursor Backward Tab\n+    push('\\x1b[Z', vt)\n+    cursor(0, 56, state)\n+    push('\\x1b[2Z', vt)\n+    cursor(0, 40, state)\n+  end)\n+\n+  itp('12state_scroll', function()\n+    local vt = init()\n+    local state = wantstate(vt, { s = true })\n+\n+    -- Linefeed\n+    push(string.rep('\\n', 24), vt)\n+    cursor(24, 0, state)\n+    push('\\n', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+    cursor(24, 0, state)\n+\n+    reset(state, nil)\n+\n+    -- Index\n+    push('\\x1b[25H', vt)\n+    push('\\x1bD', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+\n+    reset(state, nil)\n+\n+    -- Reverse Index\n+    push('\\x1bM', vt)\n+    expect('scrollrect 0..25,0..80 => -1,+0')\n+\n+    reset(state, nil)\n+\n+    -- Linefeed in DECSTBM\n+    push('\\x1b[1;10r', vt)\n+    cursor(0, 0, state)\n+    push(string.rep('\\n', 9), vt)\n+    cursor(9, 0, state)\n+    push('\\n', vt)\n+    expect('scrollrect 0..10,0..80 => +1,+0')\n+    cursor(9, 0, state)\n+\n+    -- Linefeed outside DECSTBM\n+    push('\\x1b[20H', vt)\n+    cursor(19, 0, state)\n+    push('\\n', vt)\n+    cursor(20, 0, state)\n+\n+    -- Index in DECSTBM\n+    push('\\x1b[9;10r', vt)\n+    push('\\x1b[10H', vt)\n+    push('\\x1bM', vt)\n+    cursor(8, 0, state)\n+    push('\\x1bM', vt)\n+    expect('scrollrect 8..10,0..80 => -1,+0')\n+\n+    -- Reverse Index in DECSTBM\n+    push('\\x1b[25H', vt)\n+    cursor(24, 0, state)\n+    push('\\n', vt)\n+    -- no scrollrect\n+    cursor(24, 0, state)\n+\n+    -- Linefeed in DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[3;10r\\x1b[10;40s', vt)\n+    push('\\x1b[10;10H\\n', vt)\n+    expect('scrollrect 2..10,9..40 => +1,+0')\n+\n+    -- IND/RI in DECSTBM+DECSLRM\n+    push('\\x1bD', vt)\n+    expect('scrollrect 2..10,9..40 => +1,+0')\n+    push('\\x1b[3;10H\\x1bM', vt)\n+    expect('scrollrect 2..10,9..40 => -1,+0')\n+\n+    -- DECRQSS on DECSTBM\n+    push('\\x1bP$qr\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r3;10r\\x1b\\\\')\n+\n+    -- DECRQSS on DECSLRM\n+    push('\\x1bP$qs\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r10;40s\\x1b\\\\')\n+\n+    -- Setting invalid DECSLRM with !DECVSSM is still rejected\n+    push('\\x1b[?69l\\x1b[;0s\\x1b[?69h', vt)\n+\n+    reset(state, nil)\n+\n+    -- Scroll Down\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[2S', vt)\n+    expect('scrollrect 0..25,0..80 => +2,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[100S', vt)\n+    expect('scrollrect 0..25,0..80 => +25,+0')\n+\n+    -- Scroll Up\n+    push('\\x1b[T', vt)\n+    expect('scrollrect 0..25,0..80 => -1,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[2T', vt)\n+    expect('scrollrect 0..25,0..80 => -2,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[100T', vt)\n+    expect('scrollrect 0..25,0..80 => -25,+0')\n+\n+    -- SD/SU in DECSTBM\n+    push('\\x1b[5;20r', vt)\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 4..20,0..80 => +1,+0')\n+    push('\\x1b[T', vt)\n+    expect('scrollrect 4..20,0..80 => -1,+0')\n+\n+    reset(state, nil)\n+\n+    -- SD/SU in DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[3;10r\\x1b[10;40s', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[3;10H', vt)\n+    cursor(2, 9, state)\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 2..10,9..40 => +1,+0')\n+    push('\\x1b[?69l', vt)\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 2..10,0..80 => +1,+0')\n+\n+    -- Invalid boundaries\n+    reset(state, nil)\n+\n+    push('\\x1b[100;105r\\x1bD', vt)\n+    push('\\x1b[5;2r\\x1bD', vt)\n+\n+    reset(state, nil)\n+    state = wantstate(vt, { m = true, e = true })\n+\n+    -- Scroll Down move+erase emulation\n+    push('\\x1b[S', vt)\n+    expect('moverect 1..25,0..80 -> 0..24,0..80\\nerase 24..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2S', vt)\n+    expect('moverect 2..25,0..80 -> 0..23,0..80\\nerase 23..25,0..80')\n+    cursor(0, 0, state)\n+\n+    -- Scroll Up move+erase emulation\n+    push('\\x1b[T', vt)\n+    expect('moverect 0..24,0..80 -> 1..25,0..80\\nerase 0..1,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2T', vt)\n+    expect('moverect 0..23,0..80 -> 2..25,0..80\\nerase 0..2,0..80')\n+    cursor(0, 0, state)\n+\n+    -- DECSTBM resets cursor position\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b[r', vt)\n+    cursor(0, 0, state)\n+  end)\n+\n+  itp('13state_edit', function()\n+    local vt = init()\n+    local state = wantstate(vt, { s = true, e = true, b = true })\n+\n+    -- ICH\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ACD', vt)\n+    push('\\x1b[2D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[@', vt)\n+    expect('scrollrect 0..1,1..80 => +0,-1')\n+    cursor(0, 1, state)\n+    push('B', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[3@', vt)\n+    expect('scrollrect 0..1,2..80 => +0,-3')\n+\n+    -- ICH with DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[;50s', vt)\n+    push('\\x1b[20G\\x1b[@', vt)\n+    expect('scrollrect 0..1,19..50 => +0,-1')\n+\n+    -- ICH outside DECSLRM\n+    push('\\x1b[70G\\x1b[@', vt)\n+    -- nothing happens\n+\n+    -- DCH\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABBC', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[P', vt)\n+    expect('scrollrect 0..1,1..80 => +0,+1')\n+    cursor(0, 1, state)\n+    push('\\x1b[3P', vt)\n+    expect('scrollrect 0..1,1..80 => +0,+3')\n+    cursor(0, 1, state)\n+\n+    -- DCH with DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[;50s', vt)\n+    push('\\x1b[20G\\x1b[P', vt)\n+    expect('scrollrect 0..1,19..50 => +0,+1')\n+\n+    -- DCH outside DECSLRM\n+    push('\\x1b[70G\\x1b[P', vt)\n+    -- nothing happens\n+\n+    -- ECH\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABC', vt)\n+    push('\\x1b[2D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[X', vt)\n+    expect('erase 0..1,1..2')\n+    cursor(0, 1, state)\n+    push('\\x1b[3X', vt)\n+    expect('erase 0..1,1..4')\n+    cursor(0, 1, state)\n+    -- ECH more columns than there are should be bounded\n+    push('\\x1b[100X', vt)\n+    expect('erase 0..1,1..80')\n+\n+    -- IL\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('A\\r\\nC', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[L', vt)\n+    expect('scrollrect 1..25,0..80 => -1,+0')\n+    -- TODO(libvterm): ECMA-48 says we should move to line home, but neither xterm nor xfce4-terminal do this\n+    cursor(1, 1, state)\n+    push('\\rB', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[3L', vt)\n+    expect('scrollrect 1..25,0..80 => -3,+0')\n+\n+    -- IL with DECSTBM\n+    push('\\x1b[5;15r', vt)\n+    push('\\x1b[5H\\x1b[L', vt)\n+    expect('scrollrect 4..15,0..80 => -1,+0')\n+\n+    -- IL outside DECSTBM\n+    push('\\x1b[20H\\x1b[L', vt)\n+    -- nothing happens\n+\n+    -- IL with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[10;50s', vt)\n+    push('\\x1b[5;10H\\x1b[L', vt)\n+    expect('scrollrect 4..15,9..50 => -1,+0')\n+\n+    -- DL\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('A\\r\\nB\\r\\nB\\r\\nC', vt)\n+    cursor(3, 1, state)\n+    push('\\x1b[2H', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[M', vt)\n+    expect('scrollrect 1..25,0..80 => +1,+0')\n+    cursor(1, 0, state)\n+    push('\\x1b[3M', vt)\n+    expect('scrollrect 1..25,0..80 => +3,+0')\n+    cursor(1, 0, state)\n+\n+    -- DL with DECSTBM\n+    push('\\x1b[5;15r', vt)\n+    push('\\x1b[5H\\x1b[M', vt)\n+    expect('scrollrect 4..15,0..80 => +1,+0')\n+\n+    -- DL outside DECSTBM\n+    push('\\x1b[20H\\x1b[M', vt)\n+    -- nothing happens\n+\n+    -- DL with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[10;50s', vt)\n+    push('\\x1b[5;10H\\x1b[M', vt)\n+    expect('scrollrect 4..15,9..50 => +1,+0')\n+\n+    -- DECIC\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    push(\"\\x1b[20G\\x1b[5'}\", vt)\n+    expect('scrollrect 0..25,19..80 => +0,-5')\n+\n+    -- DECIC with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[4;20r\\x1b[20;60s', vt)\n+    push(\"\\x1b[4;20H\\x1b[3'}\", vt)\n+    expect('scrollrect 3..20,19..60 => +0,-3')\n+\n+    -- DECIC outside DECSLRM\n+    push(\"\\x1b[70G\\x1b['}\", vt)\n+    -- nothing happens\n+\n+    -- DECDC\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    push(\"\\x1b[20G\\x1b[5'~\", vt)\n+    expect('scrollrect 0..25,19..80 => +0,+5')\n+\n+    -- DECDC with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[4;20r\\x1b[20;60s', vt)\n+    push(\"\\x1b[4;20H\\x1b[3'~\", vt)\n+    expect('scrollrect 3..20,19..60 => +0,+3')\n+\n+    -- DECDC outside DECSLRM\n+    push(\"\\x1b[70G\\x1b['~\", vt)\n+    -- nothing happens\n+\n+    -- EL 0\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABCDE', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[0K', vt)\n+    expect('erase 0..1,2..80')\n+    cursor(0, 2, state)\n+\n+    -- EL 1\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABCDE', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[1K', vt)\n+    expect('erase 0..1,0..3')\n+    cursor(0, 2, state)\n+\n+    -- EL 2\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABCDE', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[2K', vt)\n+    expect('erase 0..1,0..80')\n+    cursor(0, 2, state)\n+\n+    -- SEL\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[11G', vt)\n+    cursor(0, 10, state)\n+    push('\\x1b[?0K', vt)\n+    expect('erase 0..1,10..80 selective')\n+    cursor(0, 10, state)\n+    push('\\x1b[?1K', vt)\n+    expect('erase 0..1,0..11 selective')\n+    cursor(0, 10, state)\n+    push('\\x1b[?2K', vt)\n+    expect('erase 0..1,0..80 selective')\n+    cursor(0, 10, state)\n+\n+    -- ED 0\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[0J', vt)\n+    expect('erase 1..2,1..80\\nerase 2..25,0..80')\n+    cursor(1, 1, state)\n+\n+    -- ED 1\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[1J', vt)\n+    expect('erase 0..1,0..80\\nerase 1..2,0..2')\n+    cursor(1, 1, state)\n+\n+    -- ED 2\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[2J', vt)\n+    expect('erase 0..25,0..80')\n+    cursor(1, 1, state)\n+\n+    -- ED 3\n+    push('\\x1b[3J', vt)\n+    expect('sb_clear')\n+\n+    -- SED\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b[?0J', vt)\n+    expect('erase 4..5,4..80 selective\\nerase 5..25,0..80 selective')\n+    cursor(4, 4, state)\n+    push('\\x1b[?1J', vt)\n+    expect('erase 0..4,0..80 selective\\nerase 4..5,0..5 selective')\n+    cursor(4, 4, state)\n+    push('\\x1b[?2J', vt)\n+    expect('erase 0..25,0..80 selective')\n+    cursor(4, 4, state)\n+\n+    -- DECRQSS on DECSCA\n+    push('\\x1b[2\"q', vt)\n+    push('\\x1bP$q\"q\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r2\"q\\x1b\\\\')\n+\n+    state = wantstate(vt, { m = true, e = true, b = true })\n+    expect('erase 0..25,0..80') -- TODO(dundargoc): strange, this should not be needed according to the original code\n+\n+    -- ICH move+erase emuation\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ACD', vt)\n+    push('\\x1b[2D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[@', vt)\n+    expect('moverect 0..1,1..79 -> 0..1,2..80\\nerase 0..1,1..2')\n+    cursor(0, 1, state)\n+    push('B', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[3@', vt)\n+    expect('moverect 0..1,2..77 -> 0..1,5..80\\nerase 0..1,2..5')\n+\n+    -- DCH move+erase emulation\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABBC', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[P', vt)\n+    expect('moverect 0..1,2..80 -> 0..1,1..79\\nerase 0..1,79..80')\n+    cursor(0, 1, state)\n+    push('\\x1b[3P', vt)\n+    expect('moverect 0..1,4..80 -> 0..1,1..77\\nerase 0..1,77..80')\n+    cursor(0, 1, state)\n+  end)\n+\n+  itp('14state_encoding', function()\n+    local vt = init()\n+    vterm.vterm_set_utf8(vt, false)\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Default\n+    reset(state, nil)\n+    push('#', vt)\n+    expect('putglyph 23 1 0,0')\n+\n+    -- Designate G0=UK\n+    reset(state, nil)\n+    push('\\x1b(A', vt)\n+    push('#', vt)\n+    expect('putglyph a3 1 0,0')\n+\n+    -- Designate G0=DEC drawing\n+    reset(state, nil)\n+    push('\\x1b(0', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,0')\n+\n+    -- Designate G1 + LS1\n+    reset(state, nil)\n+    push('\\x1b)0', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x0e', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,1')\n+    -- LS0\n+    push('\\x0f', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,2')\n+\n+    -- Designate G2 + LS2\n+    push('\\x1b*0', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,3')\n+    push('\\x1bn', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,4')\n+    push('\\x0f', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,5')\n+\n+    -- Designate G3 + LS3\n+    push('\\x1b+0', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,6')\n+    push('\\x1bo', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,7')\n+    push('\\x0f', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,8')\n+\n+    -- SS2\n+    push('a\\x8eaa', vt)\n+    expect('putglyph 61 1 0,9\\nputglyph 2592 1 0,10\\nputglyph 61 1 0,11')\n+\n+    -- SS3\n+    push('a\\x8faa', vt)\n+    expect('putglyph 61 1 0,12\\nputglyph 2592 1 0,13\\nputglyph 61 1 0,14')\n+\n+    -- LS1R\n+    reset(state, nil)\n+    push('\\x1b~', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x1b)0', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 2592 1 0,1')\n+\n+    -- LS2R\n+    reset(state, nil)\n+    push('\\x1b}', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x1b*0', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 2592 1 0,1')\n+\n+    -- LS3R\n+    reset(state, nil)\n+    push('\\x1b|', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x1b+0', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 2592 1 0,1')\n+\n+    vterm.vterm_set_utf8(vt, true)\n+    -- U+0108 == c4 88\n+    reset(state, nil)\n+    push('\\x1b(B', vt)\n+    push('AB\\xc4\\x88D', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 108 1 0,2\\nputglyph 44 1 0,3')\n+  end)\n+\n+  itp('15state_mode', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true, m = true, e = true })\n+\n+    -- Insert/Replace Mode\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('AC\\x1b[DB', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 43 1 0,1\\nputglyph 42 1 0,1')\n+    push('\\x1b[4h', vt)\n+    push('\\x1b[G', vt)\n+    push('AC\\x1b[DB', vt)\n+    expect(\n+      'moverect 0..1,0..79 -> 0..1,1..80\\nerase 0..1,0..1\\nputglyph 41 1 0,0\\nmoverect 0..1,1..79 -> 0..1,2..80\\nerase 0..1,1..2\\nputglyph 43 1 0,1\\nmoverect 0..1,1..79 -> 0..1,2..80\\nerase 0..1,1..2\\nputglyph 42 1 0,1'\n+    )\n+\n+    -- Insert mode only happens once for UTF-8 combining\n+    push('e', vt)\n+    expect('moverect 0..1,2..79 -> 0..1,3..80\\nerase 0..1,2..3\\nputglyph 65 1 0,2')\n+    push('\\xCC\\x81', vt)\n+    expect('putglyph 65,301 1 0,2')\n+\n+    -- Newline/Linefeed mode\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[5G\\n', vt)\n+    cursor(1, 4, state)\n+    push('\\x1b[20h', vt)\n+    push('\\x1b[5G\\n', vt)\n+    cursor(2, 0, state)\n+\n+    -- DEC origin mode\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[5;15r', vt)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[3;3H', vt)\n+    cursor(2, 2, state)\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[H', vt)\n+    cursor(4, 0, state)\n+    push('\\x1b[3;3H', vt)\n+    cursor(6, 2, state)\n+\n+    -- DECRQM on DECOM\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[?6$p', vt)\n+    expect_output('\\x1b[?6;1$y')\n+    push('\\x1b[?6l', vt)\n+    push('\\x1b[?6$p', vt)\n+    expect_output('\\x1b[?6;2$y')\n+\n+    -- Origin mode with DECSLRM\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[20;60s', vt)\n+    push('\\x1b[H', vt)\n+    cursor(4, 19, state)\n+\n+    push('\\x1b[?69l', vt)\n+\n+    -- Origin mode bounds cursor to scrolling region\n+    push('\\x1b[H', vt)\n+    push('\\x1b[10A', vt)\n+    cursor(4, 0, state)\n+    push('\\x1b[20B', vt)\n+    cursor(14, 0, state)\n+\n+    -- Origin mode without scroll region\n+    push('\\x1b[?6l', vt)\n+    push('\\x1b[r\\x1b[?6h', vt)\n+    cursor(0, 0, state)\n+  end)\n+\n+  itp('16state_resize', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Placement\n+    reset(state, nil)\n+    push('AB\\x1b[79GCDE', vt)\n+    expect(\n+      'putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 43 1 0,78\\nputglyph 44 1 0,79\\nputglyph 45 1 1,0'\n+    )\n+\n+    -- Resize\n+    reset(state, nil)\n+    resize(27, 85, vt)\n+    push('AB\\x1b[79GCDE', vt)\n+    expect(\n+      'putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 43 1 0,78\\nputglyph 44 1 0,79\\nputglyph 45 1 0,80'\n+    )\n+    cursor(0, 81, state)\n+\n+    -- Resize without reset\n+    resize(28, 90, vt)\n+    cursor(0, 81, state)\n+    push('FGHI', vt)\n+    expect('putglyph 46 1 0,81\\nputglyph 47 1 0,82\\nputglyph 48 1 0,83\\nputglyph 49 1 0,84')\n+    cursor(0, 85, state)\n+\n+    -- Resize shrink moves cursor\n+    resize(25, 80, vt)\n+    cursor(0, 79, state)\n+\n+    -- Resize grow doesn't cancel phantom\n+    reset(state, nil)\n+    push('\\x1b[79GAB', vt)\n+    expect('putglyph 41 1 0,78\\nputglyph 42 1 0,79')\n+    cursor(0, 79, state)\n+    resize(30, 100, vt)\n+    cursor(0, 80, state)\n+    push('C', vt)\n+    expect('putglyph 43 1 0,80')\n+    cursor(0, 81, state)\n+  end)\n+\n+  itp('17state_mouse', function()\n+    local vt = init()\n+    local state = wantstate(vt, { p = true })\n+\n+    -- DECRQM on with mouse off\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;2$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;2$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;2$y')\n+\n+    -- Mouse in simple button report mode\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    push('\\x1b[?1000h', vt)\n+    expect('settermprop 8 1')\n+\n+    -- Press 1\n+    mousemove(0, 0, vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\x21\\x21')\n+\n+    -- Release 1\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\x21\\x21')\n+\n+    -- Ctrl-Press 1\n+    mousebtn('d', 1, vt, { C = true })\n+    expect_output('\\x1b[M\\x30\\x21\\x21')\n+    mousebtn('u', 1, vt, { C = true })\n+    expect_output('\\x1b[M\\x33\\x21\\x21')\n+\n+    -- Button 2\n+    mousebtn('d', 2, vt)\n+    expect_output('\\x1b[M\\x21\\x21\\x21')\n+    mousebtn('u', 2, vt)\n+    expect_output('\\x1b[M\\x23\\x21\\x21')\n+\n+    -- Position\n+    mousemove(10, 20, vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\x35\\x2b')\n+\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\x35\\x2b')\n+    mousemove(10, 21, vt)\n+    -- no output\n+\n+    -- Wheel events\n+    mousebtn('d', 4, vt)\n+    expect_output('\\x1b[M\\x60\\x36\\x2b')\n+    mousebtn('d', 4, vt)\n+    expect_output('\\x1b[M\\x60\\x36\\x2b')\n+    mousebtn('d', 5, vt)\n+    expect_output('\\x1b[M\\x61\\x36\\x2b')\n+    mousebtn('d', 6, vt)\n+    expect_output('\\x1b[M\\x62\\x36\\x2b')\n+    mousebtn('d', 7, vt)\n+    expect_output('\\x1b[M\\x63\\x36\\x2b')\n+\n+    -- DECRQM on mouse button mode\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;1$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;2$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;2$y')\n+\n+    -- Drag events\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    push('\\x1b[?1002h', vt)\n+    expect('settermprop 8 2')\n+\n+    mousemove(5, 5, vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\x26\\x26')\n+    mousemove(5, 6, vt)\n+    expect_output('\\x1b[M\\x40\\x27\\x26')\n+    mousemove(6, 6, vt)\n+    expect_output('\\x1b[M\\x40\\x27\\x27')\n+    mousemove(6, 6, vt)\n+    -- no output\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\x27\\x27')\n+    mousemove(6, 7, vt)\n+    -- no output\n+\n+    -- DECRQM on mouse drag mode\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;2$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;1$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;2$y')\n+\n+    -- Non-drag motion events\n+    push('\\x1b[?1003h', vt)\n+    expect('settermprop 8 3')\n+\n+    mousemove(6, 8, vt)\n+    expect_output('\\x1b[M\\x43\\x29\\x27')\n+\n+    -- DECRQM on mouse motion mode\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;2$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;2$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;1$y')\n+\n+    -- Bounds checking\n+    mousemove(300, 300, vt)\n+    expect_output('\\x1b[M\\x43\\xff\\xff')\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\xff\\xff')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\xff\\xff')\n+\n+    -- DECRQM on standard encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;2$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;2$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;2$y')\n+\n+    -- UTF-8 extended encoding mode\n+    -- 300 + 32 + 1 = 333 = U+014d = \\xc5\\x8d\n+    push('\\x1b[?1005h', vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\xc5\\x8d\\xc5\\x8d')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\xc5\\x8d\\xc5\\x8d')\n+\n+    -- DECRQM on UTF-8 extended encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;1$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;2$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;2$y')\n+\n+    -- SGR extended encoding mode\n+    push('\\x1b[?1006h', vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[<0;301;301M')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[<0;301;301m')\n+\n+    -- DECRQM on SGR extended encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;2$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;1$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;2$y')\n+\n+    -- rxvt extended encoding mode\n+    push('\\x1b[?1015h', vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[0;301;301M')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[3;301;301M')\n+\n+    -- DECRQM on rxvt extended encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;2$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;2$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;1$y')\n+\n+    -- Mouse disabled reports nothing\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    mousemove(0, 0, vt)\n+    mousebtn('d', 1, vt)\n+    mousebtn('u', 1, vt)\n+\n+    -- DECSM can set multiple modes at once\n+    push('\\x1b[?1002;1006h', vt)\n+    expect('settermprop 8 2')\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[<0;1;1M')\n+  end)\n+\n+  itp('18state_termprops', function()\n+    local vt = init()\n+    local state = wantstate(vt, { p = true })\n+\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+\n+    -- Cursor visibility\n+    push('\\x1b[?25h', vt)\n+    expect('settermprop 1 true')\n+    push('\\x1b[?25$p', vt)\n+    expect_output('\\x1b[?25;1$y')\n+    push('\\x1b[?25l', vt)\n+    expect('settermprop 1 false')\n+    push('\\x1b[?25$p', vt)\n+    expect_output('\\x1b[?25;2$y')\n+\n+    -- Cursor blink\n+    push('\\x1b[?12h', vt)\n+    expect('settermprop 2 true')\n+    push('\\x1b[?12$p', vt)\n+    expect_output('\\x1b[?12;1$y')\n+    push('\\x1b[?12l', vt)\n+    expect('settermprop 2 false')\n+    push('\\x1b[?12$p', vt)\n+    expect_output('\\x1b[?12;2$y')\n+\n+    -- Cursor shape\n+    push('\\x1b[3 q', vt)\n+    expect('settermprop 2 true\\nsettermprop 7 2')\n+\n+    -- Title\n+    push('\\x1b]2;Here is my title\\a', vt)\n+    expect('settermprop 4 [\"Here is my title\"]')\n+\n+    -- Title split write\n+    push('\\x1b]2;Here is', vt)\n+    expect('settermprop 4 [\"Here is\"')\n+    push(' another title\\a', vt)\n+    expect('settermprop 4 \" another title\"]')\n+  end)\n+\n+  itp('20state_wrapping', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true, m = true })\n+\n+    -- 79th Column\n+    push('\\x1b[75G', vt)\n+    push(string.rep('A', 5), vt)\n+    expect(\n+      'putglyph 41 1 0,74\\nputglyph 41 1 0,75\\nputglyph 41 1 0,76\\nputglyph 41 1 0,77\\nputglyph 41 1 0,78'\n+    )\n+    cursor(0, 79, state)\n+\n+    -- 80th Column Phantom\n+    push('A', vt)\n+    expect('putglyph 41 1 0,79')\n+    cursor(0, 79, state)\n+\n+    -- Line Wraparound\n+    push('B', vt)\n+    expect('putglyph 42 1 1,0')\n+    cursor(1, 1, state)\n+\n+    -- Line Wraparound during combined write\n+    push('\\x1b[78G', vt)\n+    push('BBBCC', vt)\n+    expect(\n+      'putglyph 42 1 1,77\\nputglyph 42 1 1,78\\nputglyph 42 1 1,79\\nputglyph 43 1 2,0\\nputglyph 43 1 2,1'\n+    )\n+    cursor(2, 2, state)\n+\n+    -- DEC Auto Wrap Mode\n+    reset(state, nil)\n+    push('\\x1b[?7l', vt)\n+    push('\\x1b[75G', vt)\n+    push(string.rep('D', 6), vt)\n+    expect(\n+      'putglyph 44 1 0,74\\nputglyph 44 1 0,75\\nputglyph 44 1 0,76\\nputglyph 44 1 0,77\\nputglyph 44 1 0,78\\nputglyph 44 1 0,79'\n+    )\n+    cursor(0, 79, state)\n+    push('D', vt)\n+    expect('putglyph 44 1 0,79')\n+    cursor(0, 79, state)\n+    push('\\x1b[?7h', vt)\n+\n+    -- 80th column causes linefeed on wraparound\n+    push('\\x1b[25;78HABC', vt)\n+    expect('putglyph 41 1 24,77\\nputglyph 42 1 24,78\\nputglyph 43 1 24,79')\n+    cursor(24, 79, state)\n+    push('D', vt)\n+    expect('moverect 1..25,0..80 -> 0..24,0..80\\nputglyph 44 1 24,0')\n+\n+    -- 80th column phantom linefeed phantom cancelled by explicit cursor move\n+    push('\\x1b[25;78HABC', vt)\n+    expect('putglyph 41 1 24,77\\nputglyph 42 1 24,78\\nputglyph 43 1 24,79')\n+    cursor(24, 79, state)\n+    push('\\x1b[25;1HD', vt)\n+    expect('putglyph 44 1 24,0')\n+  end)\n+\n+  itp('21state_tabstops', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Initial\n+    reset(state, nil)\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,8')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,16')\n+    cursor(0, 17, state)\n+\n+    -- HTS\n+    push('\\x1b[5G\\x1bH', vt)\n+    push('\\x1b[G\\tX', vt)\n+    expect('putglyph 58 1 0,4')\n+    cursor(0, 5, state)\n+\n+    -- TBC 0\n+    push('\\x1b[9G\\x1b[g', vt)\n+    push('\\x1b[G\\tX\\tX', vt)\n+    expect('putglyph 58 1 0,4\\nputglyph 58 1 0,16')\n+    cursor(0, 17, state)\n+\n+    -- TBC 3\n+    push('\\x1b[3g\\x1b[50G\\x1bH\\x1b[G', vt)\n+    cursor(0, 0, state)\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,49')\n+    cursor(0, 50, state)\n+\n+    -- Tabstops after resize\n+    reset(state, nil)\n+    resize(30, 100, vt)\n+    -- Should be 100/8 = 12 tabstops\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,8')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,16')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,24')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,32')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,40')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,48')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,56')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,64')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,72')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,80')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,88')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,96')\n+    cursor(0, 97, state)\n+  end)\n+\n+  itp('22state_save', function()\n+    local vt = init()\n+    local state = wantstate(vt, { p = true })\n+\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+\n+    -- Set up state\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[1m', vt)\n+    pen('bold', true, state)\n+\n+    -- Save\n+    push('\\x1b[?1048h', vt)\n+\n+    -- Change state\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b[4 q', vt)\n+    expect('settermprop 2 false\\nsettermprop 7 2')\n+    push('\\x1b[22;4m', vt)\n+    pen('bold', false, state)\n+    pen('underline', 1, state)\n+\n+    -- Restore\n+    push('\\x1b[?1048l', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(1, 1, state)\n+    pen('bold', true, state)\n+    pen('underline', 0, state)\n+\n+    -- Save/restore using DECSC/DECRC\n+    push('\\x1b[2;2H\\x1b7', vt)\n+    cursor(1, 1, state)\n+\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b8', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(1, 1, state)\n+\n+    -- Save twice, restore twice happens on both edge transitions\n+    push('\\x1b[2;10H\\x1b[?1048h\\x1b[6;10H\\x1b[?1048h', vt)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[?1048l', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(5, 9, state)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[?1048l', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(5, 9, state)\n+  end)\n+\n+  itp('25state_input', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Unmodified ASCII\n+    inchar(41, vt)\n+    expect('output 29')\n+    inchar(61, vt)\n+    expect('output 3d')\n+\n+    -- Ctrl modifier on ASCII letters\n+    inchar(41, vt, { C = true })\n+    expect('output 1b,5b,34,31,3b,35,75')\n+    inchar(61, vt, { C = true })\n+    expect('output 1b,5b,36,31,3b,35,75')\n+\n+    -- Alt modifier on ASCII letters\n+    inchar(41, vt, { A = true })\n+    expect('output 1b,29')\n+    inchar(61, vt, { A = true })\n+    expect('output 1b,3d')\n+\n+    -- Ctrl-Alt modifier on ASCII letters\n+    inchar(41, vt, { C = true, A = true })\n+    expect('output 1b,5b,34,31,3b,37,75')\n+    inchar(61, vt, { C = true, A = true })\n+    expect('output 1b,5b,36,31,3b,37,75')\n+\n+    -- Special handling of Ctrl-I\n+    inchar(49, vt)\n+    expect('output 31')\n+    inchar(69, vt)\n+    expect('output 45')\n+    inchar(49, vt, { C = true })\n+    expect('output 1b,5b,34,39,3b,35,75')\n+    inchar(69, vt, { C = true })\n+    expect('output 1b,5b,36,39,3b,35,75')\n+    inchar(49, vt, { A = true })\n+    expect('output 1b,31')\n+    inchar(69, vt, { A = true })\n+    expect('output 1b,45')\n+    inchar(49, vt, { A = true, C = true })\n+    expect('output 1b,5b,34,39,3b,37,75')\n+    inchar(69, vt, { A = true, C = true })\n+    expect('output 1b,5b,36,39,3b,37,75')\n+\n+    -- Special handling of Space\n+    inchar(20, vt)\n+    expect('output 14')\n+    inchar(20, vt, { S = true })\n+    expect('output 14')\n+    inchar(20, vt, { C = true })\n+    expect('output 1b,5b,32,30,3b,35,75')\n+    inchar(20, vt, { C = true, S = true })\n+    expect('output 1b,5b,32,30,3b,35,75')\n+    inchar(20, vt, { A = true })\n+    expect('output 1b,14')\n+    inchar(20, vt, { S = true, A = true })\n+    expect('output 1b,14')\n+    inchar(20, vt, { C = true, A = true })\n+    expect('output 1b,5b,32,30,3b,37,75')\n+    inchar(20, vt, { S = true, C = true, A = true })\n+    expect('output 1b,5b,32,30,3b,37,75')\n+\n+    -- Cursor keys in reset (cursor) mode\n+    inkey('up', vt)\n+    expect_output('\\x1b[A')\n+    inkey('up', vt, { S = true })\n+    expect_output('\\x1b[1;2A')\n+    inkey('up', vt, { C = true })\n+    expect_output('\\x1b[1;5A')\n+    inkey('up', vt, { S = true, C = true })\n+    expect_output('\\x1b[1;6A')\n+    inkey('up', vt, { A = true })\n+    expect_output('\\x1b[1;3A')\n+    inkey('up', vt, { S = true, A = true })\n+    expect_output('\\x1b[1;4A')\n+    inkey('up', vt, { C = true, A = true })\n+    expect_output('\\x1b[1;7A')\n+    inkey('up', vt, { S = true, C = true, A = true })\n+    expect_output('\\x1b[1;8A')\n+\n+    -- Cursor keys in application mode\n+    push('\\x1b[?1h', vt)\n+    -- Plain \"Up\" should be SS3 A now\n+    inkey('up', vt)\n+    expect_output('\\x1bOA')\n+    -- Modified keys should still use CSI\n+    inkey('up', vt, { S = true })\n+    expect_output('\\x1b[1;2A')\n+    inkey('up', vt, { C = true })\n+    expect_output('\\x1b[1;5A')\n+\n+    -- Shift-Tab should be different\n+    inkey('tab', vt)\n+    expect_output('\\x09')\n+    inkey('tab', vt, { S = true })\n+    expect_output('\\x1b[Z')\n+    inkey('tab', vt, { C = true })\n+    expect_output('\\x1b[9;5u')\n+    inkey('tab', vt, { A = true })\n+    expect_output('\\x1b\\x09')\n+    inkey('tab', vt, { C = true, A = true })\n+    expect_output('\\x1b[9;7u')\n+\n+    -- Enter in linefeed mode\n+    inkey('enter', vt)\n+    expect_output('\\x0d')\n+\n+    -- Enter in newline mode\n+    push('\\x1b[20h', vt)\n+    inkey('enter', vt)\n+    expect_output('\\x0d\\x0a')\n+\n+    -- Unmodified F1 is SS3 P\n+    inkey('f1', vt)\n+    expect_output('\\x1bOP')\n+\n+    -- Modified F1 is CSI P\n+    inkey('f1', vt, { S = true })\n+    expect_output('\\x1b[1;2P')\n+    inkey('f1', vt, { A = true })\n+    expect_output('\\x1b[1;3P')\n+    inkey('f1', vt, { C = true })\n+    expect_output('\\x1b[1;5P')\n+\n+    -- Keypad in DECKPNM\n+    inkey('kp0', vt)\n+    expect_output('0')\n+\n+    -- Keypad in DECKPAM\n+    push('\\x1b=', vt)\n+    inkey('kp0', vt)\n+    expect_output('\\x1bOp')\n+\n+    -- Bracketed paste mode off\n+    vterm.vterm_keyboard_start_paste(vt)\n+    vterm.vterm_keyboard_end_paste(vt)\n+\n+    -- Bracketed paste mode on\n+    push('\\x1b[?2004h', vt)\n+    vterm.vterm_keyboard_start_paste(vt)\n+    expect_output('\\x1b[200~')\n+    vterm.vterm_keyboard_end_paste(vt)\n+    expect_output('\\x1b[201~')\n+\n+    -- Focus reporting disabled\n+    vterm.vterm_state_focus_in(state)\n+    vterm.vterm_state_focus_out(state)\n+\n+    -- Focus reporting enabled\n+    state = wantstate(vt, { p = true })\n+    push('\\x1b[?1004h', vt)\n+    expect('settermprop 9 true')\n+    vterm.vterm_state_focus_in(state)\n+    expect_output('\\x1b[I')\n+    vterm.vterm_state_focus_out(state)\n+    expect_output('\\x1b[O')\n+  end)\n+\n+  itp('26state_query', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- DA\n+    reset(state, nil)\n+    push('\\x1b[c', vt)\n+    expect_output('\\x1b[?1;2c')\n+\n+    -- XTVERSION\n+    reset(state, nil)\n+    push('\\x1b[>q', vt)\n+    expect_output('\\x1bP>|libvterm(0.3)\\x1b\\\\')\n+\n+    -- DSR\n+    reset(state, nil)\n+    push('\\x1b[5n', vt)\n+    expect_output('\\x1b[0n')\n+\n+    -- CPR\n+    push('\\x1b[6n', vt)\n+    expect_output('\\x1b[1;1R')\n+    push('\\x1b[10;10H\\x1b[6n', vt)\n+    expect_output('\\x1b[10;10R')\n+\n+    -- DECCPR\n+    push('\\x1b[?6n', vt)\n+    expect_output('\\x1b[?10;10R')\n+\n+    -- DECRQSS on DECSCUSR\n+    push('\\x1b[3 q', vt)\n+    push('\\x1bP$q q\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r3 q\\x1b\\\\')\n+\n+    -- DECRQSS on SGR\n+    push('\\x1b[1;5;7m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r1;5;7m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR ANSI colours\n+    push('\\x1b[0;31;42m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r31;42m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR ANSI hi-bright colours\n+    push('\\x1b[0;93;104m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r93;104m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR 256-palette colours\n+    push('\\x1b[0;38:5:56;48:5:78m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r38:5:56;48:5:78m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR RGB8 colours\n+    push('\\x1b[0;38:2:24:68:112;48:2:13:57:101m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r38:2:24:68:112;48:2:13:57:101m\\x1b\\\\')\n+\n+    -- S8C1T on DSR\n+    push('\\x1b G', vt)\n+    push('\\x1b[5n', vt)\n+    expect_output('\\x9b0n')\n+    push('\\x1b F', vt)\n+  end)\n+\n+  itp('27state_reset', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    reset(state, nil)\n+\n+    -- RIS homes cursor\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    state = wantstate(vt, { m = true })\n+    push('\\x1bc', vt)\n+    cursor(0, 0, state)\n+    wantstate(vt)\n+\n+    -- RIS cancels scrolling region\n+    push('\\x1b[5;10r', vt)\n+    wantstate(vt, { s = true })\n+    push('\\x1bc\\x1b[25H\\n', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+    wantstate(vt)\n+\n+    -- RIS erases screen\n+    push('ABCDE', vt)\n+    state = wantstate(vt, { e = true })\n+    push('\\x1bc', vt)\n+    expect('erase 0..25,0..80')\n+    wantstate(vt)\n+\n+    -- RIS clears tabstops\n+    push('\\x1b[5G\\x1bH\\x1b[G\\t', vt)\n+    cursor(0, 4, state)\n+    push('\\x1bc\\t', vt)\n+    cursor(0, 8, state)\n+  end)\n+\n+  itp('28state_dbl_wh', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Single Width, Single Height\n+    reset(state, nil)\n+    push('\\x1b#5', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 0,0\\nputglyph 65 1 0,1\\nputglyph 6c 1 0,2\\nputglyph 6c 1 0,3\\nputglyph 6f 1 0,4'\n+    )\n+\n+    -- Double Width, Single Height\n+    reset(state, nil)\n+    push('\\x1b#6', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 0,0 dwl\\nputglyph 65 1 0,1 dwl\\nputglyph 6c 1 0,2 dwl\\nputglyph 6c 1 0,3 dwl\\nputglyph 6f 1 0,4 dwl'\n+    )\n+    cursor(0, 5, state)\n+    push('\\x1b[40GAB', vt)\n+    expect('putglyph 41 1 0,39 dwl\\nputglyph 42 1 1,0')\n+    cursor(1, 1, state)\n+\n+    -- Double Height\n+    reset(state, nil)\n+    push('\\x1b#3', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 0,0 dwl dhl-top\\nputglyph 65 1 0,1 dwl dhl-top\\nputglyph 6c 1 0,2 dwl dhl-top\\nputglyph 6c 1 0,3 dwl dhl-top\\nputglyph 6f 1 0,4 dwl dhl-top'\n+    )\n+    cursor(0, 5, state)\n+    push('\\r\\n\\x1b#4', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 1,0 dwl dhl-bottom\\nputglyph 65 1 1,1 dwl dhl-bottom\\nputglyph 6c 1 1,2 dwl dhl-bottom\\nputglyph 6c 1 1,3 dwl dhl-bottom\\nputglyph 6f 1 1,4 dwl dhl-bottom'\n+    )\n+    cursor(1, 5, state)\n+\n+    -- Double Width scrolling\n+    reset(state, nil)\n+    push('\\x1b[20H\\x1b#6ABC', vt)\n+    expect('putglyph 41 1 19,0 dwl\\nputglyph 42 1 19,1 dwl\\nputglyph 43 1 19,2 dwl')\n+    push('\\x1b[25H\\n', vt)\n+    push('\\x1b[19;4HDE', vt)\n+    expect('putglyph 44 1 18,3 dwl\\nputglyph 45 1 18,4 dwl')\n+    push('\\x1b[H\\x1bM', vt)\n+    push('\\x1b[20;6HFG', vt)\n+    expect('putglyph 46 1 19,5 dwl\\nputglyph 47 1 19,6 dwl')\n+  end)\n+\n+  itp('29state_fallback', function()\n+    local vt = init()\n+    local state = wantstate(vt, { f = true })\n+    reset(state, nil)\n+\n+    -- Unrecognised control\n+    push('\\x03', vt)\n+    expect('control 03')\n+\n+    -- Unrecognised CSI\n+    push('\\x1b[?15;2z', vt)\n+    expect('csi 7a L=3f 15,2')\n+\n+    -- Unrecognised OSC\n+    push('\\x1b]27;Something\\x1b\\\\', vt)\n+    expect('osc [27;Something]')\n+\n+    -- Unrecognised DCS\n+    push('\\x1bPz123\\x1b\\\\', vt)\n+    expect('dcs [z123]')\n+\n+    -- Unrecognised APC\n+    push('\\x1b_z123\\x1b\\\\', vt)\n+    expect('apc [z123]')\n+\n+    -- Unrecognised PM\n+    push('\\x1b^z123\\x1b\\\\', vt)\n+    expect('pm [z123]')\n+\n+    -- Unrecognised SOS\n+    push('\\x1bXz123\\x1b\\\\', vt)\n+    expect('sos [z123]')\n+  end)\n+\n+  itp('30state_pen', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Reset\n+    push('\\x1b[m', vt)\n+    pen('bold', false, state)\n+    pen('underline', 0, state)\n+    pen('italic', false, state)\n+    pen('blink', false, state)\n+    pen('reverse', false, state)\n+    pen('font', 0, state)\n+    -- TODO(dundargoc): fix\n+    -- ?pen foreground = rgb(240,240,240,is_default_fg)\n+    -- ?pen background = rgb(0,0,0,is_default_bg)\n+\n+    -- Bold\n+    push('\\x1b[1m', vt)\n+    pen('bold', true, state)\n+    push('\\x1b[22m', vt)\n+    pen('bold', false, state)\n+    push('\\x1b[1m\\x1b[m', vt)\n+    pen('bold', false, state)\n+\n+    -- Underline\n+    push('\\x1b[4m', vt)\n+    pen('underline', 1, state)\n+    push('\\x1b[21m', vt)\n+    pen('underline', 2, state)\n+    push('\\x1b[24m', vt)\n+    pen('underline', 0, state)\n+    push('\\x1b[4m\\x1b[4:0m', vt)\n+    pen('underline', 0, state)\n+    push('\\x1b[4:1m', vt)\n+    pen('underline', 1, state)\n+    push('\\x1b[4:2m', vt)\n+    pen('underline', 2, state)\n+    push('\\x1b[4:3m', vt)\n+    pen('underline', 3, state)\n+    push('\\x1b[4m\\x1b[m', vt)\n+    pen('underline', 0, state)\n+\n+    -- Italic\n+    push('\\x1b[3m', vt)\n+    pen('italic', true, state)\n+    push('\\x1b[23m', vt)\n+    pen('italic', false, state)\n+    push('\\x1b[3m\\x1b[m', vt)\n+    pen('italic', false, state)\n+\n+    -- Blink\n+    push('\\x1b[5m', vt)\n+    pen('blink', true, state)\n+    push('\\x1b[25m', vt)\n+    pen('blink', false, state)\n+    push('\\x1b[5m\\x1b[m', vt)\n+    pen('blink', false, state)\n+\n+    -- Reverse\n+    push('\\x1b[7m', vt)\n+    pen('reverse', true, state)\n+    push('\\x1b[27m', vt)\n+    pen('reverse', false, state)\n+    push('\\x1b[7m\\x1b[m', vt)\n+    pen('reverse', false, state)\n+\n+    -- Font Selection\n+    push('\\x1b[11m', vt)\n+    pen('font', 1, state)\n+    push('\\x1b[19m', vt)\n+    pen('font', 9, state)\n+    push('\\x1b[10m', vt)\n+    pen('font', 0, state)\n+    push('\\x1b[11m\\x1b[m', vt)\n+    pen('font', 0, state)\n+\n+    -- TODO(dundargoc): fix\n+    -- -- Foreground\n+    -- push \"\\x1b[31m\"\n+    --   ?pen foreground = idx(1)\n+    -- push \"\\x1b[32m\"\n+    --   ?pen foreground = idx(2)\n+    -- push \"\\x1b[34m\"\n+    --   ?pen foreground = idx(4)\n+    -- push \"\\x1b[91m\"\n+    --   ?pen foreground = idx(9)\n+    -- push \"\\x1b[38:2:10:20:30m\"\n+    --   ?pen foreground = rgb(10,20,30)\n+    -- push \"\\x1b[38:5:1m\"\n+    --   ?pen foreground = idx(1)\n+    -- push \"\\x1b[39m\"\n+    --   ?pen foreground = rgb(240,240,240,is_default_fg)\n+    --\n+    -- -- Background\n+    -- push \"\\x1b[41m\"\n+    --   ?pen background = idx(1)\n+    -- push \"\\x1b[42m\"\n+    --   ?pen background = idx(2)\n+    -- push \"\\x1b[44m\"\n+    --   ?pen background = idx(4)\n+    -- push \"\\x1b[101m\"\n+    --   ?pen background = idx(9)\n+    -- push \"\\x1b[48:2:10:20:30m\"\n+    --   ?pen background = rgb(10,20,30)\n+    -- push \"\\x1b[48:5:1m\"\n+    --   ?pen background = idx(1)\n+    -- push \"\\x1b[49m\"\n+    --   ?pen background = rgb(0,0,0,is_default_bg)\n+    --\n+    -- -- Bold+ANSI colour == highbright\n+    -- push \"\\x1b[m\\x1b[1;37m\"\n+    --   ?pen bold = on\n+    --   ?pen foreground = idx(15)\n+    -- push \"\\x1b[m\\x1b[37;1m\"\n+    --   ?pen bold = on\n+    --   ?pen foreground = idx(15)\n+    --\n+    -- -- Super/Subscript\n+    -- push \"\\x1b[73m\"\n+    --   ?pen small = on\n+    --   ?pen baseline = raise\n+    -- push \"\\x1b[74m\"\n+    --   ?pen small = on\n+    --   ?pen baseline = lower\n+    -- push \"\\x1b[75m\"\n+    --   ?pen small = off\n+    --   ?pen baseline = normal\n+    --\n+    -- -- DECSTR resets pen attributes\n+    -- push \"\\x1b[1;4m\"\n+    --   ?pen bold = on\n+    --   ?pen underline = 1\n+    -- push \"\\x1b[!p\"\n+    --   ?pen bold = off\n+    --   ?pen underline = 0\n+  end)\n+\n+  itp('31state_rep', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- REP no argument\n+    reset(state, nil)\n+    push('a\\x1b[b', vt)\n+    expect('putglyph 61 1 0,0\\nputglyph 61 1 0,1')\n+\n+    -- REP zero (zero should be interpreted as one)\n+    reset(state, nil)\n+    push('a\\x1b[0b', vt)\n+    expect('putglyph 61 1 0,0\\nputglyph 61 1 0,1')\n+\n+    -- REP lowercase a times two\n+    reset(state, nil)\n+    push('a\\x1b[2b', vt)\n+    expect('putglyph 61 1 0,0\\nputglyph 61 1 0,1\\nputglyph 61 1 0,2')\n+\n+    -- REP with UTF-8 1 char\n+    -- U+00E9 = C3 A9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(state, nil)\n+    push('\\xC3\\xA9\\x1b[b', vt)\n+    expect('putglyph e9 1 0,0\\nputglyph e9 1 0,1')\n+\n+    -- REP with UTF-8 wide char\n+    -- U+00E9 = C3 A9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(state, nil)\n+    push('\\xEF\\xBC\\x90\\x1b[b', vt)\n+    expect('putglyph ff10 2 0,0\\nputglyph ff10 2 0,2')\n+\n+    -- REP with UTF-8 combining character\n+    reset(state, nil)\n+    push('e\\xCC\\x81\\x1b[b', vt)\n+    expect('putglyph 65,301 1 0,0\\nputglyph 65,301 1 0,1')\n+\n+    -- REP till end of line\n+    reset(state, nil)\n+    push('a\\x1b[1000bb', vt)\n+    expect(\n+      'putglyph 61 1 0,0\\nputglyph 61 1 0,1\\nputglyph 61 1 0,2\\nputglyph 61 1 0,3\\nputglyph 61 1 0,4\\nputglyph 61 1 0,5\\nputglyph 61 1 0,6\\nputglyph 61 1 0,7\\nputglyph 61 1 0,8\\nputglyph 61 1 0,9\\nputglyph 61 1 0,10\\nputglyph 61 1 0,11\\nputglyph 61 1 0,12\\nputglyph 61 1 0,13\\nputglyph 61 1 0,14\\nputglyph 61 1 0,15\\nputglyph 61 1 0,16\\nputglyph 61 1 0,17\\nputglyph 61 1 0,18\\nputglyph 61 1 0,19\\nputglyph 61 1 0,20\\nputglyph 61 1 0,21\\nputglyph 61 1 0,22\\nputglyph 61 1 0,23\\nputglyph 61 1 0,24\\nputglyph 61 1 0,25\\nputglyph 61 1 0,26\\nputglyph 61 1 0,27\\nputglyph 61 1 0,28\\nputglyph 61 1 0,29\\nputglyph 61 1 0,30\\nputglyph 61 1 0,31\\nputglyph 61 1 0,32\\nputglyph 61 1 0,33\\nputglyph 61 1 0,34\\nputglyph 61 1 0,35\\nputglyph 61 1 0,36\\nputglyph 61 1 0,37\\nputglyph 61 1 0,38\\nputglyph 61 1 0,39\\nputglyph 61 1 0,40\\nputglyph 61 1 0,41\\nputglyph 61 1 0,42\\nputglyph 61 1 0,43\\nputglyph 61 1 0,44\\nputglyph 61 1 0,45\\nputglyph 61 1 0,46\\nputglyph 61 1 0,47\\nputglyph 61 1 0,48\\nputglyph 61 1 0,49\\nputglyph 61 1 0,50\\nputglyph 61 1 0,51\\nputglyph 61 1 0,52\\nputglyph 61 1 0,53\\nputglyph 61 1 0,54\\nputglyph 61 1 0,55\\nputglyph 61 1 0,56\\nputglyph 61 1 0,57\\nputglyph 61 1 0,58\\nputglyph 61 1 0,59\\nputglyph 61 1 0,60\\nputglyph 61 1 0,61\\nputglyph 61 1 0,62\\nputglyph 61 1 0,63\\nputglyph 61 1 0,64\\nputglyph 61 1 0,65\\nputglyph 61 1 0,66\\nputglyph 61 1 0,67\\nputglyph 61 1 0,68\\nputglyph 61 1 0,69\\nputglyph 61 1 0,70\\nputglyph 61 1 0,71\\nputglyph 61 1 0,72\\nputglyph 61 1 0,73\\nputglyph 61 1 0,74\\nputglyph 61 1 0,75\\nputglyph 61 1 0,76\\nputglyph 61 1 0,77\\nputglyph 61 1 0,78\\nputglyph 61 1 0,79\\nputglyph 62 1 1,0'\n+    )\n+  end)\n+\n+  itp('32state_flow', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Many of these test cases inspired by\n+    -- https://blueprints.launchpad.net/libvterm/+spec/reflow-cases\n+\n+    -- Spillover text marks continuation on second line\n+    reset(state, nil)\n+    push(string.rep('A', 100), vt)\n+    push('\\r\\n', vt)\n+    lineinfo(0, {}, state)\n+    lineinfo(1, { cont = true }, state)\n+\n+    -- CRLF in column 80 does not mark continuation\n+    reset(state, nil)\n+    push(string.rep('B', 80), vt)\n+    push('\\r\\n', vt)\n+    push(string.rep('B', 20), vt)\n+    push('\\r\\n', vt)\n+    lineinfo(0, {}, state)\n+    lineinfo(1, {}, state)\n+\n+    -- EL cancels continuation of following line\n+    reset(state, nil)\n+    push(string.rep('D', 100), vt)\n+    lineinfo(1, { cont = true }, state)\n+    push('\\x1bM\\x1b[79G\\x1b[K', vt)\n+    lineinfo(1, {}, state)\n+  end)\n+\n+  itp('40state_selection', function()\n+    local vt = init()\n+    wantstate(vt)\n+\n+    -- Set clipboard; final chunk len 4\n+    push('\\x1b]52;c;SGVsbG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello,]')\n+\n+    -- Set clipboard; final chunk len 3\n+    push('\\x1b]52;c;SGVsbG8sIHc=\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello, w]')\n+\n+    -- Set clipboard; final chunk len 2\n+    push('\\x1b]52;c;SGVsbG8sIHdvcmxkCg==\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello, world\\n]')\n+\n+    -- Set clipboard; split between chunks\n+    push('\\x1b]52;c;SGVs', vt)\n+    expect('selection-set mask=0001 [Hel')\n+    push('bG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 lo,]')\n+\n+    -- Set clipboard; split within chunk\n+    push('\\x1b]52;c;SGVsbG', vt)\n+    expect('selection-set mask=0001 [Hel')\n+    push('8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 lo,]')\n+\n+    -- Set clipboard; empty first chunk\n+    push('\\x1b]52;c;', vt)\n+    push('SGVsbG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello,]')\n+\n+    -- Set clipboard; empty final chunk\n+    push('\\x1b]52;c;SGVsbG8s', vt)\n+    expect('selection-set mask=0001 [Hello,')\n+    push('\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 ]')\n+\n+    -- Set clipboard; longer than buffer\n+    push('\\x1b]52;c;' .. string.rep('LS0t', 10) .. '\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [---------------\\nselection-set mask=0001 ---------------]')\n+\n+    -- Clear clipboard\n+    push('\\x1b]52;c;\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 []')\n+\n+    -- Set invalid data clears and ignores\n+    push('\\x1b]52;c;SGVs*SGVsbG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 []')\n+\n+    -- Query clipboard\n+    push('\\x1b]52;c;?\\x1b\\\\', vt)\n+    expect('selection-query mask=0001')\n+\n+    -- TODO(dundargoc): fix\n+    -- -- Send clipboard; final chunk len 4\n+    -- SELECTION 1 [\"Hello,\"]\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVsbG8s\"\n+    --   output \"\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; final chunk len 3\n+    -- SELECTION 1 [\"Hello, w\"]\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVsbG8s\"\n+    --   output \"IHc=\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; final chunk len 2\n+    -- SELECTION 1 [\"Hello, world\\n\"]\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVsbG8sIHdvcmxk\"\n+    --   output \"Cg==\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; split between chunks\n+    -- SELECTION 1 [\"Hel\"\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVs\"\n+    -- SELECTION 1  \"lo,\"]\n+    --   output \"bG8s\"\n+    --   output \"\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; split within chunk\n+    -- SELECTION 1 [\"Hello\"\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVs\"\n+    -- SELECTION 1 \",\"]\n+    --   output \"bG8s\"\n+    --   output \"\\x1b\\\\\"\n+  end)\n+\n+  itp('60screen_ascii', function()\n+    local vt = init()\n+    local screen = wantscreen(vt, { a = true, c = true })\n+\n+    -- Get\n+    reset(nil, screen)\n+    push('ABC', vt)\n+    expect('movecursor 0,3')\n+    screen_chars(0, 0, 1, 3, 'ABC', screen)\n+    screen_chars(0, 0, 1, 80, 'ABC', screen)\n+    screen_text(0, 0, 1, 3, '41,42,43', screen)\n+    screen_text(0, 0, 1, 80, '41,42,43', screen)\n+    screen_cell(0, 0, '{41} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 1, '{42} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 2, '{43} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_row(0, 'ABC', screen)\n+    screen_eol(0, 0, 0, screen)\n+    screen_eol(0, 2, 0, screen)\n+    screen_eol(0, 3, 1, screen)\n+    push('\\x1b[H', vt)\n+    expect('movecursor 0,0')\n+    screen_row(0, 'ABC', screen)\n+    screen_text(0, 0, 1, 80, '41,42,43', screen)\n+    push('E', vt)\n+    expect('movecursor 0,1')\n+    screen_row(0, 'EBC', screen)\n+    screen_text(0, 0, 1, 80, '45,42,43', screen)\n+\n+    screen = wantscreen(vt, { a = true })\n+\n+    -- Erase\n+    reset(nil, screen)\n+    push('ABCDE\\x1b[H\\x1b[K', vt)\n+    -- TODO(dundargoc): fix\n+    -- screen_row(0, '', screen)\n+    screen_text(0, 0, 1, 80, '', screen)\n+\n+    -- Copycell\n+    reset(nil, screen)\n+    push('ABC\\x1b[H\\x1b[@', vt)\n+    push('1', vt)\n+    screen_row(0, '1ABC', screen)\n+\n+    reset(nil, screen)\n+    push('ABC\\x1b[H\\x1b[P', vt)\n+    screen_chars(0, 0, 1, 1, 'B', screen)\n+    screen_chars(0, 1, 1, 2, 'C', screen)\n+    screen_chars(0, 0, 1, 80, 'BC', screen)\n+\n+    -- Space padding\n+    reset(nil, screen)\n+    push('Hello\\x1b[CWorld', vt)\n+    screen_row(0, 'Hello World', screen)\n+    screen_text(0, 0, 1, 80, '48,65,6c,6c,6f,20,57,6f,72,6c,64', screen)\n+\n+    -- Linefeed padding\n+    reset(nil, screen)\n+    push('Hello\\r\\nWorld', vt)\n+    screen_chars(0, 0, 2, 80, 'Hello\\nWorld', screen)\n+    screen_text(0, 0, 2, 80, '48,65,6c,6c,6f,0a,57,6f,72,6c,64', screen)\n+\n+    -- Altscreen\n+    reset(nil, screen)\n+    push('P', vt)\n+    screen_row(0, 'P', screen)\n+    -- TODO(dundargoc): fix\n+    -- push('\\x1b[?1049h', vt)\n+    -- screen_row(0, '', screen)\n+    -- push('\\x1b[2K\\x1b[HA', vt)\n+    -- screen_row(0, 'A', screen)\n+    -- push('\\x1b[?1049l', vt)\n+    -- screen_row(0, 'P', screen)\n+  end)\n+\n+  itp('61screen_unicode', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    -- Single width UTF-8\n+    -- U+00C1 = C3 81  name: LATIN CAPITAL LETTER A WITH ACUTE\n+    -- U+00E9 = C3 A9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(nil, screen)\n+    push('\\xC3\\x81\\xC3\\xA9', vt)\n+    screen_row(0, 'Áé', screen)\n+    screen_text(0, 0, 1, 80, 'c3,81,c3,a9', screen)\n+    screen_cell(0, 0, '{c1} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Wide char\n+    -- U+FF10 = EF BC 90  name: FULLWIDTH DIGIT ZERO\n+    reset(nil, screen)\n+    push('0123\\x1b[H', vt)\n+    push('\\xEF\\xBC\\x90', vt)\n+    screen_row(0, '０23', screen)\n+    screen_text(0, 0, 1, 80, 'ef,bc,90,32,33', screen)\n+    screen_cell(0, 0, '{ff10} width=2 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Combining char\n+    -- U+0301 = CC 81  name: COMBINING ACUTE\n+    reset(nil, screen)\n+    push('0123\\x1b[H', vt)\n+    push('e\\xCC\\x81', vt)\n+    screen_row(0, 'é123', screen)\n+    screen_text(0, 0, 1, 80, '65,cc,81,31,32,33', screen)\n+    screen_cell(0, 0, '{65,301} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- 10 combining accents should not crash\n+    reset(nil, screen)\n+    push('e\\xCC\\x81\\xCC\\x82\\xCC\\x83\\xCC\\x84\\xCC\\x85\\xCC\\x86\\xCC\\x87\\xCC\\x88\\xCC\\x89\\xCC\\x8A', vt)\n+    screen_cell(\n+      0,\n+      0,\n+      '{65,301,302,303,304,305} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)',\n+      screen\n+    )\n+\n+    -- 40 combining accents in two split writes of 20 should not crash\n+    reset(nil, screen)\n+    push(\n+      'e\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81',\n+      vt\n+    )\n+    push(\n+      '\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81',\n+      vt\n+    )\n+    screen_cell(\n+      0,\n+      0,\n+      '{65,301,301,301,301,301} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)',\n+      screen\n+    )\n+\n+    -- Outputing CJK doublewidth in 80th column should wraparound to next line and not crash\"\n+    reset(nil, screen)\n+    push('\\x1b[80G\\xEF\\xBC\\x90', vt)\n+    screen_cell(0, 79, '{} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(1, 0, '{ff10} width=2 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+  end)\n+\n+  pending('62screen_damage', function() end)\n+\n+  itp('63screen_resize', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+    local screen = wantscreen(vt)\n+\n+    -- Resize wider preserves cells\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('AB\\r\\nCD', vt)\n+    screen_chars(0, 0, 1, 80, 'AB', screen)\n+    screen_chars(1, 0, 2, 80, 'CD', screen)\n+    resize(25, 100, vt)\n+    screen_chars(0, 0, 1, 100, 'AB', screen)\n+    screen_chars(1, 0, 2, 100, 'CD', screen)\n+\n+    -- Resize wider allows print in new area\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('AB\\x1b[79GCD', vt)\n+    screen_chars(0, 0, 1, 2, 'AB', screen)\n+    screen_chars(0, 78, 1, 80, 'CD', screen)\n+    resize(25, 100, vt)\n+    screen_chars(0, 0, 1, 2, 'AB', screen)\n+    screen_chars(0, 78, 1, 80, 'CD', screen)\n+    push('E', vt)\n+    screen_chars(0, 78, 1, 81, 'CDE', screen)\n+\n+    -- Resize shorter with blanks just truncates\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('Top\\x1b[10HLine 10', vt)\n+    screen_row(0, 'Top', screen)\n+    screen_row(9, 'Line 10', screen)\n+    cursor(9, 7, state)\n+    resize(20, 80, vt)\n+    screen_row(0, 'Top', screen)\n+    screen_row(9, 'Line 10', screen)\n+    cursor(9, 7, state)\n+\n+    -- Resize shorter with content must scroll\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('Top\\x1b[25HLine 25\\x1b[15H', vt)\n+    screen_row(0, 'Top', screen)\n+    screen_row(24, 'Line 25', screen)\n+    cursor(14, 0, state)\n+    screen = wantscreen(vt, { b = true })\n+    resize(20, 80, vt)\n+    expect(\n+      'sb_pushline 80 = 54 6F 70\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 ='\n+    )\n+    -- TODO(dundargoc): fix or remove\n+    -- screen_row( 0  , \"\",screen)\n+    screen_row(19, 'Line 25', screen)\n+    cursor(9, 0, state)\n+\n+    -- Resize shorter does not lose line with cursor\n+    -- See also https://github.com/neovim/libvterm/commit/1b745d29d45623aa8d22a7b9288c7b0e331c7088\n+    reset(state, screen)\n+    wantscreen(vt)\n+    resize(25, 80, vt)\n+    screen = wantscreen(vt, { b = true })\n+    push('\\x1b[24HLine 24\\r\\nLine 25\\r\\n', vt)\n+    expect('sb_pushline 80 =')\n+    screen_row(23, 'Line 25', screen)\n+    cursor(24, 0, state)\n+    resize(24, 80, vt)\n+    expect('sb_pushline 80 =')\n+    screen_row(22, 'Line 25', screen)\n+    cursor(23, 0, state)\n+\n+    -- Resize shorter does not send the cursor to a negative row\n+    -- See also https://github.com/vim/vim/pull/6141\n+    reset(state, screen)\n+    wantscreen(vt)\n+    resize(25, 80, vt)\n+    screen = wantscreen(vt, { b = true })\n+    push('\\x1b[24HLine 24\\r\\nLine 25\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    resize(20, 80, vt)\n+    expect(\n+      'sb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 ='\n+    )\n+    cursor(0, 0, state)\n+\n+    -- Resize taller attempts to pop scrollback\n+    reset(state, screen)\n+    screen = wantscreen(vt)\n+    resize(25, 80, vt)\n+    push('Line 1\\x1b[25HBottom\\x1b[15H', vt)\n+    screen_row(0, 'Line 1', screen)\n+    screen_row(24, 'Bottom', screen)\n+    cursor(14, 0, state)\n+    screen = wantscreen(vt, { b = true })\n+    resize(30, 80, vt)\n+    expect('sb_popline 80\\nsb_popline 80\\nsb_popline 80\\nsb_popline 80\\nsb_popline 80')\n+    screen_row(0, 'ABCDE', screen)\n+    screen_row(5, 'Line 1', screen)\n+    screen_row(29, 'Bottom', screen)\n+    cursor(19, 0, state)\n+    screen = wantscreen(vt)\n+\n+    -- Resize can operate on altscreen\n+    reset(state, screen)\n+    screen = wantscreen(vt, { a = true })\n+    resize(25, 80, vt)\n+    push('Main screen\\x1b[?1049h\\x1b[HAlt screen', vt)\n+    resize(30, 80, vt)\n+    screen_row(0, 'Alt screen', screen)\n+    push('\\x1b[?1049l', vt)\n+    screen_row(0, 'Main screen', screen)\n+  end)\n+\n+  itp('64screen_pen', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    -- Plain\n+    push('A', vt)\n+    screen_cell(0, 0, '{41} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Bold\n+    push('\\x1b[1mB', vt)\n+    screen_cell(0, 1, '{42} width=1 attrs={B} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Italic\n+    push('\\x1b[3mC', vt)\n+    screen_cell(0, 2, '{43} width=1 attrs={BI} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Underline\n+    push('\\x1b[4mD', vt)\n+    screen_cell(0, 3, '{44} width=1 attrs={BU1I} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Reset\n+    push('\\x1b[mE', vt)\n+    screen_cell(0, 4, '{45} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Font\n+    push('\\x1b[11mF\\x1b[m', vt)\n+    screen_cell(0, 5, '{46} width=1 attrs={F1} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Foreground\n+    push('\\x1b[31mG\\x1b[m', vt)\n+    screen_cell(0, 6, '{47} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(0,0,0)', screen)\n+\n+    -- Background\n+    push('\\x1b[42mH\\x1b[m', vt)\n+    screen_cell(0, 7, '{48} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,224,0)', screen)\n+\n+    -- Super/subscript\n+    push('x\\x1b[74m0\\x1b[73m2\\x1b[m', vt)\n+    screen_cell(0, 8, '{78} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 9, '{30} width=1 attrs={S_} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 10, '{32} width=1 attrs={S^} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- EL sets only colours to end of line, not other attrs\n+    push('\\x1b[H\\x1b[7;33;44m\\x1b[K', vt)\n+    screen_cell(0, 0, '{} width=1 attrs={} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+    screen_cell(0, 79, '{} width=1 attrs={} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+\n+    -- DECSCNM xors reverse for entire screen\n+    push('R\\x1b[?5h', vt)\n+    screen_cell(0, 0, '{52} width=1 attrs={} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+    screen_cell(1, 0, '{} width=1 attrs={R} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    push('\\x1b[?5$p', vt)\n+    expect_output('\\x1b[?5;1$y')\n+    push('\\x1b[?5l', vt)\n+    screen_cell(0, 0, '{52} width=1 attrs={R} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+    screen_cell(1, 0, '{} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    -- TODO(dundargoc): fix\n+    -- push('\\x1b[?5$p')\n+    -- expect_output('\\x1b[?5;2$y')\n+\n+    -- Set default colours\n+    reset(nil, screen)\n+    push('ABC\\x1b[31mDEF\\x1b[m', vt)\n+    screen_cell(0, 0, '{41} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 3, '{44} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(0,0,0)', screen)\n+    -- TODO(dundargoc): fix\n+    -- SETDEFAULTCOL rgb(252,253,254)\n+    --   ?screen_cell 0,0  = {41} width=1 attrs={} fg=rgb(252,253,254) bg=rgb(0,0,0)\n+    --   ?screen_cell 0,3  = {44} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(0,0,0)\n+    -- SETDEFAULTCOL rgb(250,250,250) rgb(10,20,30)\n+    --   ?screen_cell 0,0  = {41} width=1 attrs={} fg=rgb(250,250,250) bg=rgb(10,20,30)\n+    --   ?screen_cell 0,3  = {44} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(10,20,30)\n+  end)\n+\n+  itp('65screen_protect', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    -- Selective erase\n+    reset(nil, screen)\n+    push('A\\x1b[1\"qB\\x1b[\"qC', vt)\n+    screen_row(0, 'ABC', screen)\n+    push('\\x1b[G\\x1b[?J', vt)\n+    screen_row(0, ' B', screen)\n+\n+    -- Non-selective erase\n+    reset(nil, screen)\n+    push('A\\x1b[1\"qB\\x1b[\"qC', vt)\n+    screen_row(0, 'ABC', screen)\n+    -- TODO(dundargoc): fix\n+    -- push('\\x1b[G\\x1b[J', vt)\n+    -- screen_row(0, '', screen)\n+  end)\n+\n+  itp('66screen_extent', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    -- Bold extent\n+    reset(nil, screen)\n+    push('AB\\x1b[1mCD\\x1b[mE', vt)\n+    screen_attrs_extent(0, 0, '0,0-1,1', screen)\n+    screen_attrs_extent(0, 1, '0,0-1,1', screen)\n+    screen_attrs_extent(0, 2, '0,2-1,3', screen)\n+    screen_attrs_extent(0, 3, '0,2-1,3', screen)\n+    screen_attrs_extent(0, 4, '0,4-1,79', screen)\n+  end)\n+\n+  itp('67screen_dbl_wh', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    -- Single Width, Single Height\n+    reset(nil, screen)\n+    push('\\x1b#5', vt)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Double Width, Single Height\n+    reset(nil, screen)\n+    push('\\x1b#6', vt)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} dwl fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Double Height\n+    reset(nil, screen)\n+    push('\\x1b#3', vt)\n+    push('abcde', vt)\n+    push('\\r\\n\\x1b#4', vt)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} dwl dhl-top fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(\n+      1,\n+      0,\n+      '{61} width=1 attrs={} dwl dhl-bottom fg=rgb(240,240,240) bg=rgb(0,0,0)',\n+      screen\n+    )\n+\n+    -- Late change\n+    reset(nil, screen)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    push('\\x1b#6', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} dwl fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- DWL doesn't spill over on scroll\n+    reset(nil, screen)\n+    push('\\x1b[25H\\x1b#6Final\\r\\n', vt)\n+    screen_cell(23, 0, '{46} width=1 attrs={} dwl fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(24, 0, '{} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+  end)\n+\n+  itp('68screen_termprops', function()\n+    local vt = init()\n+    local screen = wantscreen(vt, { p = true })\n+\n+    reset(nil, screen)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+\n+    -- Cursor visibility\n+    push('\\x1b[?25h', vt)\n+    expect('settermprop 1 true')\n+    push('\\x1b[?25l', vt)\n+    expect('settermprop 1 false')\n+\n+    -- Title\n+    push('\\x1b]2;Here is my title\\a', vt)\n+    expect('settermprop 4 [\"Here is my title\"]')\n+  end)\n+\n+  itp('69screen_pushline', function()\n+    local vt = init()\n+    -- Run these tests on a much smaller default screen, so debug output is nowhere near as noisy\n+    resize(5, 10, vt)\n+    local state = wantstate(vt)\n+    local screen = wantscreen(vt, { r = true })\n+    reset(state, screen)\n+\n+    -- Resize wider reflows wide lines\n+    reset(state, screen)\n+    push(string.rep('A', 12), vt)\n+    screen_row(0, 'AAAAAAAAAA', screen, vt.cols)\n+    screen_row(1, 'AA', screen, vt.cols)\n+    lineinfo(1, { cont = true }, state)\n+    cursor(1, 2, state)\n+    resize(5, 15, vt)\n+    screen_row(0, 'AAAAAAAAAAAA', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row(1, '', screen, vt.cols)\n+    lineinfo(1, {}, state)\n+    cursor(0, 12, state)\n+    resize(5, 20, vt)\n+    screen_row(0, 'AAAAAAAAAAAA', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 ,'',screen, vt.cols)\n+    lineinfo(1, {}, state)\n+    cursor(0, 12, state)\n+\n+    -- Resize narrower can create continuation lines\n+    reset(state, screen)\n+    resize(5, 10, vt)\n+    push('ABCDEFGHI', vt)\n+    screen_row(0, 'ABCDEFGHI', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen, vt.cols)\n+    lineinfo(1, {}, state)\n+    cursor(0, 9, state)\n+    resize(5, 8, vt)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 0 , \"ABCDEFGH\",screen,vt.cols)\n+    screen_row(1, 'I', screen, vt.cols)\n+    lineinfo(1, { cont = true }, state)\n+    cursor(1, 1, state)\n+    resize(5, 6, vt)\n+    screen_row(0, 'ABCDEF', screen, vt.cols)\n+    screen_row(1, 'GHI', screen, vt.cols)\n+    lineinfo(1, { cont = true }, state)\n+    cursor(1, 3, state)\n+\n+    -- Shell wrapped prompt behaviour\n+    reset(state, screen)\n+    resize(5, 10, vt)\n+    push('PROMPT GOES HERE\\r\\n> \\r\\n\\r\\nPROMPT GOES HERE\\r\\n> ', vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    screen_row(2, 'PROMPT GOE', screen, vt.cols)\n+    screen_row(3, 'S HERE', screen, vt.cols)\n+    lineinfo(3, { cont = true }, state)\n+    screen_row(4, '> ', screen, vt.cols)\n+    cursor(4, 2, state)\n+    resize(5, 11, vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    screen_row(2, 'PROMPT GOES', screen, vt.cols)\n+    screen_row(3, ' HERE', screen, vt.cols)\n+    lineinfo(3, { cont = true }, state)\n+    screen_row(4, '> ', screen, vt.cols)\n+    cursor(4, 2, state)\n+    resize(5, 12, vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    screen_row(2, 'PROMPT GOES ', screen, vt.cols)\n+    screen_row(3, 'HERE', screen, vt.cols)\n+    lineinfo(3, { cont = true }, state)\n+    screen_row(4, '> ', screen, vt.cols)\n+    cursor(4, 2, state)\n+    resize(5, 16, vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    -- screen_row( 2 , \"PROMPT GOES HERE\",screen,vt.cols)\n+    lineinfo(3, {}, state)\n+    screen_row(3, '> ', screen, vt.cols)\n+    cursor(3, 2, state)\n+\n+    -- Cursor goes missing\n+    -- For more context: https://github.com/neovim/neovim/pull/21124\n+    reset(state, screen)\n+    resize(5, 5, vt)\n+    resize(3, 1, vt)\n+    push('\\x1b[2;1Habc\\r\\n\\x1b[H', vt)\n+    resize(1, 1, vt)\n+    cursor(0, 0, state)\n+  end)\n+\n+  pending('90vttest_01-movement-1', function() end)\n+  pending('90vttest_01-movement-2', function() end)\n+\n+  itp('90vttest_01-movement-3', function()\n+    -- Test of cursor-control characters inside ESC sequences\n+    local vt = init()\n+    local state = wantstate(vt)\n+    local screen = wantscreen(vt)\n+\n+    reset(state, screen)\n+\n+    push('A B C D E F G H I', vt)\n+    push('\\x0d\\x0a', vt)\n+    push('A\\x1b[2\\bCB\\x1b[2\\bCC\\x1b[2\\bCD\\x1b[2\\bCE\\x1b[2\\bCF\\x1b[2\\bCG\\x1b[2\\bCH\\x1b[2\\bCI', vt)\n+    push('\\x0d\\x0a', vt)\n+    push(\n+      'A \\x1b[\\x0d2CB\\x1b[\\x0d4CC\\x1b[\\x0d6CD\\x1b[\\x0d8CE\\x1b[\\x0d10CF\\x1b[\\x0d12CG\\x1b[\\x0d14CH\\x1b[\\x0d16CI',\n+      vt\n+    )\n+    push('\\x0d\\x0a', vt)\n+    push(\n+      'A \\x1b[1\\x0bAB \\x1b[1\\x0bAC \\x1b[1\\x0bAD \\x1b[1\\x0bAE \\x1b[1\\x0bAF \\x1b[1\\x0bAG \\x1b[1\\x0bAH \\x1b[1\\x0bAI \\x1b[1\\x0bA',\n+      vt\n+    )\n+\n+    -- Output\n+\n+    for i = 0, 2 do\n+      screen_row(i, 'A B C D E F G H I', screen)\n+    end\n+    screen_row(3, 'A B C D E F G H I ', screen)\n+\n+    cursor(3, 18, state)\n+  end)\n+\n+  itp('90vttest_01-movement-4', function()\n+    -- Test of leading zeroes in ESC sequences\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    push('\\x1b[00000000004;000000001HT', vt)\n+    push('\\x1b[00000000004;000000002Hh', vt)\n+    push('\\x1b[00000000004;000000003Hi', vt)\n+    push('\\x1b[00000000004;000000004Hs', vt)\n+    push('\\x1b[00000000004;000000005H ', vt)\n+    push('\\x1b[00000000004;000000006Hi', vt)\n+    push('\\x1b[00000000004;000000007Hs', vt)\n+    push('\\x1b[00000000004;000000008H ', vt)\n+    push('\\x1b[00000000004;000000009Ha', vt)\n+    push('\\x1b[00000000004;0000000010H ', vt)\n+    push('\\x1b[00000000004;0000000011Hc', vt)\n+    push('\\x1b[00000000004;0000000012Ho', vt)\n+    push('\\x1b[00000000004;0000000013Hr', vt)\n+    push('\\x1b[00000000004;0000000014Hr', vt)\n+    push('\\x1b[00000000004;0000000015He', vt)\n+    push('\\x1b[00000000004;0000000016Hc', vt)\n+    push('\\x1b[00000000004;0000000017Ht', vt)\n+    push('\\x1b[00000000004;0000000018H ', vt)\n+    push('\\x1b[00000000004;0000000019Hs', vt)\n+    push('\\x1b[00000000004;0000000020He', vt)\n+    push('\\x1b[00000000004;0000000021Hn', vt)\n+    push('\\x1b[00000000004;0000000022Ht', vt)\n+    push('\\x1b[00000000004;0000000023He', vt)\n+    push('\\x1b[00000000004;0000000024Hn', vt)\n+    push('\\x1b[00000000004;0000000025Hc', vt)\n+    push('\\x1b[00000000004;0000000026He', vt)\n+\n+    -- Output\n+\n+    screen_row(3, 'This is a correct sentence', screen)\n+  end)\n+\n+  pending('90vttest_02-screen-1', function() end)\n+  pending('90vttest_02-screen-2', function() end)\n+\n+  itp('90vttest_02-screen-3', function()\n+    -- Origin mode\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[23;24r', vt)\n+    push('\\n', vt)\n+    push('Bottom', vt)\n+    push('\\x1b[1;1H', vt)\n+    push('Above', vt)\n+\n+    -- Output\n+    screen_row(22, 'Above', screen)\n+    screen_row(23, 'Bottom', screen)\n+  end)\n+\n+  itp('90vttest_02-screen-4', function()\n+    -- Origin mode (2)\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    push('\\x1b[?6l', vt)\n+    push('\\x1b[23;24r', vt)\n+    push('\\x1b[24;1H', vt)\n+    push('Bottom', vt)\n+    push('\\x1b[1;1H', vt)\n+    push('Top', vt)\n+\n+    -- Output\n+    screen_row(23, 'Bottom', screen)\n+    screen_row(0, 'Top', screen)\n+  end)\n+\n+  itp('92lp1640917', function()",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1809567019",
            "id": 1809567019,
            "in_reply_to_id": 1809564001,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5r280r",
            "original_commit_id": "eec2162be6d8484d1eaf73082e4db58763c4871b",
            "original_line": 3575,
            "original_position": 3575,
            "original_start_line": null,
            "path": "test/unit/vterm_spec.lua",
            "position": null,
            "pull_request_review_id": 2383348790,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809567019/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-21T21:32:41Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809567019",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1809567365"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809567365"
                }
            },
            "author_association": "MEMBER",
            "body": "Shall I change it to something more readable/useful?",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-10-21T21:32:53Z",
            "diff_hunk": "@@ -0,0 +1,3590 @@\n+local t = require('test.unit.testutil')\n+local itp = t.gen_itp(it)\n+local bit = require('bit')\n+\n+--- @class vterm\n+--- @field ENC_UTF8 integer\n+--- @field VTERM_ATTR_BLINK integer\n+--- @field VTERM_ATTR_BOLD integer\n+--- @field VTERM_ATTR_FONT integer\n+--- @field VTERM_ATTR_ITALIC integer\n+--- @field VTERM_ATTR_REVERSE integer\n+--- @field VTERM_ATTR_UNDERLINE integer\n+--- @field VTERM_BASELINE_RAISE integer\n+--- @field VTERM_KEY_ENTER integer\n+--- @field VTERM_KEY_FUNCTION_0 integer\n+--- @field VTERM_KEY_KP_0 integer\n+--- @field VTERM_KEY_NONE integer\n+--- @field VTERM_KEY_TAB integer\n+--- @field VTERM_KEY_UP integer\n+--- @field VTERM_MAX_CHARS_PER_CELL integer\n+--- @field VTERM_MOD_ALT integer\n+--- @field VTERM_MOD_CTRL integer\n+--- @field VTERM_MOD_SHIFT integer\n+--- @field parser_apc function\n+--- @field parser_csi function\n+--- @field parser_dcs function\n+--- @field parser_osc function\n+--- @field parser_pm function\n+--- @field parser_sos function\n+--- @field parser_text function\n+--- @field print_color function\n+--- @field screen_sb_clear function\n+--- @field screen_sb_popline function\n+--- @field screen_sb_pushline function\n+--- @field selection_query function\n+--- @field selection_set function\n+--- @field state_erase function\n+--- @field state_movecursor function\n+--- @field state_moverect function\n+--- @field state_pos function\n+--- @field state_putglyph function\n+--- @field state_sb_clear function\n+--- @field state_scrollrect function\n+--- @field state_setpenattr function\n+--- @field state_settermprop function\n+--- @field term_output function\n+--- @field vterm_input_write function\n+--- @field vterm_keyboard_end_paste function\n+--- @field vterm_keyboard_key function\n+--- @field vterm_keyboard_start_paste function\n+--- @field vterm_keyboard_unichar function\n+--- @field vterm_lookup_encoding fun(any, any):any\n+--- @field vterm_mouse_button function\n+--- @field vterm_mouse_move function\n+--- @field vterm_new fun(any, any):any\n+--- @field vterm_obtain_screen fun(any):any\n+--- @field vterm_obtain_state fun(any): any\n+--- @field vterm_output_set_callback function\n+--- @field vterm_parser_set_callbacks fun(any, any, any):any\n+--- @field vterm_screen_convert_color_to_rgb function\n+--- @field vterm_screen_enable_altscreen function\n+--- @field vterm_screen_enable_reflow function\n+--- @field vterm_screen_get_attrs_extent function\n+--- @field vterm_screen_get_cell function\n+--- @field vterm_screen_get_chars fun(any, any, any, any):any\n+--- @field vterm_screen_get_text fun(any, any, any, any):any\n+--- @field vterm_screen_is_eol fun(any, any):any\n+--- @field vterm_screen_reset function\n+--- @field vterm_screen_set_callbacks function\n+--- @field vterm_set_size function\n+--- @field vterm_set_utf8 fun(any, any, any):any\n+--- @field vterm_state_focus_in function\n+--- @field vterm_state_focus_out function\n+--- @field vterm_state_get_cursorpos fun(any, any)\n+--- @field vterm_state_get_lineinfo fun(any, any):any\n+--- @field vterm_state_get_penattr function\n+--- @field vterm_state_reset function\n+--- @field vterm_state_set_bold_highbright function\n+--- @field vterm_state_set_callbacks function\n+--- @field vterm_state_set_selection_callbacks function\n+--- @field vterm_state_set_unrecognised_fallbacks function\n+local vterm = t.cimport('./src/vterm/vterm.h', './src/vterm/vterm_internal.h')\n+\n+--- @return string\n+local function read_rm()\n+  local f = assert(io.open(t.paths.vterm_test_file, 'rb'))\n+  local text = f:read('*a')\n+  f:close()\n+  vim.fs.rm(t.paths.vterm_test_file, { force = true })\n+  return text\n+end\n+\n+local function append(str)\n+  local f = assert(io.open(t.paths.vterm_test_file, 'a'))\n+  f:write(str)\n+  f:close()\n+  return 1\n+end\n+\n+local function parser_control(control)\n+  return append(string.format('control %02x\\n', control))\n+end\n+\n+local function parser_escape(bytes)\n+  return append(string.format('escape %s\\n', t.ffi.string(bytes)))\n+end\n+\n+local function wantparser(vt)\n+  assert(vt)\n+\n+  local parser_cbs = t.ffi.new('VTermParserCallbacks')\n+  parser_cbs['text'] = vterm.parser_text\n+  parser_cbs['control'] = parser_control\n+  parser_cbs['escape'] = parser_escape\n+  parser_cbs['csi'] = vterm.parser_csi\n+  parser_cbs['osc'] = vterm.parser_osc\n+  parser_cbs['dcs'] = vterm.parser_dcs\n+  parser_cbs['apc'] = vterm.parser_apc\n+  parser_cbs['pm'] = vterm.parser_pm\n+  parser_cbs['sos'] = vterm.parser_sos\n+\n+  vterm.vterm_parser_set_callbacks(vt, parser_cbs, nil)\n+end\n+\n+--- @return any\n+local function init()\n+  local vt = vterm.vterm_new(25, 80)\n+  vterm.vterm_output_set_callback(vt, vterm.term_output, nil)\n+  vterm.vterm_set_utf8(vt, true)\n+  return vt\n+end\n+\n+local function state_setlineinfo()\n+  return 1\n+end\n+\n+--- @return any\n+local function wantstate(vt, opts)\n+  opts = opts or {}\n+  assert(vt)\n+  local state = vterm.vterm_obtain_state(vt)\n+\n+  local state_cbs = t.ffi.new('VTermStateCallbacks')\n+  state_cbs['putglyph'] = vterm.state_putglyph\n+  state_cbs['movecursor'] = vterm.state_movecursor\n+  state_cbs['scrollrect'] = vterm.state_scrollrect\n+  state_cbs['moverect'] = vterm.state_moverect\n+  state_cbs['erase'] = vterm.state_erase\n+  state_cbs['setpenattr'] = vterm.state_setpenattr\n+  state_cbs['settermprop'] = vterm.state_settermprop\n+  state_cbs['setlineinfo'] = state_setlineinfo\n+  state_cbs['sb_clear'] = vterm.state_sb_clear\n+\n+  local selection_cbs = t.ffi.new('VTermSelectionCallbacks')\n+  selection_cbs['set'] = vterm.selection_set\n+  selection_cbs['query'] = vterm.selection_query\n+\n+  vterm.vterm_state_set_callbacks(state, state_cbs, nil)\n+\n+  -- In some tests we want to check the behaviour of overflowing the buffer, so make it nicely small\n+  vterm.vterm_state_set_selection_callbacks(state, selection_cbs, nil, nil, 16)\n+  vterm.vterm_state_set_bold_highbright(state, 1)\n+  vterm.vterm_state_reset(state, 1)\n+\n+  local fallbacks = t.ffi.new('VTermStateFallbacks')\n+  fallbacks['control'] = parser_control\n+  fallbacks['csi'] = vterm.parser_csi\n+  fallbacks['osc'] = vterm.parser_osc\n+  fallbacks['dcs'] = vterm.parser_dcs\n+  fallbacks['apc'] = vterm.parser_apc\n+  fallbacks['pm'] = vterm.parser_pm\n+  fallbacks['sos'] = vterm.parser_sos\n+\n+  vterm.want_state_scrollback = opts.b or false\n+  vterm.want_state_erase = opts.e or false\n+  vterm.vterm_state_set_unrecognised_fallbacks(state, opts.f and fallbacks or nil, nil)\n+  vterm.want_state_putglyph = opts.g or false\n+  vterm.want_state_moverect = opts.m or false\n+  vterm.want_state_settermprop = opts.p or false\n+  vterm.want_state_scrollrect = opts.s or false\n+\n+  return state\n+end\n+\n+--- @return any\n+local function wantscreen(vt, opts)\n+  opts = opts or {}\n+  local screen = vterm.vterm_obtain_screen(vt)\n+  local screen_cbs = t.ffi.new('VTermScreenCallbacks')\n+\n+  -- TODO(dundargoc): fix\n+  -- screen_cbs['damage']      = vterm.screen_damage\n+  screen_cbs['moverect'] = vterm.state_moverect\n+  screen_cbs['movecursor'] = vterm.state_movecursor\n+  screen_cbs['settermprop'] = vterm.state_settermprop\n+  screen_cbs['sb_pushline'] = vterm.screen_sb_pushline\n+  screen_cbs['sb_popline'] = vterm.screen_sb_popline\n+  screen_cbs['sb_clear'] = vterm.screen_sb_clear\n+\n+  vterm.vterm_screen_set_callbacks(screen, screen_cbs, nil)\n+\n+  if opts.a then\n+    vterm.vterm_screen_enable_altscreen(screen, 1)\n+  end\n+  vterm.want_screen_scrollback = opts.b or false\n+  vterm.want_state_movecursor = opts.c or false\n+  -- TODO(dundargoc): fix\n+  -- vterm.want_screen_damage = opts.d or opts.D or false\n+  -- vterm.want_screen_cells = opts.D or false\n+  vterm.want_state_moverect = opts.m or false\n+  vterm.want_state_settermprop = opts.p or false\n+  if opts.r then\n+    vterm.vterm_screen_enable_reflow(screen, true)\n+  end\n+\n+  return screen\n+end\n+\n+local function reset(state, screen)\n+  if state then\n+    vterm.vterm_state_reset(state, 1)\n+    vterm.vterm_state_get_cursorpos(state, vterm.state_pos)\n+  end\n+  if screen then\n+    vterm.vterm_screen_reset(screen, 1)\n+  end\n+end\n+\n+local function push(input, vt)\n+  vterm.vterm_input_write(vt, input, string.len(input))\n+end\n+\n+local function expect(expected)\n+  local actual = read_rm()\n+  t.eq(expected .. '\\n', actual)\n+end\n+\n+local function expect_output(expected_preformat)\n+  local actual = read_rm()\n+  local expected = 'output '\n+\n+  for c in string.gmatch(expected_preformat, '.') do\n+    if expected ~= 'output ' then\n+      expected = expected .. ','\n+    end\n+    expected = string.format('%s%x', expected, string.byte(c))\n+  end\n+\n+  t.eq(expected .. '\\n', actual)\n+end\n+\n+local function cursor(row, col, state)\n+  local pos = t.ffi.new('VTermPos') --- @type {row: integer, col: integer}\n+  vterm.vterm_state_get_cursorpos(state, pos)\n+  t.eq(row, pos.row)\n+  t.eq(col, pos.col)\n+end\n+\n+local function lineinfo(row, expected, state)\n+  local info = vterm.vterm_state_get_lineinfo(state, row)\n+  local dwl = info.doublewidth == 1\n+  local dhl = info.doubleheight == 1\n+  local cont = info.continuation == 1\n+\n+  t.eq(dwl, expected.dwl or false)\n+  t.eq(dhl, expected.dhl or false)\n+  t.eq(cont, expected.cont or false)\n+end\n+\n+local function pen(attribute, expected, state)\n+  local is_bool = { bold = true, italic = true, blink = true, reverse = true }\n+  local vterm_attribute = {\n+    bold = vterm.VTERM_ATTR_BOLD,\n+    underline = vterm.VTERM_ATTR_UNDERLINE,\n+    italic = vterm.VTERM_ATTR_ITALIC,\n+    blink = vterm.VTERM_ATTR_BLINK,\n+    reverse = vterm.VTERM_ATTR_REVERSE,\n+    font = vterm.VTERM_ATTR_FONT,\n+  }\n+\n+  local val = t.ffi.new('VTermValue') --- @type {boolean: integer}\n+  vterm.vterm_state_get_penattr(state, vterm_attribute[attribute], val)\n+  local actual = val.boolean --- @type integer|boolean\n+  if is_bool[attribute] then\n+    actual = val.boolean == 1\n+  end\n+  t.eq(expected, actual)\n+end\n+\n+local function resize(rows, cols, vt)\n+  vterm.vterm_set_size(vt, rows, cols)\n+end\n+\n+local function screen_chars(start_row, start_col, end_row, end_col, expected, screen)\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_row'] = start_row\n+  rect['start_col'] = start_col\n+  rect['end_row'] = end_row\n+  rect['end_col'] = end_col\n+\n+  local len = vterm.vterm_screen_get_chars(screen, nil, 0, rect)\n+\n+  local chars = t.ffi.new('uint32_t[?]', len)\n+  vterm.vterm_screen_get_chars(screen, chars, len, rect)\n+\n+  local actual = ''\n+  for i = 0, tonumber(len) - 1 do\n+    actual = actual .. string.char(chars[i])\n+  end\n+\n+  t.eq(expected, actual)\n+end\n+\n+local function screen_text(start_row, start_col, end_row, end_col, expected, screen)\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_row'] = start_row\n+  rect['start_col'] = start_col\n+  rect['end_row'] = end_row\n+  rect['end_col'] = end_col\n+\n+  local len = vterm.vterm_screen_get_text(screen, nil, 0, rect)\n+\n+  local text = t.ffi.new('unsigned char[?]', len)\n+  vterm.vterm_screen_get_text(screen, text, len, rect)\n+\n+  local actual = ''\n+  for i = 0, tonumber(len) - 1 do\n+    actual = string.format('%s%02x,', actual, text[i])\n+  end\n+  actual = actual:sub(1, -2)\n+\n+  t.eq(expected, actual)\n+end\n+\n+--- @param row integer\n+local function screen_row(row, expected, screen, end_col)\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_row'] = row\n+  rect['start_col'] = 0\n+  rect['end_row'] = row + 1\n+  rect['end_col'] = end_col or 80\n+\n+  local len = vterm.vterm_screen_get_text(screen, nil, 0, rect)\n+\n+  local text = t.ffi.new('unsigned char[?]', len)\n+  vterm.vterm_screen_get_text(screen, text, len, rect)\n+\n+  t.eq(expected, t.ffi.string(text))\n+end\n+\n+local function screen_cell(row, col, expected, screen)\n+  local pos = t.ffi.new('VTermPos')\n+  pos['row'] = row\n+  pos['col'] = col\n+\n+  local cell = t.ffi.new('VTermScreenCell')\n+  vterm.vterm_screen_get_cell(screen, pos, cell)\n+\n+  local actual = '{'\n+  for i = 0, vterm.VTERM_MAX_CHARS_PER_CELL - 1 do\n+    if cell['chars'][i] ~= 0 then\n+      if i > 0 then\n+        actual = actual .. ','\n+      end\n+      actual = string.format('%s%02x', actual, cell['chars'][i])\n+    end\n+  end\n+  actual = string.format('%s} width=%d attrs={', actual, cell['width'])\n+  actual = actual .. (cell['attrs'].bold ~= 0 and 'B' or '')\n+  actual = actual\n+    .. (cell['attrs'].underline ~= 0 and string.format('U%d', cell['attrs'].underline) or '')\n+  actual = actual .. (cell['attrs'].italic ~= 0 and 'I' or '')\n+  actual = actual .. (cell['attrs'].blink ~= 0 and 'K' or '')\n+  actual = actual .. (cell['attrs'].reverse ~= 0 and 'R' or '')\n+  actual = actual .. (cell['attrs'].font ~= 0 and string.format('F%d', cell['attrs'].font) or '')\n+  actual = actual .. (cell['attrs'].small ~= 0 and 'S' or '')\n+  if cell['attrs'].baseline ~= 0 then\n+    actual = actual .. (cell['attrs'].baseline == vterm.VTERM_BASELINE_RAISE and '^' or '_')\n+  end\n+  actual = actual .. '} '\n+\n+  actual = actual .. (cell['attrs'].dwl ~= 0 and 'dwl ' or '')\n+  if cell['attrs'].dhl ~= 0 then\n+    actual = actual .. string.format('dhl-%s ', cell['attrs'].dhl == 2 and 'bottom' or 'top')\n+  end\n+\n+  actual = string.format('%sfg=', actual)\n+  vterm.vterm_screen_convert_color_to_rgb(screen, cell['fg'])\n+  vterm.print_color(cell['fg'])\n+\n+  actual = actual .. read_rm()\n+  actual = actual .. ' bg='\n+\n+  vterm.vterm_screen_convert_color_to_rgb(screen, cell['bg'])\n+  vterm.print_color(cell['bg'])\n+\n+  actual = actual .. read_rm()\n+\n+  t.eq(expected, actual)\n+end\n+\n+local function screen_eol(row, col, expected, screen)\n+  local pos = t.ffi.new('VTermPos')\n+  pos['row'] = row\n+  pos['col'] = col\n+\n+  local is_eol = vterm.vterm_screen_is_eol(screen, pos)\n+  t.eq(expected, is_eol)\n+end\n+\n+local function screen_attrs_extent(row, col, expected, screen)\n+  local pos = t.ffi.new('VTermPos')\n+  pos['row'] = row\n+  pos['col'] = col\n+\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_col'] = 0\n+  rect['end_col'] = -1\n+  vterm.vterm_screen_get_attrs_extent(screen, rect, pos, 1)\n+\n+  local actual = string.format(\n+    '%d,%d-%d,%d',\n+    rect['start_row'],\n+    rect['start_col'],\n+    rect['end_row'],\n+    rect['end_col']\n+  )\n+\n+  t.eq(expected, actual)\n+end\n+\n+local function wantencoding()\n+  local encoding = t.ffi.new('VTermEncodingInstance')\n+  encoding['enc'] = vterm.vterm_lookup_encoding(vterm.ENC_UTF8, string.byte('u'))\n+  if encoding.enc.init then\n+    encoding.enc.init(encoding.enc, encoding['data'])\n+  end\n+  return encoding\n+end\n+\n+local function encin(input, encoding)\n+  local len = string.len(input)\n+\n+  local cp = t.ffi.new('uint32_t[?]', len)\n+  local cpi = t.ffi.new('int[1]')\n+  local pos = t.ffi.new('size_t[1]', 0)\n+\n+  encoding.enc.decode(encoding.enc, encoding.data, cp, cpi, len, input, pos, len)\n+\n+  local f = assert(io.open(t.paths.vterm_test_file, 'w'))\n+  if tonumber(cpi[0]) > 0 then\n+    f:write('encout ')\n+    for i = 0, cpi[0] - 1 do\n+      if i == 0 then\n+        f:write(string.format('%x', cp[i]))\n+      else\n+        f:write(string.format(',%x', cp[i]))\n+      end\n+    end\n+    f:write('\\n')\n+  end\n+  f:close()\n+end\n+\n+local function strpe_modifiers(input_mod)\n+  local mod = t.ffi.new('VTermModifier') ---@type any\n+  if input_mod.C then\n+    mod = bit.bor(mod, vterm.VTERM_MOD_CTRL)\n+  end\n+  if input_mod.S then\n+    mod = bit.bor(mod, vterm.VTERM_MOD_SHIFT)\n+  end\n+  if input_mod.A then\n+    mod = bit.bor(mod, vterm.VTERM_MOD_ALT)\n+  end\n+  return mod\n+end\n+\n+local function strp_key(input_key)\n+  if input_key == 'up' then\n+    return vterm.VTERM_KEY_UP\n+  end\n+\n+  if input_key == 'tab' then\n+    return vterm.VTERM_KEY_TAB\n+  end\n+\n+  if input_key == 'enter' then\n+    return vterm.VTERM_KEY_ENTER\n+  end\n+\n+  if input_key == 'f1' then\n+    return vterm.VTERM_KEY_FUNCTION_0 + 1\n+  end\n+\n+  if input_key == 'kp0' then\n+    return vterm.VTERM_KEY_KP_0\n+  end\n+\n+  return vterm.VTERM_KEY_NONE\n+end\n+\n+local function mousemove(row, col, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  vterm.vterm_mouse_move(vt, row, col, mod)\n+end\n+\n+local function mousebtn(press, button, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  local flag = press == 'd' or press == 'D'\n+  vterm.vterm_mouse_button(vt, button, flag, mod)\n+end\n+\n+local function inchar(c, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  vterm.vterm_keyboard_unichar(vt, c, mod)\n+end\n+\n+local function inkey(input_key, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  local key = strp_key(input_key)\n+  vterm.vterm_keyboard_key(vt, key, mod)\n+end\n+\n+before_each(function()\n+  vim.fs.rm(t.paths.vterm_test_file, { force = true })\n+end)\n+\n+describe('vterm', function()\n+  itp('02parser', function()\n+    local vt = init()\n+    vterm.vterm_set_utf8(vt, false)\n+    wantparser(vt)\n+\n+    -- Basic text\n+    push('hello', vt)\n+    expect('text 68,65,6c,6c,6f')\n+\n+    -- C0\n+    push('\\x03', vt)\n+    expect('control 03')\n+    push('\\x1f', vt)\n+    expect('control 1f')\n+\n+    -- C1 8bit\n+    push('\\x83', vt)\n+    expect('control 83')\n+    push('\\x99', vt)\n+    expect('control 99')\n+\n+    -- C1 7bit\n+    push('\\x1b\\x43', vt)\n+    expect('control 83')\n+    push('\\x1b\\x59', vt)\n+    expect('control 99')\n+\n+    -- High bytes\n+    push('\\xa0\\xcc\\xfe', vt)\n+    expect('text a0,cc,fe')\n+\n+    -- Mixed\n+    push('1\\n2', vt)\n+    expect('text 31\\ncontrol 0a\\ntext 32')\n+\n+    -- Escape\n+    push('\\x1b=', vt)\n+    expect('escape =')\n+\n+    -- Escape 2-byte\n+    push('\\x1b(X', vt)\n+    expect('escape (X')\n+\n+    -- Split write Escape\n+    push('\\x1b(', vt)\n+    push('Y', vt)\n+    expect('escape (Y')\n+\n+    -- Escape cancels Escape, starts another\n+    push('\\x1b(\\x1b)Z', vt)\n+    expect('escape )Z')\n+\n+    -- CAN cancels Escape, returns to normal mode\n+    push('\\x1b(\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in Escape interrupts and continues\n+    push('\\x1b(\\nX', vt)\n+    expect('control 0a\\nescape (X')\n+\n+    -- CSI 0 args\n+    push('\\x1b[a', vt)\n+    expect('csi 61 *')\n+\n+    -- CSI 1 arg\n+    push('\\x1b[9b', vt)\n+    expect('csi 62 9')\n+\n+    -- CSI 2 args\n+    push('\\x1b[3;4c', vt)\n+    expect('csi 63 3,4')\n+\n+    -- CSI 1 arg 1 sub\n+    push('\\x1b[1:2c', vt)\n+    expect('csi 63 1+,2')\n+\n+    -- CSI many digits\n+    push('\\x1b[678d', vt)\n+    expect('csi 64 678')\n+\n+    -- CSI leading zero\n+    push('\\x1b[007e', vt)\n+    expect('csi 65 7')\n+\n+    -- CSI qmark\n+    push('\\x1b[?2;7f', vt)\n+    expect('csi 66 L=3f 2,7')\n+\n+    -- CSI greater\n+    push('\\x1b[>c', vt)\n+    expect('csi 63 L=3e *')\n+\n+    -- CSI SP\n+    push('\\x1b[12 q', vt)\n+    expect('csi 71 12 I=20')\n+\n+    -- Mixed CSI\n+    push('A\\x1b[8mB', vt)\n+    expect('text 41\\ncsi 6d 8\\ntext 42')\n+\n+    -- Split write\n+    push('\\x1b', vt)\n+    push('[a', vt)\n+    expect('csi 61 *')\n+    push('foo\\x1b[', vt)\n+    expect('text 66,6f,6f')\n+    push('4b', vt)\n+    expect('csi 62 4')\n+    push('\\x1b[12;', vt)\n+    push('3c', vt)\n+    expect('csi 63 12,3')\n+\n+    -- Escape cancels CSI, starts Escape\n+    push('\\x1b[123\\x1b9', vt)\n+    expect('escape 9')\n+\n+    -- CAN cancels CSI, returns to normal mode\n+    push('\\x1b[12\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in Escape interrupts and continues\n+    push('\\x1b(\\nX', vt)\n+    expect('control 0a\\nescape (X')\n+\n+    -- OSC BEL\n+    push('\\x1b]1;Hello\\x07', vt)\n+    expect('osc [1;Hello]')\n+\n+    -- OSC ST (7bit)\n+    push('\\x1b]1;Hello\\x1b\\\\', vt)\n+    expect('osc [1;Hello]')\n+\n+    -- OSC ST (8bit)\n+    push('\\x9d1;Hello\\x9c', vt)\n+    expect('osc [1;Hello]')\n+\n+    -- OSC in parts\n+    push('\\x1b]52;abc', vt)\n+    expect('osc [52;abc')\n+    push('def', vt)\n+    expect('osc def')\n+    push('ghi\\x1b\\\\', vt)\n+    expect('osc ghi]')\n+\n+    -- OSC BEL without semicolon\n+    push('\\x1b]1234\\x07', vt)\n+    expect('osc [1234;]')\n+\n+    -- OSC ST without semicolon\n+    push('\\x1b]1234\\x1b\\\\', vt)\n+    expect('osc [1234;]')\n+\n+    -- Escape cancels OSC, starts Escape\n+    push('\\x1b]Something\\x1b9', vt)\n+    expect('escape 9')\n+\n+    -- CAN cancels OSC, returns to normal mode\n+    push('\\x1b]12\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in OSC interrupts and continues\n+    push('\\x1b]2;\\nBye\\x07', vt)\n+    expect('osc [2;\\ncontrol 0a\\nosc Bye]')\n+\n+    -- DCS BEL\n+    push('\\x1bPHello\\x07', vt)\n+    expect('dcs [Hello]')\n+\n+    -- DCS ST (7bit)\n+    push('\\x1bPHello\\x1b\\\\', vt)\n+    expect('dcs [Hello]')\n+\n+    -- DCS ST (8bit)\n+    push('\\x90Hello\\x9c', vt)\n+    expect('dcs [Hello]')\n+\n+    -- Split write of 7bit ST\n+    push('\\x1bPABC\\x1b', vt)\n+    expect('dcs [ABC')\n+    push('\\\\', vt)\n+    expect('dcs ]')\n+\n+    -- Escape cancels DCS, starts Escape\n+    push('\\x1bPSomething\\x1b9', vt)\n+    expect('escape 9')\n+\n+    -- CAN cancels DCS, returns to normal mode\n+    push('\\x1bP12\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in OSC interrupts and continues\n+    push('\\x1bPBy\\ne\\x07', vt)\n+    expect('dcs [By\\ncontrol 0a\\ndcs e]')\n+\n+    -- APC BEL\n+    push('\\x1b_Hello\\x07', vt)\n+    expect('apc [Hello]')\n+\n+    -- APC ST (7bit)\n+    push('\\x1b_Hello\\x1b\\\\', vt)\n+    expect('apc [Hello]')\n+\n+    -- APC ST (8bit)\n+    push('\\x9fHello\\x9c', vt)\n+    expect('apc [Hello]')\n+\n+    -- PM BEL\n+    push('\\x1b^Hello\\x07', vt)\n+    expect('pm [Hello]')\n+\n+    -- PM ST (7bit)\n+    push('\\x1b^Hello\\x1b\\\\', vt)\n+    expect('pm [Hello]')\n+\n+    -- PM ST (8bit)\n+    push('\\x9eHello\\x9c', vt)\n+    expect('pm [Hello]')\n+\n+    -- SOS BEL\n+    push('\\x1bXHello\\x07', vt)\n+    expect('sos [Hello]')\n+\n+    -- SOS ST (7bit)\n+    push('\\x1bXHello\\x1b\\\\', vt)\n+    expect('sos [Hello]')\n+\n+    -- SOS ST (8bit)\n+    push('\\x98Hello\\x9c', vt)\n+    expect('sos [Hello]')\n+\n+    push('\\x1bXABC\\x01DEF\\x1b\\\\', vt)\n+    expect('sos [ABC\\x01DEF]')\n+    push('\\x1bXABC\\x99DEF\\x1b\\\\', vt)\n+    expect('sos [ABC\\x99DEF]')\n+\n+    -- NUL ignored\n+    push('\\x00', vt)\n+\n+    -- NUL ignored within CSI\n+    push('\\x1b[12\\x003m', vt)\n+    expect('csi 6d 123')\n+\n+    -- DEL ignored\n+    push('\\x7f', vt)\n+\n+    -- DEL ignored within CSI\n+    push('\\x1b[12\\x7f3m', vt)\n+    expect('csi 6d 123')\n+\n+    -- DEL inside text\"\n+    push('AB\\x7fC', vt)\n+    expect('text 41,42\\ntext 43')\n+  end)\n+\n+  itp('03encoding_utf8', function()\n+    local encoding = wantencoding()\n+\n+    -- Low\n+    encin('123', encoding)\n+    expect('encout 31,32,33')\n+\n+    -- We want to prove the UTF-8 parser correctly handles all the sequences.\n+    -- Easy way to do this is to check it does low/high boundary cases, as that\n+    -- leaves only two for each sequence length\n+    --\n+    -- These ranges are therefore:\n+    --\n+    -- Two bytes:\n+    -- U+0080 = 000 10000000 =>    00010   000000\n+    --                       => 11000010 10000000 = C2 80\n+    -- U+07FF = 111 11111111 =>    11111   111111\n+    --                       => 11011111 10111111 = DF BF\n+    --\n+    -- Three bytes:\n+    -- U+0800 = 00001000 00000000 =>     0000   100000   000000\n+    --                            => 11100000 10100000 10000000 = E0 A0 80\n+    -- U+FFFD = 11111111 11111101 =>     1111   111111   111101\n+    --                            => 11101111 10111111 10111101 = EF BF BD\n+    -- (We avoid U+FFFE and U+FFFF as they're invalid codepoints)\n+    --\n+    -- Four bytes:\n+    -- U+10000  = 00001 00000000 00000000 =>      000   010000   000000   000000\n+    --                                    => 11110000 10010000 10000000 10000000 = F0 90 80 80\n+    -- U+1FFFFF = 11111 11111111 11111111 =>      111   111111   111111   111111\n+    --                                    => 11110111 10111111 10111111 10111111 = F7 BF BF BF\n+\n+    -- 2 byte\n+    encin('\\xC2\\x80\\xDF\\xBF', encoding)\n+    expect('encout 80,7ff')\n+\n+    -- 3 byte\n+    encin('\\xE0\\xA0\\x80\\xEF\\xBF\\xBD', encoding)\n+    expect('encout 800,fffd')\n+\n+    -- 4 byte\n+    encin('\\xF0\\x90\\x80\\x80\\xF7\\xBF\\xBF\\xBF', encoding)\n+    expect('encout 10000,1fffff')\n+\n+    -- Next up, we check some invalid sequences\n+    --  + Early termination (back to low bytes too soon)\n+    --  + Early restart (another sequence introduction before the previous one was finished)\n+\n+    -- Early termination\n+    encin('\\xC2!', encoding)\n+    expect('encout fffd,21')\n+\n+    encin('\\xE0!\\xE0\\xA0!', encoding)\n+    expect('encout fffd,21,fffd,21')\n+\n+    encin('\\xF0!\\xF0\\x90!\\xF0\\x90\\x80!', encoding)\n+    expect('encout fffd,21,fffd,21,fffd,21')\n+\n+    -- Early restart\n+    encin('\\xC2\\xC2\\x90', encoding)\n+    expect('encout fffd,90')\n+\n+    encin('\\xE0\\xC2\\x90\\xE0\\xA0\\xC2\\x90', encoding)\n+    expect('encout fffd,90,fffd,90')\n+\n+    encin('\\xF0\\xC2\\x90\\xF0\\x90\\xC2\\x90\\xF0\\x90\\x80\\xC2\\x90', encoding)\n+    expect('encout fffd,90,fffd,90,fffd,90')\n+\n+    -- Test the overlong sequences by giving an overlong encoding of U+0000 and\n+    -- an encoding of the highest codepoint still too short\n+    --\n+    -- Two bytes:\n+    -- U+0000 = C0 80\n+    -- U+007F = 000 01111111 =>    00001   111111 =>\n+    --                       => 11000001 10111111 => C1 BF\n+    --\n+    -- Three bytes:\n+    -- U+0000 = E0 80 80\n+    -- U+07FF = 00000111 11111111 =>     0000   011111   111111\n+    --                            => 11100000 10011111 10111111 = E0 9F BF\n+    --\n+    -- Four bytes:\n+    -- U+0000 = F0 80 80 80\n+    -- U+FFFF = 11111111 11111111 =>      000   001111   111111   111111\n+    --                            => 11110000 10001111 10111111 10111111 = F0 8F BF BF\n+\n+    -- Overlong\n+    encin('\\xC0\\x80\\xC1\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    encin('\\xE0\\x80\\x80\\xE0\\x9F\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    encin('\\xF0\\x80\\x80\\x80\\xF0\\x8F\\xBF\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    -- UTF-16 surrogates U+D800 and U+DFFF\n+    -- UTF-16 Surrogates\n+    encin('\\xED\\xA0\\x80\\xED\\xBF\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    -- Split write\n+    encin('\\xC2', encoding)\n+    encin('\\xA0', encoding)\n+    expect('encout a0')\n+\n+    encin('\\xE0', encoding)\n+    encin('\\xA0\\x80', encoding)\n+    expect('encout 800')\n+    encin('\\xE0\\xA0', encoding)\n+    encin('\\x80', encoding)\n+    expect('encout 800')\n+\n+    encin('\\xF0', encoding)\n+    encin('\\x90\\x80\\x80', encoding)\n+    expect('encout 10000')\n+    encin('\\xF0\\x90', encoding)\n+    encin('\\x80\\x80', encoding)\n+    expect('encout 10000')\n+    encin('\\xF0\\x90\\x80', encoding)\n+    encin('\\x80', encoding)\n+    expect('encout 10000')\n+  end)\n+\n+  itp('10state_putglyph', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Low\n+    reset(state, nil)\n+    push('ABC', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 43 1 0,2')\n+\n+    -- UTF-8 1 char\n+    -- U+00C1 = 0xC3 0x81  name: LATIN CAPITAL LETTER A WITH ACUTE\n+    -- U+00E9 = 0xC3 0xA9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(state, nil)\n+    push('\\xC3\\x81\\xC3\\xA9', vt)\n+    expect('putglyph c1 1 0,0\\nputglyph e9 1 0,1')\n+\n+    -- UTF-8 split writes\n+    reset(state, nil)\n+    push('\\xC3', vt)\n+    push('\\x81', vt)\n+    expect('putglyph c1 1 0,0')\n+\n+    -- UTF-8 wide char\n+    -- U+FF10 = EF BC 90  name: FULLWIDTH DIGIT ZERO\n+    reset(state, nil)\n+    push('\\xEF\\xBC\\x90 ', vt)\n+    expect('putglyph ff10 2 0,0\\nputglyph 20 1 0,2')\n+\n+    -- UTF-8 emoji wide char\n+    -- U+1F600 = F0 9F 98 80  name: GRINNING FACE\n+    reset(state, nil)\n+    push('\\xF0\\x9F\\x98\\x80 ', vt)\n+    expect('putglyph 1f600 2 0,0\\nputglyph 20 1 0,2')\n+\n+    -- UTF-8 combining chars\n+    -- U+0301 = CC 81  name: COMBINING ACUTE\n+    reset(state, nil)\n+    push('e\\xCC\\x81Z', vt)\n+    expect('putglyph 65,301 1 0,0\\nputglyph 5a 1 0,1')\n+\n+    -- Combining across buffers\n+    reset(state, nil)\n+    push('e', vt)\n+    expect('putglyph 65 1 0,0')\n+    push('\\xCC\\x81Z', vt)\n+    expect('putglyph 65,301 1 0,0\\nputglyph 5a 1 0,1')\n+\n+    -- Spare combining chars get truncated\n+    reset(state, nil)\n+    push('e' .. string.rep('\\xCC\\x81', 10), vt)\n+    expect('putglyph 65,301,301,301,301,301 1 0,0') -- and nothing more\n+\n+    reset(state, nil)\n+    push('e', vt)\n+    expect('putglyph 65 1 0,0')\n+    push('\\xCC\\x81', vt)\n+    expect('putglyph 65,301 1 0,0')\n+    push('\\xCC\\x82', vt)\n+    expect('putglyph 65,301,302 1 0,0')\n+\n+    -- DECSCA protected\n+    reset(state, nil)\n+    push('A\\x1b[1\"qB\\x1b[2\"qC', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 42 1 0,1 prot\\nputglyph 43 1 0,2')\n+  end)\n+\n+  itp('11state_movecursor', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Implicit\n+    push('ABC', vt)\n+    cursor(0, 3, state)\n+\n+    -- Backspace\n+    push('\\b', vt)\n+    cursor(0, 2, state)\n+    -- Horizontal Tab\n+    push('\\t', vt)\n+    cursor(0, 8, state)\n+    -- Carriage Return\n+    push('\\r', vt)\n+    cursor(0, 0, state)\n+    -- Linefeed\n+    push('\\n', vt)\n+    cursor(1, 0, state)\n+\n+    -- Backspace bounded by lefthand edge\n+    push('\\x1b[4;2H', vt)\n+    cursor(3, 1, state)\n+    push('\\b', vt)\n+    cursor(3, 0, state)\n+    push('\\b', vt)\n+    cursor(3, 0, state)\n+\n+    -- Backspace cancels phantom\n+    push('\\x1b[4;80H', vt)\n+    cursor(3, 79, state)\n+    push('X', vt)\n+    cursor(3, 79, state)\n+    push('\\b', vt)\n+    cursor(3, 78, state)\n+\n+    -- HT bounded by righthand edge\n+    push('\\x1b[1;78H', vt)\n+    cursor(0, 77, state)\n+    push('\\t', vt)\n+    cursor(0, 79, state)\n+    push('\\t', vt)\n+    cursor(0, 79, state)\n+\n+    reset(state, nil)\n+\n+    -- Index\n+    push('ABC\\x1bD', vt)\n+    cursor(1, 3, state)\n+    -- Reverse Index\n+    push('\\x1bM', vt)\n+    cursor(0, 3, state)\n+    -- Newline\n+    push('\\x1bE', vt)\n+    cursor(1, 0, state)\n+\n+    reset(state, nil)\n+\n+    -- Cursor Forward\n+    push('\\x1b[B', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[3B', vt)\n+    cursor(4, 0, state)\n+    push('\\x1b[0B', vt)\n+    cursor(5, 0, state)\n+\n+    -- Cursor Down\n+    push('\\x1b[C', vt)\n+    cursor(5, 1, state)\n+    push('\\x1b[3C', vt)\n+    cursor(5, 4, state)\n+    push('\\x1b[0C', vt)\n+    cursor(5, 5, state)\n+\n+    -- Cursor Up\n+    push('\\x1b[A', vt)\n+    cursor(4, 5, state)\n+    push('\\x1b[3A', vt)\n+    cursor(1, 5, state)\n+    push('\\x1b[0A', vt)\n+    cursor(0, 5, state)\n+\n+    -- Cursor Backward\n+    push('\\x1b[D', vt)\n+    cursor(0, 4, state)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[0D', vt)\n+    cursor(0, 0, state)\n+\n+    -- Cursor Next Line\n+    push('   ', vt)\n+    cursor(0, 3, state)\n+    push('\\x1b[E', vt)\n+    cursor(1, 0, state)\n+    push('   ', vt)\n+    cursor(1, 3, state)\n+    push('\\x1b[2E', vt)\n+    cursor(3, 0, state)\n+    push('\\x1b[0E', vt)\n+    cursor(4, 0, state)\n+\n+    -- Cursor Previous Line\n+    push('   ', vt)\n+    cursor(4, 3, state)\n+    push('\\x1b[F', vt)\n+    cursor(3, 0, state)\n+    push('   ', vt)\n+    cursor(3, 3, state)\n+    push('\\x1b[2F', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[0F', vt)\n+    cursor(0, 0, state)\n+\n+    -- Cursor Horizonal Absolute\n+    push('\\n', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[20G', vt)\n+    cursor(1, 19, state)\n+    push('\\x1b[G', vt)\n+    cursor(1, 0, state)\n+\n+    -- Cursor Position\n+    push('\\x1b[10;5H', vt)\n+    cursor(9, 4, state)\n+    push('\\x1b[8H', vt)\n+    cursor(7, 0, state)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+\n+    -- Cursor Position cancels phantom\n+    push('\\x1b[10;78H', vt)\n+    cursor(9, 77, state)\n+    push('ABC', vt)\n+    cursor(9, 79, state)\n+    push('\\x1b[10;80H', vt)\n+    push('C', vt)\n+    cursor(9, 79, state)\n+    push('X', vt)\n+    cursor(10, 1, state)\n+\n+    reset(state, nil)\n+\n+    -- Bounds Checking\n+    push('\\x1b[A', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[D', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[25;80H', vt)\n+    cursor(24, 79, state)\n+    push('\\x1b[B', vt)\n+    cursor(24, 79, state)\n+    push('\\x1b[C', vt)\n+    cursor(24, 79, state)\n+    push('\\x1b[E', vt)\n+    cursor(24, 0, state)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[F', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[999G', vt)\n+    cursor(0, 79, state)\n+    push('\\x1b[99;99H', vt)\n+    cursor(24, 79, state)\n+\n+    reset(state, nil)\n+\n+    -- Horizontal Position Absolute\n+    push('\\x1b[5`', vt)\n+    cursor(0, 4, state)\n+\n+    -- Horizontal Position Relative\n+    push('\\x1b[3a', vt)\n+    cursor(0, 7, state)\n+\n+    -- Horizontal Position Backward\n+    push('\\x1b[3j', vt)\n+    cursor(0, 4, state)\n+\n+    -- Horizontal and Vertical Position\n+    push('\\x1b[3;3f', vt)\n+    cursor(2, 2, state)\n+\n+    -- Vertical Position Absolute\n+    push('\\x1b[5d', vt)\n+    cursor(4, 2, state)\n+\n+    -- Vertical Position Relative\n+    push('\\x1b[2e', vt)\n+    cursor(6, 2, state)\n+\n+    -- Vertical Position Backward\n+    push('\\x1b[2k', vt)\n+    cursor(4, 2, state)\n+\n+    reset(state, nil)\n+\n+    -- Horizontal Tab\n+    push('\\t', vt)\n+    cursor(0, 8, state)\n+    push('   ', vt)\n+    cursor(0, 11, state)\n+    push('\\t', vt)\n+    cursor(0, 16, state)\n+    push('       ', vt)\n+    cursor(0, 23, state)\n+    push('\\t', vt)\n+    cursor(0, 24, state)\n+    push('        ', vt)\n+    cursor(0, 32, state)\n+    push('\\t', vt)\n+    cursor(0, 40, state)\n+\n+    -- Cursor Horizontal Tab\n+    push('\\x1b[I', vt)\n+    cursor(0, 48, state)\n+    push('\\x1b[2I', vt)\n+    cursor(0, 64, state)\n+\n+    -- Cursor Backward Tab\n+    push('\\x1b[Z', vt)\n+    cursor(0, 56, state)\n+    push('\\x1b[2Z', vt)\n+    cursor(0, 40, state)\n+  end)\n+\n+  itp('12state_scroll', function()\n+    local vt = init()\n+    local state = wantstate(vt, { s = true })\n+\n+    -- Linefeed\n+    push(string.rep('\\n', 24), vt)\n+    cursor(24, 0, state)\n+    push('\\n', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+    cursor(24, 0, state)\n+\n+    reset(state, nil)\n+\n+    -- Index\n+    push('\\x1b[25H', vt)\n+    push('\\x1bD', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+\n+    reset(state, nil)\n+\n+    -- Reverse Index\n+    push('\\x1bM', vt)\n+    expect('scrollrect 0..25,0..80 => -1,+0')\n+\n+    reset(state, nil)\n+\n+    -- Linefeed in DECSTBM\n+    push('\\x1b[1;10r', vt)\n+    cursor(0, 0, state)\n+    push(string.rep('\\n', 9), vt)\n+    cursor(9, 0, state)\n+    push('\\n', vt)\n+    expect('scrollrect 0..10,0..80 => +1,+0')\n+    cursor(9, 0, state)\n+\n+    -- Linefeed outside DECSTBM\n+    push('\\x1b[20H', vt)\n+    cursor(19, 0, state)\n+    push('\\n', vt)\n+    cursor(20, 0, state)\n+\n+    -- Index in DECSTBM\n+    push('\\x1b[9;10r', vt)\n+    push('\\x1b[10H', vt)\n+    push('\\x1bM', vt)\n+    cursor(8, 0, state)\n+    push('\\x1bM', vt)\n+    expect('scrollrect 8..10,0..80 => -1,+0')\n+\n+    -- Reverse Index in DECSTBM\n+    push('\\x1b[25H', vt)\n+    cursor(24, 0, state)\n+    push('\\n', vt)\n+    -- no scrollrect\n+    cursor(24, 0, state)\n+\n+    -- Linefeed in DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[3;10r\\x1b[10;40s', vt)\n+    push('\\x1b[10;10H\\n', vt)\n+    expect('scrollrect 2..10,9..40 => +1,+0')\n+\n+    -- IND/RI in DECSTBM+DECSLRM\n+    push('\\x1bD', vt)\n+    expect('scrollrect 2..10,9..40 => +1,+0')\n+    push('\\x1b[3;10H\\x1bM', vt)\n+    expect('scrollrect 2..10,9..40 => -1,+0')\n+\n+    -- DECRQSS on DECSTBM\n+    push('\\x1bP$qr\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r3;10r\\x1b\\\\')\n+\n+    -- DECRQSS on DECSLRM\n+    push('\\x1bP$qs\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r10;40s\\x1b\\\\')\n+\n+    -- Setting invalid DECSLRM with !DECVSSM is still rejected\n+    push('\\x1b[?69l\\x1b[;0s\\x1b[?69h', vt)\n+\n+    reset(state, nil)\n+\n+    -- Scroll Down\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[2S', vt)\n+    expect('scrollrect 0..25,0..80 => +2,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[100S', vt)\n+    expect('scrollrect 0..25,0..80 => +25,+0')\n+\n+    -- Scroll Up\n+    push('\\x1b[T', vt)\n+    expect('scrollrect 0..25,0..80 => -1,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[2T', vt)\n+    expect('scrollrect 0..25,0..80 => -2,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[100T', vt)\n+    expect('scrollrect 0..25,0..80 => -25,+0')\n+\n+    -- SD/SU in DECSTBM\n+    push('\\x1b[5;20r', vt)\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 4..20,0..80 => +1,+0')\n+    push('\\x1b[T', vt)\n+    expect('scrollrect 4..20,0..80 => -1,+0')\n+\n+    reset(state, nil)\n+\n+    -- SD/SU in DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[3;10r\\x1b[10;40s', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[3;10H', vt)\n+    cursor(2, 9, state)\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 2..10,9..40 => +1,+0')\n+    push('\\x1b[?69l', vt)\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 2..10,0..80 => +1,+0')\n+\n+    -- Invalid boundaries\n+    reset(state, nil)\n+\n+    push('\\x1b[100;105r\\x1bD', vt)\n+    push('\\x1b[5;2r\\x1bD', vt)\n+\n+    reset(state, nil)\n+    state = wantstate(vt, { m = true, e = true })\n+\n+    -- Scroll Down move+erase emulation\n+    push('\\x1b[S', vt)\n+    expect('moverect 1..25,0..80 -> 0..24,0..80\\nerase 24..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2S', vt)\n+    expect('moverect 2..25,0..80 -> 0..23,0..80\\nerase 23..25,0..80')\n+    cursor(0, 0, state)\n+\n+    -- Scroll Up move+erase emulation\n+    push('\\x1b[T', vt)\n+    expect('moverect 0..24,0..80 -> 1..25,0..80\\nerase 0..1,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2T', vt)\n+    expect('moverect 0..23,0..80 -> 2..25,0..80\\nerase 0..2,0..80')\n+    cursor(0, 0, state)\n+\n+    -- DECSTBM resets cursor position\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b[r', vt)\n+    cursor(0, 0, state)\n+  end)\n+\n+  itp('13state_edit', function()\n+    local vt = init()\n+    local state = wantstate(vt, { s = true, e = true, b = true })\n+\n+    -- ICH\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ACD', vt)\n+    push('\\x1b[2D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[@', vt)\n+    expect('scrollrect 0..1,1..80 => +0,-1')\n+    cursor(0, 1, state)\n+    push('B', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[3@', vt)\n+    expect('scrollrect 0..1,2..80 => +0,-3')\n+\n+    -- ICH with DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[;50s', vt)\n+    push('\\x1b[20G\\x1b[@', vt)\n+    expect('scrollrect 0..1,19..50 => +0,-1')\n+\n+    -- ICH outside DECSLRM\n+    push('\\x1b[70G\\x1b[@', vt)\n+    -- nothing happens\n+\n+    -- DCH\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABBC', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[P', vt)\n+    expect('scrollrect 0..1,1..80 => +0,+1')\n+    cursor(0, 1, state)\n+    push('\\x1b[3P', vt)\n+    expect('scrollrect 0..1,1..80 => +0,+3')\n+    cursor(0, 1, state)\n+\n+    -- DCH with DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[;50s', vt)\n+    push('\\x1b[20G\\x1b[P', vt)\n+    expect('scrollrect 0..1,19..50 => +0,+1')\n+\n+    -- DCH outside DECSLRM\n+    push('\\x1b[70G\\x1b[P', vt)\n+    -- nothing happens\n+\n+    -- ECH\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABC', vt)\n+    push('\\x1b[2D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[X', vt)\n+    expect('erase 0..1,1..2')\n+    cursor(0, 1, state)\n+    push('\\x1b[3X', vt)\n+    expect('erase 0..1,1..4')\n+    cursor(0, 1, state)\n+    -- ECH more columns than there are should be bounded\n+    push('\\x1b[100X', vt)\n+    expect('erase 0..1,1..80')\n+\n+    -- IL\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('A\\r\\nC', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[L', vt)\n+    expect('scrollrect 1..25,0..80 => -1,+0')\n+    -- TODO(libvterm): ECMA-48 says we should move to line home, but neither xterm nor xfce4-terminal do this\n+    cursor(1, 1, state)\n+    push('\\rB', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[3L', vt)\n+    expect('scrollrect 1..25,0..80 => -3,+0')\n+\n+    -- IL with DECSTBM\n+    push('\\x1b[5;15r', vt)\n+    push('\\x1b[5H\\x1b[L', vt)\n+    expect('scrollrect 4..15,0..80 => -1,+0')\n+\n+    -- IL outside DECSTBM\n+    push('\\x1b[20H\\x1b[L', vt)\n+    -- nothing happens\n+\n+    -- IL with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[10;50s', vt)\n+    push('\\x1b[5;10H\\x1b[L', vt)\n+    expect('scrollrect 4..15,9..50 => -1,+0')\n+\n+    -- DL\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('A\\r\\nB\\r\\nB\\r\\nC', vt)\n+    cursor(3, 1, state)\n+    push('\\x1b[2H', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[M', vt)\n+    expect('scrollrect 1..25,0..80 => +1,+0')\n+    cursor(1, 0, state)\n+    push('\\x1b[3M', vt)\n+    expect('scrollrect 1..25,0..80 => +3,+0')\n+    cursor(1, 0, state)\n+\n+    -- DL with DECSTBM\n+    push('\\x1b[5;15r', vt)\n+    push('\\x1b[5H\\x1b[M', vt)\n+    expect('scrollrect 4..15,0..80 => +1,+0')\n+\n+    -- DL outside DECSTBM\n+    push('\\x1b[20H\\x1b[M', vt)\n+    -- nothing happens\n+\n+    -- DL with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[10;50s', vt)\n+    push('\\x1b[5;10H\\x1b[M', vt)\n+    expect('scrollrect 4..15,9..50 => +1,+0')\n+\n+    -- DECIC\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    push(\"\\x1b[20G\\x1b[5'}\", vt)\n+    expect('scrollrect 0..25,19..80 => +0,-5')\n+\n+    -- DECIC with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[4;20r\\x1b[20;60s', vt)\n+    push(\"\\x1b[4;20H\\x1b[3'}\", vt)\n+    expect('scrollrect 3..20,19..60 => +0,-3')\n+\n+    -- DECIC outside DECSLRM\n+    push(\"\\x1b[70G\\x1b['}\", vt)\n+    -- nothing happens\n+\n+    -- DECDC\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    push(\"\\x1b[20G\\x1b[5'~\", vt)\n+    expect('scrollrect 0..25,19..80 => +0,+5')\n+\n+    -- DECDC with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[4;20r\\x1b[20;60s', vt)\n+    push(\"\\x1b[4;20H\\x1b[3'~\", vt)\n+    expect('scrollrect 3..20,19..60 => +0,+3')\n+\n+    -- DECDC outside DECSLRM\n+    push(\"\\x1b[70G\\x1b['~\", vt)\n+    -- nothing happens\n+\n+    -- EL 0\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABCDE', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[0K', vt)\n+    expect('erase 0..1,2..80')\n+    cursor(0, 2, state)\n+\n+    -- EL 1\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABCDE', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[1K', vt)\n+    expect('erase 0..1,0..3')\n+    cursor(0, 2, state)\n+\n+    -- EL 2\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABCDE', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[2K', vt)\n+    expect('erase 0..1,0..80')\n+    cursor(0, 2, state)\n+\n+    -- SEL\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[11G', vt)\n+    cursor(0, 10, state)\n+    push('\\x1b[?0K', vt)\n+    expect('erase 0..1,10..80 selective')\n+    cursor(0, 10, state)\n+    push('\\x1b[?1K', vt)\n+    expect('erase 0..1,0..11 selective')\n+    cursor(0, 10, state)\n+    push('\\x1b[?2K', vt)\n+    expect('erase 0..1,0..80 selective')\n+    cursor(0, 10, state)\n+\n+    -- ED 0\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[0J', vt)\n+    expect('erase 1..2,1..80\\nerase 2..25,0..80')\n+    cursor(1, 1, state)\n+\n+    -- ED 1\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[1J', vt)\n+    expect('erase 0..1,0..80\\nerase 1..2,0..2')\n+    cursor(1, 1, state)\n+\n+    -- ED 2\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[2J', vt)\n+    expect('erase 0..25,0..80')\n+    cursor(1, 1, state)\n+\n+    -- ED 3\n+    push('\\x1b[3J', vt)\n+    expect('sb_clear')\n+\n+    -- SED\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b[?0J', vt)\n+    expect('erase 4..5,4..80 selective\\nerase 5..25,0..80 selective')\n+    cursor(4, 4, state)\n+    push('\\x1b[?1J', vt)\n+    expect('erase 0..4,0..80 selective\\nerase 4..5,0..5 selective')\n+    cursor(4, 4, state)\n+    push('\\x1b[?2J', vt)\n+    expect('erase 0..25,0..80 selective')\n+    cursor(4, 4, state)\n+\n+    -- DECRQSS on DECSCA\n+    push('\\x1b[2\"q', vt)\n+    push('\\x1bP$q\"q\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r2\"q\\x1b\\\\')\n+\n+    state = wantstate(vt, { m = true, e = true, b = true })\n+    expect('erase 0..25,0..80') -- TODO(dundargoc): strange, this should not be needed according to the original code\n+\n+    -- ICH move+erase emuation\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ACD', vt)\n+    push('\\x1b[2D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[@', vt)\n+    expect('moverect 0..1,1..79 -> 0..1,2..80\\nerase 0..1,1..2')\n+    cursor(0, 1, state)\n+    push('B', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[3@', vt)\n+    expect('moverect 0..1,2..77 -> 0..1,5..80\\nerase 0..1,2..5')\n+\n+    -- DCH move+erase emulation\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABBC', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[P', vt)\n+    expect('moverect 0..1,2..80 -> 0..1,1..79\\nerase 0..1,79..80')\n+    cursor(0, 1, state)\n+    push('\\x1b[3P', vt)\n+    expect('moverect 0..1,4..80 -> 0..1,1..77\\nerase 0..1,77..80')\n+    cursor(0, 1, state)\n+  end)\n+\n+  itp('14state_encoding', function()\n+    local vt = init()\n+    vterm.vterm_set_utf8(vt, false)\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Default\n+    reset(state, nil)\n+    push('#', vt)\n+    expect('putglyph 23 1 0,0')\n+\n+    -- Designate G0=UK\n+    reset(state, nil)\n+    push('\\x1b(A', vt)\n+    push('#', vt)\n+    expect('putglyph a3 1 0,0')\n+\n+    -- Designate G0=DEC drawing\n+    reset(state, nil)\n+    push('\\x1b(0', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,0')\n+\n+    -- Designate G1 + LS1\n+    reset(state, nil)\n+    push('\\x1b)0', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x0e', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,1')\n+    -- LS0\n+    push('\\x0f', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,2')\n+\n+    -- Designate G2 + LS2\n+    push('\\x1b*0', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,3')\n+    push('\\x1bn', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,4')\n+    push('\\x0f', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,5')\n+\n+    -- Designate G3 + LS3\n+    push('\\x1b+0', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,6')\n+    push('\\x1bo', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,7')\n+    push('\\x0f', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,8')\n+\n+    -- SS2\n+    push('a\\x8eaa', vt)\n+    expect('putglyph 61 1 0,9\\nputglyph 2592 1 0,10\\nputglyph 61 1 0,11')\n+\n+    -- SS3\n+    push('a\\x8faa', vt)\n+    expect('putglyph 61 1 0,12\\nputglyph 2592 1 0,13\\nputglyph 61 1 0,14')\n+\n+    -- LS1R\n+    reset(state, nil)\n+    push('\\x1b~', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x1b)0', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 2592 1 0,1')\n+\n+    -- LS2R\n+    reset(state, nil)\n+    push('\\x1b}', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x1b*0', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 2592 1 0,1')\n+\n+    -- LS3R\n+    reset(state, nil)\n+    push('\\x1b|', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x1b+0', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 2592 1 0,1')\n+\n+    vterm.vterm_set_utf8(vt, true)\n+    -- U+0108 == c4 88\n+    reset(state, nil)\n+    push('\\x1b(B', vt)\n+    push('AB\\xc4\\x88D', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 108 1 0,2\\nputglyph 44 1 0,3')\n+  end)\n+\n+  itp('15state_mode', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true, m = true, e = true })\n+\n+    -- Insert/Replace Mode\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('AC\\x1b[DB', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 43 1 0,1\\nputglyph 42 1 0,1')\n+    push('\\x1b[4h', vt)\n+    push('\\x1b[G', vt)\n+    push('AC\\x1b[DB', vt)\n+    expect(\n+      'moverect 0..1,0..79 -> 0..1,1..80\\nerase 0..1,0..1\\nputglyph 41 1 0,0\\nmoverect 0..1,1..79 -> 0..1,2..80\\nerase 0..1,1..2\\nputglyph 43 1 0,1\\nmoverect 0..1,1..79 -> 0..1,2..80\\nerase 0..1,1..2\\nputglyph 42 1 0,1'\n+    )\n+\n+    -- Insert mode only happens once for UTF-8 combining\n+    push('e', vt)\n+    expect('moverect 0..1,2..79 -> 0..1,3..80\\nerase 0..1,2..3\\nputglyph 65 1 0,2')\n+    push('\\xCC\\x81', vt)\n+    expect('putglyph 65,301 1 0,2')\n+\n+    -- Newline/Linefeed mode\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[5G\\n', vt)\n+    cursor(1, 4, state)\n+    push('\\x1b[20h', vt)\n+    push('\\x1b[5G\\n', vt)\n+    cursor(2, 0, state)\n+\n+    -- DEC origin mode\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[5;15r', vt)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[3;3H', vt)\n+    cursor(2, 2, state)\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[H', vt)\n+    cursor(4, 0, state)\n+    push('\\x1b[3;3H', vt)\n+    cursor(6, 2, state)\n+\n+    -- DECRQM on DECOM\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[?6$p', vt)\n+    expect_output('\\x1b[?6;1$y')\n+    push('\\x1b[?6l', vt)\n+    push('\\x1b[?6$p', vt)\n+    expect_output('\\x1b[?6;2$y')\n+\n+    -- Origin mode with DECSLRM\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[20;60s', vt)\n+    push('\\x1b[H', vt)\n+    cursor(4, 19, state)\n+\n+    push('\\x1b[?69l', vt)\n+\n+    -- Origin mode bounds cursor to scrolling region\n+    push('\\x1b[H', vt)\n+    push('\\x1b[10A', vt)\n+    cursor(4, 0, state)\n+    push('\\x1b[20B', vt)\n+    cursor(14, 0, state)\n+\n+    -- Origin mode without scroll region\n+    push('\\x1b[?6l', vt)\n+    push('\\x1b[r\\x1b[?6h', vt)\n+    cursor(0, 0, state)\n+  end)\n+\n+  itp('16state_resize', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Placement\n+    reset(state, nil)\n+    push('AB\\x1b[79GCDE', vt)\n+    expect(\n+      'putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 43 1 0,78\\nputglyph 44 1 0,79\\nputglyph 45 1 1,0'\n+    )\n+\n+    -- Resize\n+    reset(state, nil)\n+    resize(27, 85, vt)\n+    push('AB\\x1b[79GCDE', vt)\n+    expect(\n+      'putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 43 1 0,78\\nputglyph 44 1 0,79\\nputglyph 45 1 0,80'\n+    )\n+    cursor(0, 81, state)\n+\n+    -- Resize without reset\n+    resize(28, 90, vt)\n+    cursor(0, 81, state)\n+    push('FGHI', vt)\n+    expect('putglyph 46 1 0,81\\nputglyph 47 1 0,82\\nputglyph 48 1 0,83\\nputglyph 49 1 0,84')\n+    cursor(0, 85, state)\n+\n+    -- Resize shrink moves cursor\n+    resize(25, 80, vt)\n+    cursor(0, 79, state)\n+\n+    -- Resize grow doesn't cancel phantom\n+    reset(state, nil)\n+    push('\\x1b[79GAB', vt)\n+    expect('putglyph 41 1 0,78\\nputglyph 42 1 0,79')\n+    cursor(0, 79, state)\n+    resize(30, 100, vt)\n+    cursor(0, 80, state)\n+    push('C', vt)\n+    expect('putglyph 43 1 0,80')\n+    cursor(0, 81, state)\n+  end)\n+\n+  itp('17state_mouse', function()\n+    local vt = init()\n+    local state = wantstate(vt, { p = true })\n+\n+    -- DECRQM on with mouse off\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;2$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;2$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;2$y')\n+\n+    -- Mouse in simple button report mode\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    push('\\x1b[?1000h', vt)\n+    expect('settermprop 8 1')\n+\n+    -- Press 1\n+    mousemove(0, 0, vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\x21\\x21')\n+\n+    -- Release 1\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\x21\\x21')\n+\n+    -- Ctrl-Press 1\n+    mousebtn('d', 1, vt, { C = true })\n+    expect_output('\\x1b[M\\x30\\x21\\x21')\n+    mousebtn('u', 1, vt, { C = true })\n+    expect_output('\\x1b[M\\x33\\x21\\x21')\n+\n+    -- Button 2\n+    mousebtn('d', 2, vt)\n+    expect_output('\\x1b[M\\x21\\x21\\x21')\n+    mousebtn('u', 2, vt)\n+    expect_output('\\x1b[M\\x23\\x21\\x21')\n+\n+    -- Position\n+    mousemove(10, 20, vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\x35\\x2b')\n+\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\x35\\x2b')\n+    mousemove(10, 21, vt)\n+    -- no output\n+\n+    -- Wheel events\n+    mousebtn('d', 4, vt)\n+    expect_output('\\x1b[M\\x60\\x36\\x2b')\n+    mousebtn('d', 4, vt)\n+    expect_output('\\x1b[M\\x60\\x36\\x2b')\n+    mousebtn('d', 5, vt)\n+    expect_output('\\x1b[M\\x61\\x36\\x2b')\n+    mousebtn('d', 6, vt)\n+    expect_output('\\x1b[M\\x62\\x36\\x2b')\n+    mousebtn('d', 7, vt)\n+    expect_output('\\x1b[M\\x63\\x36\\x2b')\n+\n+    -- DECRQM on mouse button mode\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;1$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;2$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;2$y')\n+\n+    -- Drag events\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    push('\\x1b[?1002h', vt)\n+    expect('settermprop 8 2')\n+\n+    mousemove(5, 5, vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\x26\\x26')\n+    mousemove(5, 6, vt)\n+    expect_output('\\x1b[M\\x40\\x27\\x26')\n+    mousemove(6, 6, vt)\n+    expect_output('\\x1b[M\\x40\\x27\\x27')\n+    mousemove(6, 6, vt)\n+    -- no output\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\x27\\x27')\n+    mousemove(6, 7, vt)\n+    -- no output\n+\n+    -- DECRQM on mouse drag mode\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;2$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;1$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;2$y')\n+\n+    -- Non-drag motion events\n+    push('\\x1b[?1003h', vt)\n+    expect('settermprop 8 3')\n+\n+    mousemove(6, 8, vt)\n+    expect_output('\\x1b[M\\x43\\x29\\x27')\n+\n+    -- DECRQM on mouse motion mode\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;2$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;2$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;1$y')\n+\n+    -- Bounds checking\n+    mousemove(300, 300, vt)\n+    expect_output('\\x1b[M\\x43\\xff\\xff')\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\xff\\xff')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\xff\\xff')\n+\n+    -- DECRQM on standard encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;2$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;2$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;2$y')\n+\n+    -- UTF-8 extended encoding mode\n+    -- 300 + 32 + 1 = 333 = U+014d = \\xc5\\x8d\n+    push('\\x1b[?1005h', vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\xc5\\x8d\\xc5\\x8d')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\xc5\\x8d\\xc5\\x8d')\n+\n+    -- DECRQM on UTF-8 extended encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;1$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;2$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;2$y')\n+\n+    -- SGR extended encoding mode\n+    push('\\x1b[?1006h', vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[<0;301;301M')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[<0;301;301m')\n+\n+    -- DECRQM on SGR extended encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;2$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;1$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;2$y')\n+\n+    -- rxvt extended encoding mode\n+    push('\\x1b[?1015h', vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[0;301;301M')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[3;301;301M')\n+\n+    -- DECRQM on rxvt extended encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;2$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;2$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;1$y')\n+\n+    -- Mouse disabled reports nothing\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    mousemove(0, 0, vt)\n+    mousebtn('d', 1, vt)\n+    mousebtn('u', 1, vt)\n+\n+    -- DECSM can set multiple modes at once\n+    push('\\x1b[?1002;1006h', vt)\n+    expect('settermprop 8 2')\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[<0;1;1M')\n+  end)\n+\n+  itp('18state_termprops', function()\n+    local vt = init()\n+    local state = wantstate(vt, { p = true })\n+\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+\n+    -- Cursor visibility\n+    push('\\x1b[?25h', vt)\n+    expect('settermprop 1 true')\n+    push('\\x1b[?25$p', vt)\n+    expect_output('\\x1b[?25;1$y')\n+    push('\\x1b[?25l', vt)\n+    expect('settermprop 1 false')\n+    push('\\x1b[?25$p', vt)\n+    expect_output('\\x1b[?25;2$y')\n+\n+    -- Cursor blink\n+    push('\\x1b[?12h', vt)\n+    expect('settermprop 2 true')\n+    push('\\x1b[?12$p', vt)\n+    expect_output('\\x1b[?12;1$y')\n+    push('\\x1b[?12l', vt)\n+    expect('settermprop 2 false')\n+    push('\\x1b[?12$p', vt)\n+    expect_output('\\x1b[?12;2$y')\n+\n+    -- Cursor shape\n+    push('\\x1b[3 q', vt)\n+    expect('settermprop 2 true\\nsettermprop 7 2')\n+\n+    -- Title\n+    push('\\x1b]2;Here is my title\\a', vt)\n+    expect('settermprop 4 [\"Here is my title\"]')\n+\n+    -- Title split write\n+    push('\\x1b]2;Here is', vt)\n+    expect('settermprop 4 [\"Here is\"')\n+    push(' another title\\a', vt)\n+    expect('settermprop 4 \" another title\"]')\n+  end)\n+\n+  itp('20state_wrapping', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true, m = true })\n+\n+    -- 79th Column\n+    push('\\x1b[75G', vt)\n+    push(string.rep('A', 5), vt)\n+    expect(\n+      'putglyph 41 1 0,74\\nputglyph 41 1 0,75\\nputglyph 41 1 0,76\\nputglyph 41 1 0,77\\nputglyph 41 1 0,78'\n+    )\n+    cursor(0, 79, state)\n+\n+    -- 80th Column Phantom\n+    push('A', vt)\n+    expect('putglyph 41 1 0,79')\n+    cursor(0, 79, state)\n+\n+    -- Line Wraparound\n+    push('B', vt)\n+    expect('putglyph 42 1 1,0')\n+    cursor(1, 1, state)\n+\n+    -- Line Wraparound during combined write\n+    push('\\x1b[78G', vt)\n+    push('BBBCC', vt)\n+    expect(\n+      'putglyph 42 1 1,77\\nputglyph 42 1 1,78\\nputglyph 42 1 1,79\\nputglyph 43 1 2,0\\nputglyph 43 1 2,1'\n+    )\n+    cursor(2, 2, state)\n+\n+    -- DEC Auto Wrap Mode\n+    reset(state, nil)\n+    push('\\x1b[?7l', vt)\n+    push('\\x1b[75G', vt)\n+    push(string.rep('D', 6), vt)\n+    expect(\n+      'putglyph 44 1 0,74\\nputglyph 44 1 0,75\\nputglyph 44 1 0,76\\nputglyph 44 1 0,77\\nputglyph 44 1 0,78\\nputglyph 44 1 0,79'\n+    )\n+    cursor(0, 79, state)\n+    push('D', vt)\n+    expect('putglyph 44 1 0,79')\n+    cursor(0, 79, state)\n+    push('\\x1b[?7h', vt)\n+\n+    -- 80th column causes linefeed on wraparound\n+    push('\\x1b[25;78HABC', vt)\n+    expect('putglyph 41 1 24,77\\nputglyph 42 1 24,78\\nputglyph 43 1 24,79')\n+    cursor(24, 79, state)\n+    push('D', vt)\n+    expect('moverect 1..25,0..80 -> 0..24,0..80\\nputglyph 44 1 24,0')\n+\n+    -- 80th column phantom linefeed phantom cancelled by explicit cursor move\n+    push('\\x1b[25;78HABC', vt)\n+    expect('putglyph 41 1 24,77\\nputglyph 42 1 24,78\\nputglyph 43 1 24,79')\n+    cursor(24, 79, state)\n+    push('\\x1b[25;1HD', vt)\n+    expect('putglyph 44 1 24,0')\n+  end)\n+\n+  itp('21state_tabstops', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Initial\n+    reset(state, nil)\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,8')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,16')\n+    cursor(0, 17, state)\n+\n+    -- HTS\n+    push('\\x1b[5G\\x1bH', vt)\n+    push('\\x1b[G\\tX', vt)\n+    expect('putglyph 58 1 0,4')\n+    cursor(0, 5, state)\n+\n+    -- TBC 0\n+    push('\\x1b[9G\\x1b[g', vt)\n+    push('\\x1b[G\\tX\\tX', vt)\n+    expect('putglyph 58 1 0,4\\nputglyph 58 1 0,16')\n+    cursor(0, 17, state)\n+\n+    -- TBC 3\n+    push('\\x1b[3g\\x1b[50G\\x1bH\\x1b[G', vt)\n+    cursor(0, 0, state)\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,49')\n+    cursor(0, 50, state)\n+\n+    -- Tabstops after resize\n+    reset(state, nil)\n+    resize(30, 100, vt)\n+    -- Should be 100/8 = 12 tabstops\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,8')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,16')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,24')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,32')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,40')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,48')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,56')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,64')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,72')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,80')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,88')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,96')\n+    cursor(0, 97, state)\n+  end)\n+\n+  itp('22state_save', function()\n+    local vt = init()\n+    local state = wantstate(vt, { p = true })\n+\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+\n+    -- Set up state\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[1m', vt)\n+    pen('bold', true, state)\n+\n+    -- Save\n+    push('\\x1b[?1048h', vt)\n+\n+    -- Change state\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b[4 q', vt)\n+    expect('settermprop 2 false\\nsettermprop 7 2')\n+    push('\\x1b[22;4m', vt)\n+    pen('bold', false, state)\n+    pen('underline', 1, state)\n+\n+    -- Restore\n+    push('\\x1b[?1048l', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(1, 1, state)\n+    pen('bold', true, state)\n+    pen('underline', 0, state)\n+\n+    -- Save/restore using DECSC/DECRC\n+    push('\\x1b[2;2H\\x1b7', vt)\n+    cursor(1, 1, state)\n+\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b8', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(1, 1, state)\n+\n+    -- Save twice, restore twice happens on both edge transitions\n+    push('\\x1b[2;10H\\x1b[?1048h\\x1b[6;10H\\x1b[?1048h', vt)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[?1048l', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(5, 9, state)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[?1048l', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(5, 9, state)\n+  end)\n+\n+  itp('25state_input', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Unmodified ASCII\n+    inchar(41, vt)\n+    expect('output 29')\n+    inchar(61, vt)\n+    expect('output 3d')\n+\n+    -- Ctrl modifier on ASCII letters\n+    inchar(41, vt, { C = true })\n+    expect('output 1b,5b,34,31,3b,35,75')\n+    inchar(61, vt, { C = true })\n+    expect('output 1b,5b,36,31,3b,35,75')\n+\n+    -- Alt modifier on ASCII letters\n+    inchar(41, vt, { A = true })\n+    expect('output 1b,29')\n+    inchar(61, vt, { A = true })\n+    expect('output 1b,3d')\n+\n+    -- Ctrl-Alt modifier on ASCII letters\n+    inchar(41, vt, { C = true, A = true })\n+    expect('output 1b,5b,34,31,3b,37,75')\n+    inchar(61, vt, { C = true, A = true })\n+    expect('output 1b,5b,36,31,3b,37,75')\n+\n+    -- Special handling of Ctrl-I\n+    inchar(49, vt)\n+    expect('output 31')\n+    inchar(69, vt)\n+    expect('output 45')\n+    inchar(49, vt, { C = true })\n+    expect('output 1b,5b,34,39,3b,35,75')\n+    inchar(69, vt, { C = true })\n+    expect('output 1b,5b,36,39,3b,35,75')\n+    inchar(49, vt, { A = true })\n+    expect('output 1b,31')\n+    inchar(69, vt, { A = true })\n+    expect('output 1b,45')\n+    inchar(49, vt, { A = true, C = true })\n+    expect('output 1b,5b,34,39,3b,37,75')\n+    inchar(69, vt, { A = true, C = true })\n+    expect('output 1b,5b,36,39,3b,37,75')\n+\n+    -- Special handling of Space\n+    inchar(20, vt)\n+    expect('output 14')\n+    inchar(20, vt, { S = true })\n+    expect('output 14')\n+    inchar(20, vt, { C = true })\n+    expect('output 1b,5b,32,30,3b,35,75')\n+    inchar(20, vt, { C = true, S = true })\n+    expect('output 1b,5b,32,30,3b,35,75')\n+    inchar(20, vt, { A = true })\n+    expect('output 1b,14')\n+    inchar(20, vt, { S = true, A = true })\n+    expect('output 1b,14')\n+    inchar(20, vt, { C = true, A = true })\n+    expect('output 1b,5b,32,30,3b,37,75')\n+    inchar(20, vt, { S = true, C = true, A = true })\n+    expect('output 1b,5b,32,30,3b,37,75')\n+\n+    -- Cursor keys in reset (cursor) mode\n+    inkey('up', vt)\n+    expect_output('\\x1b[A')\n+    inkey('up', vt, { S = true })\n+    expect_output('\\x1b[1;2A')\n+    inkey('up', vt, { C = true })\n+    expect_output('\\x1b[1;5A')\n+    inkey('up', vt, { S = true, C = true })\n+    expect_output('\\x1b[1;6A')\n+    inkey('up', vt, { A = true })\n+    expect_output('\\x1b[1;3A')\n+    inkey('up', vt, { S = true, A = true })\n+    expect_output('\\x1b[1;4A')\n+    inkey('up', vt, { C = true, A = true })\n+    expect_output('\\x1b[1;7A')\n+    inkey('up', vt, { S = true, C = true, A = true })\n+    expect_output('\\x1b[1;8A')\n+\n+    -- Cursor keys in application mode\n+    push('\\x1b[?1h', vt)\n+    -- Plain \"Up\" should be SS3 A now\n+    inkey('up', vt)\n+    expect_output('\\x1bOA')\n+    -- Modified keys should still use CSI\n+    inkey('up', vt, { S = true })\n+    expect_output('\\x1b[1;2A')\n+    inkey('up', vt, { C = true })\n+    expect_output('\\x1b[1;5A')\n+\n+    -- Shift-Tab should be different\n+    inkey('tab', vt)\n+    expect_output('\\x09')\n+    inkey('tab', vt, { S = true })\n+    expect_output('\\x1b[Z')\n+    inkey('tab', vt, { C = true })\n+    expect_output('\\x1b[9;5u')\n+    inkey('tab', vt, { A = true })\n+    expect_output('\\x1b\\x09')\n+    inkey('tab', vt, { C = true, A = true })\n+    expect_output('\\x1b[9;7u')\n+\n+    -- Enter in linefeed mode\n+    inkey('enter', vt)\n+    expect_output('\\x0d')\n+\n+    -- Enter in newline mode\n+    push('\\x1b[20h', vt)\n+    inkey('enter', vt)\n+    expect_output('\\x0d\\x0a')\n+\n+    -- Unmodified F1 is SS3 P\n+    inkey('f1', vt)\n+    expect_output('\\x1bOP')\n+\n+    -- Modified F1 is CSI P\n+    inkey('f1', vt, { S = true })\n+    expect_output('\\x1b[1;2P')\n+    inkey('f1', vt, { A = true })\n+    expect_output('\\x1b[1;3P')\n+    inkey('f1', vt, { C = true })\n+    expect_output('\\x1b[1;5P')\n+\n+    -- Keypad in DECKPNM\n+    inkey('kp0', vt)\n+    expect_output('0')\n+\n+    -- Keypad in DECKPAM\n+    push('\\x1b=', vt)\n+    inkey('kp0', vt)\n+    expect_output('\\x1bOp')\n+\n+    -- Bracketed paste mode off\n+    vterm.vterm_keyboard_start_paste(vt)\n+    vterm.vterm_keyboard_end_paste(vt)\n+\n+    -- Bracketed paste mode on\n+    push('\\x1b[?2004h', vt)\n+    vterm.vterm_keyboard_start_paste(vt)\n+    expect_output('\\x1b[200~')\n+    vterm.vterm_keyboard_end_paste(vt)\n+    expect_output('\\x1b[201~')\n+\n+    -- Focus reporting disabled\n+    vterm.vterm_state_focus_in(state)\n+    vterm.vterm_state_focus_out(state)\n+\n+    -- Focus reporting enabled\n+    state = wantstate(vt, { p = true })\n+    push('\\x1b[?1004h', vt)\n+    expect('settermprop 9 true')\n+    vterm.vterm_state_focus_in(state)\n+    expect_output('\\x1b[I')\n+    vterm.vterm_state_focus_out(state)\n+    expect_output('\\x1b[O')\n+  end)\n+\n+  itp('26state_query', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- DA\n+    reset(state, nil)\n+    push('\\x1b[c', vt)\n+    expect_output('\\x1b[?1;2c')\n+\n+    -- XTVERSION\n+    reset(state, nil)\n+    push('\\x1b[>q', vt)\n+    expect_output('\\x1bP>|libvterm(0.3)\\x1b\\\\')\n+\n+    -- DSR\n+    reset(state, nil)\n+    push('\\x1b[5n', vt)\n+    expect_output('\\x1b[0n')\n+\n+    -- CPR\n+    push('\\x1b[6n', vt)\n+    expect_output('\\x1b[1;1R')\n+    push('\\x1b[10;10H\\x1b[6n', vt)\n+    expect_output('\\x1b[10;10R')\n+\n+    -- DECCPR\n+    push('\\x1b[?6n', vt)\n+    expect_output('\\x1b[?10;10R')\n+\n+    -- DECRQSS on DECSCUSR\n+    push('\\x1b[3 q', vt)\n+    push('\\x1bP$q q\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r3 q\\x1b\\\\')\n+\n+    -- DECRQSS on SGR\n+    push('\\x1b[1;5;7m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r1;5;7m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR ANSI colours\n+    push('\\x1b[0;31;42m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r31;42m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR ANSI hi-bright colours\n+    push('\\x1b[0;93;104m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r93;104m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR 256-palette colours\n+    push('\\x1b[0;38:5:56;48:5:78m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r38:5:56;48:5:78m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR RGB8 colours\n+    push('\\x1b[0;38:2:24:68:112;48:2:13:57:101m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r38:2:24:68:112;48:2:13:57:101m\\x1b\\\\')\n+\n+    -- S8C1T on DSR\n+    push('\\x1b G', vt)\n+    push('\\x1b[5n', vt)\n+    expect_output('\\x9b0n')\n+    push('\\x1b F', vt)\n+  end)\n+\n+  itp('27state_reset', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    reset(state, nil)\n+\n+    -- RIS homes cursor\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    state = wantstate(vt, { m = true })\n+    push('\\x1bc', vt)\n+    cursor(0, 0, state)\n+    wantstate(vt)\n+\n+    -- RIS cancels scrolling region\n+    push('\\x1b[5;10r', vt)\n+    wantstate(vt, { s = true })\n+    push('\\x1bc\\x1b[25H\\n', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+    wantstate(vt)\n+\n+    -- RIS erases screen\n+    push('ABCDE', vt)\n+    state = wantstate(vt, { e = true })\n+    push('\\x1bc', vt)\n+    expect('erase 0..25,0..80')\n+    wantstate(vt)\n+\n+    -- RIS clears tabstops\n+    push('\\x1b[5G\\x1bH\\x1b[G\\t', vt)\n+    cursor(0, 4, state)\n+    push('\\x1bc\\t', vt)\n+    cursor(0, 8, state)\n+  end)\n+\n+  itp('28state_dbl_wh', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Single Width, Single Height\n+    reset(state, nil)\n+    push('\\x1b#5', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 0,0\\nputglyph 65 1 0,1\\nputglyph 6c 1 0,2\\nputglyph 6c 1 0,3\\nputglyph 6f 1 0,4'\n+    )\n+\n+    -- Double Width, Single Height\n+    reset(state, nil)\n+    push('\\x1b#6', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 0,0 dwl\\nputglyph 65 1 0,1 dwl\\nputglyph 6c 1 0,2 dwl\\nputglyph 6c 1 0,3 dwl\\nputglyph 6f 1 0,4 dwl'\n+    )\n+    cursor(0, 5, state)\n+    push('\\x1b[40GAB', vt)\n+    expect('putglyph 41 1 0,39 dwl\\nputglyph 42 1 1,0')\n+    cursor(1, 1, state)\n+\n+    -- Double Height\n+    reset(state, nil)\n+    push('\\x1b#3', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 0,0 dwl dhl-top\\nputglyph 65 1 0,1 dwl dhl-top\\nputglyph 6c 1 0,2 dwl dhl-top\\nputglyph 6c 1 0,3 dwl dhl-top\\nputglyph 6f 1 0,4 dwl dhl-top'\n+    )\n+    cursor(0, 5, state)\n+    push('\\r\\n\\x1b#4', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 1,0 dwl dhl-bottom\\nputglyph 65 1 1,1 dwl dhl-bottom\\nputglyph 6c 1 1,2 dwl dhl-bottom\\nputglyph 6c 1 1,3 dwl dhl-bottom\\nputglyph 6f 1 1,4 dwl dhl-bottom'\n+    )\n+    cursor(1, 5, state)\n+\n+    -- Double Width scrolling\n+    reset(state, nil)\n+    push('\\x1b[20H\\x1b#6ABC', vt)\n+    expect('putglyph 41 1 19,0 dwl\\nputglyph 42 1 19,1 dwl\\nputglyph 43 1 19,2 dwl')\n+    push('\\x1b[25H\\n', vt)\n+    push('\\x1b[19;4HDE', vt)\n+    expect('putglyph 44 1 18,3 dwl\\nputglyph 45 1 18,4 dwl')\n+    push('\\x1b[H\\x1bM', vt)\n+    push('\\x1b[20;6HFG', vt)\n+    expect('putglyph 46 1 19,5 dwl\\nputglyph 47 1 19,6 dwl')\n+  end)\n+\n+  itp('29state_fallback', function()\n+    local vt = init()\n+    local state = wantstate(vt, { f = true })\n+    reset(state, nil)\n+\n+    -- Unrecognised control\n+    push('\\x03', vt)\n+    expect('control 03')\n+\n+    -- Unrecognised CSI\n+    push('\\x1b[?15;2z', vt)\n+    expect('csi 7a L=3f 15,2')\n+\n+    -- Unrecognised OSC\n+    push('\\x1b]27;Something\\x1b\\\\', vt)\n+    expect('osc [27;Something]')\n+\n+    -- Unrecognised DCS\n+    push('\\x1bPz123\\x1b\\\\', vt)\n+    expect('dcs [z123]')\n+\n+    -- Unrecognised APC\n+    push('\\x1b_z123\\x1b\\\\', vt)\n+    expect('apc [z123]')\n+\n+    -- Unrecognised PM\n+    push('\\x1b^z123\\x1b\\\\', vt)\n+    expect('pm [z123]')\n+\n+    -- Unrecognised SOS\n+    push('\\x1bXz123\\x1b\\\\', vt)\n+    expect('sos [z123]')\n+  end)\n+\n+  itp('30state_pen', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Reset\n+    push('\\x1b[m', vt)\n+    pen('bold', false, state)\n+    pen('underline', 0, state)\n+    pen('italic', false, state)\n+    pen('blink', false, state)\n+    pen('reverse', false, state)\n+    pen('font', 0, state)\n+    -- TODO(dundargoc): fix\n+    -- ?pen foreground = rgb(240,240,240,is_default_fg)\n+    -- ?pen background = rgb(0,0,0,is_default_bg)\n+\n+    -- Bold\n+    push('\\x1b[1m', vt)\n+    pen('bold', true, state)\n+    push('\\x1b[22m', vt)\n+    pen('bold', false, state)\n+    push('\\x1b[1m\\x1b[m', vt)\n+    pen('bold', false, state)\n+\n+    -- Underline\n+    push('\\x1b[4m', vt)\n+    pen('underline', 1, state)\n+    push('\\x1b[21m', vt)\n+    pen('underline', 2, state)\n+    push('\\x1b[24m', vt)\n+    pen('underline', 0, state)\n+    push('\\x1b[4m\\x1b[4:0m', vt)\n+    pen('underline', 0, state)\n+    push('\\x1b[4:1m', vt)\n+    pen('underline', 1, state)\n+    push('\\x1b[4:2m', vt)\n+    pen('underline', 2, state)\n+    push('\\x1b[4:3m', vt)\n+    pen('underline', 3, state)\n+    push('\\x1b[4m\\x1b[m', vt)\n+    pen('underline', 0, state)\n+\n+    -- Italic\n+    push('\\x1b[3m', vt)\n+    pen('italic', true, state)\n+    push('\\x1b[23m', vt)\n+    pen('italic', false, state)\n+    push('\\x1b[3m\\x1b[m', vt)\n+    pen('italic', false, state)\n+\n+    -- Blink\n+    push('\\x1b[5m', vt)\n+    pen('blink', true, state)\n+    push('\\x1b[25m', vt)\n+    pen('blink', false, state)\n+    push('\\x1b[5m\\x1b[m', vt)\n+    pen('blink', false, state)\n+\n+    -- Reverse\n+    push('\\x1b[7m', vt)\n+    pen('reverse', true, state)\n+    push('\\x1b[27m', vt)\n+    pen('reverse', false, state)\n+    push('\\x1b[7m\\x1b[m', vt)\n+    pen('reverse', false, state)\n+\n+    -- Font Selection\n+    push('\\x1b[11m', vt)\n+    pen('font', 1, state)\n+    push('\\x1b[19m', vt)\n+    pen('font', 9, state)\n+    push('\\x1b[10m', vt)\n+    pen('font', 0, state)\n+    push('\\x1b[11m\\x1b[m', vt)\n+    pen('font', 0, state)\n+\n+    -- TODO(dundargoc): fix\n+    -- -- Foreground\n+    -- push \"\\x1b[31m\"\n+    --   ?pen foreground = idx(1)\n+    -- push \"\\x1b[32m\"\n+    --   ?pen foreground = idx(2)\n+    -- push \"\\x1b[34m\"\n+    --   ?pen foreground = idx(4)\n+    -- push \"\\x1b[91m\"\n+    --   ?pen foreground = idx(9)\n+    -- push \"\\x1b[38:2:10:20:30m\"\n+    --   ?pen foreground = rgb(10,20,30)\n+    -- push \"\\x1b[38:5:1m\"\n+    --   ?pen foreground = idx(1)\n+    -- push \"\\x1b[39m\"\n+    --   ?pen foreground = rgb(240,240,240,is_default_fg)\n+    --\n+    -- -- Background\n+    -- push \"\\x1b[41m\"\n+    --   ?pen background = idx(1)\n+    -- push \"\\x1b[42m\"\n+    --   ?pen background = idx(2)\n+    -- push \"\\x1b[44m\"\n+    --   ?pen background = idx(4)\n+    -- push \"\\x1b[101m\"\n+    --   ?pen background = idx(9)\n+    -- push \"\\x1b[48:2:10:20:30m\"\n+    --   ?pen background = rgb(10,20,30)\n+    -- push \"\\x1b[48:5:1m\"\n+    --   ?pen background = idx(1)\n+    -- push \"\\x1b[49m\"\n+    --   ?pen background = rgb(0,0,0,is_default_bg)\n+    --\n+    -- -- Bold+ANSI colour == highbright\n+    -- push \"\\x1b[m\\x1b[1;37m\"\n+    --   ?pen bold = on\n+    --   ?pen foreground = idx(15)\n+    -- push \"\\x1b[m\\x1b[37;1m\"\n+    --   ?pen bold = on\n+    --   ?pen foreground = idx(15)\n+    --\n+    -- -- Super/Subscript\n+    -- push \"\\x1b[73m\"\n+    --   ?pen small = on\n+    --   ?pen baseline = raise\n+    -- push \"\\x1b[74m\"\n+    --   ?pen small = on\n+    --   ?pen baseline = lower\n+    -- push \"\\x1b[75m\"\n+    --   ?pen small = off\n+    --   ?pen baseline = normal\n+    --\n+    -- -- DECSTR resets pen attributes\n+    -- push \"\\x1b[1;4m\"\n+    --   ?pen bold = on\n+    --   ?pen underline = 1\n+    -- push \"\\x1b[!p\"\n+    --   ?pen bold = off\n+    --   ?pen underline = 0\n+  end)\n+\n+  itp('31state_rep', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- REP no argument\n+    reset(state, nil)\n+    push('a\\x1b[b', vt)\n+    expect('putglyph 61 1 0,0\\nputglyph 61 1 0,1')\n+\n+    -- REP zero (zero should be interpreted as one)\n+    reset(state, nil)\n+    push('a\\x1b[0b', vt)\n+    expect('putglyph 61 1 0,0\\nputglyph 61 1 0,1')\n+\n+    -- REP lowercase a times two\n+    reset(state, nil)\n+    push('a\\x1b[2b', vt)\n+    expect('putglyph 61 1 0,0\\nputglyph 61 1 0,1\\nputglyph 61 1 0,2')\n+\n+    -- REP with UTF-8 1 char\n+    -- U+00E9 = C3 A9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(state, nil)\n+    push('\\xC3\\xA9\\x1b[b', vt)\n+    expect('putglyph e9 1 0,0\\nputglyph e9 1 0,1')\n+\n+    -- REP with UTF-8 wide char\n+    -- U+00E9 = C3 A9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(state, nil)\n+    push('\\xEF\\xBC\\x90\\x1b[b', vt)\n+    expect('putglyph ff10 2 0,0\\nputglyph ff10 2 0,2')\n+\n+    -- REP with UTF-8 combining character\n+    reset(state, nil)\n+    push('e\\xCC\\x81\\x1b[b', vt)\n+    expect('putglyph 65,301 1 0,0\\nputglyph 65,301 1 0,1')\n+\n+    -- REP till end of line\n+    reset(state, nil)\n+    push('a\\x1b[1000bb', vt)\n+    expect(\n+      'putglyph 61 1 0,0\\nputglyph 61 1 0,1\\nputglyph 61 1 0,2\\nputglyph 61 1 0,3\\nputglyph 61 1 0,4\\nputglyph 61 1 0,5\\nputglyph 61 1 0,6\\nputglyph 61 1 0,7\\nputglyph 61 1 0,8\\nputglyph 61 1 0,9\\nputglyph 61 1 0,10\\nputglyph 61 1 0,11\\nputglyph 61 1 0,12\\nputglyph 61 1 0,13\\nputglyph 61 1 0,14\\nputglyph 61 1 0,15\\nputglyph 61 1 0,16\\nputglyph 61 1 0,17\\nputglyph 61 1 0,18\\nputglyph 61 1 0,19\\nputglyph 61 1 0,20\\nputglyph 61 1 0,21\\nputglyph 61 1 0,22\\nputglyph 61 1 0,23\\nputglyph 61 1 0,24\\nputglyph 61 1 0,25\\nputglyph 61 1 0,26\\nputglyph 61 1 0,27\\nputglyph 61 1 0,28\\nputglyph 61 1 0,29\\nputglyph 61 1 0,30\\nputglyph 61 1 0,31\\nputglyph 61 1 0,32\\nputglyph 61 1 0,33\\nputglyph 61 1 0,34\\nputglyph 61 1 0,35\\nputglyph 61 1 0,36\\nputglyph 61 1 0,37\\nputglyph 61 1 0,38\\nputglyph 61 1 0,39\\nputglyph 61 1 0,40\\nputglyph 61 1 0,41\\nputglyph 61 1 0,42\\nputglyph 61 1 0,43\\nputglyph 61 1 0,44\\nputglyph 61 1 0,45\\nputglyph 61 1 0,46\\nputglyph 61 1 0,47\\nputglyph 61 1 0,48\\nputglyph 61 1 0,49\\nputglyph 61 1 0,50\\nputglyph 61 1 0,51\\nputglyph 61 1 0,52\\nputglyph 61 1 0,53\\nputglyph 61 1 0,54\\nputglyph 61 1 0,55\\nputglyph 61 1 0,56\\nputglyph 61 1 0,57\\nputglyph 61 1 0,58\\nputglyph 61 1 0,59\\nputglyph 61 1 0,60\\nputglyph 61 1 0,61\\nputglyph 61 1 0,62\\nputglyph 61 1 0,63\\nputglyph 61 1 0,64\\nputglyph 61 1 0,65\\nputglyph 61 1 0,66\\nputglyph 61 1 0,67\\nputglyph 61 1 0,68\\nputglyph 61 1 0,69\\nputglyph 61 1 0,70\\nputglyph 61 1 0,71\\nputglyph 61 1 0,72\\nputglyph 61 1 0,73\\nputglyph 61 1 0,74\\nputglyph 61 1 0,75\\nputglyph 61 1 0,76\\nputglyph 61 1 0,77\\nputglyph 61 1 0,78\\nputglyph 61 1 0,79\\nputglyph 62 1 1,0'\n+    )\n+  end)\n+\n+  itp('32state_flow', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Many of these test cases inspired by\n+    -- https://blueprints.launchpad.net/libvterm/+spec/reflow-cases\n+\n+    -- Spillover text marks continuation on second line\n+    reset(state, nil)\n+    push(string.rep('A', 100), vt)\n+    push('\\r\\n', vt)\n+    lineinfo(0, {}, state)\n+    lineinfo(1, { cont = true }, state)\n+\n+    -- CRLF in column 80 does not mark continuation\n+    reset(state, nil)\n+    push(string.rep('B', 80), vt)\n+    push('\\r\\n', vt)\n+    push(string.rep('B', 20), vt)\n+    push('\\r\\n', vt)\n+    lineinfo(0, {}, state)\n+    lineinfo(1, {}, state)\n+\n+    -- EL cancels continuation of following line\n+    reset(state, nil)\n+    push(string.rep('D', 100), vt)\n+    lineinfo(1, { cont = true }, state)\n+    push('\\x1bM\\x1b[79G\\x1b[K', vt)\n+    lineinfo(1, {}, state)\n+  end)\n+\n+  itp('40state_selection', function()\n+    local vt = init()\n+    wantstate(vt)\n+\n+    -- Set clipboard; final chunk len 4\n+    push('\\x1b]52;c;SGVsbG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello,]')\n+\n+    -- Set clipboard; final chunk len 3\n+    push('\\x1b]52;c;SGVsbG8sIHc=\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello, w]')\n+\n+    -- Set clipboard; final chunk len 2\n+    push('\\x1b]52;c;SGVsbG8sIHdvcmxkCg==\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello, world\\n]')\n+\n+    -- Set clipboard; split between chunks\n+    push('\\x1b]52;c;SGVs', vt)\n+    expect('selection-set mask=0001 [Hel')\n+    push('bG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 lo,]')\n+\n+    -- Set clipboard; split within chunk\n+    push('\\x1b]52;c;SGVsbG', vt)\n+    expect('selection-set mask=0001 [Hel')\n+    push('8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 lo,]')\n+\n+    -- Set clipboard; empty first chunk\n+    push('\\x1b]52;c;', vt)\n+    push('SGVsbG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello,]')\n+\n+    -- Set clipboard; empty final chunk\n+    push('\\x1b]52;c;SGVsbG8s', vt)\n+    expect('selection-set mask=0001 [Hello,')\n+    push('\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 ]')\n+\n+    -- Set clipboard; longer than buffer\n+    push('\\x1b]52;c;' .. string.rep('LS0t', 10) .. '\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [---------------\\nselection-set mask=0001 ---------------]')\n+\n+    -- Clear clipboard\n+    push('\\x1b]52;c;\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 []')\n+\n+    -- Set invalid data clears and ignores\n+    push('\\x1b]52;c;SGVs*SGVsbG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 []')\n+\n+    -- Query clipboard\n+    push('\\x1b]52;c;?\\x1b\\\\', vt)\n+    expect('selection-query mask=0001')\n+\n+    -- TODO(dundargoc): fix\n+    -- -- Send clipboard; final chunk len 4\n+    -- SELECTION 1 [\"Hello,\"]\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVsbG8s\"\n+    --   output \"\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; final chunk len 3\n+    -- SELECTION 1 [\"Hello, w\"]\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVsbG8s\"\n+    --   output \"IHc=\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; final chunk len 2\n+    -- SELECTION 1 [\"Hello, world\\n\"]\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVsbG8sIHdvcmxk\"\n+    --   output \"Cg==\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; split between chunks\n+    -- SELECTION 1 [\"Hel\"\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVs\"\n+    -- SELECTION 1  \"lo,\"]\n+    --   output \"bG8s\"\n+    --   output \"\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; split within chunk\n+    -- SELECTION 1 [\"Hello\"\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVs\"\n+    -- SELECTION 1 \",\"]\n+    --   output \"bG8s\"\n+    --   output \"\\x1b\\\\\"\n+  end)\n+\n+  itp('60screen_ascii', function()\n+    local vt = init()\n+    local screen = wantscreen(vt, { a = true, c = true })\n+\n+    -- Get\n+    reset(nil, screen)\n+    push('ABC', vt)\n+    expect('movecursor 0,3')\n+    screen_chars(0, 0, 1, 3, 'ABC', screen)\n+    screen_chars(0, 0, 1, 80, 'ABC', screen)\n+    screen_text(0, 0, 1, 3, '41,42,43', screen)\n+    screen_text(0, 0, 1, 80, '41,42,43', screen)\n+    screen_cell(0, 0, '{41} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 1, '{42} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 2, '{43} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_row(0, 'ABC', screen)\n+    screen_eol(0, 0, 0, screen)\n+    screen_eol(0, 2, 0, screen)\n+    screen_eol(0, 3, 1, screen)\n+    push('\\x1b[H', vt)\n+    expect('movecursor 0,0')\n+    screen_row(0, 'ABC', screen)\n+    screen_text(0, 0, 1, 80, '41,42,43', screen)\n+    push('E', vt)\n+    expect('movecursor 0,1')\n+    screen_row(0, 'EBC', screen)\n+    screen_text(0, 0, 1, 80, '45,42,43', screen)\n+\n+    screen = wantscreen(vt, { a = true })\n+\n+    -- Erase\n+    reset(nil, screen)\n+    push('ABCDE\\x1b[H\\x1b[K', vt)\n+    -- TODO(dundargoc): fix\n+    -- screen_row(0, '', screen)\n+    screen_text(0, 0, 1, 80, '', screen)\n+\n+    -- Copycell\n+    reset(nil, screen)\n+    push('ABC\\x1b[H\\x1b[@', vt)\n+    push('1', vt)\n+    screen_row(0, '1ABC', screen)\n+\n+    reset(nil, screen)\n+    push('ABC\\x1b[H\\x1b[P', vt)\n+    screen_chars(0, 0, 1, 1, 'B', screen)\n+    screen_chars(0, 1, 1, 2, 'C', screen)\n+    screen_chars(0, 0, 1, 80, 'BC', screen)\n+\n+    -- Space padding\n+    reset(nil, screen)\n+    push('Hello\\x1b[CWorld', vt)\n+    screen_row(0, 'Hello World', screen)\n+    screen_text(0, 0, 1, 80, '48,65,6c,6c,6f,20,57,6f,72,6c,64', screen)\n+\n+    -- Linefeed padding\n+    reset(nil, screen)\n+    push('Hello\\r\\nWorld', vt)\n+    screen_chars(0, 0, 2, 80, 'Hello\\nWorld', screen)\n+    screen_text(0, 0, 2, 80, '48,65,6c,6c,6f,0a,57,6f,72,6c,64', screen)\n+\n+    -- Altscreen\n+    reset(nil, screen)\n+    push('P', vt)\n+    screen_row(0, 'P', screen)\n+    -- TODO(dundargoc): fix\n+    -- push('\\x1b[?1049h', vt)\n+    -- screen_row(0, '', screen)\n+    -- push('\\x1b[2K\\x1b[HA', vt)\n+    -- screen_row(0, 'A', screen)\n+    -- push('\\x1b[?1049l', vt)\n+    -- screen_row(0, 'P', screen)\n+  end)\n+\n+  itp('61screen_unicode', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    -- Single width UTF-8\n+    -- U+00C1 = C3 81  name: LATIN CAPITAL LETTER A WITH ACUTE\n+    -- U+00E9 = C3 A9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(nil, screen)\n+    push('\\xC3\\x81\\xC3\\xA9', vt)\n+    screen_row(0, 'Áé', screen)\n+    screen_text(0, 0, 1, 80, 'c3,81,c3,a9', screen)\n+    screen_cell(0, 0, '{c1} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Wide char\n+    -- U+FF10 = EF BC 90  name: FULLWIDTH DIGIT ZERO\n+    reset(nil, screen)\n+    push('0123\\x1b[H', vt)\n+    push('\\xEF\\xBC\\x90', vt)\n+    screen_row(0, '０23', screen)\n+    screen_text(0, 0, 1, 80, 'ef,bc,90,32,33', screen)\n+    screen_cell(0, 0, '{ff10} width=2 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Combining char\n+    -- U+0301 = CC 81  name: COMBINING ACUTE\n+    reset(nil, screen)\n+    push('0123\\x1b[H', vt)\n+    push('e\\xCC\\x81', vt)\n+    screen_row(0, 'é123', screen)\n+    screen_text(0, 0, 1, 80, '65,cc,81,31,32,33', screen)\n+    screen_cell(0, 0, '{65,301} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- 10 combining accents should not crash\n+    reset(nil, screen)\n+    push('e\\xCC\\x81\\xCC\\x82\\xCC\\x83\\xCC\\x84\\xCC\\x85\\xCC\\x86\\xCC\\x87\\xCC\\x88\\xCC\\x89\\xCC\\x8A', vt)\n+    screen_cell(\n+      0,\n+      0,\n+      '{65,301,302,303,304,305} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)',\n+      screen\n+    )\n+\n+    -- 40 combining accents in two split writes of 20 should not crash\n+    reset(nil, screen)\n+    push(\n+      'e\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81',\n+      vt\n+    )\n+    push(\n+      '\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81',\n+      vt\n+    )\n+    screen_cell(\n+      0,\n+      0,\n+      '{65,301,301,301,301,301} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)',\n+      screen\n+    )\n+\n+    -- Outputing CJK doublewidth in 80th column should wraparound to next line and not crash\"\n+    reset(nil, screen)\n+    push('\\x1b[80G\\xEF\\xBC\\x90', vt)\n+    screen_cell(0, 79, '{} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(1, 0, '{ff10} width=2 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+  end)\n+\n+  pending('62screen_damage', function() end)\n+\n+  itp('63screen_resize', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+    local screen = wantscreen(vt)\n+\n+    -- Resize wider preserves cells\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('AB\\r\\nCD', vt)\n+    screen_chars(0, 0, 1, 80, 'AB', screen)\n+    screen_chars(1, 0, 2, 80, 'CD', screen)\n+    resize(25, 100, vt)\n+    screen_chars(0, 0, 1, 100, 'AB', screen)\n+    screen_chars(1, 0, 2, 100, 'CD', screen)\n+\n+    -- Resize wider allows print in new area\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('AB\\x1b[79GCD', vt)\n+    screen_chars(0, 0, 1, 2, 'AB', screen)\n+    screen_chars(0, 78, 1, 80, 'CD', screen)\n+    resize(25, 100, vt)\n+    screen_chars(0, 0, 1, 2, 'AB', screen)\n+    screen_chars(0, 78, 1, 80, 'CD', screen)\n+    push('E', vt)\n+    screen_chars(0, 78, 1, 81, 'CDE', screen)\n+\n+    -- Resize shorter with blanks just truncates\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('Top\\x1b[10HLine 10', vt)\n+    screen_row(0, 'Top', screen)\n+    screen_row(9, 'Line 10', screen)\n+    cursor(9, 7, state)\n+    resize(20, 80, vt)\n+    screen_row(0, 'Top', screen)\n+    screen_row(9, 'Line 10', screen)\n+    cursor(9, 7, state)\n+\n+    -- Resize shorter with content must scroll\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('Top\\x1b[25HLine 25\\x1b[15H', vt)\n+    screen_row(0, 'Top', screen)\n+    screen_row(24, 'Line 25', screen)\n+    cursor(14, 0, state)\n+    screen = wantscreen(vt, { b = true })\n+    resize(20, 80, vt)\n+    expect(\n+      'sb_pushline 80 = 54 6F 70\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 ='\n+    )\n+    -- TODO(dundargoc): fix or remove\n+    -- screen_row( 0  , \"\",screen)\n+    screen_row(19, 'Line 25', screen)\n+    cursor(9, 0, state)\n+\n+    -- Resize shorter does not lose line with cursor\n+    -- See also https://github.com/neovim/libvterm/commit/1b745d29d45623aa8d22a7b9288c7b0e331c7088\n+    reset(state, screen)\n+    wantscreen(vt)\n+    resize(25, 80, vt)\n+    screen = wantscreen(vt, { b = true })\n+    push('\\x1b[24HLine 24\\r\\nLine 25\\r\\n', vt)\n+    expect('sb_pushline 80 =')\n+    screen_row(23, 'Line 25', screen)\n+    cursor(24, 0, state)\n+    resize(24, 80, vt)\n+    expect('sb_pushline 80 =')\n+    screen_row(22, 'Line 25', screen)\n+    cursor(23, 0, state)\n+\n+    -- Resize shorter does not send the cursor to a negative row\n+    -- See also https://github.com/vim/vim/pull/6141\n+    reset(state, screen)\n+    wantscreen(vt)\n+    resize(25, 80, vt)\n+    screen = wantscreen(vt, { b = true })\n+    push('\\x1b[24HLine 24\\r\\nLine 25\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    resize(20, 80, vt)\n+    expect(\n+      'sb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 ='\n+    )\n+    cursor(0, 0, state)\n+\n+    -- Resize taller attempts to pop scrollback\n+    reset(state, screen)\n+    screen = wantscreen(vt)\n+    resize(25, 80, vt)\n+    push('Line 1\\x1b[25HBottom\\x1b[15H', vt)\n+    screen_row(0, 'Line 1', screen)\n+    screen_row(24, 'Bottom', screen)\n+    cursor(14, 0, state)\n+    screen = wantscreen(vt, { b = true })\n+    resize(30, 80, vt)\n+    expect('sb_popline 80\\nsb_popline 80\\nsb_popline 80\\nsb_popline 80\\nsb_popline 80')\n+    screen_row(0, 'ABCDE', screen)\n+    screen_row(5, 'Line 1', screen)\n+    screen_row(29, 'Bottom', screen)\n+    cursor(19, 0, state)\n+    screen = wantscreen(vt)\n+\n+    -- Resize can operate on altscreen\n+    reset(state, screen)\n+    screen = wantscreen(vt, { a = true })\n+    resize(25, 80, vt)\n+    push('Main screen\\x1b[?1049h\\x1b[HAlt screen', vt)\n+    resize(30, 80, vt)\n+    screen_row(0, 'Alt screen', screen)\n+    push('\\x1b[?1049l', vt)\n+    screen_row(0, 'Main screen', screen)\n+  end)\n+\n+  itp('64screen_pen', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    -- Plain\n+    push('A', vt)\n+    screen_cell(0, 0, '{41} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Bold\n+    push('\\x1b[1mB', vt)\n+    screen_cell(0, 1, '{42} width=1 attrs={B} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Italic\n+    push('\\x1b[3mC', vt)\n+    screen_cell(0, 2, '{43} width=1 attrs={BI} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Underline\n+    push('\\x1b[4mD', vt)\n+    screen_cell(0, 3, '{44} width=1 attrs={BU1I} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Reset\n+    push('\\x1b[mE', vt)\n+    screen_cell(0, 4, '{45} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Font\n+    push('\\x1b[11mF\\x1b[m', vt)\n+    screen_cell(0, 5, '{46} width=1 attrs={F1} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Foreground\n+    push('\\x1b[31mG\\x1b[m', vt)\n+    screen_cell(0, 6, '{47} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(0,0,0)', screen)\n+\n+    -- Background\n+    push('\\x1b[42mH\\x1b[m', vt)\n+    screen_cell(0, 7, '{48} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,224,0)', screen)\n+\n+    -- Super/subscript\n+    push('x\\x1b[74m0\\x1b[73m2\\x1b[m', vt)\n+    screen_cell(0, 8, '{78} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 9, '{30} width=1 attrs={S_} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 10, '{32} width=1 attrs={S^} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- EL sets only colours to end of line, not other attrs\n+    push('\\x1b[H\\x1b[7;33;44m\\x1b[K', vt)\n+    screen_cell(0, 0, '{} width=1 attrs={} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+    screen_cell(0, 79, '{} width=1 attrs={} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+\n+    -- DECSCNM xors reverse for entire screen\n+    push('R\\x1b[?5h', vt)\n+    screen_cell(0, 0, '{52} width=1 attrs={} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+    screen_cell(1, 0, '{} width=1 attrs={R} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    push('\\x1b[?5$p', vt)\n+    expect_output('\\x1b[?5;1$y')\n+    push('\\x1b[?5l', vt)\n+    screen_cell(0, 0, '{52} width=1 attrs={R} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+    screen_cell(1, 0, '{} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    -- TODO(dundargoc): fix\n+    -- push('\\x1b[?5$p')\n+    -- expect_output('\\x1b[?5;2$y')\n+\n+    -- Set default colours\n+    reset(nil, screen)\n+    push('ABC\\x1b[31mDEF\\x1b[m', vt)\n+    screen_cell(0, 0, '{41} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 3, '{44} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(0,0,0)', screen)\n+    -- TODO(dundargoc): fix\n+    -- SETDEFAULTCOL rgb(252,253,254)\n+    --   ?screen_cell 0,0  = {41} width=1 attrs={} fg=rgb(252,253,254) bg=rgb(0,0,0)\n+    --   ?screen_cell 0,3  = {44} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(0,0,0)\n+    -- SETDEFAULTCOL rgb(250,250,250) rgb(10,20,30)\n+    --   ?screen_cell 0,0  = {41} width=1 attrs={} fg=rgb(250,250,250) bg=rgb(10,20,30)\n+    --   ?screen_cell 0,3  = {44} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(10,20,30)\n+  end)\n+\n+  itp('65screen_protect', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    -- Selective erase\n+    reset(nil, screen)\n+    push('A\\x1b[1\"qB\\x1b[\"qC', vt)\n+    screen_row(0, 'ABC', screen)\n+    push('\\x1b[G\\x1b[?J', vt)\n+    screen_row(0, ' B', screen)\n+\n+    -- Non-selective erase\n+    reset(nil, screen)\n+    push('A\\x1b[1\"qB\\x1b[\"qC', vt)\n+    screen_row(0, 'ABC', screen)\n+    -- TODO(dundargoc): fix\n+    -- push('\\x1b[G\\x1b[J', vt)\n+    -- screen_row(0, '', screen)\n+  end)\n+\n+  itp('66screen_extent', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    -- Bold extent\n+    reset(nil, screen)\n+    push('AB\\x1b[1mCD\\x1b[mE', vt)\n+    screen_attrs_extent(0, 0, '0,0-1,1', screen)\n+    screen_attrs_extent(0, 1, '0,0-1,1', screen)\n+    screen_attrs_extent(0, 2, '0,2-1,3', screen)\n+    screen_attrs_extent(0, 3, '0,2-1,3', screen)\n+    screen_attrs_extent(0, 4, '0,4-1,79', screen)\n+  end)\n+\n+  itp('67screen_dbl_wh', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    -- Single Width, Single Height\n+    reset(nil, screen)\n+    push('\\x1b#5', vt)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Double Width, Single Height\n+    reset(nil, screen)\n+    push('\\x1b#6', vt)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} dwl fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Double Height\n+    reset(nil, screen)\n+    push('\\x1b#3', vt)\n+    push('abcde', vt)\n+    push('\\r\\n\\x1b#4', vt)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} dwl dhl-top fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(\n+      1,\n+      0,\n+      '{61} width=1 attrs={} dwl dhl-bottom fg=rgb(240,240,240) bg=rgb(0,0,0)',\n+      screen\n+    )\n+\n+    -- Late change\n+    reset(nil, screen)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    push('\\x1b#6', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} dwl fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- DWL doesn't spill over on scroll\n+    reset(nil, screen)\n+    push('\\x1b[25H\\x1b#6Final\\r\\n', vt)\n+    screen_cell(23, 0, '{46} width=1 attrs={} dwl fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(24, 0, '{} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+  end)\n+\n+  itp('68screen_termprops', function()\n+    local vt = init()\n+    local screen = wantscreen(vt, { p = true })\n+\n+    reset(nil, screen)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+\n+    -- Cursor visibility\n+    push('\\x1b[?25h', vt)\n+    expect('settermprop 1 true')\n+    push('\\x1b[?25l', vt)\n+    expect('settermprop 1 false')\n+\n+    -- Title\n+    push('\\x1b]2;Here is my title\\a', vt)\n+    expect('settermprop 4 [\"Here is my title\"]')\n+  end)\n+\n+  itp('69screen_pushline', function()\n+    local vt = init()\n+    -- Run these tests on a much smaller default screen, so debug output is nowhere near as noisy\n+    resize(5, 10, vt)\n+    local state = wantstate(vt)\n+    local screen = wantscreen(vt, { r = true })\n+    reset(state, screen)\n+\n+    -- Resize wider reflows wide lines\n+    reset(state, screen)\n+    push(string.rep('A', 12), vt)\n+    screen_row(0, 'AAAAAAAAAA', screen, vt.cols)\n+    screen_row(1, 'AA', screen, vt.cols)\n+    lineinfo(1, { cont = true }, state)\n+    cursor(1, 2, state)\n+    resize(5, 15, vt)\n+    screen_row(0, 'AAAAAAAAAAAA', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row(1, '', screen, vt.cols)\n+    lineinfo(1, {}, state)\n+    cursor(0, 12, state)\n+    resize(5, 20, vt)\n+    screen_row(0, 'AAAAAAAAAAAA', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 ,'',screen, vt.cols)\n+    lineinfo(1, {}, state)\n+    cursor(0, 12, state)\n+\n+    -- Resize narrower can create continuation lines\n+    reset(state, screen)\n+    resize(5, 10, vt)\n+    push('ABCDEFGHI', vt)\n+    screen_row(0, 'ABCDEFGHI', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen, vt.cols)\n+    lineinfo(1, {}, state)\n+    cursor(0, 9, state)\n+    resize(5, 8, vt)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 0 , \"ABCDEFGH\",screen,vt.cols)\n+    screen_row(1, 'I', screen, vt.cols)\n+    lineinfo(1, { cont = true }, state)\n+    cursor(1, 1, state)\n+    resize(5, 6, vt)\n+    screen_row(0, 'ABCDEF', screen, vt.cols)\n+    screen_row(1, 'GHI', screen, vt.cols)\n+    lineinfo(1, { cont = true }, state)\n+    cursor(1, 3, state)\n+\n+    -- Shell wrapped prompt behaviour\n+    reset(state, screen)\n+    resize(5, 10, vt)\n+    push('PROMPT GOES HERE\\r\\n> \\r\\n\\r\\nPROMPT GOES HERE\\r\\n> ', vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    screen_row(2, 'PROMPT GOE', screen, vt.cols)\n+    screen_row(3, 'S HERE', screen, vt.cols)\n+    lineinfo(3, { cont = true }, state)\n+    screen_row(4, '> ', screen, vt.cols)\n+    cursor(4, 2, state)\n+    resize(5, 11, vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    screen_row(2, 'PROMPT GOES', screen, vt.cols)\n+    screen_row(3, ' HERE', screen, vt.cols)\n+    lineinfo(3, { cont = true }, state)\n+    screen_row(4, '> ', screen, vt.cols)\n+    cursor(4, 2, state)\n+    resize(5, 12, vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    screen_row(2, 'PROMPT GOES ', screen, vt.cols)\n+    screen_row(3, 'HERE', screen, vt.cols)\n+    lineinfo(3, { cont = true }, state)\n+    screen_row(4, '> ', screen, vt.cols)\n+    cursor(4, 2, state)\n+    resize(5, 16, vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    -- screen_row( 2 , \"PROMPT GOES HERE\",screen,vt.cols)\n+    lineinfo(3, {}, state)\n+    screen_row(3, '> ', screen, vt.cols)\n+    cursor(3, 2, state)\n+\n+    -- Cursor goes missing\n+    -- For more context: https://github.com/neovim/neovim/pull/21124\n+    reset(state, screen)\n+    resize(5, 5, vt)\n+    resize(3, 1, vt)\n+    push('\\x1b[2;1Habc\\r\\n\\x1b[H', vt)\n+    resize(1, 1, vt)\n+    cursor(0, 0, state)\n+  end)\n+\n+  pending('90vttest_01-movement-1', function() end)\n+  pending('90vttest_01-movement-2', function() end)\n+\n+  itp('90vttest_01-movement-3', function()\n+    -- Test of cursor-control characters inside ESC sequences\n+    local vt = init()\n+    local state = wantstate(vt)\n+    local screen = wantscreen(vt)\n+\n+    reset(state, screen)\n+\n+    push('A B C D E F G H I', vt)\n+    push('\\x0d\\x0a', vt)\n+    push('A\\x1b[2\\bCB\\x1b[2\\bCC\\x1b[2\\bCD\\x1b[2\\bCE\\x1b[2\\bCF\\x1b[2\\bCG\\x1b[2\\bCH\\x1b[2\\bCI', vt)\n+    push('\\x0d\\x0a', vt)\n+    push(\n+      'A \\x1b[\\x0d2CB\\x1b[\\x0d4CC\\x1b[\\x0d6CD\\x1b[\\x0d8CE\\x1b[\\x0d10CF\\x1b[\\x0d12CG\\x1b[\\x0d14CH\\x1b[\\x0d16CI',\n+      vt\n+    )\n+    push('\\x0d\\x0a', vt)\n+    push(\n+      'A \\x1b[1\\x0bAB \\x1b[1\\x0bAC \\x1b[1\\x0bAD \\x1b[1\\x0bAE \\x1b[1\\x0bAF \\x1b[1\\x0bAG \\x1b[1\\x0bAH \\x1b[1\\x0bAI \\x1b[1\\x0bA',\n+      vt\n+    )\n+\n+    -- Output\n+\n+    for i = 0, 2 do\n+      screen_row(i, 'A B C D E F G H I', screen)\n+    end\n+    screen_row(3, 'A B C D E F G H I ', screen)\n+\n+    cursor(3, 18, state)\n+  end)\n+\n+  itp('90vttest_01-movement-4', function()\n+    -- Test of leading zeroes in ESC sequences\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    push('\\x1b[00000000004;000000001HT', vt)\n+    push('\\x1b[00000000004;000000002Hh', vt)\n+    push('\\x1b[00000000004;000000003Hi', vt)\n+    push('\\x1b[00000000004;000000004Hs', vt)\n+    push('\\x1b[00000000004;000000005H ', vt)\n+    push('\\x1b[00000000004;000000006Hi', vt)\n+    push('\\x1b[00000000004;000000007Hs', vt)\n+    push('\\x1b[00000000004;000000008H ', vt)\n+    push('\\x1b[00000000004;000000009Ha', vt)\n+    push('\\x1b[00000000004;0000000010H ', vt)\n+    push('\\x1b[00000000004;0000000011Hc', vt)\n+    push('\\x1b[00000000004;0000000012Ho', vt)\n+    push('\\x1b[00000000004;0000000013Hr', vt)\n+    push('\\x1b[00000000004;0000000014Hr', vt)\n+    push('\\x1b[00000000004;0000000015He', vt)\n+    push('\\x1b[00000000004;0000000016Hc', vt)\n+    push('\\x1b[00000000004;0000000017Ht', vt)\n+    push('\\x1b[00000000004;0000000018H ', vt)\n+    push('\\x1b[00000000004;0000000019Hs', vt)\n+    push('\\x1b[00000000004;0000000020He', vt)\n+    push('\\x1b[00000000004;0000000021Hn', vt)\n+    push('\\x1b[00000000004;0000000022Ht', vt)\n+    push('\\x1b[00000000004;0000000023He', vt)\n+    push('\\x1b[00000000004;0000000024Hn', vt)\n+    push('\\x1b[00000000004;0000000025Hc', vt)\n+    push('\\x1b[00000000004;0000000026He', vt)\n+\n+    -- Output\n+\n+    screen_row(3, 'This is a correct sentence', screen)\n+  end)\n+\n+  pending('90vttest_02-screen-1', function() end)\n+  pending('90vttest_02-screen-2', function() end)\n+\n+  itp('90vttest_02-screen-3', function()\n+    -- Origin mode\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[23;24r', vt)\n+    push('\\n', vt)\n+    push('Bottom', vt)\n+    push('\\x1b[1;1H', vt)\n+    push('Above', vt)\n+\n+    -- Output\n+    screen_row(22, 'Above', screen)\n+    screen_row(23, 'Bottom', screen)\n+  end)\n+\n+  itp('90vttest_02-screen-4', function()\n+    -- Origin mode (2)\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    push('\\x1b[?6l', vt)\n+    push('\\x1b[23;24r', vt)\n+    push('\\x1b[24;1H', vt)\n+    push('Bottom', vt)\n+    push('\\x1b[1;1H', vt)\n+    push('Top', vt)\n+\n+    -- Output\n+    screen_row(23, 'Bottom', screen)\n+    screen_row(0, 'Top', screen)\n+  end)\n+\n+  itp('92lp1640917', function()",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1809567365",
            "id": 1809567365,
            "in_reply_to_id": 1809564001,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5r286F",
            "original_commit_id": "eec2162be6d8484d1eaf73082e4db58763c4871b",
            "original_line": 3575,
            "original_position": 3575,
            "original_start_line": null,
            "path": "test/unit/vterm_spec.lua",
            "position": null,
            "pull_request_review_id": 2383349352,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809567365/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-21T21:32:53Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809567365",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1809577718"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809577718"
                }
            },
            "author_association": "MEMBER",
            "body": "Just checking that it's intentional. If a more meaningful name is possible then great",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-10-21T21:45:26Z",
            "diff_hunk": "@@ -0,0 +1,3590 @@\n+local t = require('test.unit.testutil')\n+local itp = t.gen_itp(it)\n+local bit = require('bit')\n+\n+--- @class vterm\n+--- @field ENC_UTF8 integer\n+--- @field VTERM_ATTR_BLINK integer\n+--- @field VTERM_ATTR_BOLD integer\n+--- @field VTERM_ATTR_FONT integer\n+--- @field VTERM_ATTR_ITALIC integer\n+--- @field VTERM_ATTR_REVERSE integer\n+--- @field VTERM_ATTR_UNDERLINE integer\n+--- @field VTERM_BASELINE_RAISE integer\n+--- @field VTERM_KEY_ENTER integer\n+--- @field VTERM_KEY_FUNCTION_0 integer\n+--- @field VTERM_KEY_KP_0 integer\n+--- @field VTERM_KEY_NONE integer\n+--- @field VTERM_KEY_TAB integer\n+--- @field VTERM_KEY_UP integer\n+--- @field VTERM_MAX_CHARS_PER_CELL integer\n+--- @field VTERM_MOD_ALT integer\n+--- @field VTERM_MOD_CTRL integer\n+--- @field VTERM_MOD_SHIFT integer\n+--- @field parser_apc function\n+--- @field parser_csi function\n+--- @field parser_dcs function\n+--- @field parser_osc function\n+--- @field parser_pm function\n+--- @field parser_sos function\n+--- @field parser_text function\n+--- @field print_color function\n+--- @field screen_sb_clear function\n+--- @field screen_sb_popline function\n+--- @field screen_sb_pushline function\n+--- @field selection_query function\n+--- @field selection_set function\n+--- @field state_erase function\n+--- @field state_movecursor function\n+--- @field state_moverect function\n+--- @field state_pos function\n+--- @field state_putglyph function\n+--- @field state_sb_clear function\n+--- @field state_scrollrect function\n+--- @field state_setpenattr function\n+--- @field state_settermprop function\n+--- @field term_output function\n+--- @field vterm_input_write function\n+--- @field vterm_keyboard_end_paste function\n+--- @field vterm_keyboard_key function\n+--- @field vterm_keyboard_start_paste function\n+--- @field vterm_keyboard_unichar function\n+--- @field vterm_lookup_encoding fun(any, any):any\n+--- @field vterm_mouse_button function\n+--- @field vterm_mouse_move function\n+--- @field vterm_new fun(any, any):any\n+--- @field vterm_obtain_screen fun(any):any\n+--- @field vterm_obtain_state fun(any): any\n+--- @field vterm_output_set_callback function\n+--- @field vterm_parser_set_callbacks fun(any, any, any):any\n+--- @field vterm_screen_convert_color_to_rgb function\n+--- @field vterm_screen_enable_altscreen function\n+--- @field vterm_screen_enable_reflow function\n+--- @field vterm_screen_get_attrs_extent function\n+--- @field vterm_screen_get_cell function\n+--- @field vterm_screen_get_chars fun(any, any, any, any):any\n+--- @field vterm_screen_get_text fun(any, any, any, any):any\n+--- @field vterm_screen_is_eol fun(any, any):any\n+--- @field vterm_screen_reset function\n+--- @field vterm_screen_set_callbacks function\n+--- @field vterm_set_size function\n+--- @field vterm_set_utf8 fun(any, any, any):any\n+--- @field vterm_state_focus_in function\n+--- @field vterm_state_focus_out function\n+--- @field vterm_state_get_cursorpos fun(any, any)\n+--- @field vterm_state_get_lineinfo fun(any, any):any\n+--- @field vterm_state_get_penattr function\n+--- @field vterm_state_reset function\n+--- @field vterm_state_set_bold_highbright function\n+--- @field vterm_state_set_callbacks function\n+--- @field vterm_state_set_selection_callbacks function\n+--- @field vterm_state_set_unrecognised_fallbacks function\n+local vterm = t.cimport('./src/vterm/vterm.h', './src/vterm/vterm_internal.h')\n+\n+--- @return string\n+local function read_rm()\n+  local f = assert(io.open(t.paths.vterm_test_file, 'rb'))\n+  local text = f:read('*a')\n+  f:close()\n+  vim.fs.rm(t.paths.vterm_test_file, { force = true })\n+  return text\n+end\n+\n+local function append(str)\n+  local f = assert(io.open(t.paths.vterm_test_file, 'a'))\n+  f:write(str)\n+  f:close()\n+  return 1\n+end\n+\n+local function parser_control(control)\n+  return append(string.format('control %02x\\n', control))\n+end\n+\n+local function parser_escape(bytes)\n+  return append(string.format('escape %s\\n', t.ffi.string(bytes)))\n+end\n+\n+local function wantparser(vt)\n+  assert(vt)\n+\n+  local parser_cbs = t.ffi.new('VTermParserCallbacks')\n+  parser_cbs['text'] = vterm.parser_text\n+  parser_cbs['control'] = parser_control\n+  parser_cbs['escape'] = parser_escape\n+  parser_cbs['csi'] = vterm.parser_csi\n+  parser_cbs['osc'] = vterm.parser_osc\n+  parser_cbs['dcs'] = vterm.parser_dcs\n+  parser_cbs['apc'] = vterm.parser_apc\n+  parser_cbs['pm'] = vterm.parser_pm\n+  parser_cbs['sos'] = vterm.parser_sos\n+\n+  vterm.vterm_parser_set_callbacks(vt, parser_cbs, nil)\n+end\n+\n+--- @return any\n+local function init()\n+  local vt = vterm.vterm_new(25, 80)\n+  vterm.vterm_output_set_callback(vt, vterm.term_output, nil)\n+  vterm.vterm_set_utf8(vt, true)\n+  return vt\n+end\n+\n+local function state_setlineinfo()\n+  return 1\n+end\n+\n+--- @return any\n+local function wantstate(vt, opts)\n+  opts = opts or {}\n+  assert(vt)\n+  local state = vterm.vterm_obtain_state(vt)\n+\n+  local state_cbs = t.ffi.new('VTermStateCallbacks')\n+  state_cbs['putglyph'] = vterm.state_putglyph\n+  state_cbs['movecursor'] = vterm.state_movecursor\n+  state_cbs['scrollrect'] = vterm.state_scrollrect\n+  state_cbs['moverect'] = vterm.state_moverect\n+  state_cbs['erase'] = vterm.state_erase\n+  state_cbs['setpenattr'] = vterm.state_setpenattr\n+  state_cbs['settermprop'] = vterm.state_settermprop\n+  state_cbs['setlineinfo'] = state_setlineinfo\n+  state_cbs['sb_clear'] = vterm.state_sb_clear\n+\n+  local selection_cbs = t.ffi.new('VTermSelectionCallbacks')\n+  selection_cbs['set'] = vterm.selection_set\n+  selection_cbs['query'] = vterm.selection_query\n+\n+  vterm.vterm_state_set_callbacks(state, state_cbs, nil)\n+\n+  -- In some tests we want to check the behaviour of overflowing the buffer, so make it nicely small\n+  vterm.vterm_state_set_selection_callbacks(state, selection_cbs, nil, nil, 16)\n+  vterm.vterm_state_set_bold_highbright(state, 1)\n+  vterm.vterm_state_reset(state, 1)\n+\n+  local fallbacks = t.ffi.new('VTermStateFallbacks')\n+  fallbacks['control'] = parser_control\n+  fallbacks['csi'] = vterm.parser_csi\n+  fallbacks['osc'] = vterm.parser_osc\n+  fallbacks['dcs'] = vterm.parser_dcs\n+  fallbacks['apc'] = vterm.parser_apc\n+  fallbacks['pm'] = vterm.parser_pm\n+  fallbacks['sos'] = vterm.parser_sos\n+\n+  vterm.want_state_scrollback = opts.b or false\n+  vterm.want_state_erase = opts.e or false\n+  vterm.vterm_state_set_unrecognised_fallbacks(state, opts.f and fallbacks or nil, nil)\n+  vterm.want_state_putglyph = opts.g or false\n+  vterm.want_state_moverect = opts.m or false\n+  vterm.want_state_settermprop = opts.p or false\n+  vterm.want_state_scrollrect = opts.s or false\n+\n+  return state\n+end\n+\n+--- @return any\n+local function wantscreen(vt, opts)\n+  opts = opts or {}\n+  local screen = vterm.vterm_obtain_screen(vt)\n+  local screen_cbs = t.ffi.new('VTermScreenCallbacks')\n+\n+  -- TODO(dundargoc): fix\n+  -- screen_cbs['damage']      = vterm.screen_damage\n+  screen_cbs['moverect'] = vterm.state_moverect\n+  screen_cbs['movecursor'] = vterm.state_movecursor\n+  screen_cbs['settermprop'] = vterm.state_settermprop\n+  screen_cbs['sb_pushline'] = vterm.screen_sb_pushline\n+  screen_cbs['sb_popline'] = vterm.screen_sb_popline\n+  screen_cbs['sb_clear'] = vterm.screen_sb_clear\n+\n+  vterm.vterm_screen_set_callbacks(screen, screen_cbs, nil)\n+\n+  if opts.a then\n+    vterm.vterm_screen_enable_altscreen(screen, 1)\n+  end\n+  vterm.want_screen_scrollback = opts.b or false\n+  vterm.want_state_movecursor = opts.c or false\n+  -- TODO(dundargoc): fix\n+  -- vterm.want_screen_damage = opts.d or opts.D or false\n+  -- vterm.want_screen_cells = opts.D or false\n+  vterm.want_state_moverect = opts.m or false\n+  vterm.want_state_settermprop = opts.p or false\n+  if opts.r then\n+    vterm.vterm_screen_enable_reflow(screen, true)\n+  end\n+\n+  return screen\n+end\n+\n+local function reset(state, screen)\n+  if state then\n+    vterm.vterm_state_reset(state, 1)\n+    vterm.vterm_state_get_cursorpos(state, vterm.state_pos)\n+  end\n+  if screen then\n+    vterm.vterm_screen_reset(screen, 1)\n+  end\n+end\n+\n+local function push(input, vt)\n+  vterm.vterm_input_write(vt, input, string.len(input))\n+end\n+\n+local function expect(expected)\n+  local actual = read_rm()\n+  t.eq(expected .. '\\n', actual)\n+end\n+\n+local function expect_output(expected_preformat)\n+  local actual = read_rm()\n+  local expected = 'output '\n+\n+  for c in string.gmatch(expected_preformat, '.') do\n+    if expected ~= 'output ' then\n+      expected = expected .. ','\n+    end\n+    expected = string.format('%s%x', expected, string.byte(c))\n+  end\n+\n+  t.eq(expected .. '\\n', actual)\n+end\n+\n+local function cursor(row, col, state)\n+  local pos = t.ffi.new('VTermPos') --- @type {row: integer, col: integer}\n+  vterm.vterm_state_get_cursorpos(state, pos)\n+  t.eq(row, pos.row)\n+  t.eq(col, pos.col)\n+end\n+\n+local function lineinfo(row, expected, state)\n+  local info = vterm.vterm_state_get_lineinfo(state, row)\n+  local dwl = info.doublewidth == 1\n+  local dhl = info.doubleheight == 1\n+  local cont = info.continuation == 1\n+\n+  t.eq(dwl, expected.dwl or false)\n+  t.eq(dhl, expected.dhl or false)\n+  t.eq(cont, expected.cont or false)\n+end\n+\n+local function pen(attribute, expected, state)\n+  local is_bool = { bold = true, italic = true, blink = true, reverse = true }\n+  local vterm_attribute = {\n+    bold = vterm.VTERM_ATTR_BOLD,\n+    underline = vterm.VTERM_ATTR_UNDERLINE,\n+    italic = vterm.VTERM_ATTR_ITALIC,\n+    blink = vterm.VTERM_ATTR_BLINK,\n+    reverse = vterm.VTERM_ATTR_REVERSE,\n+    font = vterm.VTERM_ATTR_FONT,\n+  }\n+\n+  local val = t.ffi.new('VTermValue') --- @type {boolean: integer}\n+  vterm.vterm_state_get_penattr(state, vterm_attribute[attribute], val)\n+  local actual = val.boolean --- @type integer|boolean\n+  if is_bool[attribute] then\n+    actual = val.boolean == 1\n+  end\n+  t.eq(expected, actual)\n+end\n+\n+local function resize(rows, cols, vt)\n+  vterm.vterm_set_size(vt, rows, cols)\n+end\n+\n+local function screen_chars(start_row, start_col, end_row, end_col, expected, screen)\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_row'] = start_row\n+  rect['start_col'] = start_col\n+  rect['end_row'] = end_row\n+  rect['end_col'] = end_col\n+\n+  local len = vterm.vterm_screen_get_chars(screen, nil, 0, rect)\n+\n+  local chars = t.ffi.new('uint32_t[?]', len)\n+  vterm.vterm_screen_get_chars(screen, chars, len, rect)\n+\n+  local actual = ''\n+  for i = 0, tonumber(len) - 1 do\n+    actual = actual .. string.char(chars[i])\n+  end\n+\n+  t.eq(expected, actual)\n+end\n+\n+local function screen_text(start_row, start_col, end_row, end_col, expected, screen)\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_row'] = start_row\n+  rect['start_col'] = start_col\n+  rect['end_row'] = end_row\n+  rect['end_col'] = end_col\n+\n+  local len = vterm.vterm_screen_get_text(screen, nil, 0, rect)\n+\n+  local text = t.ffi.new('unsigned char[?]', len)\n+  vterm.vterm_screen_get_text(screen, text, len, rect)\n+\n+  local actual = ''\n+  for i = 0, tonumber(len) - 1 do\n+    actual = string.format('%s%02x,', actual, text[i])\n+  end\n+  actual = actual:sub(1, -2)\n+\n+  t.eq(expected, actual)\n+end\n+\n+--- @param row integer\n+local function screen_row(row, expected, screen, end_col)\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_row'] = row\n+  rect['start_col'] = 0\n+  rect['end_row'] = row + 1\n+  rect['end_col'] = end_col or 80\n+\n+  local len = vterm.vterm_screen_get_text(screen, nil, 0, rect)\n+\n+  local text = t.ffi.new('unsigned char[?]', len)\n+  vterm.vterm_screen_get_text(screen, text, len, rect)\n+\n+  t.eq(expected, t.ffi.string(text))\n+end\n+\n+local function screen_cell(row, col, expected, screen)\n+  local pos = t.ffi.new('VTermPos')\n+  pos['row'] = row\n+  pos['col'] = col\n+\n+  local cell = t.ffi.new('VTermScreenCell')\n+  vterm.vterm_screen_get_cell(screen, pos, cell)\n+\n+  local actual = '{'\n+  for i = 0, vterm.VTERM_MAX_CHARS_PER_CELL - 1 do\n+    if cell['chars'][i] ~= 0 then\n+      if i > 0 then\n+        actual = actual .. ','\n+      end\n+      actual = string.format('%s%02x', actual, cell['chars'][i])\n+    end\n+  end\n+  actual = string.format('%s} width=%d attrs={', actual, cell['width'])\n+  actual = actual .. (cell['attrs'].bold ~= 0 and 'B' or '')\n+  actual = actual\n+    .. (cell['attrs'].underline ~= 0 and string.format('U%d', cell['attrs'].underline) or '')\n+  actual = actual .. (cell['attrs'].italic ~= 0 and 'I' or '')\n+  actual = actual .. (cell['attrs'].blink ~= 0 and 'K' or '')\n+  actual = actual .. (cell['attrs'].reverse ~= 0 and 'R' or '')\n+  actual = actual .. (cell['attrs'].font ~= 0 and string.format('F%d', cell['attrs'].font) or '')\n+  actual = actual .. (cell['attrs'].small ~= 0 and 'S' or '')\n+  if cell['attrs'].baseline ~= 0 then\n+    actual = actual .. (cell['attrs'].baseline == vterm.VTERM_BASELINE_RAISE and '^' or '_')\n+  end\n+  actual = actual .. '} '\n+\n+  actual = actual .. (cell['attrs'].dwl ~= 0 and 'dwl ' or '')\n+  if cell['attrs'].dhl ~= 0 then\n+    actual = actual .. string.format('dhl-%s ', cell['attrs'].dhl == 2 and 'bottom' or 'top')\n+  end\n+\n+  actual = string.format('%sfg=', actual)\n+  vterm.vterm_screen_convert_color_to_rgb(screen, cell['fg'])\n+  vterm.print_color(cell['fg'])\n+\n+  actual = actual .. read_rm()\n+  actual = actual .. ' bg='\n+\n+  vterm.vterm_screen_convert_color_to_rgb(screen, cell['bg'])\n+  vterm.print_color(cell['bg'])\n+\n+  actual = actual .. read_rm()\n+\n+  t.eq(expected, actual)\n+end\n+\n+local function screen_eol(row, col, expected, screen)\n+  local pos = t.ffi.new('VTermPos')\n+  pos['row'] = row\n+  pos['col'] = col\n+\n+  local is_eol = vterm.vterm_screen_is_eol(screen, pos)\n+  t.eq(expected, is_eol)\n+end\n+\n+local function screen_attrs_extent(row, col, expected, screen)\n+  local pos = t.ffi.new('VTermPos')\n+  pos['row'] = row\n+  pos['col'] = col\n+\n+  local rect = t.ffi.new('VTermRect')\n+  rect['start_col'] = 0\n+  rect['end_col'] = -1\n+  vterm.vterm_screen_get_attrs_extent(screen, rect, pos, 1)\n+\n+  local actual = string.format(\n+    '%d,%d-%d,%d',\n+    rect['start_row'],\n+    rect['start_col'],\n+    rect['end_row'],\n+    rect['end_col']\n+  )\n+\n+  t.eq(expected, actual)\n+end\n+\n+local function wantencoding()\n+  local encoding = t.ffi.new('VTermEncodingInstance')\n+  encoding['enc'] = vterm.vterm_lookup_encoding(vterm.ENC_UTF8, string.byte('u'))\n+  if encoding.enc.init then\n+    encoding.enc.init(encoding.enc, encoding['data'])\n+  end\n+  return encoding\n+end\n+\n+local function encin(input, encoding)\n+  local len = string.len(input)\n+\n+  local cp = t.ffi.new('uint32_t[?]', len)\n+  local cpi = t.ffi.new('int[1]')\n+  local pos = t.ffi.new('size_t[1]', 0)\n+\n+  encoding.enc.decode(encoding.enc, encoding.data, cp, cpi, len, input, pos, len)\n+\n+  local f = assert(io.open(t.paths.vterm_test_file, 'w'))\n+  if tonumber(cpi[0]) > 0 then\n+    f:write('encout ')\n+    for i = 0, cpi[0] - 1 do\n+      if i == 0 then\n+        f:write(string.format('%x', cp[i]))\n+      else\n+        f:write(string.format(',%x', cp[i]))\n+      end\n+    end\n+    f:write('\\n')\n+  end\n+  f:close()\n+end\n+\n+local function strpe_modifiers(input_mod)\n+  local mod = t.ffi.new('VTermModifier') ---@type any\n+  if input_mod.C then\n+    mod = bit.bor(mod, vterm.VTERM_MOD_CTRL)\n+  end\n+  if input_mod.S then\n+    mod = bit.bor(mod, vterm.VTERM_MOD_SHIFT)\n+  end\n+  if input_mod.A then\n+    mod = bit.bor(mod, vterm.VTERM_MOD_ALT)\n+  end\n+  return mod\n+end\n+\n+local function strp_key(input_key)\n+  if input_key == 'up' then\n+    return vterm.VTERM_KEY_UP\n+  end\n+\n+  if input_key == 'tab' then\n+    return vterm.VTERM_KEY_TAB\n+  end\n+\n+  if input_key == 'enter' then\n+    return vterm.VTERM_KEY_ENTER\n+  end\n+\n+  if input_key == 'f1' then\n+    return vterm.VTERM_KEY_FUNCTION_0 + 1\n+  end\n+\n+  if input_key == 'kp0' then\n+    return vterm.VTERM_KEY_KP_0\n+  end\n+\n+  return vterm.VTERM_KEY_NONE\n+end\n+\n+local function mousemove(row, col, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  vterm.vterm_mouse_move(vt, row, col, mod)\n+end\n+\n+local function mousebtn(press, button, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  local flag = press == 'd' or press == 'D'\n+  vterm.vterm_mouse_button(vt, button, flag, mod)\n+end\n+\n+local function inchar(c, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  vterm.vterm_keyboard_unichar(vt, c, mod)\n+end\n+\n+local function inkey(input_key, vt, input_mod)\n+  input_mod = input_mod or {}\n+  local mod = strpe_modifiers(input_mod)\n+  local key = strp_key(input_key)\n+  vterm.vterm_keyboard_key(vt, key, mod)\n+end\n+\n+before_each(function()\n+  vim.fs.rm(t.paths.vterm_test_file, { force = true })\n+end)\n+\n+describe('vterm', function()\n+  itp('02parser', function()\n+    local vt = init()\n+    vterm.vterm_set_utf8(vt, false)\n+    wantparser(vt)\n+\n+    -- Basic text\n+    push('hello', vt)\n+    expect('text 68,65,6c,6c,6f')\n+\n+    -- C0\n+    push('\\x03', vt)\n+    expect('control 03')\n+    push('\\x1f', vt)\n+    expect('control 1f')\n+\n+    -- C1 8bit\n+    push('\\x83', vt)\n+    expect('control 83')\n+    push('\\x99', vt)\n+    expect('control 99')\n+\n+    -- C1 7bit\n+    push('\\x1b\\x43', vt)\n+    expect('control 83')\n+    push('\\x1b\\x59', vt)\n+    expect('control 99')\n+\n+    -- High bytes\n+    push('\\xa0\\xcc\\xfe', vt)\n+    expect('text a0,cc,fe')\n+\n+    -- Mixed\n+    push('1\\n2', vt)\n+    expect('text 31\\ncontrol 0a\\ntext 32')\n+\n+    -- Escape\n+    push('\\x1b=', vt)\n+    expect('escape =')\n+\n+    -- Escape 2-byte\n+    push('\\x1b(X', vt)\n+    expect('escape (X')\n+\n+    -- Split write Escape\n+    push('\\x1b(', vt)\n+    push('Y', vt)\n+    expect('escape (Y')\n+\n+    -- Escape cancels Escape, starts another\n+    push('\\x1b(\\x1b)Z', vt)\n+    expect('escape )Z')\n+\n+    -- CAN cancels Escape, returns to normal mode\n+    push('\\x1b(\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in Escape interrupts and continues\n+    push('\\x1b(\\nX', vt)\n+    expect('control 0a\\nescape (X')\n+\n+    -- CSI 0 args\n+    push('\\x1b[a', vt)\n+    expect('csi 61 *')\n+\n+    -- CSI 1 arg\n+    push('\\x1b[9b', vt)\n+    expect('csi 62 9')\n+\n+    -- CSI 2 args\n+    push('\\x1b[3;4c', vt)\n+    expect('csi 63 3,4')\n+\n+    -- CSI 1 arg 1 sub\n+    push('\\x1b[1:2c', vt)\n+    expect('csi 63 1+,2')\n+\n+    -- CSI many digits\n+    push('\\x1b[678d', vt)\n+    expect('csi 64 678')\n+\n+    -- CSI leading zero\n+    push('\\x1b[007e', vt)\n+    expect('csi 65 7')\n+\n+    -- CSI qmark\n+    push('\\x1b[?2;7f', vt)\n+    expect('csi 66 L=3f 2,7')\n+\n+    -- CSI greater\n+    push('\\x1b[>c', vt)\n+    expect('csi 63 L=3e *')\n+\n+    -- CSI SP\n+    push('\\x1b[12 q', vt)\n+    expect('csi 71 12 I=20')\n+\n+    -- Mixed CSI\n+    push('A\\x1b[8mB', vt)\n+    expect('text 41\\ncsi 6d 8\\ntext 42')\n+\n+    -- Split write\n+    push('\\x1b', vt)\n+    push('[a', vt)\n+    expect('csi 61 *')\n+    push('foo\\x1b[', vt)\n+    expect('text 66,6f,6f')\n+    push('4b', vt)\n+    expect('csi 62 4')\n+    push('\\x1b[12;', vt)\n+    push('3c', vt)\n+    expect('csi 63 12,3')\n+\n+    -- Escape cancels CSI, starts Escape\n+    push('\\x1b[123\\x1b9', vt)\n+    expect('escape 9')\n+\n+    -- CAN cancels CSI, returns to normal mode\n+    push('\\x1b[12\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in Escape interrupts and continues\n+    push('\\x1b(\\nX', vt)\n+    expect('control 0a\\nescape (X')\n+\n+    -- OSC BEL\n+    push('\\x1b]1;Hello\\x07', vt)\n+    expect('osc [1;Hello]')\n+\n+    -- OSC ST (7bit)\n+    push('\\x1b]1;Hello\\x1b\\\\', vt)\n+    expect('osc [1;Hello]')\n+\n+    -- OSC ST (8bit)\n+    push('\\x9d1;Hello\\x9c', vt)\n+    expect('osc [1;Hello]')\n+\n+    -- OSC in parts\n+    push('\\x1b]52;abc', vt)\n+    expect('osc [52;abc')\n+    push('def', vt)\n+    expect('osc def')\n+    push('ghi\\x1b\\\\', vt)\n+    expect('osc ghi]')\n+\n+    -- OSC BEL without semicolon\n+    push('\\x1b]1234\\x07', vt)\n+    expect('osc [1234;]')\n+\n+    -- OSC ST without semicolon\n+    push('\\x1b]1234\\x1b\\\\', vt)\n+    expect('osc [1234;]')\n+\n+    -- Escape cancels OSC, starts Escape\n+    push('\\x1b]Something\\x1b9', vt)\n+    expect('escape 9')\n+\n+    -- CAN cancels OSC, returns to normal mode\n+    push('\\x1b]12\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in OSC interrupts and continues\n+    push('\\x1b]2;\\nBye\\x07', vt)\n+    expect('osc [2;\\ncontrol 0a\\nosc Bye]')\n+\n+    -- DCS BEL\n+    push('\\x1bPHello\\x07', vt)\n+    expect('dcs [Hello]')\n+\n+    -- DCS ST (7bit)\n+    push('\\x1bPHello\\x1b\\\\', vt)\n+    expect('dcs [Hello]')\n+\n+    -- DCS ST (8bit)\n+    push('\\x90Hello\\x9c', vt)\n+    expect('dcs [Hello]')\n+\n+    -- Split write of 7bit ST\n+    push('\\x1bPABC\\x1b', vt)\n+    expect('dcs [ABC')\n+    push('\\\\', vt)\n+    expect('dcs ]')\n+\n+    -- Escape cancels DCS, starts Escape\n+    push('\\x1bPSomething\\x1b9', vt)\n+    expect('escape 9')\n+\n+    -- CAN cancels DCS, returns to normal mode\n+    push('\\x1bP12\\x18AB', vt)\n+    expect('text 41,42')\n+\n+    -- C0 in OSC interrupts and continues\n+    push('\\x1bPBy\\ne\\x07', vt)\n+    expect('dcs [By\\ncontrol 0a\\ndcs e]')\n+\n+    -- APC BEL\n+    push('\\x1b_Hello\\x07', vt)\n+    expect('apc [Hello]')\n+\n+    -- APC ST (7bit)\n+    push('\\x1b_Hello\\x1b\\\\', vt)\n+    expect('apc [Hello]')\n+\n+    -- APC ST (8bit)\n+    push('\\x9fHello\\x9c', vt)\n+    expect('apc [Hello]')\n+\n+    -- PM BEL\n+    push('\\x1b^Hello\\x07', vt)\n+    expect('pm [Hello]')\n+\n+    -- PM ST (7bit)\n+    push('\\x1b^Hello\\x1b\\\\', vt)\n+    expect('pm [Hello]')\n+\n+    -- PM ST (8bit)\n+    push('\\x9eHello\\x9c', vt)\n+    expect('pm [Hello]')\n+\n+    -- SOS BEL\n+    push('\\x1bXHello\\x07', vt)\n+    expect('sos [Hello]')\n+\n+    -- SOS ST (7bit)\n+    push('\\x1bXHello\\x1b\\\\', vt)\n+    expect('sos [Hello]')\n+\n+    -- SOS ST (8bit)\n+    push('\\x98Hello\\x9c', vt)\n+    expect('sos [Hello]')\n+\n+    push('\\x1bXABC\\x01DEF\\x1b\\\\', vt)\n+    expect('sos [ABC\\x01DEF]')\n+    push('\\x1bXABC\\x99DEF\\x1b\\\\', vt)\n+    expect('sos [ABC\\x99DEF]')\n+\n+    -- NUL ignored\n+    push('\\x00', vt)\n+\n+    -- NUL ignored within CSI\n+    push('\\x1b[12\\x003m', vt)\n+    expect('csi 6d 123')\n+\n+    -- DEL ignored\n+    push('\\x7f', vt)\n+\n+    -- DEL ignored within CSI\n+    push('\\x1b[12\\x7f3m', vt)\n+    expect('csi 6d 123')\n+\n+    -- DEL inside text\"\n+    push('AB\\x7fC', vt)\n+    expect('text 41,42\\ntext 43')\n+  end)\n+\n+  itp('03encoding_utf8', function()\n+    local encoding = wantencoding()\n+\n+    -- Low\n+    encin('123', encoding)\n+    expect('encout 31,32,33')\n+\n+    -- We want to prove the UTF-8 parser correctly handles all the sequences.\n+    -- Easy way to do this is to check it does low/high boundary cases, as that\n+    -- leaves only two for each sequence length\n+    --\n+    -- These ranges are therefore:\n+    --\n+    -- Two bytes:\n+    -- U+0080 = 000 10000000 =>    00010   000000\n+    --                       => 11000010 10000000 = C2 80\n+    -- U+07FF = 111 11111111 =>    11111   111111\n+    --                       => 11011111 10111111 = DF BF\n+    --\n+    -- Three bytes:\n+    -- U+0800 = 00001000 00000000 =>     0000   100000   000000\n+    --                            => 11100000 10100000 10000000 = E0 A0 80\n+    -- U+FFFD = 11111111 11111101 =>     1111   111111   111101\n+    --                            => 11101111 10111111 10111101 = EF BF BD\n+    -- (We avoid U+FFFE and U+FFFF as they're invalid codepoints)\n+    --\n+    -- Four bytes:\n+    -- U+10000  = 00001 00000000 00000000 =>      000   010000   000000   000000\n+    --                                    => 11110000 10010000 10000000 10000000 = F0 90 80 80\n+    -- U+1FFFFF = 11111 11111111 11111111 =>      111   111111   111111   111111\n+    --                                    => 11110111 10111111 10111111 10111111 = F7 BF BF BF\n+\n+    -- 2 byte\n+    encin('\\xC2\\x80\\xDF\\xBF', encoding)\n+    expect('encout 80,7ff')\n+\n+    -- 3 byte\n+    encin('\\xE0\\xA0\\x80\\xEF\\xBF\\xBD', encoding)\n+    expect('encout 800,fffd')\n+\n+    -- 4 byte\n+    encin('\\xF0\\x90\\x80\\x80\\xF7\\xBF\\xBF\\xBF', encoding)\n+    expect('encout 10000,1fffff')\n+\n+    -- Next up, we check some invalid sequences\n+    --  + Early termination (back to low bytes too soon)\n+    --  + Early restart (another sequence introduction before the previous one was finished)\n+\n+    -- Early termination\n+    encin('\\xC2!', encoding)\n+    expect('encout fffd,21')\n+\n+    encin('\\xE0!\\xE0\\xA0!', encoding)\n+    expect('encout fffd,21,fffd,21')\n+\n+    encin('\\xF0!\\xF0\\x90!\\xF0\\x90\\x80!', encoding)\n+    expect('encout fffd,21,fffd,21,fffd,21')\n+\n+    -- Early restart\n+    encin('\\xC2\\xC2\\x90', encoding)\n+    expect('encout fffd,90')\n+\n+    encin('\\xE0\\xC2\\x90\\xE0\\xA0\\xC2\\x90', encoding)\n+    expect('encout fffd,90,fffd,90')\n+\n+    encin('\\xF0\\xC2\\x90\\xF0\\x90\\xC2\\x90\\xF0\\x90\\x80\\xC2\\x90', encoding)\n+    expect('encout fffd,90,fffd,90,fffd,90')\n+\n+    -- Test the overlong sequences by giving an overlong encoding of U+0000 and\n+    -- an encoding of the highest codepoint still too short\n+    --\n+    -- Two bytes:\n+    -- U+0000 = C0 80\n+    -- U+007F = 000 01111111 =>    00001   111111 =>\n+    --                       => 11000001 10111111 => C1 BF\n+    --\n+    -- Three bytes:\n+    -- U+0000 = E0 80 80\n+    -- U+07FF = 00000111 11111111 =>     0000   011111   111111\n+    --                            => 11100000 10011111 10111111 = E0 9F BF\n+    --\n+    -- Four bytes:\n+    -- U+0000 = F0 80 80 80\n+    -- U+FFFF = 11111111 11111111 =>      000   001111   111111   111111\n+    --                            => 11110000 10001111 10111111 10111111 = F0 8F BF BF\n+\n+    -- Overlong\n+    encin('\\xC0\\x80\\xC1\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    encin('\\xE0\\x80\\x80\\xE0\\x9F\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    encin('\\xF0\\x80\\x80\\x80\\xF0\\x8F\\xBF\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    -- UTF-16 surrogates U+D800 and U+DFFF\n+    -- UTF-16 Surrogates\n+    encin('\\xED\\xA0\\x80\\xED\\xBF\\xBF', encoding)\n+    expect('encout fffd,fffd')\n+\n+    -- Split write\n+    encin('\\xC2', encoding)\n+    encin('\\xA0', encoding)\n+    expect('encout a0')\n+\n+    encin('\\xE0', encoding)\n+    encin('\\xA0\\x80', encoding)\n+    expect('encout 800')\n+    encin('\\xE0\\xA0', encoding)\n+    encin('\\x80', encoding)\n+    expect('encout 800')\n+\n+    encin('\\xF0', encoding)\n+    encin('\\x90\\x80\\x80', encoding)\n+    expect('encout 10000')\n+    encin('\\xF0\\x90', encoding)\n+    encin('\\x80\\x80', encoding)\n+    expect('encout 10000')\n+    encin('\\xF0\\x90\\x80', encoding)\n+    encin('\\x80', encoding)\n+    expect('encout 10000')\n+  end)\n+\n+  itp('10state_putglyph', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Low\n+    reset(state, nil)\n+    push('ABC', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 43 1 0,2')\n+\n+    -- UTF-8 1 char\n+    -- U+00C1 = 0xC3 0x81  name: LATIN CAPITAL LETTER A WITH ACUTE\n+    -- U+00E9 = 0xC3 0xA9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(state, nil)\n+    push('\\xC3\\x81\\xC3\\xA9', vt)\n+    expect('putglyph c1 1 0,0\\nputglyph e9 1 0,1')\n+\n+    -- UTF-8 split writes\n+    reset(state, nil)\n+    push('\\xC3', vt)\n+    push('\\x81', vt)\n+    expect('putglyph c1 1 0,0')\n+\n+    -- UTF-8 wide char\n+    -- U+FF10 = EF BC 90  name: FULLWIDTH DIGIT ZERO\n+    reset(state, nil)\n+    push('\\xEF\\xBC\\x90 ', vt)\n+    expect('putglyph ff10 2 0,0\\nputglyph 20 1 0,2')\n+\n+    -- UTF-8 emoji wide char\n+    -- U+1F600 = F0 9F 98 80  name: GRINNING FACE\n+    reset(state, nil)\n+    push('\\xF0\\x9F\\x98\\x80 ', vt)\n+    expect('putglyph 1f600 2 0,0\\nputglyph 20 1 0,2')\n+\n+    -- UTF-8 combining chars\n+    -- U+0301 = CC 81  name: COMBINING ACUTE\n+    reset(state, nil)\n+    push('e\\xCC\\x81Z', vt)\n+    expect('putglyph 65,301 1 0,0\\nputglyph 5a 1 0,1')\n+\n+    -- Combining across buffers\n+    reset(state, nil)\n+    push('e', vt)\n+    expect('putglyph 65 1 0,0')\n+    push('\\xCC\\x81Z', vt)\n+    expect('putglyph 65,301 1 0,0\\nputglyph 5a 1 0,1')\n+\n+    -- Spare combining chars get truncated\n+    reset(state, nil)\n+    push('e' .. string.rep('\\xCC\\x81', 10), vt)\n+    expect('putglyph 65,301,301,301,301,301 1 0,0') -- and nothing more\n+\n+    reset(state, nil)\n+    push('e', vt)\n+    expect('putglyph 65 1 0,0')\n+    push('\\xCC\\x81', vt)\n+    expect('putglyph 65,301 1 0,0')\n+    push('\\xCC\\x82', vt)\n+    expect('putglyph 65,301,302 1 0,0')\n+\n+    -- DECSCA protected\n+    reset(state, nil)\n+    push('A\\x1b[1\"qB\\x1b[2\"qC', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 42 1 0,1 prot\\nputglyph 43 1 0,2')\n+  end)\n+\n+  itp('11state_movecursor', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Implicit\n+    push('ABC', vt)\n+    cursor(0, 3, state)\n+\n+    -- Backspace\n+    push('\\b', vt)\n+    cursor(0, 2, state)\n+    -- Horizontal Tab\n+    push('\\t', vt)\n+    cursor(0, 8, state)\n+    -- Carriage Return\n+    push('\\r', vt)\n+    cursor(0, 0, state)\n+    -- Linefeed\n+    push('\\n', vt)\n+    cursor(1, 0, state)\n+\n+    -- Backspace bounded by lefthand edge\n+    push('\\x1b[4;2H', vt)\n+    cursor(3, 1, state)\n+    push('\\b', vt)\n+    cursor(3, 0, state)\n+    push('\\b', vt)\n+    cursor(3, 0, state)\n+\n+    -- Backspace cancels phantom\n+    push('\\x1b[4;80H', vt)\n+    cursor(3, 79, state)\n+    push('X', vt)\n+    cursor(3, 79, state)\n+    push('\\b', vt)\n+    cursor(3, 78, state)\n+\n+    -- HT bounded by righthand edge\n+    push('\\x1b[1;78H', vt)\n+    cursor(0, 77, state)\n+    push('\\t', vt)\n+    cursor(0, 79, state)\n+    push('\\t', vt)\n+    cursor(0, 79, state)\n+\n+    reset(state, nil)\n+\n+    -- Index\n+    push('ABC\\x1bD', vt)\n+    cursor(1, 3, state)\n+    -- Reverse Index\n+    push('\\x1bM', vt)\n+    cursor(0, 3, state)\n+    -- Newline\n+    push('\\x1bE', vt)\n+    cursor(1, 0, state)\n+\n+    reset(state, nil)\n+\n+    -- Cursor Forward\n+    push('\\x1b[B', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[3B', vt)\n+    cursor(4, 0, state)\n+    push('\\x1b[0B', vt)\n+    cursor(5, 0, state)\n+\n+    -- Cursor Down\n+    push('\\x1b[C', vt)\n+    cursor(5, 1, state)\n+    push('\\x1b[3C', vt)\n+    cursor(5, 4, state)\n+    push('\\x1b[0C', vt)\n+    cursor(5, 5, state)\n+\n+    -- Cursor Up\n+    push('\\x1b[A', vt)\n+    cursor(4, 5, state)\n+    push('\\x1b[3A', vt)\n+    cursor(1, 5, state)\n+    push('\\x1b[0A', vt)\n+    cursor(0, 5, state)\n+\n+    -- Cursor Backward\n+    push('\\x1b[D', vt)\n+    cursor(0, 4, state)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[0D', vt)\n+    cursor(0, 0, state)\n+\n+    -- Cursor Next Line\n+    push('   ', vt)\n+    cursor(0, 3, state)\n+    push('\\x1b[E', vt)\n+    cursor(1, 0, state)\n+    push('   ', vt)\n+    cursor(1, 3, state)\n+    push('\\x1b[2E', vt)\n+    cursor(3, 0, state)\n+    push('\\x1b[0E', vt)\n+    cursor(4, 0, state)\n+\n+    -- Cursor Previous Line\n+    push('   ', vt)\n+    cursor(4, 3, state)\n+    push('\\x1b[F', vt)\n+    cursor(3, 0, state)\n+    push('   ', vt)\n+    cursor(3, 3, state)\n+    push('\\x1b[2F', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[0F', vt)\n+    cursor(0, 0, state)\n+\n+    -- Cursor Horizonal Absolute\n+    push('\\n', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[20G', vt)\n+    cursor(1, 19, state)\n+    push('\\x1b[G', vt)\n+    cursor(1, 0, state)\n+\n+    -- Cursor Position\n+    push('\\x1b[10;5H', vt)\n+    cursor(9, 4, state)\n+    push('\\x1b[8H', vt)\n+    cursor(7, 0, state)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+\n+    -- Cursor Position cancels phantom\n+    push('\\x1b[10;78H', vt)\n+    cursor(9, 77, state)\n+    push('ABC', vt)\n+    cursor(9, 79, state)\n+    push('\\x1b[10;80H', vt)\n+    push('C', vt)\n+    cursor(9, 79, state)\n+    push('X', vt)\n+    cursor(10, 1, state)\n+\n+    reset(state, nil)\n+\n+    -- Bounds Checking\n+    push('\\x1b[A', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[D', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[25;80H', vt)\n+    cursor(24, 79, state)\n+    push('\\x1b[B', vt)\n+    cursor(24, 79, state)\n+    push('\\x1b[C', vt)\n+    cursor(24, 79, state)\n+    push('\\x1b[E', vt)\n+    cursor(24, 0, state)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[F', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[999G', vt)\n+    cursor(0, 79, state)\n+    push('\\x1b[99;99H', vt)\n+    cursor(24, 79, state)\n+\n+    reset(state, nil)\n+\n+    -- Horizontal Position Absolute\n+    push('\\x1b[5`', vt)\n+    cursor(0, 4, state)\n+\n+    -- Horizontal Position Relative\n+    push('\\x1b[3a', vt)\n+    cursor(0, 7, state)\n+\n+    -- Horizontal Position Backward\n+    push('\\x1b[3j', vt)\n+    cursor(0, 4, state)\n+\n+    -- Horizontal and Vertical Position\n+    push('\\x1b[3;3f', vt)\n+    cursor(2, 2, state)\n+\n+    -- Vertical Position Absolute\n+    push('\\x1b[5d', vt)\n+    cursor(4, 2, state)\n+\n+    -- Vertical Position Relative\n+    push('\\x1b[2e', vt)\n+    cursor(6, 2, state)\n+\n+    -- Vertical Position Backward\n+    push('\\x1b[2k', vt)\n+    cursor(4, 2, state)\n+\n+    reset(state, nil)\n+\n+    -- Horizontal Tab\n+    push('\\t', vt)\n+    cursor(0, 8, state)\n+    push('   ', vt)\n+    cursor(0, 11, state)\n+    push('\\t', vt)\n+    cursor(0, 16, state)\n+    push('       ', vt)\n+    cursor(0, 23, state)\n+    push('\\t', vt)\n+    cursor(0, 24, state)\n+    push('        ', vt)\n+    cursor(0, 32, state)\n+    push('\\t', vt)\n+    cursor(0, 40, state)\n+\n+    -- Cursor Horizontal Tab\n+    push('\\x1b[I', vt)\n+    cursor(0, 48, state)\n+    push('\\x1b[2I', vt)\n+    cursor(0, 64, state)\n+\n+    -- Cursor Backward Tab\n+    push('\\x1b[Z', vt)\n+    cursor(0, 56, state)\n+    push('\\x1b[2Z', vt)\n+    cursor(0, 40, state)\n+  end)\n+\n+  itp('12state_scroll', function()\n+    local vt = init()\n+    local state = wantstate(vt, { s = true })\n+\n+    -- Linefeed\n+    push(string.rep('\\n', 24), vt)\n+    cursor(24, 0, state)\n+    push('\\n', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+    cursor(24, 0, state)\n+\n+    reset(state, nil)\n+\n+    -- Index\n+    push('\\x1b[25H', vt)\n+    push('\\x1bD', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+\n+    reset(state, nil)\n+\n+    -- Reverse Index\n+    push('\\x1bM', vt)\n+    expect('scrollrect 0..25,0..80 => -1,+0')\n+\n+    reset(state, nil)\n+\n+    -- Linefeed in DECSTBM\n+    push('\\x1b[1;10r', vt)\n+    cursor(0, 0, state)\n+    push(string.rep('\\n', 9), vt)\n+    cursor(9, 0, state)\n+    push('\\n', vt)\n+    expect('scrollrect 0..10,0..80 => +1,+0')\n+    cursor(9, 0, state)\n+\n+    -- Linefeed outside DECSTBM\n+    push('\\x1b[20H', vt)\n+    cursor(19, 0, state)\n+    push('\\n', vt)\n+    cursor(20, 0, state)\n+\n+    -- Index in DECSTBM\n+    push('\\x1b[9;10r', vt)\n+    push('\\x1b[10H', vt)\n+    push('\\x1bM', vt)\n+    cursor(8, 0, state)\n+    push('\\x1bM', vt)\n+    expect('scrollrect 8..10,0..80 => -1,+0')\n+\n+    -- Reverse Index in DECSTBM\n+    push('\\x1b[25H', vt)\n+    cursor(24, 0, state)\n+    push('\\n', vt)\n+    -- no scrollrect\n+    cursor(24, 0, state)\n+\n+    -- Linefeed in DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[3;10r\\x1b[10;40s', vt)\n+    push('\\x1b[10;10H\\n', vt)\n+    expect('scrollrect 2..10,9..40 => +1,+0')\n+\n+    -- IND/RI in DECSTBM+DECSLRM\n+    push('\\x1bD', vt)\n+    expect('scrollrect 2..10,9..40 => +1,+0')\n+    push('\\x1b[3;10H\\x1bM', vt)\n+    expect('scrollrect 2..10,9..40 => -1,+0')\n+\n+    -- DECRQSS on DECSTBM\n+    push('\\x1bP$qr\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r3;10r\\x1b\\\\')\n+\n+    -- DECRQSS on DECSLRM\n+    push('\\x1bP$qs\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r10;40s\\x1b\\\\')\n+\n+    -- Setting invalid DECSLRM with !DECVSSM is still rejected\n+    push('\\x1b[?69l\\x1b[;0s\\x1b[?69h', vt)\n+\n+    reset(state, nil)\n+\n+    -- Scroll Down\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[2S', vt)\n+    expect('scrollrect 0..25,0..80 => +2,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[100S', vt)\n+    expect('scrollrect 0..25,0..80 => +25,+0')\n+\n+    -- Scroll Up\n+    push('\\x1b[T', vt)\n+    expect('scrollrect 0..25,0..80 => -1,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[2T', vt)\n+    expect('scrollrect 0..25,0..80 => -2,+0')\n+    cursor(0, 0, state)\n+    push('\\x1b[100T', vt)\n+    expect('scrollrect 0..25,0..80 => -25,+0')\n+\n+    -- SD/SU in DECSTBM\n+    push('\\x1b[5;20r', vt)\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 4..20,0..80 => +1,+0')\n+    push('\\x1b[T', vt)\n+    expect('scrollrect 4..20,0..80 => -1,+0')\n+\n+    reset(state, nil)\n+\n+    -- SD/SU in DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[3;10r\\x1b[10;40s', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[3;10H', vt)\n+    cursor(2, 9, state)\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 2..10,9..40 => +1,+0')\n+    push('\\x1b[?69l', vt)\n+    push('\\x1b[S', vt)\n+    expect('scrollrect 2..10,0..80 => +1,+0')\n+\n+    -- Invalid boundaries\n+    reset(state, nil)\n+\n+    push('\\x1b[100;105r\\x1bD', vt)\n+    push('\\x1b[5;2r\\x1bD', vt)\n+\n+    reset(state, nil)\n+    state = wantstate(vt, { m = true, e = true })\n+\n+    -- Scroll Down move+erase emulation\n+    push('\\x1b[S', vt)\n+    expect('moverect 1..25,0..80 -> 0..24,0..80\\nerase 24..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2S', vt)\n+    expect('moverect 2..25,0..80 -> 0..23,0..80\\nerase 23..25,0..80')\n+    cursor(0, 0, state)\n+\n+    -- Scroll Up move+erase emulation\n+    push('\\x1b[T', vt)\n+    expect('moverect 0..24,0..80 -> 1..25,0..80\\nerase 0..1,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2T', vt)\n+    expect('moverect 0..23,0..80 -> 2..25,0..80\\nerase 0..2,0..80')\n+    cursor(0, 0, state)\n+\n+    -- DECSTBM resets cursor position\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b[r', vt)\n+    cursor(0, 0, state)\n+  end)\n+\n+  itp('13state_edit', function()\n+    local vt = init()\n+    local state = wantstate(vt, { s = true, e = true, b = true })\n+\n+    -- ICH\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ACD', vt)\n+    push('\\x1b[2D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[@', vt)\n+    expect('scrollrect 0..1,1..80 => +0,-1')\n+    cursor(0, 1, state)\n+    push('B', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[3@', vt)\n+    expect('scrollrect 0..1,2..80 => +0,-3')\n+\n+    -- ICH with DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[;50s', vt)\n+    push('\\x1b[20G\\x1b[@', vt)\n+    expect('scrollrect 0..1,19..50 => +0,-1')\n+\n+    -- ICH outside DECSLRM\n+    push('\\x1b[70G\\x1b[@', vt)\n+    -- nothing happens\n+\n+    -- DCH\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABBC', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[P', vt)\n+    expect('scrollrect 0..1,1..80 => +0,+1')\n+    cursor(0, 1, state)\n+    push('\\x1b[3P', vt)\n+    expect('scrollrect 0..1,1..80 => +0,+3')\n+    cursor(0, 1, state)\n+\n+    -- DCH with DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[;50s', vt)\n+    push('\\x1b[20G\\x1b[P', vt)\n+    expect('scrollrect 0..1,19..50 => +0,+1')\n+\n+    -- DCH outside DECSLRM\n+    push('\\x1b[70G\\x1b[P', vt)\n+    -- nothing happens\n+\n+    -- ECH\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABC', vt)\n+    push('\\x1b[2D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[X', vt)\n+    expect('erase 0..1,1..2')\n+    cursor(0, 1, state)\n+    push('\\x1b[3X', vt)\n+    expect('erase 0..1,1..4')\n+    cursor(0, 1, state)\n+    -- ECH more columns than there are should be bounded\n+    push('\\x1b[100X', vt)\n+    expect('erase 0..1,1..80')\n+\n+    -- IL\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('A\\r\\nC', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[L', vt)\n+    expect('scrollrect 1..25,0..80 => -1,+0')\n+    -- TODO(libvterm): ECMA-48 says we should move to line home, but neither xterm nor xfce4-terminal do this\n+    cursor(1, 1, state)\n+    push('\\rB', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[3L', vt)\n+    expect('scrollrect 1..25,0..80 => -3,+0')\n+\n+    -- IL with DECSTBM\n+    push('\\x1b[5;15r', vt)\n+    push('\\x1b[5H\\x1b[L', vt)\n+    expect('scrollrect 4..15,0..80 => -1,+0')\n+\n+    -- IL outside DECSTBM\n+    push('\\x1b[20H\\x1b[L', vt)\n+    -- nothing happens\n+\n+    -- IL with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[10;50s', vt)\n+    push('\\x1b[5;10H\\x1b[L', vt)\n+    expect('scrollrect 4..15,9..50 => -1,+0')\n+\n+    -- DL\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('A\\r\\nB\\r\\nB\\r\\nC', vt)\n+    cursor(3, 1, state)\n+    push('\\x1b[2H', vt)\n+    cursor(1, 0, state)\n+    push('\\x1b[M', vt)\n+    expect('scrollrect 1..25,0..80 => +1,+0')\n+    cursor(1, 0, state)\n+    push('\\x1b[3M', vt)\n+    expect('scrollrect 1..25,0..80 => +3,+0')\n+    cursor(1, 0, state)\n+\n+    -- DL with DECSTBM\n+    push('\\x1b[5;15r', vt)\n+    push('\\x1b[5H\\x1b[M', vt)\n+    expect('scrollrect 4..15,0..80 => +1,+0')\n+\n+    -- DL outside DECSTBM\n+    push('\\x1b[20H\\x1b[M', vt)\n+    -- nothing happens\n+\n+    -- DL with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[10;50s', vt)\n+    push('\\x1b[5;10H\\x1b[M', vt)\n+    expect('scrollrect 4..15,9..50 => +1,+0')\n+\n+    -- DECIC\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    push(\"\\x1b[20G\\x1b[5'}\", vt)\n+    expect('scrollrect 0..25,19..80 => +0,-5')\n+\n+    -- DECIC with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[4;20r\\x1b[20;60s', vt)\n+    push(\"\\x1b[4;20H\\x1b[3'}\", vt)\n+    expect('scrollrect 3..20,19..60 => +0,-3')\n+\n+    -- DECIC outside DECSLRM\n+    push(\"\\x1b[70G\\x1b['}\", vt)\n+    -- nothing happens\n+\n+    -- DECDC\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    push(\"\\x1b[20G\\x1b[5'~\", vt)\n+    expect('scrollrect 0..25,19..80 => +0,+5')\n+\n+    -- DECDC with DECSTBM+DECSLRM\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[4;20r\\x1b[20;60s', vt)\n+    push(\"\\x1b[4;20H\\x1b[3'~\", vt)\n+    expect('scrollrect 3..20,19..60 => +0,+3')\n+\n+    -- DECDC outside DECSLRM\n+    push(\"\\x1b[70G\\x1b['~\", vt)\n+    -- nothing happens\n+\n+    -- EL 0\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABCDE', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[0K', vt)\n+    expect('erase 0..1,2..80')\n+    cursor(0, 2, state)\n+\n+    -- EL 1\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABCDE', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[1K', vt)\n+    expect('erase 0..1,0..3')\n+    cursor(0, 2, state)\n+\n+    -- EL 2\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABCDE', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[2K', vt)\n+    expect('erase 0..1,0..80')\n+    cursor(0, 2, state)\n+\n+    -- SEL\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[11G', vt)\n+    cursor(0, 10, state)\n+    push('\\x1b[?0K', vt)\n+    expect('erase 0..1,10..80 selective')\n+    cursor(0, 10, state)\n+    push('\\x1b[?1K', vt)\n+    expect('erase 0..1,0..11 selective')\n+    cursor(0, 10, state)\n+    push('\\x1b[?2K', vt)\n+    expect('erase 0..1,0..80 selective')\n+    cursor(0, 10, state)\n+\n+    -- ED 0\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[0J', vt)\n+    expect('erase 1..2,1..80\\nerase 2..25,0..80')\n+    cursor(1, 1, state)\n+\n+    -- ED 1\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[1J', vt)\n+    expect('erase 0..1,0..80\\nerase 1..2,0..2')\n+    cursor(1, 1, state)\n+\n+    -- ED 2\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[2J', vt)\n+    expect('erase 0..25,0..80')\n+    cursor(1, 1, state)\n+\n+    -- ED 3\n+    push('\\x1b[3J', vt)\n+    expect('sb_clear')\n+\n+    -- SED\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b[?0J', vt)\n+    expect('erase 4..5,4..80 selective\\nerase 5..25,0..80 selective')\n+    cursor(4, 4, state)\n+    push('\\x1b[?1J', vt)\n+    expect('erase 0..4,0..80 selective\\nerase 4..5,0..5 selective')\n+    cursor(4, 4, state)\n+    push('\\x1b[?2J', vt)\n+    expect('erase 0..25,0..80 selective')\n+    cursor(4, 4, state)\n+\n+    -- DECRQSS on DECSCA\n+    push('\\x1b[2\"q', vt)\n+    push('\\x1bP$q\"q\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r2\"q\\x1b\\\\')\n+\n+    state = wantstate(vt, { m = true, e = true, b = true })\n+    expect('erase 0..25,0..80') -- TODO(dundargoc): strange, this should not be needed according to the original code\n+\n+    -- ICH move+erase emuation\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ACD', vt)\n+    push('\\x1b[2D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[@', vt)\n+    expect('moverect 0..1,1..79 -> 0..1,2..80\\nerase 0..1,1..2')\n+    cursor(0, 1, state)\n+    push('B', vt)\n+    cursor(0, 2, state)\n+    push('\\x1b[3@', vt)\n+    expect('moverect 0..1,2..77 -> 0..1,5..80\\nerase 0..1,2..5')\n+\n+    -- DCH move+erase emulation\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('ABBC', vt)\n+    push('\\x1b[3D', vt)\n+    cursor(0, 1, state)\n+    push('\\x1b[P', vt)\n+    expect('moverect 0..1,2..80 -> 0..1,1..79\\nerase 0..1,79..80')\n+    cursor(0, 1, state)\n+    push('\\x1b[3P', vt)\n+    expect('moverect 0..1,4..80 -> 0..1,1..77\\nerase 0..1,77..80')\n+    cursor(0, 1, state)\n+  end)\n+\n+  itp('14state_encoding', function()\n+    local vt = init()\n+    vterm.vterm_set_utf8(vt, false)\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Default\n+    reset(state, nil)\n+    push('#', vt)\n+    expect('putglyph 23 1 0,0')\n+\n+    -- Designate G0=UK\n+    reset(state, nil)\n+    push('\\x1b(A', vt)\n+    push('#', vt)\n+    expect('putglyph a3 1 0,0')\n+\n+    -- Designate G0=DEC drawing\n+    reset(state, nil)\n+    push('\\x1b(0', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,0')\n+\n+    -- Designate G1 + LS1\n+    reset(state, nil)\n+    push('\\x1b)0', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x0e', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,1')\n+    -- LS0\n+    push('\\x0f', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,2')\n+\n+    -- Designate G2 + LS2\n+    push('\\x1b*0', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,3')\n+    push('\\x1bn', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,4')\n+    push('\\x0f', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,5')\n+\n+    -- Designate G3 + LS3\n+    push('\\x1b+0', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,6')\n+    push('\\x1bo', vt)\n+    push('a', vt)\n+    expect('putglyph 2592 1 0,7')\n+    push('\\x0f', vt)\n+    push('a', vt)\n+    expect('putglyph 61 1 0,8')\n+\n+    -- SS2\n+    push('a\\x8eaa', vt)\n+    expect('putglyph 61 1 0,9\\nputglyph 2592 1 0,10\\nputglyph 61 1 0,11')\n+\n+    -- SS3\n+    push('a\\x8faa', vt)\n+    expect('putglyph 61 1 0,12\\nputglyph 2592 1 0,13\\nputglyph 61 1 0,14')\n+\n+    -- LS1R\n+    reset(state, nil)\n+    push('\\x1b~', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x1b)0', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 2592 1 0,1')\n+\n+    -- LS2R\n+    reset(state, nil)\n+    push('\\x1b}', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x1b*0', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 2592 1 0,1')\n+\n+    -- LS3R\n+    reset(state, nil)\n+    push('\\x1b|', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 61 1 0,0')\n+    push('\\x1b+0', vt)\n+    push('\\xe1', vt)\n+    expect('putglyph 2592 1 0,1')\n+\n+    vterm.vterm_set_utf8(vt, true)\n+    -- U+0108 == c4 88\n+    reset(state, nil)\n+    push('\\x1b(B', vt)\n+    push('AB\\xc4\\x88D', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 108 1 0,2\\nputglyph 44 1 0,3')\n+  end)\n+\n+  itp('15state_mode', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true, m = true, e = true })\n+\n+    -- Insert/Replace Mode\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('AC\\x1b[DB', vt)\n+    expect('putglyph 41 1 0,0\\nputglyph 43 1 0,1\\nputglyph 42 1 0,1')\n+    push('\\x1b[4h', vt)\n+    push('\\x1b[G', vt)\n+    push('AC\\x1b[DB', vt)\n+    expect(\n+      'moverect 0..1,0..79 -> 0..1,1..80\\nerase 0..1,0..1\\nputglyph 41 1 0,0\\nmoverect 0..1,1..79 -> 0..1,2..80\\nerase 0..1,1..2\\nputglyph 43 1 0,1\\nmoverect 0..1,1..79 -> 0..1,2..80\\nerase 0..1,1..2\\nputglyph 42 1 0,1'\n+    )\n+\n+    -- Insert mode only happens once for UTF-8 combining\n+    push('e', vt)\n+    expect('moverect 0..1,2..79 -> 0..1,3..80\\nerase 0..1,2..3\\nputglyph 65 1 0,2')\n+    push('\\xCC\\x81', vt)\n+    expect('putglyph 65,301 1 0,2')\n+\n+    -- Newline/Linefeed mode\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[5G\\n', vt)\n+    cursor(1, 4, state)\n+    push('\\x1b[20h', vt)\n+    push('\\x1b[5G\\n', vt)\n+    cursor(2, 0, state)\n+\n+    -- DEC origin mode\n+    reset(state, nil)\n+    expect('erase 0..25,0..80')\n+    cursor(0, 0, state)\n+    push('\\x1b[5;15r', vt)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[3;3H', vt)\n+    cursor(2, 2, state)\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[H', vt)\n+    cursor(4, 0, state)\n+    push('\\x1b[3;3H', vt)\n+    cursor(6, 2, state)\n+\n+    -- DECRQM on DECOM\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[?6$p', vt)\n+    expect_output('\\x1b[?6;1$y')\n+    push('\\x1b[?6l', vt)\n+    push('\\x1b[?6$p', vt)\n+    expect_output('\\x1b[?6;2$y')\n+\n+    -- Origin mode with DECSLRM\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[?69h', vt)\n+    push('\\x1b[20;60s', vt)\n+    push('\\x1b[H', vt)\n+    cursor(4, 19, state)\n+\n+    push('\\x1b[?69l', vt)\n+\n+    -- Origin mode bounds cursor to scrolling region\n+    push('\\x1b[H', vt)\n+    push('\\x1b[10A', vt)\n+    cursor(4, 0, state)\n+    push('\\x1b[20B', vt)\n+    cursor(14, 0, state)\n+\n+    -- Origin mode without scroll region\n+    push('\\x1b[?6l', vt)\n+    push('\\x1b[r\\x1b[?6h', vt)\n+    cursor(0, 0, state)\n+  end)\n+\n+  itp('16state_resize', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Placement\n+    reset(state, nil)\n+    push('AB\\x1b[79GCDE', vt)\n+    expect(\n+      'putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 43 1 0,78\\nputglyph 44 1 0,79\\nputglyph 45 1 1,0'\n+    )\n+\n+    -- Resize\n+    reset(state, nil)\n+    resize(27, 85, vt)\n+    push('AB\\x1b[79GCDE', vt)\n+    expect(\n+      'putglyph 41 1 0,0\\nputglyph 42 1 0,1\\nputglyph 43 1 0,78\\nputglyph 44 1 0,79\\nputglyph 45 1 0,80'\n+    )\n+    cursor(0, 81, state)\n+\n+    -- Resize without reset\n+    resize(28, 90, vt)\n+    cursor(0, 81, state)\n+    push('FGHI', vt)\n+    expect('putglyph 46 1 0,81\\nputglyph 47 1 0,82\\nputglyph 48 1 0,83\\nputglyph 49 1 0,84')\n+    cursor(0, 85, state)\n+\n+    -- Resize shrink moves cursor\n+    resize(25, 80, vt)\n+    cursor(0, 79, state)\n+\n+    -- Resize grow doesn't cancel phantom\n+    reset(state, nil)\n+    push('\\x1b[79GAB', vt)\n+    expect('putglyph 41 1 0,78\\nputglyph 42 1 0,79')\n+    cursor(0, 79, state)\n+    resize(30, 100, vt)\n+    cursor(0, 80, state)\n+    push('C', vt)\n+    expect('putglyph 43 1 0,80')\n+    cursor(0, 81, state)\n+  end)\n+\n+  itp('17state_mouse', function()\n+    local vt = init()\n+    local state = wantstate(vt, { p = true })\n+\n+    -- DECRQM on with mouse off\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;2$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;2$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;2$y')\n+\n+    -- Mouse in simple button report mode\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    push('\\x1b[?1000h', vt)\n+    expect('settermprop 8 1')\n+\n+    -- Press 1\n+    mousemove(0, 0, vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\x21\\x21')\n+\n+    -- Release 1\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\x21\\x21')\n+\n+    -- Ctrl-Press 1\n+    mousebtn('d', 1, vt, { C = true })\n+    expect_output('\\x1b[M\\x30\\x21\\x21')\n+    mousebtn('u', 1, vt, { C = true })\n+    expect_output('\\x1b[M\\x33\\x21\\x21')\n+\n+    -- Button 2\n+    mousebtn('d', 2, vt)\n+    expect_output('\\x1b[M\\x21\\x21\\x21')\n+    mousebtn('u', 2, vt)\n+    expect_output('\\x1b[M\\x23\\x21\\x21')\n+\n+    -- Position\n+    mousemove(10, 20, vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\x35\\x2b')\n+\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\x35\\x2b')\n+    mousemove(10, 21, vt)\n+    -- no output\n+\n+    -- Wheel events\n+    mousebtn('d', 4, vt)\n+    expect_output('\\x1b[M\\x60\\x36\\x2b')\n+    mousebtn('d', 4, vt)\n+    expect_output('\\x1b[M\\x60\\x36\\x2b')\n+    mousebtn('d', 5, vt)\n+    expect_output('\\x1b[M\\x61\\x36\\x2b')\n+    mousebtn('d', 6, vt)\n+    expect_output('\\x1b[M\\x62\\x36\\x2b')\n+    mousebtn('d', 7, vt)\n+    expect_output('\\x1b[M\\x63\\x36\\x2b')\n+\n+    -- DECRQM on mouse button mode\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;1$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;2$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;2$y')\n+\n+    -- Drag events\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    push('\\x1b[?1002h', vt)\n+    expect('settermprop 8 2')\n+\n+    mousemove(5, 5, vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\x26\\x26')\n+    mousemove(5, 6, vt)\n+    expect_output('\\x1b[M\\x40\\x27\\x26')\n+    mousemove(6, 6, vt)\n+    expect_output('\\x1b[M\\x40\\x27\\x27')\n+    mousemove(6, 6, vt)\n+    -- no output\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\x27\\x27')\n+    mousemove(6, 7, vt)\n+    -- no output\n+\n+    -- DECRQM on mouse drag mode\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;2$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;1$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;2$y')\n+\n+    -- Non-drag motion events\n+    push('\\x1b[?1003h', vt)\n+    expect('settermprop 8 3')\n+\n+    mousemove(6, 8, vt)\n+    expect_output('\\x1b[M\\x43\\x29\\x27')\n+\n+    -- DECRQM on mouse motion mode\n+    push('\\x1b[?1000$p', vt)\n+    expect_output('\\x1b[?1000;2$y')\n+    push('\\x1b[?1002$p', vt)\n+    expect_output('\\x1b[?1002;2$y')\n+    push('\\x1b[?1003$p', vt)\n+    expect_output('\\x1b[?1003;1$y')\n+\n+    -- Bounds checking\n+    mousemove(300, 300, vt)\n+    expect_output('\\x1b[M\\x43\\xff\\xff')\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\xff\\xff')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\xff\\xff')\n+\n+    -- DECRQM on standard encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;2$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;2$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;2$y')\n+\n+    -- UTF-8 extended encoding mode\n+    -- 300 + 32 + 1 = 333 = U+014d = \\xc5\\x8d\n+    push('\\x1b[?1005h', vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[M\\x20\\xc5\\x8d\\xc5\\x8d')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[M\\x23\\xc5\\x8d\\xc5\\x8d')\n+\n+    -- DECRQM on UTF-8 extended encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;1$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;2$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;2$y')\n+\n+    -- SGR extended encoding mode\n+    push('\\x1b[?1006h', vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[<0;301;301M')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[<0;301;301m')\n+\n+    -- DECRQM on SGR extended encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;2$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;1$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;2$y')\n+\n+    -- rxvt extended encoding mode\n+    push('\\x1b[?1015h', vt)\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[0;301;301M')\n+    mousebtn('u', 1, vt)\n+    expect_output('\\x1b[3;301;301M')\n+\n+    -- DECRQM on rxvt extended encoding mode\n+    push('\\x1b[?1005$p', vt)\n+    expect_output('\\x1b[?1005;2$y')\n+    push('\\x1b[?1006$p', vt)\n+    expect_output('\\x1b[?1006;2$y')\n+    push('\\x1b[?1015$p', vt)\n+    expect_output('\\x1b[?1015;1$y')\n+\n+    -- Mouse disabled reports nothing\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    mousemove(0, 0, vt)\n+    mousebtn('d', 1, vt)\n+    mousebtn('u', 1, vt)\n+\n+    -- DECSM can set multiple modes at once\n+    push('\\x1b[?1002;1006h', vt)\n+    expect('settermprop 8 2')\n+    mousebtn('d', 1, vt)\n+    expect_output('\\x1b[<0;1;1M')\n+  end)\n+\n+  itp('18state_termprops', function()\n+    local vt = init()\n+    local state = wantstate(vt, { p = true })\n+\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+\n+    -- Cursor visibility\n+    push('\\x1b[?25h', vt)\n+    expect('settermprop 1 true')\n+    push('\\x1b[?25$p', vt)\n+    expect_output('\\x1b[?25;1$y')\n+    push('\\x1b[?25l', vt)\n+    expect('settermprop 1 false')\n+    push('\\x1b[?25$p', vt)\n+    expect_output('\\x1b[?25;2$y')\n+\n+    -- Cursor blink\n+    push('\\x1b[?12h', vt)\n+    expect('settermprop 2 true')\n+    push('\\x1b[?12$p', vt)\n+    expect_output('\\x1b[?12;1$y')\n+    push('\\x1b[?12l', vt)\n+    expect('settermprop 2 false')\n+    push('\\x1b[?12$p', vt)\n+    expect_output('\\x1b[?12;2$y')\n+\n+    -- Cursor shape\n+    push('\\x1b[3 q', vt)\n+    expect('settermprop 2 true\\nsettermprop 7 2')\n+\n+    -- Title\n+    push('\\x1b]2;Here is my title\\a', vt)\n+    expect('settermprop 4 [\"Here is my title\"]')\n+\n+    -- Title split write\n+    push('\\x1b]2;Here is', vt)\n+    expect('settermprop 4 [\"Here is\"')\n+    push(' another title\\a', vt)\n+    expect('settermprop 4 \" another title\"]')\n+  end)\n+\n+  itp('20state_wrapping', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true, m = true })\n+\n+    -- 79th Column\n+    push('\\x1b[75G', vt)\n+    push(string.rep('A', 5), vt)\n+    expect(\n+      'putglyph 41 1 0,74\\nputglyph 41 1 0,75\\nputglyph 41 1 0,76\\nputglyph 41 1 0,77\\nputglyph 41 1 0,78'\n+    )\n+    cursor(0, 79, state)\n+\n+    -- 80th Column Phantom\n+    push('A', vt)\n+    expect('putglyph 41 1 0,79')\n+    cursor(0, 79, state)\n+\n+    -- Line Wraparound\n+    push('B', vt)\n+    expect('putglyph 42 1 1,0')\n+    cursor(1, 1, state)\n+\n+    -- Line Wraparound during combined write\n+    push('\\x1b[78G', vt)\n+    push('BBBCC', vt)\n+    expect(\n+      'putglyph 42 1 1,77\\nputglyph 42 1 1,78\\nputglyph 42 1 1,79\\nputglyph 43 1 2,0\\nputglyph 43 1 2,1'\n+    )\n+    cursor(2, 2, state)\n+\n+    -- DEC Auto Wrap Mode\n+    reset(state, nil)\n+    push('\\x1b[?7l', vt)\n+    push('\\x1b[75G', vt)\n+    push(string.rep('D', 6), vt)\n+    expect(\n+      'putglyph 44 1 0,74\\nputglyph 44 1 0,75\\nputglyph 44 1 0,76\\nputglyph 44 1 0,77\\nputglyph 44 1 0,78\\nputglyph 44 1 0,79'\n+    )\n+    cursor(0, 79, state)\n+    push('D', vt)\n+    expect('putglyph 44 1 0,79')\n+    cursor(0, 79, state)\n+    push('\\x1b[?7h', vt)\n+\n+    -- 80th column causes linefeed on wraparound\n+    push('\\x1b[25;78HABC', vt)\n+    expect('putglyph 41 1 24,77\\nputglyph 42 1 24,78\\nputglyph 43 1 24,79')\n+    cursor(24, 79, state)\n+    push('D', vt)\n+    expect('moverect 1..25,0..80 -> 0..24,0..80\\nputglyph 44 1 24,0')\n+\n+    -- 80th column phantom linefeed phantom cancelled by explicit cursor move\n+    push('\\x1b[25;78HABC', vt)\n+    expect('putglyph 41 1 24,77\\nputglyph 42 1 24,78\\nputglyph 43 1 24,79')\n+    cursor(24, 79, state)\n+    push('\\x1b[25;1HD', vt)\n+    expect('putglyph 44 1 24,0')\n+  end)\n+\n+  itp('21state_tabstops', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Initial\n+    reset(state, nil)\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,8')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,16')\n+    cursor(0, 17, state)\n+\n+    -- HTS\n+    push('\\x1b[5G\\x1bH', vt)\n+    push('\\x1b[G\\tX', vt)\n+    expect('putglyph 58 1 0,4')\n+    cursor(0, 5, state)\n+\n+    -- TBC 0\n+    push('\\x1b[9G\\x1b[g', vt)\n+    push('\\x1b[G\\tX\\tX', vt)\n+    expect('putglyph 58 1 0,4\\nputglyph 58 1 0,16')\n+    cursor(0, 17, state)\n+\n+    -- TBC 3\n+    push('\\x1b[3g\\x1b[50G\\x1bH\\x1b[G', vt)\n+    cursor(0, 0, state)\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,49')\n+    cursor(0, 50, state)\n+\n+    -- Tabstops after resize\n+    reset(state, nil)\n+    resize(30, 100, vt)\n+    -- Should be 100/8 = 12 tabstops\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,8')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,16')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,24')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,32')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,40')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,48')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,56')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,64')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,72')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,80')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,88')\n+    push('\\tX', vt)\n+    expect('putglyph 58 1 0,96')\n+    cursor(0, 97, state)\n+  end)\n+\n+  itp('22state_save', function()\n+    local vt = init()\n+    local state = wantstate(vt, { p = true })\n+\n+    reset(state, nil)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+\n+    -- Set up state\n+    push('\\x1b[2;2H', vt)\n+    cursor(1, 1, state)\n+    push('\\x1b[1m', vt)\n+    pen('bold', true, state)\n+\n+    -- Save\n+    push('\\x1b[?1048h', vt)\n+\n+    -- Change state\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b[4 q', vt)\n+    expect('settermprop 2 false\\nsettermprop 7 2')\n+    push('\\x1b[22;4m', vt)\n+    pen('bold', false, state)\n+    pen('underline', 1, state)\n+\n+    -- Restore\n+    push('\\x1b[?1048l', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(1, 1, state)\n+    pen('bold', true, state)\n+    pen('underline', 0, state)\n+\n+    -- Save/restore using DECSC/DECRC\n+    push('\\x1b[2;2H\\x1b7', vt)\n+    cursor(1, 1, state)\n+\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    push('\\x1b8', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(1, 1, state)\n+\n+    -- Save twice, restore twice happens on both edge transitions\n+    push('\\x1b[2;10H\\x1b[?1048h\\x1b[6;10H\\x1b[?1048h', vt)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[?1048l', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(5, 9, state)\n+    push('\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    push('\\x1b[?1048l', vt)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+    cursor(5, 9, state)\n+  end)\n+\n+  itp('25state_input', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Unmodified ASCII\n+    inchar(41, vt)\n+    expect('output 29')\n+    inchar(61, vt)\n+    expect('output 3d')\n+\n+    -- Ctrl modifier on ASCII letters\n+    inchar(41, vt, { C = true })\n+    expect('output 1b,5b,34,31,3b,35,75')\n+    inchar(61, vt, { C = true })\n+    expect('output 1b,5b,36,31,3b,35,75')\n+\n+    -- Alt modifier on ASCII letters\n+    inchar(41, vt, { A = true })\n+    expect('output 1b,29')\n+    inchar(61, vt, { A = true })\n+    expect('output 1b,3d')\n+\n+    -- Ctrl-Alt modifier on ASCII letters\n+    inchar(41, vt, { C = true, A = true })\n+    expect('output 1b,5b,34,31,3b,37,75')\n+    inchar(61, vt, { C = true, A = true })\n+    expect('output 1b,5b,36,31,3b,37,75')\n+\n+    -- Special handling of Ctrl-I\n+    inchar(49, vt)\n+    expect('output 31')\n+    inchar(69, vt)\n+    expect('output 45')\n+    inchar(49, vt, { C = true })\n+    expect('output 1b,5b,34,39,3b,35,75')\n+    inchar(69, vt, { C = true })\n+    expect('output 1b,5b,36,39,3b,35,75')\n+    inchar(49, vt, { A = true })\n+    expect('output 1b,31')\n+    inchar(69, vt, { A = true })\n+    expect('output 1b,45')\n+    inchar(49, vt, { A = true, C = true })\n+    expect('output 1b,5b,34,39,3b,37,75')\n+    inchar(69, vt, { A = true, C = true })\n+    expect('output 1b,5b,36,39,3b,37,75')\n+\n+    -- Special handling of Space\n+    inchar(20, vt)\n+    expect('output 14')\n+    inchar(20, vt, { S = true })\n+    expect('output 14')\n+    inchar(20, vt, { C = true })\n+    expect('output 1b,5b,32,30,3b,35,75')\n+    inchar(20, vt, { C = true, S = true })\n+    expect('output 1b,5b,32,30,3b,35,75')\n+    inchar(20, vt, { A = true })\n+    expect('output 1b,14')\n+    inchar(20, vt, { S = true, A = true })\n+    expect('output 1b,14')\n+    inchar(20, vt, { C = true, A = true })\n+    expect('output 1b,5b,32,30,3b,37,75')\n+    inchar(20, vt, { S = true, C = true, A = true })\n+    expect('output 1b,5b,32,30,3b,37,75')\n+\n+    -- Cursor keys in reset (cursor) mode\n+    inkey('up', vt)\n+    expect_output('\\x1b[A')\n+    inkey('up', vt, { S = true })\n+    expect_output('\\x1b[1;2A')\n+    inkey('up', vt, { C = true })\n+    expect_output('\\x1b[1;5A')\n+    inkey('up', vt, { S = true, C = true })\n+    expect_output('\\x1b[1;6A')\n+    inkey('up', vt, { A = true })\n+    expect_output('\\x1b[1;3A')\n+    inkey('up', vt, { S = true, A = true })\n+    expect_output('\\x1b[1;4A')\n+    inkey('up', vt, { C = true, A = true })\n+    expect_output('\\x1b[1;7A')\n+    inkey('up', vt, { S = true, C = true, A = true })\n+    expect_output('\\x1b[1;8A')\n+\n+    -- Cursor keys in application mode\n+    push('\\x1b[?1h', vt)\n+    -- Plain \"Up\" should be SS3 A now\n+    inkey('up', vt)\n+    expect_output('\\x1bOA')\n+    -- Modified keys should still use CSI\n+    inkey('up', vt, { S = true })\n+    expect_output('\\x1b[1;2A')\n+    inkey('up', vt, { C = true })\n+    expect_output('\\x1b[1;5A')\n+\n+    -- Shift-Tab should be different\n+    inkey('tab', vt)\n+    expect_output('\\x09')\n+    inkey('tab', vt, { S = true })\n+    expect_output('\\x1b[Z')\n+    inkey('tab', vt, { C = true })\n+    expect_output('\\x1b[9;5u')\n+    inkey('tab', vt, { A = true })\n+    expect_output('\\x1b\\x09')\n+    inkey('tab', vt, { C = true, A = true })\n+    expect_output('\\x1b[9;7u')\n+\n+    -- Enter in linefeed mode\n+    inkey('enter', vt)\n+    expect_output('\\x0d')\n+\n+    -- Enter in newline mode\n+    push('\\x1b[20h', vt)\n+    inkey('enter', vt)\n+    expect_output('\\x0d\\x0a')\n+\n+    -- Unmodified F1 is SS3 P\n+    inkey('f1', vt)\n+    expect_output('\\x1bOP')\n+\n+    -- Modified F1 is CSI P\n+    inkey('f1', vt, { S = true })\n+    expect_output('\\x1b[1;2P')\n+    inkey('f1', vt, { A = true })\n+    expect_output('\\x1b[1;3P')\n+    inkey('f1', vt, { C = true })\n+    expect_output('\\x1b[1;5P')\n+\n+    -- Keypad in DECKPNM\n+    inkey('kp0', vt)\n+    expect_output('0')\n+\n+    -- Keypad in DECKPAM\n+    push('\\x1b=', vt)\n+    inkey('kp0', vt)\n+    expect_output('\\x1bOp')\n+\n+    -- Bracketed paste mode off\n+    vterm.vterm_keyboard_start_paste(vt)\n+    vterm.vterm_keyboard_end_paste(vt)\n+\n+    -- Bracketed paste mode on\n+    push('\\x1b[?2004h', vt)\n+    vterm.vterm_keyboard_start_paste(vt)\n+    expect_output('\\x1b[200~')\n+    vterm.vterm_keyboard_end_paste(vt)\n+    expect_output('\\x1b[201~')\n+\n+    -- Focus reporting disabled\n+    vterm.vterm_state_focus_in(state)\n+    vterm.vterm_state_focus_out(state)\n+\n+    -- Focus reporting enabled\n+    state = wantstate(vt, { p = true })\n+    push('\\x1b[?1004h', vt)\n+    expect('settermprop 9 true')\n+    vterm.vterm_state_focus_in(state)\n+    expect_output('\\x1b[I')\n+    vterm.vterm_state_focus_out(state)\n+    expect_output('\\x1b[O')\n+  end)\n+\n+  itp('26state_query', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- DA\n+    reset(state, nil)\n+    push('\\x1b[c', vt)\n+    expect_output('\\x1b[?1;2c')\n+\n+    -- XTVERSION\n+    reset(state, nil)\n+    push('\\x1b[>q', vt)\n+    expect_output('\\x1bP>|libvterm(0.3)\\x1b\\\\')\n+\n+    -- DSR\n+    reset(state, nil)\n+    push('\\x1b[5n', vt)\n+    expect_output('\\x1b[0n')\n+\n+    -- CPR\n+    push('\\x1b[6n', vt)\n+    expect_output('\\x1b[1;1R')\n+    push('\\x1b[10;10H\\x1b[6n', vt)\n+    expect_output('\\x1b[10;10R')\n+\n+    -- DECCPR\n+    push('\\x1b[?6n', vt)\n+    expect_output('\\x1b[?10;10R')\n+\n+    -- DECRQSS on DECSCUSR\n+    push('\\x1b[3 q', vt)\n+    push('\\x1bP$q q\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r3 q\\x1b\\\\')\n+\n+    -- DECRQSS on SGR\n+    push('\\x1b[1;5;7m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r1;5;7m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR ANSI colours\n+    push('\\x1b[0;31;42m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r31;42m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR ANSI hi-bright colours\n+    push('\\x1b[0;93;104m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r93;104m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR 256-palette colours\n+    push('\\x1b[0;38:5:56;48:5:78m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r38:5:56;48:5:78m\\x1b\\\\')\n+\n+    -- DECRQSS on SGR RGB8 colours\n+    push('\\x1b[0;38:2:24:68:112;48:2:13:57:101m', vt)\n+    push('\\x1bP$qm\\x1b\\\\', vt)\n+    expect_output('\\x1bP1$r38:2:24:68:112;48:2:13:57:101m\\x1b\\\\')\n+\n+    -- S8C1T on DSR\n+    push('\\x1b G', vt)\n+    push('\\x1b[5n', vt)\n+    expect_output('\\x9b0n')\n+    push('\\x1b F', vt)\n+  end)\n+\n+  itp('27state_reset', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    reset(state, nil)\n+\n+    -- RIS homes cursor\n+    push('\\x1b[5;5H', vt)\n+    cursor(4, 4, state)\n+    state = wantstate(vt, { m = true })\n+    push('\\x1bc', vt)\n+    cursor(0, 0, state)\n+    wantstate(vt)\n+\n+    -- RIS cancels scrolling region\n+    push('\\x1b[5;10r', vt)\n+    wantstate(vt, { s = true })\n+    push('\\x1bc\\x1b[25H\\n', vt)\n+    expect('scrollrect 0..25,0..80 => +1,+0')\n+    wantstate(vt)\n+\n+    -- RIS erases screen\n+    push('ABCDE', vt)\n+    state = wantstate(vt, { e = true })\n+    push('\\x1bc', vt)\n+    expect('erase 0..25,0..80')\n+    wantstate(vt)\n+\n+    -- RIS clears tabstops\n+    push('\\x1b[5G\\x1bH\\x1b[G\\t', vt)\n+    cursor(0, 4, state)\n+    push('\\x1bc\\t', vt)\n+    cursor(0, 8, state)\n+  end)\n+\n+  itp('28state_dbl_wh', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- Single Width, Single Height\n+    reset(state, nil)\n+    push('\\x1b#5', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 0,0\\nputglyph 65 1 0,1\\nputglyph 6c 1 0,2\\nputglyph 6c 1 0,3\\nputglyph 6f 1 0,4'\n+    )\n+\n+    -- Double Width, Single Height\n+    reset(state, nil)\n+    push('\\x1b#6', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 0,0 dwl\\nputglyph 65 1 0,1 dwl\\nputglyph 6c 1 0,2 dwl\\nputglyph 6c 1 0,3 dwl\\nputglyph 6f 1 0,4 dwl'\n+    )\n+    cursor(0, 5, state)\n+    push('\\x1b[40GAB', vt)\n+    expect('putglyph 41 1 0,39 dwl\\nputglyph 42 1 1,0')\n+    cursor(1, 1, state)\n+\n+    -- Double Height\n+    reset(state, nil)\n+    push('\\x1b#3', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 0,0 dwl dhl-top\\nputglyph 65 1 0,1 dwl dhl-top\\nputglyph 6c 1 0,2 dwl dhl-top\\nputglyph 6c 1 0,3 dwl dhl-top\\nputglyph 6f 1 0,4 dwl dhl-top'\n+    )\n+    cursor(0, 5, state)\n+    push('\\r\\n\\x1b#4', vt)\n+    push('Hello', vt)\n+    expect(\n+      'putglyph 48 1 1,0 dwl dhl-bottom\\nputglyph 65 1 1,1 dwl dhl-bottom\\nputglyph 6c 1 1,2 dwl dhl-bottom\\nputglyph 6c 1 1,3 dwl dhl-bottom\\nputglyph 6f 1 1,4 dwl dhl-bottom'\n+    )\n+    cursor(1, 5, state)\n+\n+    -- Double Width scrolling\n+    reset(state, nil)\n+    push('\\x1b[20H\\x1b#6ABC', vt)\n+    expect('putglyph 41 1 19,0 dwl\\nputglyph 42 1 19,1 dwl\\nputglyph 43 1 19,2 dwl')\n+    push('\\x1b[25H\\n', vt)\n+    push('\\x1b[19;4HDE', vt)\n+    expect('putglyph 44 1 18,3 dwl\\nputglyph 45 1 18,4 dwl')\n+    push('\\x1b[H\\x1bM', vt)\n+    push('\\x1b[20;6HFG', vt)\n+    expect('putglyph 46 1 19,5 dwl\\nputglyph 47 1 19,6 dwl')\n+  end)\n+\n+  itp('29state_fallback', function()\n+    local vt = init()\n+    local state = wantstate(vt, { f = true })\n+    reset(state, nil)\n+\n+    -- Unrecognised control\n+    push('\\x03', vt)\n+    expect('control 03')\n+\n+    -- Unrecognised CSI\n+    push('\\x1b[?15;2z', vt)\n+    expect('csi 7a L=3f 15,2')\n+\n+    -- Unrecognised OSC\n+    push('\\x1b]27;Something\\x1b\\\\', vt)\n+    expect('osc [27;Something]')\n+\n+    -- Unrecognised DCS\n+    push('\\x1bPz123\\x1b\\\\', vt)\n+    expect('dcs [z123]')\n+\n+    -- Unrecognised APC\n+    push('\\x1b_z123\\x1b\\\\', vt)\n+    expect('apc [z123]')\n+\n+    -- Unrecognised PM\n+    push('\\x1b^z123\\x1b\\\\', vt)\n+    expect('pm [z123]')\n+\n+    -- Unrecognised SOS\n+    push('\\x1bXz123\\x1b\\\\', vt)\n+    expect('sos [z123]')\n+  end)\n+\n+  itp('30state_pen', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Reset\n+    push('\\x1b[m', vt)\n+    pen('bold', false, state)\n+    pen('underline', 0, state)\n+    pen('italic', false, state)\n+    pen('blink', false, state)\n+    pen('reverse', false, state)\n+    pen('font', 0, state)\n+    -- TODO(dundargoc): fix\n+    -- ?pen foreground = rgb(240,240,240,is_default_fg)\n+    -- ?pen background = rgb(0,0,0,is_default_bg)\n+\n+    -- Bold\n+    push('\\x1b[1m', vt)\n+    pen('bold', true, state)\n+    push('\\x1b[22m', vt)\n+    pen('bold', false, state)\n+    push('\\x1b[1m\\x1b[m', vt)\n+    pen('bold', false, state)\n+\n+    -- Underline\n+    push('\\x1b[4m', vt)\n+    pen('underline', 1, state)\n+    push('\\x1b[21m', vt)\n+    pen('underline', 2, state)\n+    push('\\x1b[24m', vt)\n+    pen('underline', 0, state)\n+    push('\\x1b[4m\\x1b[4:0m', vt)\n+    pen('underline', 0, state)\n+    push('\\x1b[4:1m', vt)\n+    pen('underline', 1, state)\n+    push('\\x1b[4:2m', vt)\n+    pen('underline', 2, state)\n+    push('\\x1b[4:3m', vt)\n+    pen('underline', 3, state)\n+    push('\\x1b[4m\\x1b[m', vt)\n+    pen('underline', 0, state)\n+\n+    -- Italic\n+    push('\\x1b[3m', vt)\n+    pen('italic', true, state)\n+    push('\\x1b[23m', vt)\n+    pen('italic', false, state)\n+    push('\\x1b[3m\\x1b[m', vt)\n+    pen('italic', false, state)\n+\n+    -- Blink\n+    push('\\x1b[5m', vt)\n+    pen('blink', true, state)\n+    push('\\x1b[25m', vt)\n+    pen('blink', false, state)\n+    push('\\x1b[5m\\x1b[m', vt)\n+    pen('blink', false, state)\n+\n+    -- Reverse\n+    push('\\x1b[7m', vt)\n+    pen('reverse', true, state)\n+    push('\\x1b[27m', vt)\n+    pen('reverse', false, state)\n+    push('\\x1b[7m\\x1b[m', vt)\n+    pen('reverse', false, state)\n+\n+    -- Font Selection\n+    push('\\x1b[11m', vt)\n+    pen('font', 1, state)\n+    push('\\x1b[19m', vt)\n+    pen('font', 9, state)\n+    push('\\x1b[10m', vt)\n+    pen('font', 0, state)\n+    push('\\x1b[11m\\x1b[m', vt)\n+    pen('font', 0, state)\n+\n+    -- TODO(dundargoc): fix\n+    -- -- Foreground\n+    -- push \"\\x1b[31m\"\n+    --   ?pen foreground = idx(1)\n+    -- push \"\\x1b[32m\"\n+    --   ?pen foreground = idx(2)\n+    -- push \"\\x1b[34m\"\n+    --   ?pen foreground = idx(4)\n+    -- push \"\\x1b[91m\"\n+    --   ?pen foreground = idx(9)\n+    -- push \"\\x1b[38:2:10:20:30m\"\n+    --   ?pen foreground = rgb(10,20,30)\n+    -- push \"\\x1b[38:5:1m\"\n+    --   ?pen foreground = idx(1)\n+    -- push \"\\x1b[39m\"\n+    --   ?pen foreground = rgb(240,240,240,is_default_fg)\n+    --\n+    -- -- Background\n+    -- push \"\\x1b[41m\"\n+    --   ?pen background = idx(1)\n+    -- push \"\\x1b[42m\"\n+    --   ?pen background = idx(2)\n+    -- push \"\\x1b[44m\"\n+    --   ?pen background = idx(4)\n+    -- push \"\\x1b[101m\"\n+    --   ?pen background = idx(9)\n+    -- push \"\\x1b[48:2:10:20:30m\"\n+    --   ?pen background = rgb(10,20,30)\n+    -- push \"\\x1b[48:5:1m\"\n+    --   ?pen background = idx(1)\n+    -- push \"\\x1b[49m\"\n+    --   ?pen background = rgb(0,0,0,is_default_bg)\n+    --\n+    -- -- Bold+ANSI colour == highbright\n+    -- push \"\\x1b[m\\x1b[1;37m\"\n+    --   ?pen bold = on\n+    --   ?pen foreground = idx(15)\n+    -- push \"\\x1b[m\\x1b[37;1m\"\n+    --   ?pen bold = on\n+    --   ?pen foreground = idx(15)\n+    --\n+    -- -- Super/Subscript\n+    -- push \"\\x1b[73m\"\n+    --   ?pen small = on\n+    --   ?pen baseline = raise\n+    -- push \"\\x1b[74m\"\n+    --   ?pen small = on\n+    --   ?pen baseline = lower\n+    -- push \"\\x1b[75m\"\n+    --   ?pen small = off\n+    --   ?pen baseline = normal\n+    --\n+    -- -- DECSTR resets pen attributes\n+    -- push \"\\x1b[1;4m\"\n+    --   ?pen bold = on\n+    --   ?pen underline = 1\n+    -- push \"\\x1b[!p\"\n+    --   ?pen bold = off\n+    --   ?pen underline = 0\n+  end)\n+\n+  itp('31state_rep', function()\n+    local vt = init()\n+    local state = wantstate(vt, { g = true })\n+\n+    -- REP no argument\n+    reset(state, nil)\n+    push('a\\x1b[b', vt)\n+    expect('putglyph 61 1 0,0\\nputglyph 61 1 0,1')\n+\n+    -- REP zero (zero should be interpreted as one)\n+    reset(state, nil)\n+    push('a\\x1b[0b', vt)\n+    expect('putglyph 61 1 0,0\\nputglyph 61 1 0,1')\n+\n+    -- REP lowercase a times two\n+    reset(state, nil)\n+    push('a\\x1b[2b', vt)\n+    expect('putglyph 61 1 0,0\\nputglyph 61 1 0,1\\nputglyph 61 1 0,2')\n+\n+    -- REP with UTF-8 1 char\n+    -- U+00E9 = C3 A9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(state, nil)\n+    push('\\xC3\\xA9\\x1b[b', vt)\n+    expect('putglyph e9 1 0,0\\nputglyph e9 1 0,1')\n+\n+    -- REP with UTF-8 wide char\n+    -- U+00E9 = C3 A9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(state, nil)\n+    push('\\xEF\\xBC\\x90\\x1b[b', vt)\n+    expect('putglyph ff10 2 0,0\\nputglyph ff10 2 0,2')\n+\n+    -- REP with UTF-8 combining character\n+    reset(state, nil)\n+    push('e\\xCC\\x81\\x1b[b', vt)\n+    expect('putglyph 65,301 1 0,0\\nputglyph 65,301 1 0,1')\n+\n+    -- REP till end of line\n+    reset(state, nil)\n+    push('a\\x1b[1000bb', vt)\n+    expect(\n+      'putglyph 61 1 0,0\\nputglyph 61 1 0,1\\nputglyph 61 1 0,2\\nputglyph 61 1 0,3\\nputglyph 61 1 0,4\\nputglyph 61 1 0,5\\nputglyph 61 1 0,6\\nputglyph 61 1 0,7\\nputglyph 61 1 0,8\\nputglyph 61 1 0,9\\nputglyph 61 1 0,10\\nputglyph 61 1 0,11\\nputglyph 61 1 0,12\\nputglyph 61 1 0,13\\nputglyph 61 1 0,14\\nputglyph 61 1 0,15\\nputglyph 61 1 0,16\\nputglyph 61 1 0,17\\nputglyph 61 1 0,18\\nputglyph 61 1 0,19\\nputglyph 61 1 0,20\\nputglyph 61 1 0,21\\nputglyph 61 1 0,22\\nputglyph 61 1 0,23\\nputglyph 61 1 0,24\\nputglyph 61 1 0,25\\nputglyph 61 1 0,26\\nputglyph 61 1 0,27\\nputglyph 61 1 0,28\\nputglyph 61 1 0,29\\nputglyph 61 1 0,30\\nputglyph 61 1 0,31\\nputglyph 61 1 0,32\\nputglyph 61 1 0,33\\nputglyph 61 1 0,34\\nputglyph 61 1 0,35\\nputglyph 61 1 0,36\\nputglyph 61 1 0,37\\nputglyph 61 1 0,38\\nputglyph 61 1 0,39\\nputglyph 61 1 0,40\\nputglyph 61 1 0,41\\nputglyph 61 1 0,42\\nputglyph 61 1 0,43\\nputglyph 61 1 0,44\\nputglyph 61 1 0,45\\nputglyph 61 1 0,46\\nputglyph 61 1 0,47\\nputglyph 61 1 0,48\\nputglyph 61 1 0,49\\nputglyph 61 1 0,50\\nputglyph 61 1 0,51\\nputglyph 61 1 0,52\\nputglyph 61 1 0,53\\nputglyph 61 1 0,54\\nputglyph 61 1 0,55\\nputglyph 61 1 0,56\\nputglyph 61 1 0,57\\nputglyph 61 1 0,58\\nputglyph 61 1 0,59\\nputglyph 61 1 0,60\\nputglyph 61 1 0,61\\nputglyph 61 1 0,62\\nputglyph 61 1 0,63\\nputglyph 61 1 0,64\\nputglyph 61 1 0,65\\nputglyph 61 1 0,66\\nputglyph 61 1 0,67\\nputglyph 61 1 0,68\\nputglyph 61 1 0,69\\nputglyph 61 1 0,70\\nputglyph 61 1 0,71\\nputglyph 61 1 0,72\\nputglyph 61 1 0,73\\nputglyph 61 1 0,74\\nputglyph 61 1 0,75\\nputglyph 61 1 0,76\\nputglyph 61 1 0,77\\nputglyph 61 1 0,78\\nputglyph 61 1 0,79\\nputglyph 62 1 1,0'\n+    )\n+  end)\n+\n+  itp('32state_flow', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+\n+    -- Many of these test cases inspired by\n+    -- https://blueprints.launchpad.net/libvterm/+spec/reflow-cases\n+\n+    -- Spillover text marks continuation on second line\n+    reset(state, nil)\n+    push(string.rep('A', 100), vt)\n+    push('\\r\\n', vt)\n+    lineinfo(0, {}, state)\n+    lineinfo(1, { cont = true }, state)\n+\n+    -- CRLF in column 80 does not mark continuation\n+    reset(state, nil)\n+    push(string.rep('B', 80), vt)\n+    push('\\r\\n', vt)\n+    push(string.rep('B', 20), vt)\n+    push('\\r\\n', vt)\n+    lineinfo(0, {}, state)\n+    lineinfo(1, {}, state)\n+\n+    -- EL cancels continuation of following line\n+    reset(state, nil)\n+    push(string.rep('D', 100), vt)\n+    lineinfo(1, { cont = true }, state)\n+    push('\\x1bM\\x1b[79G\\x1b[K', vt)\n+    lineinfo(1, {}, state)\n+  end)\n+\n+  itp('40state_selection', function()\n+    local vt = init()\n+    wantstate(vt)\n+\n+    -- Set clipboard; final chunk len 4\n+    push('\\x1b]52;c;SGVsbG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello,]')\n+\n+    -- Set clipboard; final chunk len 3\n+    push('\\x1b]52;c;SGVsbG8sIHc=\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello, w]')\n+\n+    -- Set clipboard; final chunk len 2\n+    push('\\x1b]52;c;SGVsbG8sIHdvcmxkCg==\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello, world\\n]')\n+\n+    -- Set clipboard; split between chunks\n+    push('\\x1b]52;c;SGVs', vt)\n+    expect('selection-set mask=0001 [Hel')\n+    push('bG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 lo,]')\n+\n+    -- Set clipboard; split within chunk\n+    push('\\x1b]52;c;SGVsbG', vt)\n+    expect('selection-set mask=0001 [Hel')\n+    push('8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 lo,]')\n+\n+    -- Set clipboard; empty first chunk\n+    push('\\x1b]52;c;', vt)\n+    push('SGVsbG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [Hello,]')\n+\n+    -- Set clipboard; empty final chunk\n+    push('\\x1b]52;c;SGVsbG8s', vt)\n+    expect('selection-set mask=0001 [Hello,')\n+    push('\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 ]')\n+\n+    -- Set clipboard; longer than buffer\n+    push('\\x1b]52;c;' .. string.rep('LS0t', 10) .. '\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 [---------------\\nselection-set mask=0001 ---------------]')\n+\n+    -- Clear clipboard\n+    push('\\x1b]52;c;\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 []')\n+\n+    -- Set invalid data clears and ignores\n+    push('\\x1b]52;c;SGVs*SGVsbG8s\\x1b\\\\', vt)\n+    expect('selection-set mask=0001 []')\n+\n+    -- Query clipboard\n+    push('\\x1b]52;c;?\\x1b\\\\', vt)\n+    expect('selection-query mask=0001')\n+\n+    -- TODO(dundargoc): fix\n+    -- -- Send clipboard; final chunk len 4\n+    -- SELECTION 1 [\"Hello,\"]\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVsbG8s\"\n+    --   output \"\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; final chunk len 3\n+    -- SELECTION 1 [\"Hello, w\"]\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVsbG8s\"\n+    --   output \"IHc=\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; final chunk len 2\n+    -- SELECTION 1 [\"Hello, world\\n\"]\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVsbG8sIHdvcmxk\"\n+    --   output \"Cg==\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; split between chunks\n+    -- SELECTION 1 [\"Hel\"\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVs\"\n+    -- SELECTION 1  \"lo,\"]\n+    --   output \"bG8s\"\n+    --   output \"\\x1b\\\\\"\n+    --\n+    -- -- Send clipboard; split within chunk\n+    -- SELECTION 1 [\"Hello\"\n+    --   output \"\\x1b]52;c;\"\n+    --   output \"SGVs\"\n+    -- SELECTION 1 \",\"]\n+    --   output \"bG8s\"\n+    --   output \"\\x1b\\\\\"\n+  end)\n+\n+  itp('60screen_ascii', function()\n+    local vt = init()\n+    local screen = wantscreen(vt, { a = true, c = true })\n+\n+    -- Get\n+    reset(nil, screen)\n+    push('ABC', vt)\n+    expect('movecursor 0,3')\n+    screen_chars(0, 0, 1, 3, 'ABC', screen)\n+    screen_chars(0, 0, 1, 80, 'ABC', screen)\n+    screen_text(0, 0, 1, 3, '41,42,43', screen)\n+    screen_text(0, 0, 1, 80, '41,42,43', screen)\n+    screen_cell(0, 0, '{41} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 1, '{42} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 2, '{43} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_row(0, 'ABC', screen)\n+    screen_eol(0, 0, 0, screen)\n+    screen_eol(0, 2, 0, screen)\n+    screen_eol(0, 3, 1, screen)\n+    push('\\x1b[H', vt)\n+    expect('movecursor 0,0')\n+    screen_row(0, 'ABC', screen)\n+    screen_text(0, 0, 1, 80, '41,42,43', screen)\n+    push('E', vt)\n+    expect('movecursor 0,1')\n+    screen_row(0, 'EBC', screen)\n+    screen_text(0, 0, 1, 80, '45,42,43', screen)\n+\n+    screen = wantscreen(vt, { a = true })\n+\n+    -- Erase\n+    reset(nil, screen)\n+    push('ABCDE\\x1b[H\\x1b[K', vt)\n+    -- TODO(dundargoc): fix\n+    -- screen_row(0, '', screen)\n+    screen_text(0, 0, 1, 80, '', screen)\n+\n+    -- Copycell\n+    reset(nil, screen)\n+    push('ABC\\x1b[H\\x1b[@', vt)\n+    push('1', vt)\n+    screen_row(0, '1ABC', screen)\n+\n+    reset(nil, screen)\n+    push('ABC\\x1b[H\\x1b[P', vt)\n+    screen_chars(0, 0, 1, 1, 'B', screen)\n+    screen_chars(0, 1, 1, 2, 'C', screen)\n+    screen_chars(0, 0, 1, 80, 'BC', screen)\n+\n+    -- Space padding\n+    reset(nil, screen)\n+    push('Hello\\x1b[CWorld', vt)\n+    screen_row(0, 'Hello World', screen)\n+    screen_text(0, 0, 1, 80, '48,65,6c,6c,6f,20,57,6f,72,6c,64', screen)\n+\n+    -- Linefeed padding\n+    reset(nil, screen)\n+    push('Hello\\r\\nWorld', vt)\n+    screen_chars(0, 0, 2, 80, 'Hello\\nWorld', screen)\n+    screen_text(0, 0, 2, 80, '48,65,6c,6c,6f,0a,57,6f,72,6c,64', screen)\n+\n+    -- Altscreen\n+    reset(nil, screen)\n+    push('P', vt)\n+    screen_row(0, 'P', screen)\n+    -- TODO(dundargoc): fix\n+    -- push('\\x1b[?1049h', vt)\n+    -- screen_row(0, '', screen)\n+    -- push('\\x1b[2K\\x1b[HA', vt)\n+    -- screen_row(0, 'A', screen)\n+    -- push('\\x1b[?1049l', vt)\n+    -- screen_row(0, 'P', screen)\n+  end)\n+\n+  itp('61screen_unicode', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    -- Single width UTF-8\n+    -- U+00C1 = C3 81  name: LATIN CAPITAL LETTER A WITH ACUTE\n+    -- U+00E9 = C3 A9  name: LATIN SMALL LETTER E WITH ACUTE\n+    reset(nil, screen)\n+    push('\\xC3\\x81\\xC3\\xA9', vt)\n+    screen_row(0, 'Áé', screen)\n+    screen_text(0, 0, 1, 80, 'c3,81,c3,a9', screen)\n+    screen_cell(0, 0, '{c1} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Wide char\n+    -- U+FF10 = EF BC 90  name: FULLWIDTH DIGIT ZERO\n+    reset(nil, screen)\n+    push('0123\\x1b[H', vt)\n+    push('\\xEF\\xBC\\x90', vt)\n+    screen_row(0, '０23', screen)\n+    screen_text(0, 0, 1, 80, 'ef,bc,90,32,33', screen)\n+    screen_cell(0, 0, '{ff10} width=2 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Combining char\n+    -- U+0301 = CC 81  name: COMBINING ACUTE\n+    reset(nil, screen)\n+    push('0123\\x1b[H', vt)\n+    push('e\\xCC\\x81', vt)\n+    screen_row(0, 'é123', screen)\n+    screen_text(0, 0, 1, 80, '65,cc,81,31,32,33', screen)\n+    screen_cell(0, 0, '{65,301} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- 10 combining accents should not crash\n+    reset(nil, screen)\n+    push('e\\xCC\\x81\\xCC\\x82\\xCC\\x83\\xCC\\x84\\xCC\\x85\\xCC\\x86\\xCC\\x87\\xCC\\x88\\xCC\\x89\\xCC\\x8A', vt)\n+    screen_cell(\n+      0,\n+      0,\n+      '{65,301,302,303,304,305} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)',\n+      screen\n+    )\n+\n+    -- 40 combining accents in two split writes of 20 should not crash\n+    reset(nil, screen)\n+    push(\n+      'e\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81',\n+      vt\n+    )\n+    push(\n+      '\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81\\xCC\\x81',\n+      vt\n+    )\n+    screen_cell(\n+      0,\n+      0,\n+      '{65,301,301,301,301,301} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)',\n+      screen\n+    )\n+\n+    -- Outputing CJK doublewidth in 80th column should wraparound to next line and not crash\"\n+    reset(nil, screen)\n+    push('\\x1b[80G\\xEF\\xBC\\x90', vt)\n+    screen_cell(0, 79, '{} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(1, 0, '{ff10} width=2 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+  end)\n+\n+  pending('62screen_damage', function() end)\n+\n+  itp('63screen_resize', function()\n+    local vt = init()\n+    local state = wantstate(vt)\n+    local screen = wantscreen(vt)\n+\n+    -- Resize wider preserves cells\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('AB\\r\\nCD', vt)\n+    screen_chars(0, 0, 1, 80, 'AB', screen)\n+    screen_chars(1, 0, 2, 80, 'CD', screen)\n+    resize(25, 100, vt)\n+    screen_chars(0, 0, 1, 100, 'AB', screen)\n+    screen_chars(1, 0, 2, 100, 'CD', screen)\n+\n+    -- Resize wider allows print in new area\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('AB\\x1b[79GCD', vt)\n+    screen_chars(0, 0, 1, 2, 'AB', screen)\n+    screen_chars(0, 78, 1, 80, 'CD', screen)\n+    resize(25, 100, vt)\n+    screen_chars(0, 0, 1, 2, 'AB', screen)\n+    screen_chars(0, 78, 1, 80, 'CD', screen)\n+    push('E', vt)\n+    screen_chars(0, 78, 1, 81, 'CDE', screen)\n+\n+    -- Resize shorter with blanks just truncates\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('Top\\x1b[10HLine 10', vt)\n+    screen_row(0, 'Top', screen)\n+    screen_row(9, 'Line 10', screen)\n+    cursor(9, 7, state)\n+    resize(20, 80, vt)\n+    screen_row(0, 'Top', screen)\n+    screen_row(9, 'Line 10', screen)\n+    cursor(9, 7, state)\n+\n+    -- Resize shorter with content must scroll\n+    reset(state, screen)\n+    resize(25, 80, vt)\n+    push('Top\\x1b[25HLine 25\\x1b[15H', vt)\n+    screen_row(0, 'Top', screen)\n+    screen_row(24, 'Line 25', screen)\n+    cursor(14, 0, state)\n+    screen = wantscreen(vt, { b = true })\n+    resize(20, 80, vt)\n+    expect(\n+      'sb_pushline 80 = 54 6F 70\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 ='\n+    )\n+    -- TODO(dundargoc): fix or remove\n+    -- screen_row( 0  , \"\",screen)\n+    screen_row(19, 'Line 25', screen)\n+    cursor(9, 0, state)\n+\n+    -- Resize shorter does not lose line with cursor\n+    -- See also https://github.com/neovim/libvterm/commit/1b745d29d45623aa8d22a7b9288c7b0e331c7088\n+    reset(state, screen)\n+    wantscreen(vt)\n+    resize(25, 80, vt)\n+    screen = wantscreen(vt, { b = true })\n+    push('\\x1b[24HLine 24\\r\\nLine 25\\r\\n', vt)\n+    expect('sb_pushline 80 =')\n+    screen_row(23, 'Line 25', screen)\n+    cursor(24, 0, state)\n+    resize(24, 80, vt)\n+    expect('sb_pushline 80 =')\n+    screen_row(22, 'Line 25', screen)\n+    cursor(23, 0, state)\n+\n+    -- Resize shorter does not send the cursor to a negative row\n+    -- See also https://github.com/vim/vim/pull/6141\n+    reset(state, screen)\n+    wantscreen(vt)\n+    resize(25, 80, vt)\n+    screen = wantscreen(vt, { b = true })\n+    push('\\x1b[24HLine 24\\r\\nLine 25\\x1b[H', vt)\n+    cursor(0, 0, state)\n+    resize(20, 80, vt)\n+    expect(\n+      'sb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 =\\nsb_pushline 80 ='\n+    )\n+    cursor(0, 0, state)\n+\n+    -- Resize taller attempts to pop scrollback\n+    reset(state, screen)\n+    screen = wantscreen(vt)\n+    resize(25, 80, vt)\n+    push('Line 1\\x1b[25HBottom\\x1b[15H', vt)\n+    screen_row(0, 'Line 1', screen)\n+    screen_row(24, 'Bottom', screen)\n+    cursor(14, 0, state)\n+    screen = wantscreen(vt, { b = true })\n+    resize(30, 80, vt)\n+    expect('sb_popline 80\\nsb_popline 80\\nsb_popline 80\\nsb_popline 80\\nsb_popline 80')\n+    screen_row(0, 'ABCDE', screen)\n+    screen_row(5, 'Line 1', screen)\n+    screen_row(29, 'Bottom', screen)\n+    cursor(19, 0, state)\n+    screen = wantscreen(vt)\n+\n+    -- Resize can operate on altscreen\n+    reset(state, screen)\n+    screen = wantscreen(vt, { a = true })\n+    resize(25, 80, vt)\n+    push('Main screen\\x1b[?1049h\\x1b[HAlt screen', vt)\n+    resize(30, 80, vt)\n+    screen_row(0, 'Alt screen', screen)\n+    push('\\x1b[?1049l', vt)\n+    screen_row(0, 'Main screen', screen)\n+  end)\n+\n+  itp('64screen_pen', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    -- Plain\n+    push('A', vt)\n+    screen_cell(0, 0, '{41} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Bold\n+    push('\\x1b[1mB', vt)\n+    screen_cell(0, 1, '{42} width=1 attrs={B} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Italic\n+    push('\\x1b[3mC', vt)\n+    screen_cell(0, 2, '{43} width=1 attrs={BI} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Underline\n+    push('\\x1b[4mD', vt)\n+    screen_cell(0, 3, '{44} width=1 attrs={BU1I} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Reset\n+    push('\\x1b[mE', vt)\n+    screen_cell(0, 4, '{45} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Font\n+    push('\\x1b[11mF\\x1b[m', vt)\n+    screen_cell(0, 5, '{46} width=1 attrs={F1} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Foreground\n+    push('\\x1b[31mG\\x1b[m', vt)\n+    screen_cell(0, 6, '{47} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(0,0,0)', screen)\n+\n+    -- Background\n+    push('\\x1b[42mH\\x1b[m', vt)\n+    screen_cell(0, 7, '{48} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,224,0)', screen)\n+\n+    -- Super/subscript\n+    push('x\\x1b[74m0\\x1b[73m2\\x1b[m', vt)\n+    screen_cell(0, 8, '{78} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 9, '{30} width=1 attrs={S_} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 10, '{32} width=1 attrs={S^} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- EL sets only colours to end of line, not other attrs\n+    push('\\x1b[H\\x1b[7;33;44m\\x1b[K', vt)\n+    screen_cell(0, 0, '{} width=1 attrs={} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+    screen_cell(0, 79, '{} width=1 attrs={} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+\n+    -- DECSCNM xors reverse for entire screen\n+    push('R\\x1b[?5h', vt)\n+    screen_cell(0, 0, '{52} width=1 attrs={} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+    screen_cell(1, 0, '{} width=1 attrs={R} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    push('\\x1b[?5$p', vt)\n+    expect_output('\\x1b[?5;1$y')\n+    push('\\x1b[?5l', vt)\n+    screen_cell(0, 0, '{52} width=1 attrs={R} fg=rgb(224,224,0) bg=rgb(0,0,224)', screen)\n+    screen_cell(1, 0, '{} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    -- TODO(dundargoc): fix\n+    -- push('\\x1b[?5$p')\n+    -- expect_output('\\x1b[?5;2$y')\n+\n+    -- Set default colours\n+    reset(nil, screen)\n+    push('ABC\\x1b[31mDEF\\x1b[m', vt)\n+    screen_cell(0, 0, '{41} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(0, 3, '{44} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(0,0,0)', screen)\n+    -- TODO(dundargoc): fix\n+    -- SETDEFAULTCOL rgb(252,253,254)\n+    --   ?screen_cell 0,0  = {41} width=1 attrs={} fg=rgb(252,253,254) bg=rgb(0,0,0)\n+    --   ?screen_cell 0,3  = {44} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(0,0,0)\n+    -- SETDEFAULTCOL rgb(250,250,250) rgb(10,20,30)\n+    --   ?screen_cell 0,0  = {41} width=1 attrs={} fg=rgb(250,250,250) bg=rgb(10,20,30)\n+    --   ?screen_cell 0,3  = {44} width=1 attrs={} fg=rgb(224,0,0) bg=rgb(10,20,30)\n+  end)\n+\n+  itp('65screen_protect', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    -- Selective erase\n+    reset(nil, screen)\n+    push('A\\x1b[1\"qB\\x1b[\"qC', vt)\n+    screen_row(0, 'ABC', screen)\n+    push('\\x1b[G\\x1b[?J', vt)\n+    screen_row(0, ' B', screen)\n+\n+    -- Non-selective erase\n+    reset(nil, screen)\n+    push('A\\x1b[1\"qB\\x1b[\"qC', vt)\n+    screen_row(0, 'ABC', screen)\n+    -- TODO(dundargoc): fix\n+    -- push('\\x1b[G\\x1b[J', vt)\n+    -- screen_row(0, '', screen)\n+  end)\n+\n+  itp('66screen_extent', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    -- Bold extent\n+    reset(nil, screen)\n+    push('AB\\x1b[1mCD\\x1b[mE', vt)\n+    screen_attrs_extent(0, 0, '0,0-1,1', screen)\n+    screen_attrs_extent(0, 1, '0,0-1,1', screen)\n+    screen_attrs_extent(0, 2, '0,2-1,3', screen)\n+    screen_attrs_extent(0, 3, '0,2-1,3', screen)\n+    screen_attrs_extent(0, 4, '0,4-1,79', screen)\n+  end)\n+\n+  itp('67screen_dbl_wh', function()\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    -- Single Width, Single Height\n+    reset(nil, screen)\n+    push('\\x1b#5', vt)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Double Width, Single Height\n+    reset(nil, screen)\n+    push('\\x1b#6', vt)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} dwl fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- Double Height\n+    reset(nil, screen)\n+    push('\\x1b#3', vt)\n+    push('abcde', vt)\n+    push('\\r\\n\\x1b#4', vt)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} dwl dhl-top fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(\n+      1,\n+      0,\n+      '{61} width=1 attrs={} dwl dhl-bottom fg=rgb(240,240,240) bg=rgb(0,0,0)',\n+      screen\n+    )\n+\n+    -- Late change\n+    reset(nil, screen)\n+    push('abcde', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    push('\\x1b#6', vt)\n+    screen_cell(0, 0, '{61} width=1 attrs={} dwl fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+\n+    -- DWL doesn't spill over on scroll\n+    reset(nil, screen)\n+    push('\\x1b[25H\\x1b#6Final\\r\\n', vt)\n+    screen_cell(23, 0, '{46} width=1 attrs={} dwl fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+    screen_cell(24, 0, '{} width=1 attrs={} fg=rgb(240,240,240) bg=rgb(0,0,0)', screen)\n+  end)\n+\n+  itp('68screen_termprops', function()\n+    local vt = init()\n+    local screen = wantscreen(vt, { p = true })\n+\n+    reset(nil, screen)\n+    expect('settermprop 1 true\\nsettermprop 2 true\\nsettermprop 7 1')\n+\n+    -- Cursor visibility\n+    push('\\x1b[?25h', vt)\n+    expect('settermprop 1 true')\n+    push('\\x1b[?25l', vt)\n+    expect('settermprop 1 false')\n+\n+    -- Title\n+    push('\\x1b]2;Here is my title\\a', vt)\n+    expect('settermprop 4 [\"Here is my title\"]')\n+  end)\n+\n+  itp('69screen_pushline', function()\n+    local vt = init()\n+    -- Run these tests on a much smaller default screen, so debug output is nowhere near as noisy\n+    resize(5, 10, vt)\n+    local state = wantstate(vt)\n+    local screen = wantscreen(vt, { r = true })\n+    reset(state, screen)\n+\n+    -- Resize wider reflows wide lines\n+    reset(state, screen)\n+    push(string.rep('A', 12), vt)\n+    screen_row(0, 'AAAAAAAAAA', screen, vt.cols)\n+    screen_row(1, 'AA', screen, vt.cols)\n+    lineinfo(1, { cont = true }, state)\n+    cursor(1, 2, state)\n+    resize(5, 15, vt)\n+    screen_row(0, 'AAAAAAAAAAAA', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row(1, '', screen, vt.cols)\n+    lineinfo(1, {}, state)\n+    cursor(0, 12, state)\n+    resize(5, 20, vt)\n+    screen_row(0, 'AAAAAAAAAAAA', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 ,'',screen, vt.cols)\n+    lineinfo(1, {}, state)\n+    cursor(0, 12, state)\n+\n+    -- Resize narrower can create continuation lines\n+    reset(state, screen)\n+    resize(5, 10, vt)\n+    push('ABCDEFGHI', vt)\n+    screen_row(0, 'ABCDEFGHI', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen, vt.cols)\n+    lineinfo(1, {}, state)\n+    cursor(0, 9, state)\n+    resize(5, 8, vt)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 0 , \"ABCDEFGH\",screen,vt.cols)\n+    screen_row(1, 'I', screen, vt.cols)\n+    lineinfo(1, { cont = true }, state)\n+    cursor(1, 1, state)\n+    resize(5, 6, vt)\n+    screen_row(0, 'ABCDEF', screen, vt.cols)\n+    screen_row(1, 'GHI', screen, vt.cols)\n+    lineinfo(1, { cont = true }, state)\n+    cursor(1, 3, state)\n+\n+    -- Shell wrapped prompt behaviour\n+    reset(state, screen)\n+    resize(5, 10, vt)\n+    push('PROMPT GOES HERE\\r\\n> \\r\\n\\r\\nPROMPT GOES HERE\\r\\n> ', vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    screen_row(2, 'PROMPT GOE', screen, vt.cols)\n+    screen_row(3, 'S HERE', screen, vt.cols)\n+    lineinfo(3, { cont = true }, state)\n+    screen_row(4, '> ', screen, vt.cols)\n+    cursor(4, 2, state)\n+    resize(5, 11, vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    screen_row(2, 'PROMPT GOES', screen, vt.cols)\n+    screen_row(3, ' HERE', screen, vt.cols)\n+    lineinfo(3, { cont = true }, state)\n+    screen_row(4, '> ', screen, vt.cols)\n+    cursor(4, 2, state)\n+    resize(5, 12, vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    screen_row(2, 'PROMPT GOES ', screen, vt.cols)\n+    screen_row(3, 'HERE', screen, vt.cols)\n+    lineinfo(3, { cont = true }, state)\n+    screen_row(4, '> ', screen, vt.cols)\n+    cursor(4, 2, state)\n+    resize(5, 16, vt)\n+    screen_row(0, '> ', screen, vt.cols)\n+    -- TODO(dundargoc): fix\n+    -- screen_row( 1 , \"\",screen,vt.cols)\n+    -- screen_row( 2 , \"PROMPT GOES HERE\",screen,vt.cols)\n+    lineinfo(3, {}, state)\n+    screen_row(3, '> ', screen, vt.cols)\n+    cursor(3, 2, state)\n+\n+    -- Cursor goes missing\n+    -- For more context: https://github.com/neovim/neovim/pull/21124\n+    reset(state, screen)\n+    resize(5, 5, vt)\n+    resize(3, 1, vt)\n+    push('\\x1b[2;1Habc\\r\\n\\x1b[H', vt)\n+    resize(1, 1, vt)\n+    cursor(0, 0, state)\n+  end)\n+\n+  pending('90vttest_01-movement-1', function() end)\n+  pending('90vttest_01-movement-2', function() end)\n+\n+  itp('90vttest_01-movement-3', function()\n+    -- Test of cursor-control characters inside ESC sequences\n+    local vt = init()\n+    local state = wantstate(vt)\n+    local screen = wantscreen(vt)\n+\n+    reset(state, screen)\n+\n+    push('A B C D E F G H I', vt)\n+    push('\\x0d\\x0a', vt)\n+    push('A\\x1b[2\\bCB\\x1b[2\\bCC\\x1b[2\\bCD\\x1b[2\\bCE\\x1b[2\\bCF\\x1b[2\\bCG\\x1b[2\\bCH\\x1b[2\\bCI', vt)\n+    push('\\x0d\\x0a', vt)\n+    push(\n+      'A \\x1b[\\x0d2CB\\x1b[\\x0d4CC\\x1b[\\x0d6CD\\x1b[\\x0d8CE\\x1b[\\x0d10CF\\x1b[\\x0d12CG\\x1b[\\x0d14CH\\x1b[\\x0d16CI',\n+      vt\n+    )\n+    push('\\x0d\\x0a', vt)\n+    push(\n+      'A \\x1b[1\\x0bAB \\x1b[1\\x0bAC \\x1b[1\\x0bAD \\x1b[1\\x0bAE \\x1b[1\\x0bAF \\x1b[1\\x0bAG \\x1b[1\\x0bAH \\x1b[1\\x0bAI \\x1b[1\\x0bA',\n+      vt\n+    )\n+\n+    -- Output\n+\n+    for i = 0, 2 do\n+      screen_row(i, 'A B C D E F G H I', screen)\n+    end\n+    screen_row(3, 'A B C D E F G H I ', screen)\n+\n+    cursor(3, 18, state)\n+  end)\n+\n+  itp('90vttest_01-movement-4', function()\n+    -- Test of leading zeroes in ESC sequences\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    push('\\x1b[00000000004;000000001HT', vt)\n+    push('\\x1b[00000000004;000000002Hh', vt)\n+    push('\\x1b[00000000004;000000003Hi', vt)\n+    push('\\x1b[00000000004;000000004Hs', vt)\n+    push('\\x1b[00000000004;000000005H ', vt)\n+    push('\\x1b[00000000004;000000006Hi', vt)\n+    push('\\x1b[00000000004;000000007Hs', vt)\n+    push('\\x1b[00000000004;000000008H ', vt)\n+    push('\\x1b[00000000004;000000009Ha', vt)\n+    push('\\x1b[00000000004;0000000010H ', vt)\n+    push('\\x1b[00000000004;0000000011Hc', vt)\n+    push('\\x1b[00000000004;0000000012Ho', vt)\n+    push('\\x1b[00000000004;0000000013Hr', vt)\n+    push('\\x1b[00000000004;0000000014Hr', vt)\n+    push('\\x1b[00000000004;0000000015He', vt)\n+    push('\\x1b[00000000004;0000000016Hc', vt)\n+    push('\\x1b[00000000004;0000000017Ht', vt)\n+    push('\\x1b[00000000004;0000000018H ', vt)\n+    push('\\x1b[00000000004;0000000019Hs', vt)\n+    push('\\x1b[00000000004;0000000020He', vt)\n+    push('\\x1b[00000000004;0000000021Hn', vt)\n+    push('\\x1b[00000000004;0000000022Ht', vt)\n+    push('\\x1b[00000000004;0000000023He', vt)\n+    push('\\x1b[00000000004;0000000024Hn', vt)\n+    push('\\x1b[00000000004;0000000025Hc', vt)\n+    push('\\x1b[00000000004;0000000026He', vt)\n+\n+    -- Output\n+\n+    screen_row(3, 'This is a correct sentence', screen)\n+  end)\n+\n+  pending('90vttest_02-screen-1', function() end)\n+  pending('90vttest_02-screen-2', function() end)\n+\n+  itp('90vttest_02-screen-3', function()\n+    -- Origin mode\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    push('\\x1b[?6h', vt)\n+    push('\\x1b[23;24r', vt)\n+    push('\\n', vt)\n+    push('Bottom', vt)\n+    push('\\x1b[1;1H', vt)\n+    push('Above', vt)\n+\n+    -- Output\n+    screen_row(22, 'Above', screen)\n+    screen_row(23, 'Bottom', screen)\n+  end)\n+\n+  itp('90vttest_02-screen-4', function()\n+    -- Origin mode (2)\n+    local vt = init()\n+    local screen = wantscreen(vt)\n+\n+    reset(nil, screen)\n+\n+    push('\\x1b[?6l', vt)\n+    push('\\x1b[23;24r', vt)\n+    push('\\x1b[24;1H', vt)\n+    push('Bottom', vt)\n+    push('\\x1b[1;1H', vt)\n+    push('Top', vt)\n+\n+    -- Output\n+    screen_row(23, 'Bottom', screen)\n+    screen_row(0, 'Top', screen)\n+  end)\n+\n+  itp('92lp1640917', function()",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1809577718",
            "id": 1809577718,
            "in_reply_to_id": 1809564001,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5r2_b2",
            "original_commit_id": "eec2162be6d8484d1eaf73082e4db58763c4871b",
            "original_line": 3575,
            "original_position": 3575,
            "original_start_line": null,
            "path": "test/unit/vterm_spec.lua",
            "position": null,
            "pull_request_review_id": 2383364769,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809577718/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-21T21:45:27Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1809577718",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/1359421?v=4",
                "events_url": "https://api.github.com/users/justinmk/events{/privacy}",
                "followers_url": "https://api.github.com/users/justinmk/followers",
                "following_url": "https://api.github.com/users/justinmk/following{/other_user}",
                "gists_url": "https://api.github.com/users/justinmk/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/justinmk",
                "id": 1359421,
                "login": "justinmk",
                "node_id": "MDQ6VXNlcjEzNTk0MjE=",
                "organizations_url": "https://api.github.com/users/justinmk/orgs",
                "received_events_url": "https://api.github.com/users/justinmk/received_events",
                "repos_url": "https://api.github.com/users/justinmk/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/justinmk/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/justinmk/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/justinmk",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1810268699"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1810268699"
                }
            },
            "author_association": "MEMBER",
            "body": "Can you mention somewhere why this change is necessary?",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-10-22T08:50:57Z",
            "diff_hunk": "@@ -219,7 +220,7 @@ typedef enum {\n \n typedef struct {\n   const char *str;\n-  size_t      len : 30;\n+  int         len : 30;",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1810268699",
            "id": 1810268699,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5r5oIb",
            "original_commit_id": "daf867be1b8d5fb521da6625d35b995979d14259",
            "original_line": 223,
            "original_position": 22,
            "original_start_line": null,
            "path": "src/vterm/vterm.h",
            "position": null,
            "pull_request_review_id": 2384436285,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1810268699/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-22T08:50:58Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1810268699",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/35768171?v=4",
                "events_url": "https://api.github.com/users/zeertzjq/events{/privacy}",
                "followers_url": "https://api.github.com/users/zeertzjq/followers",
                "following_url": "https://api.github.com/users/zeertzjq/following{/other_user}",
                "gists_url": "https://api.github.com/users/zeertzjq/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/zeertzjq",
                "id": 35768171,
                "login": "zeertzjq",
                "node_id": "MDQ6VXNlcjM1NzY4MTcx",
                "organizations_url": "https://api.github.com/users/zeertzjq/orgs",
                "received_events_url": "https://api.github.com/users/zeertzjq/received_events",
                "repos_url": "https://api.github.com/users/zeertzjq/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/zeertzjq/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/zeertzjq/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/zeertzjq",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1810335873"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1810335873"
                }
            },
            "author_association": "MEMBER",
            "body": "The tests fail with `test/unit/testutil.lua:276: invalid value near ':' at line 18'` otherwise.",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-10-22T09:19:33Z",
            "diff_hunk": "@@ -219,7 +220,7 @@ typedef enum {\n \n typedef struct {\n   const char *str;\n-  size_t      len : 30;\n+  int         len : 30;",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1810335873",
            "id": 1810335873,
            "in_reply_to_id": 1810268699,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5r54iB",
            "original_commit_id": "daf867be1b8d5fb521da6625d35b995979d14259",
            "original_line": 223,
            "original_position": 22,
            "original_start_line": null,
            "path": "src/vterm/vterm.h",
            "position": null,
            "pull_request_review_id": 2384541033,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 0,
                "laugh": 0,
                "rocket": 0,
                "total_count": 0,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1810335873/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-22T09:19:33Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1810335873",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc",
                "user_view_type": "public"
            }
        },
        {
            "_links": {
                "html": {
                    "href": "https://github.com/neovim/neovim/pull/30335#discussion_r1810613689"
                },
                "pull_request": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/30335"
                },
                "self": {
                    "href": "https://api.github.com/repos/neovim/neovim/pulls/comments/1810613689"
                }
            },
            "author_association": "MEMBER",
            "body": "Reverted it back to size_t by removing the bitfield in tests.",
            "commit_id": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
            "created_at": "2024-10-22T12:16:16Z",
            "diff_hunk": "@@ -219,7 +220,7 @@ typedef enum {\n \n typedef struct {\n   const char *str;\n-  size_t      len : 30;\n+  int         len : 30;",
            "html_url": "https://github.com/neovim/neovim/pull/30335#discussion_r1810613689",
            "id": 1810613689,
            "in_reply_to_id": 1810268699,
            "line": null,
            "node_id": "PRRC_kwDOAPphoM5r68W5",
            "original_commit_id": "daf867be1b8d5fb521da6625d35b995979d14259",
            "original_line": 223,
            "original_position": 22,
            "original_start_line": null,
            "path": "src/vterm/vterm.h",
            "position": null,
            "pull_request_review_id": 2385018939,
            "pull_request_url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
            "reactions": {
                "+1": 0,
                "-1": 0,
                "confused": 0,
                "eyes": 0,
                "heart": 0,
                "hooray": 1,
                "laugh": 0,
                "rocket": 0,
                "total_count": 1,
                "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1810613689/reactions"
            },
            "side": "RIGHT",
            "start_line": null,
            "start_side": null,
            "subject_type": "line",
            "updated_at": "2024-10-22T12:16:16Z",
            "url": "https://api.github.com/repos/neovim/neovim/pulls/comments/1810613689",
            "user": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc",
                "user_view_type": "public"
            }
        }
    ],
    "comment_regular_data": [],
    "comments_url": "https://api.github.com/repos/neovim/neovim/issues/30335/comments",
    "commits_url": "https://api.github.com/repos/neovim/neovim/pulls/30335/commits",
    "created_at": "2024-09-10T16:13:06Z",
    "diff_url": "https://github.com/neovim/neovim/pull/30335.diff",
    "draft": false,
    "head": {
        "label": "dundargoc:test/vterm",
        "ref": "test/vterm",
        "repo": {
            "allow_forking": true,
            "archive_url": "https://api.github.com/repos/dundargoc/neovim/{archive_format}{/ref}",
            "archived": false,
            "assignees_url": "https://api.github.com/repos/dundargoc/neovim/assignees{/user}",
            "blobs_url": "https://api.github.com/repos/dundargoc/neovim/git/blobs{/sha}",
            "branches_url": "https://api.github.com/repos/dundargoc/neovim/branches{/branch}",
            "clone_url": "https://github.com/dundargoc/neovim.git",
            "collaborators_url": "https://api.github.com/repos/dundargoc/neovim/collaborators{/collaborator}",
            "comments_url": "https://api.github.com/repos/dundargoc/neovim/comments{/number}",
            "commits_url": "https://api.github.com/repos/dundargoc/neovim/commits{/sha}",
            "compare_url": "https://api.github.com/repos/dundargoc/neovim/compare/{base}...{head}",
            "contents_url": "https://api.github.com/repos/dundargoc/neovim/contents/{+path}",
            "contributors_url": "https://api.github.com/repos/dundargoc/neovim/contributors",
            "created_at": "2021-06-20T10:14:48Z",
            "default_branch": "master",
            "deployments_url": "https://api.github.com/repos/dundargoc/neovim/deployments",
            "description": "Vim-fork focused on extensibility and usability",
            "disabled": false,
            "downloads_url": "https://api.github.com/repos/dundargoc/neovim/downloads",
            "events_url": "https://api.github.com/repos/dundargoc/neovim/events",
            "fork": true,
            "forks": 0,
            "forks_count": 0,
            "forks_url": "https://api.github.com/repos/dundargoc/neovim/forks",
            "full_name": "dundargoc/neovim",
            "git_commits_url": "https://api.github.com/repos/dundargoc/neovim/git/commits{/sha}",
            "git_refs_url": "https://api.github.com/repos/dundargoc/neovim/git/refs{/sha}",
            "git_tags_url": "https://api.github.com/repos/dundargoc/neovim/git/tags{/sha}",
            "git_url": "git://github.com/dundargoc/neovim.git",
            "has_discussions": false,
            "has_downloads": true,
            "has_issues": true,
            "has_pages": false,
            "has_projects": true,
            "has_wiki": false,
            "homepage": "https://neovim.io",
            "hooks_url": "https://api.github.com/repos/dundargoc/neovim/hooks",
            "html_url": "https://github.com/dundargoc/neovim",
            "id": 378614899,
            "is_template": false,
            "issue_comment_url": "https://api.github.com/repos/dundargoc/neovim/issues/comments{/number}",
            "issue_events_url": "https://api.github.com/repos/dundargoc/neovim/issues/events{/number}",
            "issues_url": "https://api.github.com/repos/dundargoc/neovim/issues{/number}",
            "keys_url": "https://api.github.com/repos/dundargoc/neovim/keys{/key_id}",
            "labels_url": "https://api.github.com/repos/dundargoc/neovim/labels{/name}",
            "language": "Vim Script",
            "languages_url": "https://api.github.com/repos/dundargoc/neovim/languages",
            "license": {
                "key": "other",
                "name": "Other",
                "node_id": "MDc6TGljZW5zZTA=",
                "spdx_id": "NOASSERTION",
                "url": null
            },
            "merges_url": "https://api.github.com/repos/dundargoc/neovim/merges",
            "milestones_url": "https://api.github.com/repos/dundargoc/neovim/milestones{/number}",
            "mirror_url": null,
            "name": "neovim",
            "node_id": "MDEwOlJlcG9zaXRvcnkzNzg2MTQ4OTk=",
            "notifications_url": "https://api.github.com/repos/dundargoc/neovim/notifications{?since,all,participating}",
            "open_issues": 0,
            "open_issues_count": 0,
            "owner": {
                "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
                "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
                "followers_url": "https://api.github.com/users/dundargoc/followers",
                "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
                "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
                "gravatar_id": "",
                "html_url": "https://github.com/dundargoc",
                "id": 33953936,
                "login": "dundargoc",
                "node_id": "MDQ6VXNlcjMzOTUzOTM2",
                "organizations_url": "https://api.github.com/users/dundargoc/orgs",
                "received_events_url": "https://api.github.com/users/dundargoc/received_events",
                "repos_url": "https://api.github.com/users/dundargoc/repos",
                "site_admin": false,
                "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
                "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
                "type": "User",
                "url": "https://api.github.com/users/dundargoc",
                "user_view_type": "public"
            },
            "private": false,
            "pulls_url": "https://api.github.com/repos/dundargoc/neovim/pulls{/number}",
            "pushed_at": "2024-10-28T17:57:23Z",
            "releases_url": "https://api.github.com/repos/dundargoc/neovim/releases{/id}",
            "size": 287353,
            "ssh_url": "git@github.com:dundargoc/neovim.git",
            "stargazers_count": 1,
            "stargazers_url": "https://api.github.com/repos/dundargoc/neovim/stargazers",
            "statuses_url": "https://api.github.com/repos/dundargoc/neovim/statuses/{sha}",
            "subscribers_url": "https://api.github.com/repos/dundargoc/neovim/subscribers",
            "subscription_url": "https://api.github.com/repos/dundargoc/neovim/subscription",
            "svn_url": "https://github.com/dundargoc/neovim",
            "tags_url": "https://api.github.com/repos/dundargoc/neovim/tags",
            "teams_url": "https://api.github.com/repos/dundargoc/neovim/teams",
            "topics": [],
            "trees_url": "https://api.github.com/repos/dundargoc/neovim/git/trees{/sha}",
            "updated_at": "2024-10-28T17:56:38Z",
            "url": "https://api.github.com/repos/dundargoc/neovim",
            "visibility": "public",
            "watchers": 1,
            "watchers_count": 1,
            "web_commit_signoff_required": false
        },
        "sha": "8a929db696ebe7ca26836de61659e6af4cdb9cdd",
        "user": {
            "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
            "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
            "followers_url": "https://api.github.com/users/dundargoc/followers",
            "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
            "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
            "gravatar_id": "",
            "html_url": "https://github.com/dundargoc",
            "id": 33953936,
            "login": "dundargoc",
            "node_id": "MDQ6VXNlcjMzOTUzOTM2",
            "organizations_url": "https://api.github.com/users/dundargoc/orgs",
            "received_events_url": "https://api.github.com/users/dundargoc/received_events",
            "repos_url": "https://api.github.com/users/dundargoc/repos",
            "site_admin": false,
            "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
            "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
            "type": "User",
            "url": "https://api.github.com/users/dundargoc",
            "user_view_type": "public"
        }
    },
    "html_url": "https://github.com/neovim/neovim/pull/30335",
    "id": 2063708968,
    "issue_url": "https://api.github.com/repos/neovim/neovim/issues/30335",
    "labels": [
        {
            "color": "c5def5",
            "default": false,
            "description": "",
            "id": 110418643,
            "name": "test",
            "node_id": "MDU6TGFiZWwxMTA0MTg2NDM=",
            "url": "https://api.github.com/repos/neovim/neovim/labels/test"
        }
    ],
    "locked": false,
    "merge_commit_sha": "4c25e60767508a3f8bc0631d280407a08f24a67e",
    "merged_at": "2024-10-22T19:20:11Z",
    "milestone": null,
    "node_id": "PR_kwDOAPphoM57AbMo",
    "number": 30335,
    "patch_url": "https://github.com/neovim/neovim/pull/30335.patch",
    "requested_reviewers": [],
    "requested_teams": [],
    "review_comment_url": "https://api.github.com/repos/neovim/neovim/pulls/comments{/number}",
    "review_comments_url": "https://api.github.com/repos/neovim/neovim/pulls/30335/comments",
    "state": "closed",
    "statuses_url": "https://api.github.com/repos/neovim/neovim/statuses/8a929db696ebe7ca26836de61659e6af4cdb9cdd",
    "title": "test: port libvterm unit test to neovim test suite",
    "updated_at": "2024-10-22T19:20:26Z",
    "url": "https://api.github.com/repos/neovim/neovim/pulls/30335",
    "user": {
        "avatar_url": "https://avatars.githubusercontent.com/u/33953936?v=4",
        "events_url": "https://api.github.com/users/dundargoc/events{/privacy}",
        "followers_url": "https://api.github.com/users/dundargoc/followers",
        "following_url": "https://api.github.com/users/dundargoc/following{/other_user}",
        "gists_url": "https://api.github.com/users/dundargoc/gists{/gist_id}",
        "gravatar_id": "",
        "html_url": "https://github.com/dundargoc",
        "id": 33953936,
        "login": "dundargoc",
        "node_id": "MDQ6VXNlcjMzOTUzOTM2",
        "organizations_url": "https://api.github.com/users/dundargoc/orgs",
        "received_events_url": "https://api.github.com/users/dundargoc/received_events",
        "repos_url": "https://api.github.com/users/dundargoc/repos",
        "site_admin": false,
        "starred_url": "https://api.github.com/users/dundargoc/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/dundargoc/subscriptions",
        "type": "User",
        "url": "https://api.github.com/users/dundargoc",
        "user_view_type": "public"
    }
}